=== tests/cases/compiler/typeArgInferenceWithErrorForAny.ts ===
Line 0 col 4 IdentifierName "paired" = any[]
Line 1 col 0 InvocationExpression "paired.reduce(function (a1, a2) {

    return a1.concat({});

} , [])" = any[]
Line 1 col 0 MemberAccessExpression "paired.reduce" = { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue?: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
Line 1 col 0 IdentifierName "paired" = any[]
Line 2 col 7 IdentifierName "reduce" = { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue?: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
Line 2 col 14 FunctionExpression "function (a1, a2) {

    return a1.concat({});

}" = (a1: any[], a2: any) => any[]
Line 2 col 24 IdentifierName "a1" = any[]
Line 2 col 28 IdentifierName "a2" = any
Line 4 col 11 InvocationExpression "a1.concat({})" = any[]
Line 4 col 11 MemberAccessExpression "a1.concat" = { <U extends Array<T>>(...items: U[]): any[]; (...items: any[]): any[]; }
Line 4 col 11 IdentifierName "a1" = any[]
Line 4 col 14 IdentifierName "concat" = { <U extends Array<T>>(...items: U[]): any[]; (...items: any[]): any[]; }
Line 4 col 21 ObjectLiteralExpression "{}" = {}
Line 6 col 4 ArrayLiteralExpression "[]" = any[]