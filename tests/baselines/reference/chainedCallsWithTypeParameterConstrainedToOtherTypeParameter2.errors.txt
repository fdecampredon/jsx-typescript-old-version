==== tests/cases/compiler/chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts (7 errors) ====
    class Chain<T> {
        constructor(public value: T) { }
        then<S extends T>(cb: (x: T) => S): Chain<S> {
            var t: T;
            var s: S;
            // Ok to go down the chain, but error to climb up the chain
            (new Chain(t)).then(tt => s).then(ss => t);
                                         ~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(7,38): error TS2082: Supplied parameters do not match any signature of call target:
!!! 	Call signatures of types '(ss: S) => T' and '(x: S) => S' are incompatible.
                                         ~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(7,38): error TS2087: Could not select overload for 'call' expression.
    
            // But error to try to climb up the chain
            (new Chain(s)).then(ss => t);
                           ~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(10,24): error TS2082: Supplied parameters do not match any signature of call target:
!!! 	Call signatures of types '(ss: S) => T' and '(x: S) => S' are incompatible.
                           ~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(10,24): error TS2087: Could not select overload for 'call' expression.
    
            // Staying at T or S should be fine
            (new Chain(t)).then(tt => t).then(tt => t).then(tt => t);
            (new Chain(s)).then(ss => s).then(ss => s).then(ss => s);
    
            return null;
        }
    }
    
    // Similar to above, but T is now constrained. Verify that the constraint is maintained across invocations
    interface I {
        x: number;
    }
    class Chain2<T extends I> {
        constructor(public value: T) { }
        then<S extends T>(cb: (x: T) => S): Chain2<S> {
            var i: I;
            var t: T;
            var s: S;
            // Ok to go down the chain, check the constraint at the end.
            // Should get an error that we are assigning a string to a number
            (new Chain2(i)).then(ii => t).then(tt => s).value.x = "";
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(32,9): error TS2011: Type 'string' is not assignable to type 'number'.
    
            // Staying at T or S should keep the constraint.
            // Get an error when we assign a string to a number in both cases
            (new Chain2(i)).then(ii => t).then(tt => t).then(tt => t).then(tt => t).value.x = "";
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(36,9): error TS2011: Type 'string' is not assignable to type 'number'.
            (new Chain2(i)).then(ii => s).then(ss => s).then(ss => s).then(ss => s).value.x = "";
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! chainedCallsWithTypeParameterConstrainedToOtherTypeParameter2.ts(37,9): error TS2011: Type 'string' is not assignable to type 'number'.
    
            return null;
        }
    }