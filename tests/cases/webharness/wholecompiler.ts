//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export class Comment {
        constructor(private _trivia: ISyntaxTrivia,
                    public endsLine: boolean,
                    public _start: number,
                    public _end: number) {
        }

        public start(): number {
            return this._start;
        }

        public end(): number {
            return this._end;
        }

        public fullText(): string {
            return this._trivia.fullText();
        }

        public kind(): SyntaxKind {
            return this._trivia.kind();
        }

        public structuralEquals(ast: Comment, includingPosition: boolean): boolean {
            if (includingPosition) {
                if (this.start() !== ast.start() || this.end() !== ast.end()) {
                    return false;
                }
            }

            return this._trivia.fullText() === ast._trivia.fullText() &&
                   this.endsLine === ast.endsLine;
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export interface IParameters {
        length: number;
        lastParameterIsRest(): boolean;
        ast: ISyntaxElement;
        astAt(index: number): ISyntaxElement;
        identifierAt(index: number): ISyntaxToken;
        typeAt(index: number): ISyntaxElement;
        initializerAt(index: number): EqualsValueClauseSyntax;
        isOptionalAt(index: number): boolean;
    }
}

module TypeScript.ASTHelpers {
    export function scriptIsElided(sourceUnit: SourceUnitSyntax): boolean {
        return isDTSFile(sourceUnit.syntaxTree.fileName()) || moduleMembersAreElided(sourceUnit.moduleElements);
    }

    export function moduleIsElided(declaration: ModuleDeclarationSyntax): boolean {
        return hasModifier(declaration.modifiers, PullElementFlags.Ambient) || moduleMembersAreElided(declaration.moduleElements);
    }

    function moduleMembersAreElided(members: IModuleElementSyntax[]): boolean {
        for (var i = 0, n = members.length; i < n; i++) {
            var member = members[i];

            // We should emit *this* module if it contains any non-interface types. 
            // Caveat: if we have contain a module, then we should be emitted *if we want to
            // emit that inner module as well.
            if (member.kind() === SyntaxKind.ModuleDeclaration) {
                if (!moduleIsElided(<ModuleDeclarationSyntax>member)) {
                    return false;
                }
            }
            else if (member.kind() !== SyntaxKind.InterfaceDeclaration) {
                return false;
            }
        }

        return true;
    }

    export function enumIsElided(declaration: EnumDeclarationSyntax): boolean {
        if (hasModifier(declaration.modifiers, PullElementFlags.Ambient)) {
            return true;
        }

        return false;
    }

     export function isValidAstNode(ast: ISyntaxElement): boolean {
         return ast && !isShared(ast) && start(ast) !== -1 && end(ast) !== -1;
     }

     export function isValidSpan(ast: ISpan): boolean {
        if (!ast)
            return false;

        if (ast.start() === -1 || ast.end() === -1)
            return false;

        return true;
    }

    ///
    /// Return the ISyntaxElement containing "position"
    ///
    export function getAstAtPosition(script: ISyntaxElement, pos: number, useTrailingTriviaAsLimChar: boolean = true, forceInclusive: boolean = false): ISyntaxElement {
        var top: ISyntaxElement = null;

        var pre = function (cur: ISyntaxElement, walker: IAstWalker) {
            if (!isShared(cur) && isValidAstNode(cur)) {
                var isInvalid1 = cur.kind() === SyntaxKind.ExpressionStatement && width(cur) === 0;

                if (isInvalid1) {
                    walker.options.goChildren = false;
                }
                else {
                    // Add "cur" to the stack if it contains our position
                    // For "identifier" nodes, we need a special case: A position equal to "limChar" is
                    // valid, since the position corresponds to a caret position (in between characters)
                    // For example:
                    //  bar
                    //  0123
                    // If "position === 3", the caret is at the "right" of the "r" character, which should be considered valid
                    var inclusive =
                        forceInclusive ||
                        cur.kind() === SyntaxKind.IdentifierName ||
                        cur.kind() === SyntaxKind.MemberAccessExpression ||
                        cur.kind() === SyntaxKind.QualifiedName ||
                        //cur.kind() === SyntaxKind.TypeRef ||
                        cur.kind() === SyntaxKind.VariableDeclaration ||
                        cur.kind() === SyntaxKind.VariableDeclarator ||
                        cur.kind() === SyntaxKind.InvocationExpression ||
                        pos === end(script) + lastToken(script).trailingTriviaWidth(); // Special "EOF" case

                    var minChar = start(cur);
                    var limChar = end(cur) + (useTrailingTriviaAsLimChar ? trailingTriviaWidth(cur) : 0) + (inclusive ? 1 : 0);
                    if (pos >= minChar && pos < limChar) {

                        // Ignore empty lists
                        if ((cur.kind() !== SyntaxKind.List && cur.kind() !== SyntaxKind.SeparatedList) || end(cur) > start(cur)) {
                            // TODO: Since ISyntaxElement is sometimes not correct wrt to position, only add "cur" if it's better
                            //       than top of the stack.
                            if (top === null) {
                                top = cur;
                            }
                            else if (start(cur) >= start(top) &&
                                (end(cur) + (useTrailingTriviaAsLimChar ? trailingTriviaWidth(cur) : 0)) <= (end(top) + (useTrailingTriviaAsLimChar ? trailingTriviaWidth(top) : 0))) {
                                // this new node appears to be better than the one we're 
                                // storing.  Make this the new node.

                                // However, If the current top is a missing identifier, we 
                                // don't want to replace it with another missing identifier.
                                // We want to return the first missing identifier found in a
                                // depth first walk of  the tree.
                                if (width(top) !== 0 || width(cur) !== 0) {
                                    top = cur;
                                }
                            }
                        }
                    }

                    // Don't go further down the tree if pos is outside of [minChar, limChar]
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
        };

        getAstWalkerFactory().walk(script, pre);
        return top;
    }

    export function getExtendsHeritageClause(clauses: HeritageClauseSyntax[]): HeritageClauseSyntax {
        return getHeritageClause(clauses, SyntaxKind.ExtendsHeritageClause);
    }

    export function getImplementsHeritageClause(clauses: HeritageClauseSyntax[]): HeritageClauseSyntax {
        return getHeritageClause(clauses, SyntaxKind.ImplementsHeritageClause);
    }

    function getHeritageClause(clauses: HeritageClauseSyntax[], kind: SyntaxKind): HeritageClauseSyntax {
        if (clauses) {
            for (var i = 0, n = clauses.length; i < n; i++) {
                var child = clauses[i];

                if (child.typeNames.length > 0 && child.kind() === kind) {
                    return child;
                }
            }
        }

        return null;
    }

    export function isCallExpression(ast: ISyntaxElement): boolean {
        return (ast && ast.kind() === SyntaxKind.InvocationExpression) ||
            (ast && ast.kind() === SyntaxKind.ObjectCreationExpression);
    }

    export function isCallExpressionTarget(ast: ISyntaxElement): boolean {
        return !!getCallExpressionTarget(ast);
    }

    export function getCallExpressionTarget(ast: ISyntaxElement): ISyntaxElement {
        if (!ast) {
            return null;
        }

        var current = ast;

        while (current && current.parent) {
            if (current.parent.kind() === SyntaxKind.MemberAccessExpression &&
                (<MemberAccessExpressionSyntax>current.parent).name === current) {
                current = current.parent;
                continue;
            }

            break;
        }

        if (current && current.parent) {
            if (current.parent.kind() === SyntaxKind.InvocationExpression || current.parent.kind() === SyntaxKind.ObjectCreationExpression) {
                return current === (<InvocationExpressionSyntax>current.parent).expression ? current : null;
            }
        }
        return null;
    }

    function isNameOfSomeDeclaration(ast: ISyntaxElement) {
        if (ast === null || ast.parent === null) {
            return false;
        }
        if (ast.kind() !== SyntaxKind.IdentifierName) {
            return false;
        }

        switch (ast.parent.kind()) {
            case SyntaxKind.ClassDeclaration:
                return (<ClassDeclarationSyntax>ast.parent).identifier === ast;
            case SyntaxKind.InterfaceDeclaration:
                return (<InterfaceDeclarationSyntax>ast.parent).identifier === ast;
            case SyntaxKind.EnumDeclaration:
                return (<EnumDeclarationSyntax>ast.parent).identifier === ast;
            case SyntaxKind.ModuleDeclaration:
                return (<ModuleDeclarationSyntax>ast.parent).name === ast || (<ModuleDeclarationSyntax>ast.parent).stringLiteral === ast;
            case SyntaxKind.VariableDeclarator:
                return (<VariableDeclaratorSyntax>ast.parent).propertyName === ast;
            case SyntaxKind.FunctionDeclaration:
                return (<FunctionDeclarationSyntax>ast.parent).identifier === ast;
            case SyntaxKind.MemberFunctionDeclaration:
                return (<MemberFunctionDeclarationSyntax>ast.parent).propertyName === ast;
            case SyntaxKind.Parameter:
                return (<ParameterSyntax>ast.parent).identifier === ast;
            case SyntaxKind.TypeParameter:
                return (<TypeParameterSyntax>ast.parent).identifier === ast;
            case SyntaxKind.SimplePropertyAssignment:
                return (<SimplePropertyAssignmentSyntax>ast.parent).propertyName === ast;
            case SyntaxKind.FunctionPropertyAssignment:
                return (<FunctionPropertyAssignmentSyntax>ast.parent).propertyName === ast;
            case SyntaxKind.EnumElement:
                return (<EnumElementSyntax>ast.parent).propertyName === ast;
            case SyntaxKind.ImportDeclaration:
                return (<ImportDeclarationSyntax>ast.parent).identifier === ast;
        }

        return false;
    }

    export function isDeclarationASTOrDeclarationNameAST(ast: ISyntaxElement) {
        return isNameOfSomeDeclaration(ast) || ASTHelpers.isDeclarationAST(ast);
    }

    export function getEnclosingParameterForInitializer(ast: ISyntaxElement): ParameterSyntax {
        var current = ast;
        while (current) {
            switch (current.kind()) {
                case SyntaxKind.EqualsValueClause:
                    if (current.parent && current.parent.kind() === SyntaxKind.Parameter) {
                        return <ParameterSyntax>current.parent;
                    }
                    break;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.ModuleDeclaration:
                    // exit early
                    return null;
            }

            current = current.parent;
        }
        return null;
    }

    export function getEnclosingMemberVariableDeclaration(ast: ISyntaxElement): MemberVariableDeclarationSyntax {
        var current = ast;

        while (current) {
            switch (current.kind()) {
                case SyntaxKind.MemberVariableDeclaration:
                    return <MemberVariableDeclarationSyntax>current;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.ModuleDeclaration:
                    // exit early
                    return null;
            }
            current = current.parent;
        }

        return null;
    }

    export function isNameOfFunction(ast: ISyntaxElement) {
        return ast
            && ast.parent
            && ast.kind() === SyntaxKind.IdentifierName
            && ast.parent.kind() === SyntaxKind.FunctionDeclaration
            && (<FunctionDeclarationSyntax>ast.parent).identifier === ast;
    }

    export function isNameOfMemberFunction(ast: ISyntaxElement) {
        return ast
            && ast.parent
            && ast.kind() === SyntaxKind.IdentifierName
            && ast.parent.kind() === SyntaxKind.MemberFunctionDeclaration
            && (<MemberFunctionDeclarationSyntax>ast.parent).propertyName === ast;
    }

    export function isNameOfMemberAccessExpression(ast: ISyntaxElement) {
        if (ast &&
            ast.parent &&
            ast.parent.kind() === SyntaxKind.MemberAccessExpression &&
            (<MemberAccessExpressionSyntax>ast.parent).name === ast) {

            return true;
        }

        return false;
    }

    export function isRightSideOfQualifiedName(ast: ISyntaxElement) {
        if (ast &&
            ast.parent &&
            ast.parent.kind() === SyntaxKind.QualifiedName &&
            (<QualifiedNameSyntax>ast.parent).right === ast) {

            return true;
        }

        return false;
    }

    export function parentIsModuleDeclaration(ast: ISyntaxElement) {
        return ast.parent && ast.parent.kind() === SyntaxKind.ModuleDeclaration;
    }

    export function parametersFromIdentifier(id: ISyntaxToken): IParameters {
        return {
            length: 1,
            lastParameterIsRest: () => false,
            ast: id,
            astAt: (index: number) => id,
            identifierAt: (index: number) => id,
            typeAt: (index: number): ISyntaxElement => null,
            initializerAt: (index: number): EqualsValueClauseSyntax => null,
            isOptionalAt: (index: number) => false,
        };
    }

    export function parametersFromParameter(parameter: ParameterSyntax): IParameters {
        return {
            length: 1,
            lastParameterIsRest: () => parameter.dotDotDotToken !== null,
            ast: parameter,
            astAt: (index: number) => parameter,
            identifierAt: (index: number) => parameter.identifier,
            typeAt: (index: number) => getType(parameter),
            initializerAt: (index: number) => parameter.equalsValueClause,
            isOptionalAt: (index: number) => parameterIsOptional(parameter),
        };
    }

    function parameterIsOptional(parameter: ParameterSyntax): boolean {
        return parameter.questionToken !== null || parameter.equalsValueClause !== null;
    }

    export function parametersFromParameterList(list: ParameterListSyntax): IParameters {
        return {
            length: list.parameters.length,
            lastParameterIsRest: () => lastParameterIsRest(list),
            ast: list.parameters,
            astAt: (index: number) => list.parameters[index],
            identifierAt: (index: number) => list.parameters[index].identifier,
            typeAt: (index: number) => getType(list.parameters[index]),
            initializerAt: (index: number) => list.parameters[index].equalsValueClause,
            isOptionalAt: (index: number) => parameterIsOptional(list.parameters[index]),
        };
    }

    export function isDeclarationAST(ast: ISyntaxElement): boolean {
        switch (ast.kind()) {
            case SyntaxKind.VariableDeclarator:
                return getVariableStatement(<VariableDeclaratorSyntax>ast) !== null;

            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.SimpleArrowFunctionExpression:
            case SyntaxKind.ParenthesizedArrowFunctionExpression:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ArrayType:
            case SyntaxKind.ObjectType:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ConstructorDeclaration:
            case SyntaxKind.MemberFunctionDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.MemberVariableDeclaration:
            case SyntaxKind.IndexMemberDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumElement:
            case SyntaxKind.SimplePropertyAssignment:
            case SyntaxKind.FunctionPropertyAssignment:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    export function preComments(element: ISyntaxElement): Comment[]{
        if (element) {
            switch (element.kind()) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ImportDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.IfStatement:
                case SyntaxKind.SimplePropertyAssignment:
                case SyntaxKind.MemberFunctionDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.ReturnStatement:
                case SyntaxKind.ConstructorDeclaration:
                case SyntaxKind.MemberVariableDeclaration:
                case SyntaxKind.EnumElement:
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.FunctionPropertyAssignment:
                case SyntaxKind.Parameter:
                    return convertNodeLeadingComments(element);
            }
        }

        return null;
    }

    export function postComments(element: ISyntaxElement): Comment[] {
        if (element) {
            switch (element.kind()) {
                case SyntaxKind.ExpressionStatement:
                    return convertNodeTrailingComments(element, /*allowWithNewLine:*/ true);
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ImportDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.IfStatement:
                case SyntaxKind.SimplePropertyAssignment:
                case SyntaxKind.MemberFunctionDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.ReturnStatement:
                case SyntaxKind.ConstructorDeclaration:
                case SyntaxKind.MemberVariableDeclaration:
                case SyntaxKind.EnumElement:
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.FunctionPropertyAssignment:
                case SyntaxKind.Parameter:
                    return convertNodeTrailingComments(element);
            }
        }

        return null;
    }

    function convertNodeTrailingComments(node: ISyntaxElement, allowWithNewLine = false): Comment[]{
        // Bail out quickly before doing any expensive math computation.
        var _lastToken = lastToken(node);
        if (_lastToken === null || !_lastToken.hasTrailingComment()) {
            return null;
        }

        if (!allowWithNewLine && _lastToken.hasTrailingNewLine()) {
            return null;
        }

        return convertComments(_lastToken.trailingTrivia(), fullStart(node) + fullWidth(node) - _lastToken.trailingTriviaWidth());
    }

    function convertNodeLeadingComments(element: ISyntaxElement): Comment[]{
        if (element) {
            return convertTokenLeadingComments(firstToken(element));
        }

        return null;
    }

    export function convertTokenLeadingComments(token: ISyntaxToken): Comment[]{
        if (token === null) {
            return null;
        }

        return token.hasLeadingComment()
            ? convertComments(token.leadingTrivia(), token.fullStart())
            : null;
    }

    export function convertTokenTrailingComments(token: ISyntaxToken): Comment[] {
        if (token === null) {
            return null;
        }

        return token.hasTrailingComment()
            ? convertComments(token.trailingTrivia(), fullEnd(token) - token.trailingTriviaWidth())
            : null;
    }

    function convertComments(triviaList: ISyntaxTriviaList, commentStartPosition: number): Comment[]{
        var result: Comment[] = [];

        for (var i = 0, n = triviaList.count(); i < n; i++) {
            var trivia = triviaList.syntaxTriviaAt(i);

            if (trivia.isComment()) {
                var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                result.push(convertComment(trivia, commentStartPosition, hasTrailingNewLine));
            }

            commentStartPosition += trivia.fullWidth();
        }

        return result;
    }

    function convertComment(trivia: ISyntaxTrivia, commentStartPosition: number, hasTrailingNewLine: boolean): Comment {
        var comment = new Comment(trivia, hasTrailingNewLine, commentStartPosition, commentStartPosition + trivia.fullWidth());

        return comment;
    }

    export function docComments(ast: ISyntaxElement): Comment[] {
        if (isDeclarationAST(ast)) {
            var comments: Comment[] = null;

            if (ast.kind() === SyntaxKind.VariableDeclarator) {
                // Get the doc comments for a variable off of the variable statement.  That's what
                // they'll be attached to in the tree.
                comments = TypeScript.ASTHelpers.preComments(getVariableStatement(<VariableDeclaratorSyntax>ast));
            }
            else if (ast.kind() === SyntaxKind.Parameter) {
                // First check if the parameter was written like so:
                //      (
                //          /** blah */ a,
                //          /** blah */ b);
                comments = TypeScript.ASTHelpers.preComments(ast);
                if (!comments) {
                    // Now check if it was written like so:
                    //      (/** blah */ a, /** blah */ b);
                    // In this case, the comment will belong to the preceding token.
                    var previousToken = findToken(syntaxTree(ast).sourceUnit(), firstToken(ast).fullStart() - 1);
                    if (previousToken && (previousToken.kind() === SyntaxKind.OpenParenToken || previousToken.kind() === SyntaxKind.CommaToken)) {
                        comments = convertTokenTrailingComments(previousToken);
                    }
                }
            }
            else {
                comments = TypeScript.ASTHelpers.preComments(ast);
            }

            if (comments && comments.length > 0) {
                return comments.filter(c => isDocComment(c));
            }
        }

        return sentinelEmptyArray;
    }

    export function isDocComment(comment: Comment) {
        if (comment.kind() === SyntaxKind.MultiLineCommentTrivia) {
            var fullText = comment.fullText();
            return fullText.charAt(2) === "*" && fullText.charAt(3) !== "/";
        }

        return false;
    }

    export function getParameterList(ast: ISyntaxElement): ParameterListSyntax {
        if (ast) {
            switch (ast.kind()) {
                case SyntaxKind.ConstructorDeclaration:
                    return getParameterList((<ConstructorDeclarationSyntax>ast).callSignature);
                case SyntaxKind.FunctionDeclaration:
                    return getParameterList((<FunctionDeclarationSyntax>ast).callSignature);
                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return getParameterList((<ParenthesizedArrowFunctionExpressionSyntax>ast).callSignature);
                case SyntaxKind.ConstructSignature:
                    return getParameterList((<ConstructSignatureSyntax>ast).callSignature);
                case SyntaxKind.MemberFunctionDeclaration:
                    return getParameterList((<MemberFunctionDeclarationSyntax>ast).callSignature);
                case SyntaxKind.FunctionPropertyAssignment:
                    return getParameterList((<FunctionPropertyAssignmentSyntax>ast).callSignature);
                case SyntaxKind.FunctionExpression:
                    return getParameterList((<FunctionExpressionSyntax>ast).callSignature);
                case SyntaxKind.MethodSignature:
                    return getParameterList((<MethodSignatureSyntax>ast).callSignature);
                case SyntaxKind.ConstructorType:
                    return (<ConstructorTypeSyntax>ast).parameterList;
                case SyntaxKind.FunctionType:
                    return (<FunctionTypeSyntax>ast).parameterList;
                case SyntaxKind.CallSignature:
                    return (<CallSignatureSyntax>ast).parameterList;
                case SyntaxKind.GetAccessor:
                    return (<GetAccessorSyntax>ast).parameterList;
                case SyntaxKind.SetAccessor:
                    return (<SetAccessorSyntax>ast).parameterList;
            }
        }

        return null;
    }

    export function getType(ast: ISyntaxElement): ISyntaxNodeOrToken {
        if (ast) {
            switch (ast.kind()) {
                case SyntaxKind.FunctionDeclaration:
                    return getType((<FunctionDeclarationSyntax>ast).callSignature);
                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return getType((<ParenthesizedArrowFunctionExpressionSyntax>ast).callSignature);
                case SyntaxKind.ConstructSignature:
                    return getType((<ConstructSignatureSyntax>ast).callSignature);
                case SyntaxKind.MemberFunctionDeclaration:
                    return getType((<MemberFunctionDeclarationSyntax>ast).callSignature);
                case SyntaxKind.FunctionPropertyAssignment:
                    return getType((<FunctionPropertyAssignmentSyntax>ast).callSignature);
                case SyntaxKind.FunctionExpression:
                    return getType((<FunctionExpressionSyntax>ast).callSignature);
                case SyntaxKind.MethodSignature:
                    return getType((<MethodSignatureSyntax>ast).callSignature);
                case SyntaxKind.CallSignature:
                    return getType((<CallSignatureSyntax>ast).typeAnnotation);
                case SyntaxKind.IndexSignature:
                    return getType((<IndexSignatureSyntax>ast).typeAnnotation);
                case SyntaxKind.PropertySignature:
                    return getType((<PropertySignatureSyntax>ast).typeAnnotation);
                case SyntaxKind.GetAccessor:
                    return getType((<GetAccessorSyntax>ast).typeAnnotation);
                case SyntaxKind.Parameter:
                    return getType((<ParameterSyntax>ast).typeAnnotation);
                case SyntaxKind.MemberVariableDeclaration:
                    return getType((<MemberVariableDeclarationSyntax>ast).variableDeclarator);
                case SyntaxKind.VariableDeclarator:
                    return getType((<VariableDeclaratorSyntax>ast).typeAnnotation);
                case SyntaxKind.CatchClause:
                    return getType((<CatchClauseSyntax>ast).typeAnnotation);
                case SyntaxKind.ConstructorType:
                    return (<ConstructorTypeSyntax>ast).type;
                case SyntaxKind.FunctionType:
                    return (<FunctionTypeSyntax>ast).type;
                case SyntaxKind.TypeAnnotation:
                    return (<TypeAnnotationSyntax>ast).type;
            }
        }

        return null;
    }

    function getVariableStatement(variableDeclarator: VariableDeclaratorSyntax): VariableStatementSyntax {
        if (variableDeclarator && variableDeclarator.parent && variableDeclarator.parent.parent && variableDeclarator.parent.parent.parent &&
            variableDeclarator.parent.kind() === SyntaxKind.SeparatedList &&
            variableDeclarator.parent.parent.kind() === SyntaxKind.VariableDeclaration &&
            variableDeclarator.parent.parent.parent.kind() === SyntaxKind.VariableStatement) {

            return <VariableStatementSyntax>variableDeclarator.parent.parent.parent;
        }

        return null;
    }

    export function getVariableDeclaratorModifiers(variableDeclarator: VariableDeclaratorSyntax): ISyntaxToken[] {
        var variableStatement = getVariableStatement(variableDeclarator);
        return variableStatement ? variableStatement.modifiers : Syntax.emptyList<ISyntaxToken>();
    }

    export function isIntegerLiteralAST(expression: ISyntaxElement): boolean {
        if (expression) {
            switch (expression.kind()) {
                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                    // Note: if there is a + or - sign, we can only allow a normal integer following
                    // (and not a hex integer).  i.e. -0xA is a legal expression, but it is not a 
                    // *literal*.
                    expression = (<PrefixUnaryExpressionSyntax>expression).operand;
                    return expression.kind() === SyntaxKind.NumericLiteral && IntegerUtilities.isInteger((<ISyntaxToken>expression).text());

                case SyntaxKind.NumericLiteral:
                    // If it doesn't have a + or -, then either an integer literal or a hex literal
                    // is acceptable.
                    var text = (<ISyntaxToken>expression).text();
                    return IntegerUtilities.isInteger(text) || IntegerUtilities.isHexInteger(text);
            }
        }

        return false;
    }

    export function getEnclosingModuleDeclaration(ast: ISyntaxElement): ModuleDeclarationSyntax {
        while (ast) {
            if (ast.kind() === SyntaxKind.ModuleDeclaration) {
                return <ModuleDeclarationSyntax>ast;
            }

            ast = ast.parent;
        }

        return null;
    }

    function isEntireNameOfModuleDeclaration(nameAST: ISyntaxElement) {
        return parentIsModuleDeclaration(nameAST) && (<ModuleDeclarationSyntax>nameAST.parent).name === nameAST;
    }

    export function getModuleDeclarationFromNameAST(ast: ISyntaxElement): ModuleDeclarationSyntax {
        if (ast) {
            switch (ast.kind()) {
                case SyntaxKind.StringLiteral:
                    if (parentIsModuleDeclaration(ast) && (<ModuleDeclarationSyntax>ast.parent).stringLiteral === ast) {
                        return <ModuleDeclarationSyntax>ast.parent;
                    }
                    return null;

                case SyntaxKind.IdentifierName:
                case SyntaxKind.QualifiedName:
                    if (isEntireNameOfModuleDeclaration(ast)) {
                        return <ModuleDeclarationSyntax>ast.parent;
                    }
                    break;

                default: 
                    return null;
            }

            // Only qualified names can be name of module declaration if they didnt satisfy above conditions
            for (ast = ast.parent; ast && ast.kind() === SyntaxKind.QualifiedName; ast = ast.parent) {
                if (isEntireNameOfModuleDeclaration(ast)) {
                    return <ModuleDeclarationSyntax>ast.parent;
                }
            }
        }

        return null;
    }

    export function isLastNameOfModule(ast: ModuleDeclarationSyntax, astName: ISyntaxElement): boolean {
        if (ast) {
            if (ast.stringLiteral) {
                return astName === ast.stringLiteral;
            }
            else if (ast.name.kind() === SyntaxKind.QualifiedName) {
                return astName === (<QualifiedNameSyntax>ast.name).right;
            }
            else {
                return astName === ast.name;
            }
        }

        return false;
    }

    export function getNameOfIdenfierOrQualifiedName(name: ISyntaxElement): string {
        if (name.kind() === SyntaxKind.IdentifierName) {
            return (<ISyntaxToken>name).text();
        }
        else {
            Debug.assert(name.kind() == SyntaxKind.QualifiedName);
            var dotExpr = <QualifiedNameSyntax>name;
            return getNameOfIdenfierOrQualifiedName(dotExpr.left) + "." + getNameOfIdenfierOrQualifiedName(dotExpr.right);
        }
    }

    export function getModuleNames(name: ISyntaxElement, result?: ISyntaxToken[]): ISyntaxToken[] {
        result = result || [];

        if (name.kind() === SyntaxKind.QualifiedName) {
            getModuleNames((<QualifiedNameSyntax>name).left, result);
            result.push((<QualifiedNameSyntax>name).right);
        }
        else {
            result.push(<ISyntaxToken>name);
        }

        return result;
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    function walkListChildren(preAst: ISyntaxNodeOrToken[], walker: AstWalker): void {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }

    function walkThrowStatementChildren(preAst: ThrowStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkPrefixUnaryExpressionChildren(preAst: PrefixUnaryExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.operand);
    }

    function walkPostfixUnaryExpressionChildren(preAst: PostfixUnaryExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.operand);
    }

    function walkDeleteExpressionChildren(preAst: DeleteExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkTypeArgumentListChildren(preAst: TypeArgumentListSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeArguments);
    }

    function walkTypeOfExpressionChildren(preAst: TypeOfExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkVoidExpressionChildren(preAst: VoidExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkArgumentListChildren(preAst: ArgumentListSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeArgumentList);
        walker.walk(preAst.arguments);
    }

    function walkArrayLiteralExpressionChildren(preAst: ArrayLiteralExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expressions);
    }

    function walkSimplePropertyAssignmentChildren(preAst: SimplePropertyAssignmentSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.expression);
    }

    function walkFunctionPropertyAssignmentChildren(preAst: FunctionPropertyAssignmentSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkGetAccessorChildren(preAst: GetAccessorSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }

    function walkSeparatedListChildren(preAst: ISyntaxNodeOrToken[], walker: AstWalker): void {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }

    function walkSetAccessorChildren(preAst: SetAccessorSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.block);
    }

    function walkObjectLiteralExpressionChildren(preAst: ObjectLiteralExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyAssignments);
    }

    function walkCastExpressionChildren(preAst: CastExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.type);
        walker.walk(preAst.expression);
    }

    function walkParenthesizedExpressionChildren(preAst: ParenthesizedExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkElementAccessExpressionChildren(preAst: ElementAccessExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentExpression);
    }

    function walkMemberAccessExpressionChildren(preAst: MemberAccessExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.name);
    }

    function walkQualifiedNameChildren(preAst: QualifiedNameSyntax, walker: AstWalker): void {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }

    function walkBinaryExpressionChildren(preAst: BinaryExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }

    function walkEqualsValueClauseChildren(preAst: EqualsValueClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.value);
    }

    function walkTypeParameterChildren(preAst: TypeParameterSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.constraint);
    }

    function walkTypeParameterListChildren(preAst: TypeParameterListSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeParameters);
    }

    function walkGenericTypeChildren(preAst: GenericTypeSyntax, walker: AstWalker): void {
        walker.walk(preAst.name);
        walker.walk(preAst.typeArgumentList);
    }

    function walkTypeAnnotationChildren(preAst: TypeAnnotationSyntax, walker: AstWalker): void {
        walker.walk(preAst.type);
    }

    function walkTypeQueryChildren(preAst: TypeQuerySyntax, walker: AstWalker): void {
        walker.walk(preAst.name);
    }

    function walkInvocationExpressionChildren(preAst: InvocationExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }

    function walkObjectCreationExpressionChildren(preAst: ObjectCreationExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }

    function walkTrinaryExpressionChildren(preAst: ConditionalExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.condition);
        walker.walk(preAst.whenTrue);
        walker.walk(preAst.whenFalse);
    }

    function walkFunctionExpressionChildren(preAst: FunctionExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkFunctionTypeChildren(preAst: FunctionTypeSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }

    function walkParenthesizedArrowFunctionExpressionChildren(preAst: ParenthesizedArrowFunctionExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }

    function walkSimpleArrowFunctionExpressionChildren(preAst: SimpleArrowFunctionExpressionSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }

    function walkMemberFunctionDeclarationChildren(preAst: MemberFunctionDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkFuncDeclChildren(preAst: FunctionDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkIndexMemberDeclarationChildren(preAst: IndexMemberDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.indexSignature);
    }

    function walkIndexSignatureChildren(preAst: IndexSignatureSyntax, walker: AstWalker): void {
        walker.walk(preAst.parameter);
        walker.walk(preAst.typeAnnotation);
    }

    function walkCallSignatureChildren(preAst: CallSignatureSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
    }

    function walkConstraintChildren(preAst: ConstraintSyntax, walker: AstWalker): void {
        walker.walk(preAst.type);
    }

    function walkConstructorDeclarationChildren(preAst: ConstructorDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }

    function walkConstructorTypeChildren(preAst: FunctionTypeSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }

    function walkConstructSignatureChildren(preAst: ConstructSignatureSyntax, walker: AstWalker): void {
        walker.walk(preAst.callSignature);
    }

    function walkParameterChildren(preAst: ParameterSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }

    function walkParameterListChildren(preAst: ParameterListSyntax, walker: AstWalker): void {
        walker.walk(preAst.parameters);
    }

    function walkPropertySignatureChildren(preAst: PropertySignatureSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
    }

    function walkVariableDeclaratorChildren(preAst: VariableDeclaratorSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }

    function walkMemberVariableDeclarationChildren(preAst: MemberVariableDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.variableDeclarator);
    }

    function walkMethodSignatureChildren(preAst: MethodSignatureSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
    }

    function walkReturnStatementChildren(preAst: ReturnStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkForStatementChildren(preAst: ForStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.initializer);
        walker.walk(preAst.condition);
        walker.walk(preAst.incrementor);
        walker.walk(preAst.statement);
    }

    function walkForInStatementChildren(preAst: ForInStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.left);
        walker.walk(preAst.expression);
        walker.walk(preAst.statement);
    }

    function walkIfStatementChildren(preAst: IfStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
        walker.walk(preAst.elseClause);
    }

    function walkElseClauseChildren(preAst: ElseClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.statement);
    }

    function walkWhileStatementChildren(preAst: WhileStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkDoStatementChildren(preAst: DoStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkBlockChildren(preAst: BlockSyntax, walker: AstWalker): void {
        walker.walk(preAst.statements);
    }

    function walkVariableDeclarationChildren(preAst: VariableDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.variableDeclarators);
    }

    function walkCaseSwitchClauseChildren(preAst: CaseSwitchClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.statements);
    }

    function walkDefaultSwitchClauseChildren(preAst: DefaultSwitchClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.statements);
    }

    function walkSwitchStatementChildren(preAst: SwitchStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
        walker.walk(preAst.switchClauses);
    }

    function walkTryStatementChildren(preAst: TryStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.block);
        walker.walk(preAst.catchClause);
        walker.walk(preAst.finallyClause);
    }

    function walkCatchClauseChildren(preAst: CatchClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }

    function walkExternalModuleReferenceChildren(preAst: ExternalModuleReferenceSyntax, walker: AstWalker): void {
        walker.walk(preAst.stringLiteral);
    }

    function walkFinallyClauseChildren(preAst: FinallyClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.block);
    }

    function walkClassDeclChildren(preAst: ClassDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.classElements);
    }

    function walkScriptChildren(preAst: SourceUnitSyntax, walker: AstWalker): void {
        walker.walk(preAst.moduleElements);
    }

    function walkHeritageClauseChildren(preAst: HeritageClauseSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeNames);
    }

    function walkInterfaceDeclerationChildren(preAst: InterfaceDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.body);
    }

    function walkObjectTypeChildren(preAst: ObjectTypeSyntax, walker: AstWalker): void {
        walker.walk(preAst.typeMembers);
    }

    function walkArrayTypeChildren(preAst: ArrayTypeSyntax, walker: AstWalker): void {
        walker.walk(preAst.type);
    }

    function walkModuleDeclarationChildren(preAst: ModuleDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.name);
        walker.walk(preAst.stringLiteral);
        walker.walk(preAst.moduleElements);
    }

    function walkModuleNameModuleReferenceChildren(preAst: ModuleNameModuleReferenceSyntax, walker: AstWalker): void {
        walker.walk(preAst.moduleName);
    }

    function walkEnumDeclarationChildren(preAst: EnumDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.enumElements);
    }

    function walkEnumElementChildren(preAst: EnumElementSyntax, walker: AstWalker): void {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.equalsValueClause);
    }

    function walkImportDeclarationChildren(preAst: ImportDeclarationSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.moduleReference);
    }

    function walkExportAssignmentChildren(preAst: ExportAssignmentSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
    }

    function walkWithStatementChildren(preAst: WithStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }

    function walkExpressionStatementChildren(preAst: ExpressionStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.expression);
    }

    function walkLabeledStatementChildren(preAst: LabeledStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.identifier);
        walker.walk(preAst.statement);
    }

    function walkVariableStatementChildren(preAst: VariableStatementSyntax, walker: AstWalker): void {
        walker.walk(preAst.variableDeclaration);
    }

    var childrenWalkers: IAstWalkChildren[] = new Array<IAstWalkChildren>(SyntaxKind.LastNode + 1);

    // Tokens/trivia can't ever be walked into. 
    for (var i = SyntaxKind.FirstToken, n = SyntaxKind.LastToken; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    for (var i = SyntaxKind.FirstTrivia, n = SyntaxKind.LastTrivia; i <= n; i++) {
        childrenWalkers[i] = null;
    }

    childrenWalkers[SyntaxKind.AddAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.AddExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.AndAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.AnyKeyword] = null;
    childrenWalkers[SyntaxKind.ArgumentList] = walkArgumentListChildren;
    childrenWalkers[SyntaxKind.ArrayLiteralExpression] = walkArrayLiteralExpressionChildren;
    childrenWalkers[SyntaxKind.ArrayType] = walkArrayTypeChildren;
    childrenWalkers[SyntaxKind.SimpleArrowFunctionExpression] = walkSimpleArrowFunctionExpressionChildren;
    childrenWalkers[SyntaxKind.ParenthesizedArrowFunctionExpression] = walkParenthesizedArrowFunctionExpressionChildren;
    childrenWalkers[SyntaxKind.AssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.BitwiseAndExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.BitwiseExclusiveOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.BitwiseNotExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.BitwiseOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.Block] = walkBlockChildren;
    childrenWalkers[SyntaxKind.BooleanKeyword] = null;
    childrenWalkers[SyntaxKind.BreakStatement] = null;
    childrenWalkers[SyntaxKind.CallSignature] = walkCallSignatureChildren;
    childrenWalkers[SyntaxKind.CaseSwitchClause] = walkCaseSwitchClauseChildren;
    childrenWalkers[SyntaxKind.CastExpression] = walkCastExpressionChildren;
    childrenWalkers[SyntaxKind.CatchClause] = walkCatchClauseChildren;
    childrenWalkers[SyntaxKind.ClassDeclaration] = walkClassDeclChildren;
    childrenWalkers[SyntaxKind.CommaExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.ConditionalExpression] = walkTrinaryExpressionChildren;
    childrenWalkers[SyntaxKind.Constraint] = walkConstraintChildren;
    childrenWalkers[SyntaxKind.ConstructorDeclaration] = walkConstructorDeclarationChildren;
    childrenWalkers[SyntaxKind.ConstructSignature] = walkConstructSignatureChildren;
    childrenWalkers[SyntaxKind.ContinueStatement] = null;
    childrenWalkers[SyntaxKind.ConstructorType] = walkConstructorTypeChildren;
    childrenWalkers[SyntaxKind.DebuggerStatement] = null;
    childrenWalkers[SyntaxKind.DefaultSwitchClause] = walkDefaultSwitchClauseChildren;
    childrenWalkers[SyntaxKind.DeleteExpression] = walkDeleteExpressionChildren;
    childrenWalkers[SyntaxKind.DivideAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.DivideExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.DoStatement] = walkDoStatementChildren;
    childrenWalkers[SyntaxKind.ElementAccessExpression] = walkElementAccessExpressionChildren;
    childrenWalkers[SyntaxKind.ElseClause] = walkElseClauseChildren;
    childrenWalkers[SyntaxKind.EmptyStatement] = null;
    childrenWalkers[SyntaxKind.EnumDeclaration] = walkEnumDeclarationChildren;
    childrenWalkers[SyntaxKind.EnumElement] = walkEnumElementChildren;
    childrenWalkers[SyntaxKind.EqualsExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.EqualsValueClause] = walkEqualsValueClauseChildren;
    childrenWalkers[SyntaxKind.EqualsWithTypeConversionExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.ExclusiveOrAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.ExportAssignment] = walkExportAssignmentChildren;
    childrenWalkers[SyntaxKind.ExpressionStatement] = walkExpressionStatementChildren;
    childrenWalkers[SyntaxKind.ExtendsHeritageClause] = walkHeritageClauseChildren;
    childrenWalkers[SyntaxKind.ExternalModuleReference] = walkExternalModuleReferenceChildren;
    childrenWalkers[SyntaxKind.FalseKeyword] = null;
    childrenWalkers[SyntaxKind.FinallyClause] = walkFinallyClauseChildren;
    childrenWalkers[SyntaxKind.ForInStatement] = walkForInStatementChildren;
    childrenWalkers[SyntaxKind.ForStatement] = walkForStatementChildren;
    childrenWalkers[SyntaxKind.FunctionDeclaration] = walkFuncDeclChildren;
    childrenWalkers[SyntaxKind.FunctionExpression] = walkFunctionExpressionChildren;
    childrenWalkers[SyntaxKind.FunctionPropertyAssignment] = walkFunctionPropertyAssignmentChildren;
    childrenWalkers[SyntaxKind.FunctionType] = walkFunctionTypeChildren;
    childrenWalkers[SyntaxKind.GenericType] = walkGenericTypeChildren;
    childrenWalkers[SyntaxKind.GetAccessor] = walkGetAccessorChildren;
    childrenWalkers[SyntaxKind.GreaterThanExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.GreaterThanOrEqualExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.IfStatement] = walkIfStatementChildren;
    childrenWalkers[SyntaxKind.ImplementsHeritageClause] = walkHeritageClauseChildren;
    childrenWalkers[SyntaxKind.ImportDeclaration] = walkImportDeclarationChildren;
    childrenWalkers[SyntaxKind.IndexMemberDeclaration] = walkIndexMemberDeclarationChildren;
    childrenWalkers[SyntaxKind.IndexSignature] = walkIndexSignatureChildren;
    childrenWalkers[SyntaxKind.InExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.InstanceOfExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.InterfaceDeclaration] = walkInterfaceDeclerationChildren;
    childrenWalkers[SyntaxKind.InvocationExpression] = walkInvocationExpressionChildren;
    childrenWalkers[SyntaxKind.LabeledStatement] = walkLabeledStatementChildren;
    childrenWalkers[SyntaxKind.LeftShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.LeftShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.LessThanExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.LessThanOrEqualExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.List] = walkListChildren;
    childrenWalkers[SyntaxKind.LogicalAndExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.LogicalNotExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.LogicalOrExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.MemberAccessExpression] = walkMemberAccessExpressionChildren;
    childrenWalkers[SyntaxKind.MemberFunctionDeclaration] = walkMemberFunctionDeclarationChildren;
    childrenWalkers[SyntaxKind.MemberVariableDeclaration] = walkMemberVariableDeclarationChildren;
    childrenWalkers[SyntaxKind.MethodSignature] = walkMethodSignatureChildren;
    childrenWalkers[SyntaxKind.ModuleDeclaration] = walkModuleDeclarationChildren;
    childrenWalkers[SyntaxKind.ModuleNameModuleReference] = walkModuleNameModuleReferenceChildren;
    childrenWalkers[SyntaxKind.ModuloAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.ModuloExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.MultiplyAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.MultiplyExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.IdentifierName] = null;
    childrenWalkers[SyntaxKind.NegateExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.None] = null;
    childrenWalkers[SyntaxKind.NotEqualsExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.NotEqualsWithTypeConversionExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.NullKeyword] = null;
    childrenWalkers[SyntaxKind.NumberKeyword] = null;
    childrenWalkers[SyntaxKind.NumericLiteral] = null;
    childrenWalkers[SyntaxKind.ObjectCreationExpression] = walkObjectCreationExpressionChildren;
    childrenWalkers[SyntaxKind.ObjectLiteralExpression] = walkObjectLiteralExpressionChildren;
    childrenWalkers[SyntaxKind.ObjectType] = walkObjectTypeChildren;
    childrenWalkers[SyntaxKind.OmittedExpression] = null;
    childrenWalkers[SyntaxKind.OrAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.Parameter] = walkParameterChildren;
    childrenWalkers[SyntaxKind.ParameterList] = walkParameterListChildren;
    childrenWalkers[SyntaxKind.ParenthesizedExpression] = walkParenthesizedExpressionChildren;
    childrenWalkers[SyntaxKind.PlusExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.PostDecrementExpression] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.PostIncrementExpression] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.PreDecrementExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.PreIncrementExpression] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[SyntaxKind.PropertySignature] = walkPropertySignatureChildren;
    childrenWalkers[SyntaxKind.QualifiedName] = walkQualifiedNameChildren;
    childrenWalkers[SyntaxKind.RegularExpressionLiteral] = null;
    childrenWalkers[SyntaxKind.ReturnStatement] = walkReturnStatementChildren;
    childrenWalkers[SyntaxKind.SourceUnit] = walkScriptChildren;
    childrenWalkers[SyntaxKind.SeparatedList] = walkSeparatedListChildren;
    childrenWalkers[SyntaxKind.SetAccessor] = walkSetAccessorChildren;
    childrenWalkers[SyntaxKind.SignedRightShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.SignedRightShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.SimplePropertyAssignment] = walkSimplePropertyAssignmentChildren;
    childrenWalkers[SyntaxKind.StringLiteral] = null;
    childrenWalkers[SyntaxKind.StringKeyword] = null;
    childrenWalkers[SyntaxKind.SubtractAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.SubtractExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.SuperKeyword] = null;
    childrenWalkers[SyntaxKind.SwitchStatement] = walkSwitchStatementChildren;
    childrenWalkers[SyntaxKind.ThisKeyword] = null;
    childrenWalkers[SyntaxKind.ThrowStatement] = walkThrowStatementChildren;
    childrenWalkers[SyntaxKind.TriviaList] = null;
    childrenWalkers[SyntaxKind.TrueKeyword] = null;
    childrenWalkers[SyntaxKind.TryStatement] = walkTryStatementChildren;
    childrenWalkers[SyntaxKind.TypeAnnotation] = walkTypeAnnotationChildren;
    childrenWalkers[SyntaxKind.TypeArgumentList] = walkTypeArgumentListChildren;
    childrenWalkers[SyntaxKind.TypeOfExpression] = walkTypeOfExpressionChildren;
    childrenWalkers[SyntaxKind.TypeParameter] = walkTypeParameterChildren;
    childrenWalkers[SyntaxKind.TypeParameterList] = walkTypeParameterListChildren;
    childrenWalkers[SyntaxKind.TypeQuery] = walkTypeQueryChildren;
    childrenWalkers[SyntaxKind.UnsignedRightShiftAssignmentExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.UnsignedRightShiftExpression] = walkBinaryExpressionChildren;
    childrenWalkers[SyntaxKind.VariableDeclaration] = walkVariableDeclarationChildren;
    childrenWalkers[SyntaxKind.VariableDeclarator] = walkVariableDeclaratorChildren;
    childrenWalkers[SyntaxKind.VariableStatement] = walkVariableStatementChildren;
    childrenWalkers[SyntaxKind.VoidExpression] = walkVoidExpressionChildren;
    childrenWalkers[SyntaxKind.VoidKeyword] = null;
    childrenWalkers[SyntaxKind.WhileStatement] = walkWhileStatementChildren;
    childrenWalkers[SyntaxKind.WithStatement] = walkWithStatementChildren;

    // Verify the code is up to date with the enum
    for (var e in SyntaxKind) {
        if (SyntaxKind.hasOwnProperty(e) && StringUtilities.isString(SyntaxKind[e])) {
            TypeScript.Debug.assert(childrenWalkers[e] !== undefined, "Fix initWalkers: " + SyntaxKind[e]);
        }
    }

    export class AstWalkOptions {
        public goChildren = true;
        public stopWalking = false;
    }

    interface IAstWalkChildren {
        (preAst: ISyntaxElement, walker: AstWalker): void;
    }

    export interface IAstWalker {
        options: AstWalkOptions;
        state: any
    }

    interface AstWalker {
        walk(ast: ISyntaxElement): void;
    }

    class SimplePreAstWalker implements AstWalker {
        public options: AstWalkOptions = new AstWalkOptions();

        constructor(
            private pre: (ast: ISyntaxElement, state: any) => void,
            public state: any) {
        }

        public walk(ast: ISyntaxElement): void {
            if (!ast) {
                return;
            }

            this.pre(ast, this.state);

            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
        }
    }

    class SimplePrePostAstWalker implements AstWalker {
        public options: AstWalkOptions = new AstWalkOptions();

        constructor(
            private pre: (ast: ISyntaxElement, state: any) => void,
            private post: (ast: ISyntaxElement, state: any) => void,
            public state: any) {
        }

        public walk(ast: ISyntaxElement): void {
            if (!ast) {
                return;
            }

            this.pre(ast, this.state);

            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }

            this.post(ast, this.state);
        }
    }

    class NormalAstWalker implements AstWalker {
        public options: AstWalkOptions = new AstWalkOptions();

        constructor(
            private pre: (ast: ISyntaxElement, walker: IAstWalker) => void,
            private post: (ast: ISyntaxElement, walker: IAstWalker) => void,
            public state: any) {
        }

        public walk(ast: ISyntaxElement): void {
            if (!ast) {
                return;
            }

            // If we're stopping, then bail out immediately.
            if (this.options.stopWalking) {
                return;
            }

            this.pre(ast, this);

            // If we were asked to stop, then stop.
            if (this.options.stopWalking) {
                return;
            }

            if (this.options.goChildren) {
                // Call the "walkChildren" function corresponding to "nodeType".
                var walker = childrenWalkers[ast.kind()];
                if (walker) {
                    walker(ast, this);
                }
            }
            else {
                // no go only applies to children of node issuing it
                this.options.goChildren = true;
            }

            if (this.post) {
                this.post(ast, this);
            }
        }
    }

    export class AstWalkerFactory {
        public walk(ast: ISyntaxElement, pre: (ast: ISyntaxElement, walker: IAstWalker) => void, post?: (ast: ISyntaxElement, walker: IAstWalker) => void, state?: any): void {
            new NormalAstWalker(pre, post, state).walk(ast);
        }

        public simpleWalk(ast: ISyntaxElement, pre: (ast: ISyntaxElement, state: any) => void, post?: (ast: ISyntaxElement, state: any) => void, state?: any): void {
            if (post) {
                new SimplePrePostAstWalker(pre, post, state).walk(ast);
            }
            else {
                new SimplePreAstWalker(pre, state).walk(ast);
            }
        }
    }

    var globalAstWalkerFactory = new AstWalkerFactory();

    export function getAstWalkerFactory(): AstWalkerFactory {
        return globalAstWalkerFactory;
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

module TypeScript {
    class Base64Format {
        static encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        static encode(inValue: number) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        }

        static decodeChar(inChar: string) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            }
            else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        }
    }

    export class Base64VLQFormat {
        static encode(inValue: number) {
            // Add a new least significant bit that has the sign of the value.
            // if negative number the least significant bit that gets added to the number has value 1
            // else least significant bit value that gets added is 0
            // eg. -1 changes to binary : 01 [1] => 3
            //     +1 changes to binary : 01 [0] => 2
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }

            // Encode 5 bits at a time starting from least significant bits
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31; // 11111
                inValue = inValue >> 5;
                if (inValue > 0) {
                    // There are still more digits to decode, set the msb (6th bit)
                    currentDigit = currentDigit | 32; 
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while (inValue > 0);

            return encodedStr;
        }

        static decode(inString: string) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    // Sign bit appears in the LSBit of the first value
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15; // 1111x
                }
                else {
                    result = result | ((byte & 31) << shift); // 11111
                }

                shift += (i === 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                    // Continue
                }
                else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error(getDiagnosticMessage(DiagnosticCode.Base64_value_0_finished_with_a_continuation_bit, [inString]));
        }
    }
}
///<reference path='core\integerUtilities.ts' />

module TypeScript {

    export class BloomFilter {
        private bitArray: boolean[];
        private hashFunctionCount: number;

        public static falsePositiveProbability: number = 0.0001;

        /*
        * From the bloom filter calculator here: http://hur.st/bloomfilter?n=4&p=1.0E-20
        * 
        * 1) n  = Number of items in the filter
        * 
        * 2) p = Probability of false positives, (a double between 0 and 1).
        * 
        * 3) m = Number of bits in the filter
        * 
        * 4) k = Number of hash functions
        * 
        * m = ceil((n * log(p)) / log(1.0 / (pow(2.0, log(2.0)))))
        * 
        * k = round(log(2.0) * m / n)
        *
        */
        constructor(expectedCount: number) {
            var m: number = Math.max(1, BloomFilter.computeM(expectedCount));
            var k: number = Math.max(1, BloomFilter.computeK(expectedCount));;

            // We must have size in even bytes, so that when we deserialize from bytes we get a bit array with the same count.
            // The count is used by the hash functions.
            var sizeInEvenBytes = (m + 7) & ~7;

            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }

        // m = ceil((n * log(p)) / log(1.0 / (pow(2.0, log(2.0)))))
        static computeM(expectedCount: number): number {
            var p: number = BloomFilter.falsePositiveProbability;
            var n: number = expectedCount;

            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        }

        // k = round(log(2.0) * m / n)
        static computeK(expectedCount: number): number {
            var n: number = expectedCount;
            var m: number = BloomFilter.computeM(expectedCount);

            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        }

        /** Modification of the murmurhash2 algorithm.  Code is simpler because it operates over
         * strings instead of byte arrays.  Because each string character is two bytes, it is known
         * that the input will be an even number of bytes (though not necessarily a multiple of 4).
         * 
         * This is needed over the normal 'string.GetHashCode()' because we need to be able to generate
         * 'k' different well distributed hashes for any given string s.  Also, we want to be able to
         * generate these hashes without allocating any memory.  My ideal solution would be to use an
         * MD5 hash.  However, there appears to be no way to do MD5 in .Net where you can:
         * 
         * a) feed it individual values instead of a byte[]
         * 
         * b) have the hash computed into a byte[] you provide instead of a newly allocated one
         * 
         * Generating 'k' pieces of garbage on each insert and lookup seems very wasteful.  So,
         * instead, we use murmur hash since it provides well distributed values, allows for a
         * seed, and allocates no memory.
         * 
         * Murmur hash is public domain.  Actual code is included below as reference.
         */
        private computeHash(key: string, seed: number): number {
            return Hash.computeMurmur2StringHashCode(key, seed);
        }

        public addKeys(keys: IIndexable<any>) {
            for (var name in keys) {
                if (keys[name]) {
                    this.add(name);
                }
            }
        }

        public add(value: string) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        }

        public probablyContains(value: string): boolean {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }

            return true;
        }

        public isEquivalent(filter: BloomFilter): boolean {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray)
                && this.hashFunctionCount === filter.hashFunctionCount;
        }

        static isEquivalent(array1: boolean[], array2: boolean[]): boolean {
            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0; i < array1.length; i++) {
                if (array1[i] !== array2[i]) {
                    return false;
                }
            }

            return true;
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export class TextWriter {
        private contents = "";
        public onNewLine = true;
        constructor(private name: string, private writeByteOrderMark: boolean, private outputFileType: OutputFileType) {
        }

        public Write(s: string) {
            this.contents += s;
            this.onNewLine = false;
        }

        public WriteLine(s: string) {
            this.contents += s;
            this.contents += TypeScript.newLine();
            this.onNewLine = true;
        }

        public Close(): void {
        }

        public getOutputFile(): OutputFile {
            return new OutputFile(this.name, this.writeByteOrderMark, this.contents, this.outputFileType);
        }
    }

    export class DeclarationEmitter {
        private declFile: TextWriter = null;
        private indenter = new Indenter();
        private emittedReferencePaths = false;

        constructor(private emittingFileName: string,
                    public document: Document,
                    private compiler: TypeScriptCompiler,
                    private emitOptions: EmitOptions,
                    private semanticInfoChain: SemanticInfoChain) {
            this.declFile = new TextWriter(emittingFileName, this.document.byteOrderMark !== ByteOrderMark.None, OutputFileType.Declaration);
        }

        public getOutputFile(): OutputFile {
            return this.declFile.getOutputFile();
        }

        public emitDeclarations(sourceUnit: SourceUnitSyntax) {
            this.emitDeclarationsForSourceUnit(sourceUnit);
        }

        private emitDeclarationsForList(list: ISyntaxNodeOrToken[]) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.emitDeclarationsForAST(list[i]);
            }
        }

        private emitSeparatedList(list: ISyntaxNodeOrToken[]) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.emitDeclarationsForAST(list[i]);
            }
        }

        private emitDeclarationsForAST(ast: ISyntaxElement) {
            switch (ast.kind()) {
                case SyntaxKind.VariableStatement:
                    return this.emitDeclarationsForVariableStatement(<VariableStatementSyntax>ast);
                case SyntaxKind.PropertySignature:
                    return this.emitPropertySignature(<PropertySignatureSyntax>ast);
                case SyntaxKind.VariableDeclarator:
                    return this.emitVariableDeclarator(<VariableDeclaratorSyntax>ast, true, true);
                case SyntaxKind.MemberVariableDeclaration:
                    return this.emitDeclarationsForMemberVariableDeclaration(<MemberVariableDeclarationSyntax>ast);
                case SyntaxKind.ConstructorDeclaration:
                    return this.emitDeclarationsForConstructorDeclaration(<ConstructorDeclarationSyntax>ast);
                case SyntaxKind.GetAccessor:
                    return this.emitDeclarationsForGetAccessor(<GetAccessorSyntax>ast);
                case SyntaxKind.SetAccessor:
                    return this.emitDeclarationsForSetAccessor(<SetAccessorSyntax>ast);
                case SyntaxKind.IndexMemberDeclaration:
                    return this.emitIndexMemberDeclaration(<IndexMemberDeclarationSyntax>ast);
                case SyntaxKind.IndexSignature:
                    return this.emitIndexSignature(<IndexSignatureSyntax>ast);
                case SyntaxKind.CallSignature:
                    return this.emitCallSignature(<CallSignatureSyntax>ast);
                case SyntaxKind.ConstructSignature:
                    return this.emitConstructSignature(<ConstructSignatureSyntax>ast);
                case SyntaxKind.MethodSignature:
                    return this.emitMethodSignature(<MethodSignatureSyntax>ast);
                case SyntaxKind.FunctionDeclaration:
                    return this.emitDeclarationsForFunctionDeclaration(<FunctionDeclarationSyntax>ast);
                case SyntaxKind.MemberFunctionDeclaration:
                    return this.emitMemberFunctionDeclaration(<MemberFunctionDeclarationSyntax>ast);
                case SyntaxKind.ClassDeclaration:
                    return this.emitDeclarationsForClassDeclaration(<ClassDeclarationSyntax>ast);
                case SyntaxKind.InterfaceDeclaration:
                    return this.emitDeclarationsForInterfaceDeclaration(<InterfaceDeclarationSyntax>ast);
                case SyntaxKind.ImportDeclaration:
                    return this.emitDeclarationsForImportDeclaration(<ImportDeclarationSyntax>ast);
                case SyntaxKind.ModuleDeclaration:
                    return this.emitDeclarationsForModuleDeclaration(<ModuleDeclarationSyntax>ast);
                case SyntaxKind.EnumDeclaration:
                    return this.emitDeclarationsForEnumDeclaration(<EnumDeclarationSyntax>ast);
                case SyntaxKind.ExportAssignment:
                    return this.emitDeclarationsForExportAssignment(<ExportAssignmentSyntax>ast);
            }
        }

        private getIndentString(declIndent = false) {
            return this.indenter.getIndent();
        }

        private emitIndent() {
            this.declFile.Write(this.getIndentString());
        }

        private canEmitDeclarations(declAST: ISyntaxElement): boolean {
            var container = DeclarationEmitter.getEnclosingContainer(declAST);
            if (container.kind() === SyntaxKind.ModuleDeclaration || container.kind() === SyntaxKind.SourceUnit) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(declAST);
                if (!hasFlag(pullDecl.flags, PullElementFlags.Exported)) {
                    var start = new Date().getTime();
                    var declSymbol = this.semanticInfoChain.getSymbolForAST(declAST);
                    var result = declSymbol && declSymbol.isExternallyVisible();
                    TypeScript.declarationEmitIsExternallyVisibleTime += new Date().getTime() - start;

                    return result;
                }
            }

            return true;
        }

        private getDeclFlagsString(pullDecl: PullDecl, typeString: string) {
            var result = this.getIndentString();
            var pullFlags = pullDecl.flags;

            // Static/public/private/global declare
            if (hasFlag(pullFlags, PullElementFlags.Static)) {
                if (hasFlag(pullFlags, PullElementFlags.Private)) {
                    result += "private ";
                }
                result += "static ";
            }
            else {
                if (hasFlag(pullFlags, PullElementFlags.Private)) {
                    result += "private ";
                }
                else if (hasFlag(pullFlags, PullElementFlags.Public)) {
                    result += "public ";
                }
                else {
                    var emitDeclare = !hasFlag(pullFlags, PullElementFlags.Exported);

                    var declAST = this.semanticInfoChain.getASTForDecl(pullDecl);
                    var container = DeclarationEmitter.getEnclosingContainer(declAST);

                    var isExternalModule = container.kind() === SyntaxKind.SourceUnit && this.document.isExternalModule();

                    // Emit export only for global export statements. 
                    // The container for this would be dynamic module which is whole file
                    if (isExternalModule && hasFlag(pullFlags, PullElementFlags.Exported)) {
                        result += "export ";
                        emitDeclare = true;
                    }

                    // Emit declare only in global context
                    if (isExternalModule || container.kind() === SyntaxKind.SourceUnit) {
                        // Emit declare if not interface declaration or import declaration && is not from module
                        if (emitDeclare && typeString !== "interface" && typeString !== "import") {
                            result += "declare ";
                        }
                    }

                    result += typeString + " ";
                }
            }

            return result;
        }

        private emitDeclFlags(declarationAST: ISyntaxElement, typeString: string) {
            this.declFile.Write(this.getDeclFlagsString(this.semanticInfoChain.getDeclForAST(declarationAST), typeString));
        }

        private emitTypeNamesMember(memberName: MemberName, emitIndent: boolean = false) {
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            }
            else if (memberName.prefix !== "") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write((<MemberNameString>memberName).text);
            }
            else if (memberName.isArray()) {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            }
            else {
                this.declFile.Write(memberName.suffix);
            }
        }

        private emitTypeSignature(ast: ISyntaxElement, type: PullTypeSymbol) {
            var declarationContainerAst = DeclarationEmitter.getEnclosingContainer(ast);

            var start = new Date().getTime();
            var declarationContainerDecl = this.semanticInfoChain.getDeclForAST(declarationContainerAst);

            var declarationPullSymbol = declarationContainerDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitTypeSignatureTime += new Date().getTime() - start;

            var isNotAGenericType = ast.kind() !== SyntaxKind.GenericType;

            var typeNameMembers = type.getScopedNameEx(
                declarationPullSymbol, 
                /*skipTypeParametersInName?*/ false, 
                /*useConstraintInName?*/ false, 
                /*getPrettyTypeName?*/ false, 
                /*getTypeParamMarkerInfo?*/ false, 
                /*skipInternalAliasName?*/ false,
                /*shouldAllowArrayType:*/ isNotAGenericType);
            this.emitTypeNamesMember(typeNameMembers);
        }

        private emitComment(comment: Comment) {
            var text = getTrimmedTextLines(comment);
            if (this.declFile.onNewLine) {
                this.emitIndent();
            }
            else if (comment.kind() !== SyntaxKind.MultiLineCommentTrivia) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }

            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || comment.kind() !== SyntaxKind.MultiLineCommentTrivia) {
                this.declFile.WriteLine("");
            }
            else {
                this.declFile.Write(" ");
            }
        }

        private emitDeclarationComments(ast: ISyntaxElement, endLine?: boolean): void;
        private emitDeclarationComments(astOrSymbol: any, endLine = true) {
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var declComments: Comment[] = astOrSymbol.docComments ? astOrSymbol.docComments() : ASTHelpers.docComments(astOrSymbol);
            this.writeDeclarationComments(declComments, endLine);
        }

        private writeDeclarationComments(declComments: Comment[], endLine = true) {
            if (declComments) {
                var wroteComment = false;
                for (var i = 0; i < declComments.length; i++) {
                    if (ASTHelpers.isDocComment(declComments[i])) {
                        this.emitComment(declComments[i]);
                        wroteComment = true;
                    }
                }

                if (wroteComment) {
                    if (endLine) {
                        if (!this.declFile.onNewLine) {
                            this.declFile.WriteLine("");
                        }
                    }
                    else {
                        if (this.declFile.onNewLine) {
                            this.emitIndent();
                        }
                    }
                }
            }
        }

        private emitTypeOfVariableDeclaratorOrParameter(boundDecl: ISyntaxElement) {
            var start = new Date().getTime();
            var decl = this.semanticInfoChain.getDeclForAST(boundDecl);
            var pullSymbol = decl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitGetBoundDeclTypeTime += new Date().getTime() - start;

            var type = pullSymbol.type;
            Debug.assert(type);

            this.declFile.Write(": ");
            this.emitTypeSignature(boundDecl, type);
        }

        private emitPropertySignature(varDecl: PropertySignatureSyntax): void {
            this.emitDeclarationComments(varDecl);
            this.emitIndent();
            this.declFile.Write(varDecl.propertyName.text());
            if (varDecl.questionToken) {
                this.declFile.Write("?");
            }

            this.emitTypeOfVariableDeclaratorOrParameter(varDecl);

            this.declFile.WriteLine(";");
        }

        private emitVariableDeclarator(varDecl: VariableDeclaratorSyntax, isFirstVarInList: boolean, isLastVarInList: boolean) {
            if (this.canEmitDeclarations(varDecl)) {
                this.emitDeclarationComments(varDecl);
                // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
                // If it is var list of form  var a = varList count will be 0
                if (isFirstVarInList) {
                    this.emitDeclFlags(varDecl, "var");
                }

                this.declFile.Write(varDecl.propertyName.text());

                if (!hasModifier(ASTHelpers.getVariableDeclaratorModifiers(varDecl), PullElementFlags.Private)) {
                    this.emitTypeOfVariableDeclaratorOrParameter(varDecl);
                }

                // Write ; or ,
                if (isLastVarInList) {
                    this.declFile.WriteLine(";");
                }
                else {
                    this.declFile.Write(", ");
                }
            }
        }

        private emitClassElementModifiers(modifiers: ISyntaxToken[]): void {
            if (hasModifier(modifiers, PullElementFlags.Static)) {
                if (hasModifier(modifiers, PullElementFlags.Private)) {
                    this.declFile.Write("private ");
                }
                this.declFile.Write("static ");
            }
            else {
                if (hasModifier(modifiers, PullElementFlags.Private)) {
                    this.declFile.Write("private ");
                }
                else {
                    this.declFile.Write("public ");
                }
            }
        }

        private emitDeclarationsForMemberVariableDeclaration(varDecl: MemberVariableDeclarationSyntax) {
            if (this.canEmitDeclarations(varDecl)) {
                this.emitDeclarationComments(varDecl);

                this.declFile.Write(this.getIndentString());
                this.emitClassElementModifiers(varDecl.modifiers);;

                this.declFile.Write(varDecl.variableDeclarator.propertyName.text());

                if (!hasModifier(varDecl.modifiers, PullElementFlags.Private)) {
                    this.emitTypeOfVariableDeclaratorOrParameter(varDecl);
                }

                this.declFile.WriteLine(";");
            }
        }

        private emitDeclarationsForVariableStatement(variableStatement: VariableStatementSyntax) {
            this.emitDeclarationsForVariableDeclaration(variableStatement.variableDeclaration);
        }

        private emitDeclarationsForVariableDeclaration(variableDeclaration: VariableDeclarationSyntax) {
            var varListCount = variableDeclaration.variableDeclarators.length;
            for (var i = 0; i < varListCount; i++) {
                this.emitVariableDeclarator(variableDeclaration.variableDeclarators[i], i === 0, i === varListCount - 1);
            }
        }

        private emitArgDecl(argDecl: ISyntaxElement, id: ISyntaxToken, isOptional: boolean, isPrivate: boolean) {
            this.indenter.increaseIndent();

            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(id.text());
            if (isOptional) {
                this.declFile.Write("?");
            }

            this.indenter.decreaseIndent();

            if (!isPrivate) {
                this.emitTypeOfVariableDeclaratorOrParameter(argDecl);
            }
        }

        private isOverloadedCallSignature(funcDecl: ISyntaxElement) {
            var start = new Date().getTime();
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSymbol = functionDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitIsOverloadedCallSignatureTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            var signatures = funcTypeSymbol.getCallSignatures();
            var result = signatures && signatures.length > 1;

            return result;
        }

        private emitDeclarationsForConstructorDeclaration(funcDecl: ConstructorDeclarationSyntax) {
            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                }
                //else if (this.isOverloadedCallSignature(funcDecl)) {
                //    // This means its implementation of overload signature. do not emit
                //    return;
                //}
            }

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("constructor");

            this.emitParameterList(/*isPrivate:*/ false, funcDecl.callSignature.parameterList);

            this.declFile.WriteLine(";");
        }

        private emitParameterList(isPrivate: boolean, parameterList: ParameterListSyntax): void {
            this.declFile.Write("(");
            this.emitParameters(isPrivate, ASTHelpers.parametersFromParameterList(parameterList));
            this.declFile.Write(")");
        }

        private emitParameters(isPrivate: boolean, parameterList: IParameters): void {
            var hasLastParameterRestParameter = parameterList.lastParameterIsRest();
            var argsLen = parameterList.length;
            if (hasLastParameterRestParameter) {
                argsLen--;
            }

            for (var i = 0; i < argsLen; i++) {
                this.emitArgDecl(parameterList.astAt(i), parameterList.identifierAt(i), parameterList.isOptionalAt(i), isPrivate);
                if (i < (argsLen - 1)) {
                    this.declFile.Write(", ");
                }
            }

            if (hasLastParameterRestParameter) {
                if (parameterList.length > 1) {
                    this.declFile.Write(", ...");
                }
                else {
                    this.declFile.Write("...");
                }

                var index = parameterList.length - 1;
                this.emitArgDecl(parameterList.astAt(index), parameterList.identifierAt(index), parameterList.isOptionalAt(index), isPrivate);
            }
        }

        private emitMemberFunctionDeclaration(funcDecl: MemberFunctionDeclarationSyntax) {
            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                }
                else if (this.isOverloadedCallSignature(funcDecl)) {
                    // This means its implementation of overload signature. do not emit
                    return;
                }
            }
            else if (hasModifier(funcDecl.modifiers, PullElementFlags.Private) && this.isOverloadedCallSignature(funcDecl)) {
                // Print only first overload of private function
                var callSignatures = funcTypeSymbol.getCallSignatures();
                Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl !== funcDecl) {
                    return;
                }
            }

            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitDeclarationComments(funcDecl);

            this.emitDeclFlags(funcDecl, "function");
            var id = funcDecl.propertyName.text();
            this.declFile.Write(id);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            var isPrivate = hasModifier(funcDecl.modifiers, PullElementFlags.Private);

            this.emitParameterList(isPrivate, funcDecl.callSignature.parameterList);

            if (!isPrivate) {
                var returnType = funcSignature.returnType;
                this.declFile.Write(": ");
                this.emitTypeSignature(funcDecl, returnType);
            }

            this.declFile.WriteLine(";");
        }

        private emitCallSignature(funcDecl: CallSignatureSyntax): void {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            this.emitDeclarationComments(funcDecl);

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.typeParameterList, funcSignature);

            this.emitIndent();

            this.emitParameterList(/*isPrivate:*/ false, funcDecl.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            }
            else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        }

        private emitConstructSignature(funcDecl: ConstructSignatureSyntax) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("new");

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(/*isPrivate:*/ false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            }
            else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        }

        private emitMethodSignature(funcDecl: MethodSignatureSyntax) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write(funcDecl.propertyName.text());
            if (funcDecl.questionToken) {
                this.declFile.Write("? ");
            }

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(/*isPrivate:*/ false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            }
            else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        }

        private emitDeclarationsForFunctionDeclaration(funcDecl: FunctionDeclarationSyntax) {
            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);

            var start = new Date().getTime();
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            if (funcDecl.block) {
                var funcTypeSymbol = funcSymbol.type;
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                }
                else if (this.isOverloadedCallSignature(funcDecl)) {
                    // This means its implementation of overload signature. do not emit
                    return;
                }
            }

            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            this.emitDeclarationComments(funcDecl);

            var id = funcDecl.identifier.text();
            this.emitDeclFlags(funcDecl, "function");
            if (id !== "" || !funcDecl.identifier || funcDecl.identifier.text().length > 0) {
                this.declFile.Write(id);
            }
            else if (funcPullDecl.kind === PullElementKind.ConstructSignature) {
                this.declFile.Write("new");
            }

            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            this.emitTypeParameters(funcDecl.callSignature.typeParameterList, funcSignature);

            this.emitParameterList(/*isPrivate:*/ false, funcDecl.callSignature.parameterList);

            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            if (returnType) {
                this.emitTypeSignature(funcDecl, returnType);
            }
            else {
                this.declFile.Write("any");
            }

            this.declFile.WriteLine(";");
        }

        private emitIndexMemberDeclaration(funcDecl: IndexMemberDeclarationSyntax) {
            this.emitDeclarationsForAST(funcDecl.indexSignature);
        }

        private emitIndexSignature(funcDecl: IndexSignatureSyntax) {
            if (!this.canEmitDeclarations(funcDecl)) {
                return;
            }

            this.emitDeclarationComments(funcDecl);

            this.emitIndent();
            this.declFile.Write("[");
            this.emitParameters(/*isPrivate:*/ false, ASTHelpers.parametersFromParameter(funcDecl.parameter));
            this.declFile.Write("]");

            var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSignature = funcPullDecl.getSignatureSymbol(this.semanticInfoChain);
            var returnType = funcSignature.returnType;
            this.declFile.Write(": ");
            this.emitTypeSignature(funcDecl, returnType);

            this.declFile.WriteLine(";");
        }

        private emitBaseList(bases: INameSyntax[], useExtendsList: boolean) {
            if (bases && (bases.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    var base = bases[i];
                    var baseType = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(base);
                    this.emitTypeSignature(base, baseType);
                }
            }
        }

        private emitAccessorDeclarationComments(funcDecl: ISyntaxElement) {
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var start = new Date().getTime();
            var accessors = PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            var comments: Comment[] = [];
            if (accessors.getter) {
                comments = comments.concat(ASTHelpers.docComments(accessors.getter));
            }
            if (accessors.setter) {
                comments = comments.concat(ASTHelpers.docComments(accessors.setter));
            }

            this.writeDeclarationComments(comments);
        }

        private emitDeclarationsForGetAccessor(funcDecl: GetAccessorSyntax): void {
            this.emitMemberAccessorDeclaration(funcDecl, funcDecl.modifiers, funcDecl.propertyName);
        }

        private emitDeclarationsForSetAccessor(funcDecl: SetAccessorSyntax): void {
            this.emitMemberAccessorDeclaration(funcDecl, funcDecl.modifiers, funcDecl.propertyName);
        }

        private emitMemberAccessorDeclaration(funcDecl: ISyntaxElement, modifiers: ISyntaxToken[], name: ISyntaxToken) {
            var start = new Date().getTime();
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            if (funcDecl.kind() === SyntaxKind.SetAccessor && accessorSymbol.getGetter()) {
                // Setter is being used to emit the type info. 
                return;
            }

            var isPrivate = hasModifier(modifiers, PullElementFlags.Private);
            this.emitAccessorDeclarationComments(funcDecl);
            this.declFile.Write(this.getIndentString());
            this.emitClassElementModifiers(modifiers);
            this.declFile.Write(name.text());
            if (!isPrivate) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.type;
                this.emitTypeSignature(funcDecl, type);
            }
            this.declFile.WriteLine(";");
        }

        private emitClassMembersFromConstructorDefinition(funcDecl: ConstructorDeclarationSyntax) {
            var argsLen = funcDecl.callSignature.parameterList.parameters.length;
            if (lastParameterIsRest(funcDecl.callSignature.parameterList)) {
                argsLen--;
            }

            for (var i = 0; i < argsLen; i++) {
                var parameter = funcDecl.callSignature.parameterList.parameters[i];
                var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                if (hasFlag(parameterDecl.flags, PullElementFlags.PropertyParameter)) {
                    var funcPullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
                    this.emitDeclarationComments(parameter);
                    this.declFile.Write(this.getIndentString());
                    this.emitClassElementModifiers(parameter.modifiers);
                    this.declFile.Write(parameter.identifier.text());

                    if (!hasModifier(parameter.modifiers, PullElementFlags.Private)) {
                        this.emitTypeOfVariableDeclaratorOrParameter(parameter);
                    }
                    this.declFile.WriteLine(";");
                }
            }
        }

        private emitDeclarationsForClassDeclaration(classDecl: ClassDeclarationSyntax) {
            if (!this.canEmitDeclarations(classDecl)) {
                return;
            }

            var className = classDecl.identifier.text();
            this.emitDeclarationComments(classDecl);
            var classPullDecl = this.semanticInfoChain.getDeclForAST(classDecl);
            this.emitDeclFlags(classDecl, "class");
            this.declFile.Write(className);

            this.emitTypeParameters(classDecl.typeParameterList);
            this.emitHeritageClauses(classDecl.heritageClauses);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();
            var constructorDecl = getLastConstructor(classDecl);
            if (constructorDecl) {
                this.emitClassMembersFromConstructorDefinition(constructorDecl);
            }

            this.emitDeclarationsForList(classDecl.classElements);

            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        }

        private emitHeritageClauses(clauses: HeritageClauseSyntax[]): void {
            if (clauses) {
                for (var i = 0, n = clauses.length; i < n; i++) {
                    this.emitHeritageClause(clauses[i]);
                }
            }
        }

        private emitHeritageClause(clause: HeritageClauseSyntax) {
            this.emitBaseList(clause.typeNames, clause.kind() === SyntaxKind.ExtendsHeritageClause);
        }

        static getEnclosingContainer(ast: ISyntaxElement): ISyntaxElement {
            // If the passed in as is the 'name' portion of an module declaration.  
            // If so, we want the actual container of *that* module declaration.  
            var enclosingModule = ASTHelpers.getModuleDeclarationFromNameAST(ast);
            ast = enclosingModule || ast;

            ast = ast.parent;
            while (ast) {
                if (ast.kind() === SyntaxKind.ClassDeclaration ||
                    ast.kind() === SyntaxKind.InterfaceDeclaration ||
                    ast.kind() === SyntaxKind.ModuleDeclaration ||
                    ast.kind() === SyntaxKind.SourceUnit) {

                    return ast;
                }

                ast = ast.parent;
            }

            return null;
        }

        private emitTypeParameters(typeParams: TypeParameterListSyntax, funcSignature?: PullSignatureSymbol) {
            if (!typeParams || !typeParams.typeParameters.length) {
                return;
            }

            this.declFile.Write("<");
            var containerAst = DeclarationEmitter.getEnclosingContainer(typeParams);

            var start = new Date().getTime();
            var containerDecl = this.semanticInfoChain.getDeclForAST(containerAst);
            var containerSymbol = <PullTypeSymbol>containerDecl.getSymbol(this.semanticInfoChain);
            TypeScript.declarationEmitGetTypeParameterSymbolTime += new Date().getTime() - start;

            var typars: PullTypeSymbol[];
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            }
            else {
                typars = containerSymbol.getTypeArgumentsOrTypeParameters();
            }

            for (var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }

                var memberName = typars[i].getScopedNameEx(containerSymbol, /*skipTypeParametersInName*/ false, /*useConstraintInName:*/ true);
                this.emitTypeNamesMember(memberName);
            }

            this.declFile.Write(">");
        }

        private emitDeclarationsForInterfaceDeclaration(interfaceDecl: InterfaceDeclarationSyntax) {
            if (!this.canEmitDeclarations(interfaceDecl)) {
                return;
            }

            var interfaceName = interfaceDecl.identifier.text();
            this.emitDeclarationComments(interfaceDecl);
            var interfacePullDecl = this.semanticInfoChain.getDeclForAST(interfaceDecl);
            this.emitDeclFlags(interfaceDecl, "interface");
            this.declFile.Write(interfaceName);

            this.emitTypeParameters(interfaceDecl.typeParameterList);
            this.emitHeritageClauses(interfaceDecl.heritageClauses);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();

            this.emitSeparatedList(interfaceDecl.body.typeMembers);

            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        }

        private emitDeclarationsForImportDeclaration(importDeclAST: ImportDeclarationSyntax) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var importSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);
            var isExportedImportDecl = hasModifier(importDeclAST.modifiers, PullElementFlags.Exported);

            if (isExportedImportDecl || importSymbol.typeUsedExternally() || PullContainerSymbol.usedAsSymbol(importSymbol.getContainer(), importSymbol)) {
                this.emitDeclarationComments(importDeclAST);
                this.emitIndent();
                if (isExportedImportDecl) {
                    this.declFile.Write("export ");
                }
                this.declFile.Write("import ");
                this.declFile.Write(importDeclAST.identifier.text() + " = ");
                if (importDeclAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                    this.declFile.WriteLine("require(" + (<ExternalModuleReferenceSyntax>importDeclAST.moduleReference).stringLiteral.text() + ");");
                }
                else {
                    this.declFile.WriteLine(ASTHelpers.getNameOfIdenfierOrQualifiedName((<ModuleNameModuleReferenceSyntax>importDeclAST.moduleReference).moduleName) + ";");
                }
            }
        }

        private emitDeclarationsForEnumDeclaration(moduleDecl: EnumDeclarationSyntax): void {
            if (!this.canEmitDeclarations(moduleDecl)) {
                return;
            }

            this.emitDeclarationComments(moduleDecl);
            var modulePullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl);
            this.emitDeclFlags(moduleDecl, "enum");
            this.declFile.WriteLine(moduleDecl.identifier.text() + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.enumElements.length;
            for (var j = 0; j < membersLen; j++) {
                var enumElement = moduleDecl.enumElements[j];
                var enumElementDecl = <PullEnumElementDecl>this.semanticInfoChain.getDeclForAST(enumElement);
                this.emitDeclarationComments(enumElement);
                this.emitIndent();
                this.declFile.Write(enumElement.propertyName.text());
                if (enumElementDecl.constantValue !== null) {
                    this.declFile.Write(" = " + enumElementDecl.constantValue);
                }
                this.declFile.WriteLine(",");
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        }

        private emitDeclarationsForModuleDeclaration(moduleDecl: ModuleDeclarationSyntax) {
            // If module is defined as A.B.C 
            // The whole moduleDecl will have the pullDecl corresponding to innermost
            // Which would always be exported and hence would need to be emitted
            // But we really want to check if module A needs to be emitted and hence use
            // the leftmost name to determine if this needs to be emitted
            // Since the module name will have the correct decl, it is always used to determine
            // if this ast needs to be emitted or not
            var name: ISyntaxElement = moduleDecl.stringLiteral || ArrayUtilities.first(ASTHelpers.getModuleNames(moduleDecl.name));
            if (!this.canEmitDeclarations(name)) {
                return;
            }

            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(name, "module");

            if (moduleDecl.stringLiteral) {
                this.declFile.Write(moduleDecl.stringLiteral.text());
            }
            else {
                this.declFile.Write(ASTHelpers.getNameOfIdenfierOrQualifiedName(moduleDecl.name));
            }

            this.declFile.WriteLine(" {");
            this.indenter.increaseIndent();

            this.emitDeclarationsForList(moduleDecl.moduleElements);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.declFile.WriteLine("}");
        }

        private emitDeclarationsForExportAssignment(ast: ExportAssignmentSyntax) {
            this.emitIndent();
            this.declFile.Write("export = ");
            this.declFile.Write(ast.identifier.text());
            this.declFile.WriteLine(";");
        }

        private resolveScriptReference(document: Document, reference: string) {
            if (!this.emitOptions.compilationSettings().noResolve() || isRooted(reference)) {
                return reference;
            }

            var documentDir = convertToDirectoryPath(switchToForwardSlashes(getRootFilePath(document.fileName)));
            var resolvedReferencePath = this.emitOptions.resolvePath(documentDir + reference);
            return resolvedReferencePath;
        }

        private emitReferencePaths(sourceUnit: SourceUnitSyntax) {
            // In case of shared handler we collect all the references and emit them
            if (this.emittedReferencePaths) {
                return;
            }

            // Collect all the documents that need to be emitted as reference
            var documents: Document[] = [];
            if (this.document.emitToOwnOutputFile()) {
                // Emit only from this file
                var scriptReferences = this.document.referencedFiles;
                var addedGlobalDocument = false;
                for (var j = 0; j < scriptReferences.length; j++) {
                    var currentReference = this.resolveScriptReference(this.document, scriptReferences[j]);
                    var document = this.compiler.getDocument(currentReference);
                    // All the references that are not going to be part of same file

                    if (document &&
                        (document.emitToOwnOutputFile() || document.isDeclareFile() || !addedGlobalDocument)) {

                        documents = documents.concat(document);

                            if (!document.isDeclareFile() && document.isExternalModule()) {
                            addedGlobalDocument = true;
                        }
                    }
                }
            }
            else {
                // Collect from all the references and emit
                var fileNames = this.compiler.fileNames();
                for (var i = 0; i < fileNames.length; i++) {
                    var doc = this.compiler.getDocument(fileNames[i]);
                    if (!doc.isDeclareFile() && !doc.isExternalModule()) {
                        // Check what references need to be added
                        var scriptReferences = doc.referencedFiles;
                        for (var j = 0; j < scriptReferences.length; j++) {
                            var currentReference = this.resolveScriptReference(doc, scriptReferences[j]);
                            var document = this.compiler.getDocument(currentReference);
                            // All the references that are not going to be part of same file
                            if (document &&
                                (document.isDeclareFile() || document.isExternalModule())) {
                                for (var k = 0; k < documents.length; k++) {
                                    if (documents[k] === document) {
                                        break;
                                    }
                                }

                                if (k === documents.length) {
                                    documents = documents.concat(document);
                                }
                            }
                        }
                    }
                }
            }

            // Emit the references
            var emittingFilePath = documents.length ? getRootFilePath(this.emittingFileName) : null;
            for (var i = 0; i < documents.length; i++) {
                var document = documents[i];
                var declFileName: string;
                if (document.isDeclareFile()) {
                    declFileName = document.fileName;
                }
                else {
                    declFileName = this.compiler.mapOutputFileName(document, this.emitOptions, TypeScriptCompiler.mapToDTSFileName);
                }

                // Get the relative path
                declFileName = getRelativePathToFixedPath(emittingFilePath, declFileName, false);
                this.declFile.WriteLine('/// <reference path="' + declFileName + '" />');
            }

            this.emittedReferencePaths = true;
        }

        private emitDeclarationsForSourceUnit(sourceUnit: SourceUnitSyntax) {
            this.emitReferencePaths(sourceUnit);
            this.emitDeclarationsForList(sourceUnit.moduleElements);
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export module CompilerDiagnostics {
        export var debug = false;
        export interface IDiagnosticWriter {
            Alert(output: string): void;
        }

        export var diagnosticWriter: IDiagnosticWriter = null;

        export var analysisPass: number = 0;

        export function Alert(output: string) {
            if (diagnosticWriter) {
                diagnosticWriter.Alert(output);
            }
        }

        export function debugPrint(s: string) {
            if (debug) {
                Alert(s);
            }
        }

        export function assert(condition: boolean, s: string) {
            if (debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }

    }

    export interface ILogger {
        information(): boolean;
        debug(): boolean;
        warning(): boolean;
        error(): boolean;
        fatal(): boolean;
        log(s: string): void;
    }

    export class NullLogger implements ILogger {
        public information(): boolean { return false; }
        public debug(): boolean { return false; }
        public warning(): boolean { return false; }
        public error(): boolean { return false; }
        public fatal(): boolean { return false; }
        public log(s: string): void {
        }
    }

    export function timeFunction(logger: ILogger, funcDescription: string, func: () => any): any {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        if (logger.information()) {
            logger.log(funcDescription + " completed in " + (end - start) + " msec");
        }
        return result;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class Document implements IASTForDeclMap {
        private _diagnostics: Diagnostic[] = null;
        private _bloomFilter: BloomFilter = null;
        private _lineMap: LineMap = null;

        private _declASTMap: ISyntaxElement[] = [];
        private _astDeclMap: PullDecl[] = [];
        private _amdDependencies: string[] = undefined;

        private _externalModuleIndicatorSpan: TextSpan = undefined;

        constructor(private compilationSettings: ImmutableCompilationSettings,
                    public fileName: string,
                    public referencedFiles: string[],
                    private _scriptSnapshot: IScriptSnapshot,
                    public byteOrderMark: ByteOrderMark,
                    public version: number,
                    public isOpen: boolean,
                    private _syntaxTree: SyntaxTree,
                    private _topLevelDecl: PullDecl) {
        }

        // Only for use by the semantic info chain.
        public invalidate(): void {
            // Dump all information related to syntax.  We'll have to recompute it when asked.
            this._declASTMap.length = 0;
            this._astDeclMap.length = 0;
            this._topLevelDecl = null;

            this._syntaxTree = null;
            this._diagnostics = null;
            this._bloomFilter = null;
        }

        public isDeclareFile(): boolean {
            return isDTSFile(this.fileName);
        }

        private cacheSyntaxTreeInfo(syntaxTree: SyntaxTree): void {
            // If we're not keeping around the syntax tree, store the diagnostics and line
            // map so they don't have to be recomputed.
            var start = new Date().getTime();
            this._diagnostics = syntaxTree.diagnostics();
            TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;

            this._lineMap = syntaxTree.lineMap();

            var sourceUnit = syntaxTree.sourceUnit();
            var leadingTrivia = firstToken(sourceUnit).leadingTrivia();

            this._externalModuleIndicatorSpan = this.getImplicitImportSpan(leadingTrivia) || this.getTopLevelImportOrExportSpan(sourceUnit);

            var amdDependencies: string[] = [];
            for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        amdDependencies.push(amdDependency);
                    }
                }
            }

            this._amdDependencies = amdDependencies;
        }

        private getAmdDependency(comment: string): string {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        }

        private getImplicitImportSpan(sourceUnitLeadingTrivia: ISyntaxTriviaList): TextSpan {
            for (var i = 0, n = sourceUnitLeadingTrivia.count(); i < n; i++) {
                var trivia = sourceUnitLeadingTrivia.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var span = this.getImplicitImportSpanWorker(trivia);
                    if (span) {
                        return span;
                    }
                }
            }

            return null;
        }

        private getImplicitImportSpanWorker(trivia: ISyntaxTrivia): TextSpan {
            var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
            var match = implicitImportRegEx.exec(trivia.fullText());

            if (match) {
                return new TextSpan(trivia.fullStart(), trivia.fullWidth());
            }

            return null;
        }

        private getTopLevelImportOrExportSpan(node: SourceUnitSyntax): TextSpan {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var moduleElement = node.moduleElements[i];

                var _firstToken = firstToken(moduleElement);
                if (_firstToken !== null && _firstToken.kind() === SyntaxKind.ExportKeyword) {
                    return new TextSpan(start(_firstToken), width(_firstToken));
                }

                if (moduleElement.kind() === SyntaxKind.ImportDeclaration) {
                    var importDecl = <ImportDeclarationSyntax>moduleElement;
                    if (importDecl.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                        return new TextSpan(start(importDecl), width(importDecl));
                    }
                }
            }

            return null;;
        }

        public sourceUnit(): SourceUnitSyntax {
            // If we don't have a script, create one from our parse tree.
            return this.syntaxTree().sourceUnit();
        }

        public diagnostics(): Diagnostic[] {
            if (this._diagnostics === null) {
                // force the diagnostics to get created.
                this.syntaxTree();
                Debug.assert(this._diagnostics);
            }

            return this._diagnostics;
        }

        public lineMap(): LineMap {
            if (this._lineMap === null) {
                // force the line map to get created.
                this.syntaxTree();
                Debug.assert(this._lineMap);
            }

            return this._lineMap;
        }

        public isExternalModule(): boolean {
            return this.externalModuleIndicatorSpan() !== null;
        }

        // TODO: remove this once we move entirely over to fidelity.  Right now we don't have 
        // enough information in the AST to reconstruct this span data, so we cache and store it
        // on the document.  When we move to fidelity, we can just have the type checker determine
        // this in its own codepath.
        public externalModuleIndicatorSpan(): TextSpan {
            // October 11, 2013
            // External modules are written as separate source files that contain at least one 
            // external import declaration, export assignment, or top-level exported declaration.
            if (this._externalModuleIndicatorSpan === undefined) {
                // force the info about isExternalModule to get created.
                this.syntaxTree();
                Debug.assert(this._externalModuleIndicatorSpan !== undefined);
            }

            return this._externalModuleIndicatorSpan;
        }

        public amdDependencies(): string[] {
            if (this._amdDependencies === undefined) {
                // force the info about the amd dependencies to get created.
                this.syntaxTree();
                Debug.assert(this._amdDependencies !== undefined);
            }

            return this._amdDependencies;
        }

        public syntaxTree(): SyntaxTree {
            var result = this._syntaxTree;
            if (!result) {
                var start = new Date().getTime();

                result = Parser.parse(
                    this.fileName,
                    SimpleText.fromScriptSnapshot(this._scriptSnapshot),
                    TypeScript.isDTSFile(this.fileName),
                    this.compilationSettings.codeGenTarget());

                var time = new Date().getTime() - start;

                TypeScript.syntaxTreeParseTime += time;

                this._syntaxTree = result;
            }

            this.cacheSyntaxTreeInfo(result);
            return result;
        }

        public bloomFilter(): BloomFilter {
            if (!this._bloomFilter) {
                var identifiers = createIntrinsicsObject<boolean>();
                var pre = function (cur: TypeScript.ISyntaxElement) {
                    if (ASTHelpers.isValidAstNode(cur)) {
                        if (cur.kind() === SyntaxKind.IdentifierName) {
                            var nodeText = tokenValueText((<TypeScript.ISyntaxToken>cur));

                            identifiers[nodeText] = true;
                        }
                    }
                };

                TypeScript.getAstWalkerFactory().simpleWalk(this.sourceUnit(), pre, null, identifiers);

                var identifierCount = 0;
                for (var name in identifiers) {
                    if (identifiers[name]) {
                        identifierCount++;
                    }
                }

                this._bloomFilter = new BloomFilter(identifierCount);
                this._bloomFilter.addKeys(identifiers);
            }
            return this._bloomFilter;
        }

        // Returns true if this file should get emitted into its own unique output file.  
        // Otherwise, it should be written into a single output file along with the rest of hte
        // documents in the compilation.
        public emitToOwnOutputFile(): boolean {
            // If we haven't specified an output file in our settings, then we're definitely 
            // emitting to our own file.  Also, if we're an external module, then we're 
            // definitely emitting to our own file.
            return !this.compilationSettings.outFileOption() || this.isExternalModule();
        }

        public update(scriptSnapshot: IScriptSnapshot, version: number, isOpen: boolean, textChangeRange: TextChangeRange): Document {
            // See if we are currently holding onto a syntax tree.  We may not be because we're 
            // either a closed file, or we've just been lazy and haven't had to create the syntax
            // tree yet.  Access the field instead of the method so we don't accidently realize
            // the old syntax tree.
            var oldSyntaxTree = this._syntaxTree;

            if (textChangeRange !== null && Debug.shouldAssert(AssertionLevel.Normal)) {
                var oldText = this._scriptSnapshot;
                var newText = scriptSnapshot;

                TypeScript.Debug.assert((oldText.getLength() - textChangeRange.span().length() + textChangeRange.newLength()) === newText.getLength());

                if (Debug.shouldAssert(AssertionLevel.VeryAggressive)) {
                    var oldTextPrefix = oldText.getText(0, textChangeRange.span().start());
                    var newTextPrefix = newText.getText(0, textChangeRange.span().start());
                    TypeScript.Debug.assert(oldTextPrefix === newTextPrefix);

                    var oldTextSuffix = oldText.getText(textChangeRange.span().end(), oldText.getLength());
                    var newTextSuffix = newText.getText(textChangeRange.newSpan().end(), newText.getLength());
                    TypeScript.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }

            var text = SimpleText.fromScriptSnapshot(scriptSnapshot);

            // If we don't have a text change, or we don't have an old syntax tree, then do a full
            // parse.  Otherwise, do an incremental parse.
            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null
                ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName), this.compilationSettings.codeGenTarget())
                : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);

            return new Document(this.compilationSettings, this.fileName, this.referencedFiles, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree, /*topLevelDecl:*/ null);
        }

        public static create(compilationSettings: ImmutableCompilationSettings, fileName: string, scriptSnapshot: IScriptSnapshot, byteOrderMark: ByteOrderMark, version: number, isOpen: boolean, referencedFiles: string[]): Document {
            return new Document(compilationSettings, fileName, referencedFiles, scriptSnapshot, byteOrderMark, version, isOpen, /*syntaxTree:*/ null, /*topLevelDecl:*/ null);
        }

        public topLevelDecl(): PullDecl {
            if (this._topLevelDecl === null) {
                this._topLevelDecl = DeclarationCreator.create(this, this.compilationSettings);
            }

            return this._topLevelDecl;
        }

        public _getDeclForAST(ast: ISyntaxElement): PullDecl {
            // Ensure we actually have created all our decls before we try to find a mathcing decl
            // for this ast.
            this.topLevelDecl();
            return this._astDeclMap[syntaxID(ast)];
        }

        public getEnclosingDecl(ast: ISyntaxElement): PullDecl {
            if (ast.kind() === SyntaxKind.SourceUnit) {
                return this._getDeclForAST(ast);
            }

            // First, walk up the ISyntaxElement, looking for a decl corresponding to that ISyntaxElement node.
            ast = ast.parent;
            var decl: PullDecl = null;
            while (ast) {
                //if (ast.kind === SyntaxKind.ModuleDeclaration) {
                //    var moduleDecl = <ModuleDeclarationSyntax>ast;
                //    decl = this._getDeclForAST(<ISyntaxElement>moduleDecl.stringLiteral || ArrayUtilities.last(getModuleNames(moduleDecl.name)));
                //}
                //else {
                decl = this._getDeclForAST(ast);
                //}

                if (decl) {
                    break;
                }

                ast = ast.parent;
            }

            // Now, skip over certain decls.  The resolver never considers these the 'enclosing' 
            // decl for an ISyntaxElement node.
            return decl._getEnclosingDeclFromParentDecl();
        }

        public _setDeclForAST(ast: ISyntaxElement, decl: PullDecl): void {
            Debug.assert(decl.fileName() === this.fileName);
            this._astDeclMap[syntaxID(ast)] = decl;
        }

        public _getASTForDecl(decl: PullDecl): ISyntaxElement {
            return this._declASTMap[decl.declID];
        }

        public _setASTForDecl(decl: PullDecl, ast: ISyntaxElement): void {
            Debug.assert(decl.fileName() === this.fileName);
            this._declASTMap[decl.declID] = ast;
        }
    }
}
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export enum EmitContainer {
        Prog,
        Module,
        DynamicModule,
        Class,
        Constructor,
        Function,
        Args,
        Interface,
    }

    export class EmitState {
        public column: number;
        public line: number;
        public container: EmitContainer;

        constructor() {
            this.column = 0;
            this.line = 0;
            this.container = EmitContainer.Prog;
        }
    }

    export class EmitOptions {
        private _diagnostic: Diagnostic = null;

        private _settings: ImmutableCompilationSettings = null;
        private _commonDirectoryPath = "";
        private _sharedOutputFile = "";
        private _sourceRootDirectory = "";
        private _sourceMapRootDirectory = "";
        private _outputDirectory = "";

        public diagnostic(): Diagnostic { return this._diagnostic; }

        public commonDirectoryPath() { return this._commonDirectoryPath; }
        public sharedOutputFile() { return this._sharedOutputFile; }
        public sourceRootDirectory() { return this._sourceRootDirectory; }
        public sourceMapRootDirectory() { return this._sourceMapRootDirectory; }
        public outputDirectory() { return this._outputDirectory; }

        public compilationSettings() { return this._settings; }

        constructor(compiler: TypeScriptCompiler, public resolvePath: (path: string) => string) {
            var settings = compiler.compilationSettings();
            this._settings = settings;

            // If the document is an external module, then report if the the user has not 
            // provided the right command line option.
            if (settings.moduleGenTarget() === ModuleGenTarget.Unspecified) {
                var fileNames = compiler.fileNames();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = compiler.getDocument(fileNames[i]);
                    if (!document.isDeclareFile() && document.isExternalModule()) {
                        var errorSpan = document.externalModuleIndicatorSpan();
                        this._diagnostic = new Diagnostic(document.fileName, document.lineMap(), errorSpan.start(), errorSpan.length(),
                            DiagnosticCode.Cannot_compile_external_modules_unless_the_module_flag_is_provided);

                        return;
                    }
                }
            }

            if (!settings.mapSourceFiles()) {
                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles
                if (settings.mapRoot()) {
                    if (settings.sourceRoot()) {
                        this._diagnostic = new Diagnostic(null, null, 0, 0, DiagnosticCode.Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    }
                    else {
                        this._diagnostic = new Diagnostic(null, null, 0, 0, DiagnosticCode.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                        return;
                    }
                }
                else if (settings.sourceRoot()) {
                    this._diagnostic = new Diagnostic(null, null, 0, 0, DiagnosticCode.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    return;
                }
            }

            this._sourceMapRootDirectory = convertToDirectoryPath(switchToForwardSlashes(settings.mapRoot()));
            this._sourceRootDirectory = convertToDirectoryPath(switchToForwardSlashes(settings.sourceRoot()));

            if (settings.outFileOption() ||
                settings.outDirOption() ||
                settings.mapRoot() ||
                settings.sourceRoot()) {

                if (settings.outFileOption()) {
                    this._sharedOutputFile = switchToForwardSlashes(resolvePath(settings.outFileOption()));
                }

                if (settings.outDirOption()) {
                    this._outputDirectory = convertToDirectoryPath(switchToForwardSlashes(resolvePath(settings.outDirOption())));
                }

                // Parse the directory structure
                if (this._outputDirectory || this._sourceMapRootDirectory || this.sourceRootDirectory) {
                    this.determineCommonDirectoryPath(compiler);
                }
            }
        }

        private determineCommonDirectoryPath(compiler: TypeScriptCompiler): void {
            var commonComponents: string[] = [];
            var commonComponentsLength = -1;

            var fileNames = compiler.fileNames();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = compiler.getDocument(fileNames[i]);
                var sourceUnit = document.sourceUnit();

                if (!document.isDeclareFile()) {
                    var fileComponents = filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        // First time at finding common path
                        // So common path = directory of file
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    }
                    else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                // The new components = 0 ... j -1
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    var isDynamicModuleCompilation = ArrayUtilities.any(fileNames, fileName => {
                                        document = compiler.getDocument(fileName);
                                        return !document.isDeclareFile() && document.isExternalModule();
                                    });

                                    if (this._outputDirectory || // there is --outDir specified
                                        this._sourceRootDirectory || // there is --sourceRoot specified
                                        (this._sourceMapRootDirectory && // there is --map Specified and there would be multiple js files generated
                                        (!this._sharedOutputFile || isDynamicModuleCompilation))) {
                                        // Its error to not have common path
                                        this._diagnostic = new Diagnostic(null, null, 0, 0, DiagnosticCode.Cannot_find_the_common_subdirectory_path_for_the_input_files, null);
                                        return;
                                    }

                                    return;
                                }

                                break;
                            }
                        }

                        // If the fileComponent path completely matched and less than already found update the length
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this._commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
        }
    }

    export class Indenter {
        static indentStep: number = 4;
        static indentStepString: string = "    ";
        static indentStrings: string[] = [];
        public indentAmt: number = 0;

        public increaseIndent() {
            this.indentAmt += Indenter.indentStep;
        }

        public decreaseIndent() {
            this.indentAmt -= Indenter.indentStep;
        }

        public getIndent() {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        }
    }

    export function lastParameterIsRest(parameterList: ParameterListSyntax): boolean {
        var parameters = parameterList.parameters;
        return parameters.length > 0 && (parameters[parameters.length - 1]).dotDotDotToken !== null;
    }

    export class Emitter {
        public globalThisCapturePrologueEmitted = false;
        public extendsPrologueEmitted = false;
        public thisClassNode: ClassDeclarationSyntax = null;
        public inArrowFunction: boolean = false;
        public moduleName = "";
        public emitState = new EmitState();
        public indenter = new Indenter();
        public sourceMapper: SourceMapper = null;
        public captureThisStmtString = "var _this = this;";
        private currentVariableDeclaration: VariableDeclarationSyntax;
        private declStack: PullDecl[] = [];
        private exportAssignment: ExportAssignmentSyntax = null;
        private inWithBlock = false;

        public document: Document = null;

        // If we choose to detach comments from an element (for example, the Copyright comments),
        // then keep track of that element so that we don't emit all on the comments on it when
        // we visit it.
        private detachedCommentsElement: ISyntaxElement = null;

        constructor(public emittingFileName: string,
            public outfile: TextWriter,
            public emitOptions: EmitOptions,
            private semanticInfoChain: SemanticInfoChain) {
        }

        private pushDecl(decl: PullDecl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        }

        private popDecl(decl: PullDecl) {
            if (decl) {
                this.declStack.length--;
            }
        }

        private getEnclosingDecl() {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        }

        public setExportAssignment(exportAssignment: ExportAssignmentSyntax) {
            this.exportAssignment = exportAssignment;
        }

        public getExportAssignment() {
            return this.exportAssignment;
        }

        public setDocument(document: Document) {
            this.document = document;
        }

        public shouldEmitImportDeclaration(importDeclAST: ImportDeclarationSyntax) {
            var isExternalModuleReference = importDeclAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference;
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var isExported = hasFlag(importDecl.flags, PullElementFlags.Exported);
            var isAmdCodeGen = this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous;

            // 1) Any internal reference needs to check if the emit can happen
            // 2) External module reference with export modifier always needs to be emitted
            // 3) commonjs needs the var declaration for the import declaration
            if (isExternalModuleReference && !isExported && isAmdCodeGen) {
                return false;
            }
  
            var importSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);
            if (importSymbol.isUsedAsValue()) {
                return true;
            }

            if (importDeclAST.moduleReference.kind() !== SyntaxKind.ExternalModuleReference) {
                var canBeUsedExternally = isExported || importSymbol.typeUsedExternally() || importSymbol.isUsedInExportedAlias();
                if (!canBeUsedExternally && !this.document.isExternalModule()) {
                    // top level import in non-external module are visible across the whole global module
                    canBeUsedExternally = hasFlag(importDecl.getParentDecl().kind, PullElementKind.Script | PullElementKind.DynamicModule);
                }

                if (canBeUsedExternally) {
                    if (importSymbol.getExportAssignedValueSymbol()) {
                        return true;
                    }

                    var containerSymbol = importSymbol.getExportAssignedContainerSymbol();
                    if (containerSymbol && containerSymbol.getInstanceSymbol()) {
                        return true;
                    }
                }
            }

            return false;
        }

        public emitImportDeclaration(importDeclAST: ImportDeclarationSyntax) {
            var isExternalModuleReference = importDeclAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference;
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST);
            var isExported = hasFlag(importDecl.flags, PullElementFlags.Exported);
            var isAmdCodeGen = this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous;

            this.emitComments(importDeclAST, true);

            var importSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);

            var parentSymbol = importSymbol.getContainer();
            var parentKind = parentSymbol ? parentSymbol.kind : PullElementKind.None;
            var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
            var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : PullElementKind.None;

            var needsPropertyAssignment = false;
            var usePropertyAssignmentInsteadOfVarDecl = false;
            var moduleNamePrefix: string;

            if (isExported &&
                (parentKind === PullElementKind.Container ||
                parentKind === PullElementKind.DynamicModule ||
                associatedParentSymbolKind === PullElementKind.Container ||
                associatedParentSymbolKind === PullElementKind.DynamicModule)) {
                if (importSymbol.getExportAssignedTypeSymbol() || importSymbol.getExportAssignedContainerSymbol()) {
                    // Type or container assignment that is exported
                    needsPropertyAssignment = true;
                }
                else {
                    var valueSymbol = importSymbol.getExportAssignedValueSymbol();
                    if (valueSymbol &&
                        (valueSymbol.kind === PullElementKind.Method || valueSymbol.kind === PullElementKind.Function)) {
                        needsPropertyAssignment = true;
                    }
                    else {
                        usePropertyAssignmentInsteadOfVarDecl = true;
                    }
                }

                // Calculate what name prefix to use
                if (this.emitState.container === EmitContainer.DynamicModule) {
                    moduleNamePrefix = "exports."
                }
                else {
                    moduleNamePrefix = this.moduleName + ".";
                }
            }

            if (isAmdCodeGen && isExternalModuleReference) {
                // For amdCode gen of exported external module reference, do not emit var declaration
                // Emit the property assignment since it is exported
                needsPropertyAssignment = true;
            }
            else {
                this.recordSourceMappingStart(importDeclAST);
                if (usePropertyAssignmentInsteadOfVarDecl) {
                    this.writeToOutput(moduleNamePrefix);
                }
                else {
                    this.writeToOutput("var ");
                }
                this.writeToOutput(importDeclAST.identifier.text() + " = ");
                var aliasAST = importDeclAST.moduleReference;

                if (isExternalModuleReference) {
                    this.writeToOutput("require(" + (<ExternalModuleReferenceSyntax>aliasAST).stringLiteral.text() + ")");
                }
                else {
                    this.emitJavascript((<ModuleNameModuleReferenceSyntax>aliasAST).moduleName, false);
                }

                this.recordSourceMappingEnd(importDeclAST);
                this.writeToOutput(";");

                if (needsPropertyAssignment) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
            }

            if (needsPropertyAssignment) {
                this.writeToOutputWithSourceMapRecord(moduleNamePrefix + importDeclAST.identifier.text() + " = " + importDeclAST.identifier.text(), importDeclAST);
                this.writeToOutput(";");
            }
            this.emitComments(importDeclAST, false);
        }

        public createSourceMapper(document: Document, jsFileName: string, jsFile: TextWriter, sourceMapOut: TextWriter, resolvePath: (path: string) => string) {
            this.sourceMapper = new SourceMapper(jsFile, sourceMapOut, document, jsFileName, this.emitOptions, resolvePath);
        }

        public setSourceMapperNewSourceFile(document: Document) {
            this.sourceMapper.setNewSourceFile(document, this.emitOptions);
        }

        private updateLineAndColumn(s: string) {
            var lineNumbers = TextUtilities.parseLineStarts(s);
            if (lineNumbers.length > 1) {
                // There are new lines in the string, update the line and column number accordingly
                this.emitState.line += lineNumbers.length - 1;
                this.emitState.column = s.length - lineNumbers[lineNumbers.length - 1];
            }
            else {
                // No new lines in the string
                this.emitState.column += s.length;
            }
        }

        public writeToOutputWithSourceMapRecord(s: string, astSpan: ISyntaxElement) {
            if (astSpan) {
                this.recordSourceMappingStart(astSpan);
            }

            this.writeToOutput(s);

            if (astSpan) {
                this.recordSourceMappingEnd(astSpan);
            }
        }

        public writeToOutput(s: string) {
            this.outfile.Write(s);
            this.updateLineAndColumn(s);
        }

        public writeLineToOutput(s: string, force = false) {
            // No need to print a newline if we're already at the start of the line.
            if (!force && s === "" && this.emitState.column === 0) {
                return;
            }

            this.outfile.WriteLine(s);
            this.updateLineAndColumn(s);
            this.emitState.column = 0;
            this.emitState.line++;
        }

        public writeCaptureThisStatement(ast: ISyntaxElement) {
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord(this.captureThisStmtString, ast);
            this.writeLineToOutput("");
        }

        public setContainer(c: number): number {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        }

        private getIndentString() {
            return this.indenter.getIndent();
        }

        public emitIndent() {
            this.writeToOutput(this.getIndentString());
        }

        public emitComment(comment: Comment, trailing: boolean, first: boolean, noLeadingSpace = false) {
            if (this.emitOptions.compilationSettings().removeComments()) {
                return;
            }

            var text = getTrimmedTextLines(comment);
            var emitColumn = this.emitState.column;

            if (emitColumn === 0) {
                this.emitIndent();
            }
            else if (trailing && first && !noLeadingSpace) {
                this.writeToOutput(" ");
            }

            if (comment.kind() === SyntaxKind.MultiLineCommentTrivia) {
                this.recordSourceMappingCommentStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingCommentEnd(comment);
                    this.writeLineToOutput("");
                    // Fall through
                }
                else {
                    this.recordSourceMappingCommentEnd(comment);
                    this.writeToOutput(" ");
                    return;
                }
            }
            else {
                this.recordSourceMappingCommentStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingCommentEnd(comment);
                this.writeLineToOutput("");
                // Fall through
            }

            if (!trailing && emitColumn !== 0) {
                // If we were indented before, stay indented after.
                this.emitIndent();
            }
        }

        public emitComments(ast: ISyntaxElement, pre: boolean, onlyPinnedOrTripleSlashComments: boolean = false) {
            // Emitting the comments for the exprssion inside an arrow function is handled specially
            // in emitFunctionBodyStatements.  We don't want to emit those comments a second time.
            if (ast && !isShared(ast) && ast.kind() !== SyntaxKind.Block) {
                if (ast.parent.kind() === SyntaxKind.SimpleArrowFunctionExpression || ast.parent.kind() === SyntaxKind.ParenthesizedArrowFunctionExpression) {
                    return;
                }
            }

            if (pre) {
                var preComments = TypeScript.ASTHelpers.preComments(ast);

                if (preComments && ast === this.detachedCommentsElement) {
                    // We're emitting the comments for the first script element.  Skip any 
                    // copyright comments, as we'll already have emitted those.
                    var detachedComments = this.getDetachedComments(ast);
                    preComments = preComments.slice(detachedComments.length);
                    this.detachedCommentsElement = null;
                }

                // We're emitting comments on an elided element.  Only keep the comment if it is
                // a triple slash or pinned comment.
                if (preComments && onlyPinnedOrTripleSlashComments) {
                    preComments = ArrayUtilities.where(preComments, c => this.isPinnedOrTripleSlash(c));
                }

                this.emitCommentsArray(preComments, /*trailing:*/ false);
            }
            else {
                this.emitCommentsArray(ASTHelpers.postComments(ast), /*trailing:*/ true);
            }
        }

        private isPinnedOrTripleSlash(comment: Comment): boolean {
            var fullText = comment.fullText();
            if (fullText.match(tripleSlashReferenceRegExp)) {
                return true;
            }
            else {
                return fullText.indexOf("/*!") === 0;
            }
        }

        private emitCommentsArray(comments: Comment[], trailing: boolean, noLeadingSpace = false): void {
            if (!this.emitOptions.compilationSettings().removeComments() && comments) {
                for (var i = 0, n = comments.length; i < n; i++) {
                    this.emitComment(comments[i], trailing, /*first:*/ i === 0, noLeadingSpace);
                }
            }
        }

        public emitObjectLiteralExpression(objectLiteral: ObjectLiteralExpressionSyntax) {
            this.recordSourceMappingStart(objectLiteral);

            // Try to preserve the newlines between elements that the user had.
            this.writeToken(objectLiteral.openBraceToken);
            this.emitCommaSeparatedList(objectLiteral, objectLiteral.propertyAssignments, /*buffer:*/ " ", /*preserveNewLines:*/ true);
            this.writeToken(objectLiteral.closeBraceToken);

            this.recordSourceMappingEnd(objectLiteral);
        }

        public emitArrayLiteralExpression(arrayLiteral: ArrayLiteralExpressionSyntax) {
            this.recordSourceMappingStart(arrayLiteral);
            
            // Try to preserve the newlines between elements that the user had.
            this.writeToken(arrayLiteral.openBracketToken);
            this.emitCommaSeparatedList(arrayLiteral, arrayLiteral.expressions, /*buffer:*/ "", /*preserveNewLines:*/ true);
            this.writeToken(arrayLiteral.closeBracketToken);

            this.recordSourceMappingEnd(arrayLiteral);
        }

        public emitObjectCreationExpression(objectCreationExpression: ObjectCreationExpressionSyntax) {
            this.recordSourceMappingStart(objectCreationExpression);
            this.writeToken(objectCreationExpression.newKeyword);
            this.writeToOutput(" ");
            var target = objectCreationExpression.expression;

            this.emit(target);
            if (objectCreationExpression.argumentList) {
                this.recordSourceMappingStart(objectCreationExpression.argumentList);
                this.writeToken(objectCreationExpression.argumentList.openParenToken);
                this.emitCommaSeparatedList(objectCreationExpression.argumentList, objectCreationExpression.argumentList.arguments, /*buffer:*/ "", /*preserveNewLines:*/ false);
                this.writeToken(objectCreationExpression.argumentList.closeParenToken);
                this.recordSourceMappingEnd(objectCreationExpression.argumentList);
            }

            this.recordSourceMappingEnd(objectCreationExpression);
        }

        public getConstantDecl(dotExpr: MemberAccessExpressionSyntax): PullEnumElementDecl {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(dotExpr);
            if (pullSymbol && pullSymbol.kind === PullElementKind.EnumMember) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    if (pullDecl.kind === PullElementKind.EnumMember) {
                        return <PullEnumElementDecl>pullDecl;
                    }
                }
            }

            return null;
        }

        public tryEmitConstant(dotExpr: MemberAccessExpressionSyntax) {
            var propertyName = dotExpr.name;
            var boundDecl = this.getConstantDecl(dotExpr);
            if (boundDecl) {
                var value = boundDecl.constantValue;
                if (value !== null) {
                    this.recordSourceMappingStart(dotExpr);
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.text();
                    comment += " */";
                    this.writeToOutput(comment);
                    this.recordSourceMappingEnd(dotExpr);
                    return true;
                }
            }

            return false;
        }

        public emitInvocationExpression(callNode: InvocationExpressionSyntax) {
            this.recordSourceMappingStart(callNode);
            var target = callNode.expression;
            var args = callNode.argumentList.arguments;

            if (target.kind() === SyntaxKind.MemberAccessExpression && (<MemberAccessExpressionSyntax>target).expression.kind() === SyntaxKind.SuperKeyword) {
                this.emit(target);
                this.writeToOutput(".call");
                this.recordSourceMappingStart(args);
                this.writeToken(callNode.argumentList.openParenToken);
                this.emitThis();
                if (args && args.length > 0) {
                    this.writeToOutput(", ");
                    this.emitCommaSeparatedList(callNode.argumentList, args, /*buffer:*/ "", /*preserveNewLines:*/ false);
                }
            }
            else {
                if (callNode.expression.kind() === SyntaxKind.SuperKeyword && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("_super.call");
                }
                else {
                    this.emitJavascript(target, false);
                }
                this.recordSourceMappingStart(args);
                this.writeToken(callNode.argumentList.openParenToken);
                if (callNode.expression.kind() === SyntaxKind.SuperKeyword && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("this");
                    if (args && args.length > 0) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(callNode.argumentList, args, /*buffer:*/ "", /*preserveNewLines:*/ false);
            }

            this.writeToken(callNode.argumentList.closeParenToken);
            this.recordSourceMappingEnd(args);
            this.recordSourceMappingEnd(callNode);
        }

        private emitParameterList(list: ParameterListSyntax): void {
            this.writeToken(list.openParenToken);
            this.emitCommentsArray(ASTHelpers.convertTokenTrailingComments(list.openParenToken), /*trailing:*/ true, /*noLeadingSpace:*/ true);
            this.emitFunctionParameters(ASTHelpers.parametersFromParameterList(list));
            this.writeToken(list.closeParenToken);
        }

        private emitFunctionParameters(parameters: IParameters): void {
            var argsLen = 0;

            if (parameters) {
                var parameterListAST = parameters.ast.kind() === SyntaxKind.SeparatedList ? <ParameterSyntax[]>parameters.ast : null;
                this.emitComments(parameters.ast, true);

                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = parameters.length;
                var printLen = argsLen;
                if (parameters.lastParameterIsRest()) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = parameters.astAt(i);
                    this.emit(arg);

                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                        if (parameterListAST) {
                            this.emitCommentsArray(ASTHelpers.convertTokenTrailingComments(parameterListAST.separatorAt(i)), /*trailing:*/ true, /*noLeadingSpace:*/ true);
                        }
                    }
                }
                this.setContainer(tempContainer);

                this.emitComments(parameters.ast, false);
            }
        }

        private emitFunctionBodyStatements(name: string, funcDecl: ISyntaxElement, parameterList: IParameters, block: BlockSyntax, bodyExpression: ISyntaxElement): void {
            this.writeLineToOutput(" {");
            if (name) {
                this.recordSourceMappingNameStart(name);
            }

            this.indenter.increaseIndent();

            if (block) {
                // We want any detached statements at the start of hte block to stay at the start.
                // This is important for features like VSDoc which place their comments inside a
                // block, but can't have them preceded by things like "var _this = this" when we
                // emit.

                this.emitDetachedComments(block.statements);
            }

            // Parameter list parameters with defaults could capture this
            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (parameterList) {
                this.emitDefaultValueAssignments(parameterList);
                this.emitRestParameterInitializer(parameterList);
            }

            if (block) {
                this.emitList(block.statements);
                this.emitCommentsArray(ASTHelpers.convertTokenLeadingComments(block.closeBraceToken), /*trailing:*/ false);
            }
            else {
                // Copy any comments before the body of the arrow function to the return statement.
                // This is necessary for emitting correctness so we don't emit something like this:
                //
                //      return
                //          // foo
                //          this.foo();
                //
                // Because of ASI, this gets parsed as "return;" which is *not* what we want for
                // proper semantics.  
                //var preComments = bodyExpression.preComments();
                //var postComments = bodyExpression.postComments();

                //bodyExpression.setPreComments(null);
                //bodyExpression.setPostComments(null);

                this.emitIndent();
                this.emitCommentsArray(ASTHelpers.preComments(bodyExpression), /*trailing:*/ false);
                this.writeToOutput("return ");
                this.emit(bodyExpression);
                this.writeLineToOutput(";");
                this.emitCommentsArray(ASTHelpers.preComments(bodyExpression), /*trailing:*/ true);

                //bodyExpression.setPreComments(preComments);
                //bodyExpression.setPostComments(postComments);
            }

            this.indenter.decreaseIndent();
            this.emitIndent();

            if (block) {
                this.writeToken(block.closeBraceToken);
            }
            else {
                this.writeToOutputWithSourceMapRecord("}", bodyExpression);
            }

            if (name) {
                this.recordSourceMappingNameEnd();
            }
        }

        private emitDefaultValueAssignments(parameters: IParameters): void {
            var n = parameters.length;
            if (parameters.lastParameterIsRest()) {
                n--;
            }

            for (var i = 0; i < n; i++) {
                var arg = parameters.astAt(i);
                var id = parameters.identifierAt(i);
                var equalsValueClause = parameters.initializerAt(i);
                if (equalsValueClause) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + id.text() + " === \"undefined\") { ");//
                    this.writeToken(id);
                    this.emitJavascript(equalsValueClause, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        }

        private emitRestParameterInitializer(parameters: IParameters): void {
            if (parameters.lastParameterIsRest()) {
                var n = parameters.length;
                var lastArg = parameters.astAt(n - 1);
                var id = parameters.identifierAt(n - 1);
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.writeToken(id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.writeToOutputWithSourceMapRecord("var _i = 0;", lastArg);
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord("_i < (arguments.length - " + (n - 1) + ")", lastArg);
                this.writeToOutput("; ");
                this.writeToOutputWithSourceMapRecord("_i++", lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.writeToOutputWithSourceMapRecord(id.text() + "[_i] = arguments[_i + " + (n - 1) + "];", lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        }

        private getImportDecls(fileName: string): PullDecl[] {
            var topLevelDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
            var result: PullDecl[] = [];

            var dynamicModuleDecl = topLevelDecl.getChildDecls()[0]; // Dynamic module declaration has to be present
            var queue: PullDecl[] = dynamicModuleDecl.getChildDecls();

            for (var i = 0, n = queue.length; i < n; i++) {
                var decl = queue[i];

                if (decl.kind & PullElementKind.TypeAlias) {
                    var importStatementAST = <ImportDeclarationSyntax>this.semanticInfoChain.getASTForDecl(decl);
                    if (importStatementAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference) { // external module
                        var symbol = decl.getSymbol(this.semanticInfoChain);
                        var typeSymbol = symbol && symbol.type;
                        if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                            result.push(decl);
                        }
                    }
                }
            }

            return result;
        }

        public getModuleImportAndDependencyList(sourceUnit: SourceUnitSyntax) {
            var importList = "";
            var dependencyList = "";

            var importDecls = this.getImportDecls(this.document.fileName);

            // all dependencies are quoted
            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = <PullTypeAliasSymbol>importStatementDecl.getSymbol(this.semanticInfoChain);
                    var importStatementAST = <ImportDeclarationSyntax>this.semanticInfoChain.getASTForDecl(importStatementDecl);

                    if (importStatementSymbol.isUsedAsValue()) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += importStatementDecl.name;
                        dependencyList += (<ExternalModuleReferenceSyntax>importStatementAST.moduleReference).stringLiteral.text();
                    }
                }
            }

            // emit any potential amd dependencies
            var amdDependencies = this.document.amdDependencies();
            for (var i = 0; i < amdDependencies.length; i++) {
                dependencyList += ", \"" + amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        }

        public shouldCaptureThis(ast: ISyntaxElement) {
            if (ast.kind() === SyntaxKind.SourceUnit) {
                var scriptDecl = this.semanticInfoChain.topLevelDecl(this.document.fileName);
                return hasFlag(scriptDecl.flags, PullElementFlags.MustCaptureThis);
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast);
            if (decl) {
                return hasFlag(decl.flags, PullElementFlags.MustCaptureThis);
            }

            return false;
        }

        public emitEnum(moduleDecl: EnumDeclarationSyntax) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;
            this.moduleName = moduleDecl.identifier.text();

            var temp = this.setContainer(EmitContainer.Module);
            var isExported = hasFlag(pullDecl.flags, PullElementFlags.Exported);

            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.identifier);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }

            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.identifier);
            this.writeLineToOutput(") {");

            this.recordSourceMappingNameStart(this.moduleName);

            this.indenter.increaseIndent();

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            this.emitSeparatedList(moduleDecl.enumElements);
            this.indenter.decreaseIndent();
            this.emitIndent();

            var parentIsDynamic = temp === EmitContainer.DynamicModule;
            if (temp === EmitContainer.Prog && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            }
            else if (isExported || temp === EmitContainer.Prog) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            }
            else if (!isExported && temp !== EmitContainer.Prog) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            }
            else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.writeToOutput(")();");
            }

            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== EmitContainer.Prog && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                }
                else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);
        }

        private getModuleDeclToVerifyChildNameCollision(moduleDecl: PullDecl, changeNameIfAnyDeclarationInContext: boolean) {
            if (ArrayUtilities.contains(this.declStack, moduleDecl)) {
                // Given decl is in the scope, we would need to check for child name collision
                return moduleDecl;
            }
            else if (changeNameIfAnyDeclarationInContext) {
                // Check if any other declaration of the given symbol is in scope 
                // (eg. when emitting expression of type defined from different declaration in reopened module)
                var symbol = moduleDecl.getSymbol(this.semanticInfoChain);
                if (symbol) {
                    var otherDecls = symbol.getDeclarations();
                    for (var i = 0; i < otherDecls.length; i++) {
                        // If the other decl is in the scope, use this decl to determine which name to display
                        if (ArrayUtilities.contains(this.declStack, otherDecls[i])) {
                            return otherDecls[i];
                        }
                    }
                }
            }

            return null;
        }

        private hasChildNameCollision(moduleName: string, parentDecl: PullDecl) {
            var childDecls = parentDecl.getChildDecls();
            return ArrayUtilities.any(childDecls, (childDecl: PullDecl) => {
                var childAST = this.semanticInfoChain.getASTForDecl(childDecl);
                // Enum member it can never conflict with module name as it is property of the enum
                // Only if this child would be emitted we need to look further in
                if (childDecl.kind != PullElementKind.EnumMember && this.shouldEmit(childAST)) {
                    // same name child
                    if (childDecl.name === moduleName) {
                        // collision if the parent was not class
                        if (parentDecl.kind != PullElementKind.Class) {
                            return true;
                        }

                        // If the parent was class, we would find name collision if this was not a property/method/accessor
                        if (!(childDecl.kind == PullElementKind.Method ||
                            childDecl.kind == PullElementKind.Property ||
                            childDecl.kind == PullElementKind.SetAccessor ||
                            childDecl.kind == PullElementKind.GetAccessor)) {
                            return true;
                        }
                    }

                    // Check if the name collision exists in any of the children
                    if (this.hasChildNameCollision(moduleName, childDecl)) {
                        return true;
                    }
                }
                return false;
            });
        }

        // Get the moduleName to write in js file
        // If changeNameIfAnyDeclarationInContext is true, verify if any of the declarations for the symbol would need rename.
        private getModuleName(moduleDecl: PullDecl, changeNameIfAnyDeclarationInContext?: boolean) {
            var moduleName = moduleDecl.name;
            var moduleDisplayName = moduleDecl.getDisplayName();

            // If the decl is in stack it may need name change in the js file
            moduleDecl = this.getModuleDeclToVerifyChildNameCollision(moduleDecl, changeNameIfAnyDeclarationInContext);
            if (moduleDecl && moduleDecl.kind != PullElementKind.Enum) {
                // If there is any child that would be emitted with same name as module, js files would need to use rename for the module
                while (this.hasChildNameCollision(moduleName, moduleDecl)) {
                    // there was name collision with member which could result in faulty codegen, try rename with prepend of '_'
                    moduleName = "_" + moduleName;
                    moduleDisplayName = "_" + moduleDisplayName;
                }
            }

            return moduleDisplayName;
        }

        private emitModuleDeclarationWorker(moduleDecl: ModuleDeclarationSyntax) {
            if (moduleDecl.stringLiteral) {
                this.emitSingleModuleDeclaration(moduleDecl, moduleDecl.stringLiteral);
            }
            else {
                var moduleNames = ASTHelpers.getModuleNames(moduleDecl.name);
                this.emitSingleModuleDeclaration(moduleDecl, moduleNames[0]);
            }
        }

        private writeToken(token: ISyntaxToken) {
            if (token) {
                this.writeToOutputWithSourceMapRecord(token.text(), token);
            }
        }

        public emitSingleModuleDeclaration(moduleDecl: ModuleDeclarationSyntax, moduleName: ISyntaxToken) {
            var isLastName = ASTHelpers.isLastNameOfModule(moduleDecl, moduleName);

            if (isLastName) {
                // Doc Comments on the ast belong to the innermost module being emitted.
                this.emitComments(moduleDecl, true);
            }

            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleName);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;

            if (moduleDecl.stringLiteral) {
                this.moduleName = tokenValueText(moduleDecl.stringLiteral);
                if (isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }
            }
            else {
                this.moduleName = moduleName.text();
            }

            var temp = this.setContainer(EmitContainer.Module);
            var isExported = hasFlag(pullDecl.flags, PullElementFlags.Exported);

            // prologue

            if (!isExported) {
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(this.moduleName, moduleName);
                this.writeLineToOutput(";");
                this.recordSourceMappingEnd(moduleDecl);
                this.emitIndent();
            }

            this.writeToOutput("(");
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("function (");
            // Use the name that doesnt conflict with its members, 
            // this.moduleName needs to be updated to make sure that export member declaration is emitted correctly
            this.moduleName = this.getModuleName(pullDecl);
            this.writeToOutputWithSourceMapRecord(this.moduleName, moduleName);
            this.writeLineToOutput(") {");

            this.recordSourceMappingNameStart(moduleName.text());

            this.indenter.increaseIndent();

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            if (moduleName === moduleDecl.stringLiteral) {
                this.emitList(moduleDecl.moduleElements);
            }
            else {
                var moduleNames = ASTHelpers.getModuleNames(moduleDecl.name);
                var nameIndex = moduleNames.indexOf(<ISyntaxToken>moduleName);

                Debug.assert(nameIndex >= 0);

                if (isLastName) {
                    // If we're on the innermost module, we can emit the module elements.
                    this.emitList(moduleDecl.moduleElements);
                }
                else {
                    // otherwise, just recurse and emit the next module in the A.B.C module name.
                    this.emitIndent();
                    this.emitSingleModuleDeclaration(moduleDecl, moduleNames[nameIndex + 1]);
                    this.writeLineToOutput("");
                }
            }

            this.moduleName = moduleName.text();
            this.indenter.decreaseIndent();
            this.emitIndent();

            // epilogue
            var parentIsDynamic = temp === EmitContainer.DynamicModule;
            this.recordSourceMappingStart(moduleDecl.closeBraceToken);
            if (temp === EmitContainer.Prog && isExported) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
            }
            else if (isExported || temp === EmitContainer.Prog) {
                var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
            }
            else if (!isExported && temp !== EmitContainer.Prog) {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
            }
            else {
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(moduleDecl.closeBraceToken);
                this.writeToOutput(")();");
            }

            this.recordSourceMappingEnd(moduleDecl);
            if (temp !== EmitContainer.Prog && isExported) {
                this.recordSourceMappingStart(moduleDecl);
                if (parentIsDynamic) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                }
                else {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                }
                this.recordSourceMappingEnd(moduleDecl);
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);

            if (isLastName) {
                // Comments on the module ast belong to the innermost module being emitted.
                this.emitComments(moduleDecl, false);
            }
        }

        public emitEnumElement(varDecl: EnumElementSyntax): void {
            // <EnumName>[<EnumName>["<MemberName>"] = <MemberValue>] = "<MemberName>";
            var pullDecl = <PullEnumElementDecl>this.semanticInfoChain.getDeclForAST(varDecl);
            Debug.assert(pullDecl && pullDecl.kind === PullElementKind.EnumMember);

            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);

            var representation = (varDecl.propertyName.kind() === SyntaxKind.StringLiteral)
                ? varDecl.propertyName.text()
                : ('"' + tokenValueText(varDecl.propertyName) + '"');

            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(representation);
            this.writeToOutput(']');

            if (varDecl.equalsValueClause) {
                this.emit(varDecl.equalsValueClause);
            }
            else if (pullDecl.constantValue !== null) {
                this.writeToOutput(' = ');
                this.writeToOutput(pullDecl.constantValue.toString());
            }
            else {
                this.writeToOutput(' = null');
            }

            this.writeToOutput('] = ');
            this.writeToOutput(representation);
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.writeToOutput(';');
        }

        public emitElementAccessExpression(expression: ElementAccessExpressionSyntax) {
            this.recordSourceMappingStart(expression);
            this.emit(expression.expression);
            this.writeToken(expression.openBracketToken);
            this.emit(expression.argumentExpression);
            this.writeToken(expression.closeBracketToken);
            this.recordSourceMappingEnd(expression);
        }

        public emitSimpleArrowFunctionExpression(arrowFunction: SimpleArrowFunctionExpressionSyntax): void {
            this.emitAnyArrowFunctionExpression(arrowFunction, arrowFunction.block, arrowFunction.expression);
        }

        public emitParenthesizedArrowFunctionExpression(arrowFunction: ParenthesizedArrowFunctionExpressionSyntax): void {
            this.emitAnyArrowFunctionExpression(arrowFunction, arrowFunction.block, arrowFunction.expression);
        }

        private emitAnyArrowFunctionExpression(arrowFunction: ISyntaxElement, block: BlockSyntax, expression: ISyntaxElement): void {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = true;

            var temp = this.setContainer(EmitContainer.Function);

            this.recordSourceMappingStart(arrowFunction);

            // Start
            var pullDecl = this.semanticInfoChain.getDeclForAST(arrowFunction);
            this.pushDecl(pullDecl);

            this.emitComments(arrowFunction, true);

            this.recordSourceMappingStart(arrowFunction);
            this.writeToOutput("function ");

            var parameters: IParameters = null;
            if (arrowFunction.kind() === SyntaxKind.ParenthesizedArrowFunctionExpression) {
                var parenthesizedArrowFunction = <ParenthesizedArrowFunctionExpressionSyntax>arrowFunction;

                parameters = ASTHelpers.parametersFromParameterList(parenthesizedArrowFunction.callSignature.parameterList);
                this.emitParameterList(parenthesizedArrowFunction.callSignature.parameterList);
            }
            else {
                parameters = ASTHelpers.parametersFromIdentifier((<SimpleArrowFunctionExpressionSyntax>arrowFunction).identifier)
                this.writeToOutput("(");
                this.emitFunctionParameters(parameters);
                this.writeToOutput(")");
            }

            this.emitFunctionBodyStatements(/*funcName:*/ null, arrowFunction, parameters, block, expression);

            this.recordSourceMappingEnd(arrowFunction);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(arrowFunction);

            this.emitComments(arrowFunction, false);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        }

        public emitConstructor(funcDecl: ConstructorDeclarationSyntax) {
            if (!funcDecl.block) {
                return;
            }
            var temp = this.setContainer(EmitContainer.Constructor);

            this.recordSourceMappingStart(funcDecl);

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.emitComments(funcDecl, true);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.writeToOutput(this.thisClassNode.identifier.text());

            this.emitParameterList(funcDecl.callSignature.parameterList);
            this.writeLineToOutput(" {");

            this.recordSourceMappingNameStart("constructor");
            this.indenter.increaseIndent();

            var parameters = ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList);
            this.emitDefaultValueAssignments(parameters);
            this.emitRestParameterInitializer(parameters);

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            this.emitConstructorStatements(funcDecl);
            this.emitCommentsArray(ASTHelpers.convertTokenLeadingComments(funcDecl.block.closeBraceToken), /*trailing:*/ false);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(funcDecl.block.closeBraceToken);

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);
            this.setContainer(temp);
        }

        public emitGetAccessor(accessor: GetAccessorSyntax): void {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("get ");

            var temp = this.setContainer(EmitContainer.Function);

            this.recordSourceMappingStart(accessor);

            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(accessor);

            var accessorSymbol = PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;

            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());
            this.emitParameterList(accessor.parameterList);

            this.emitFunctionBodyStatements(null, accessor, ASTHelpers.parametersFromParameterList(accessor.parameterList), accessor.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(accessor);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(accessor);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        }

        public emitSetAccessor(accessor: SetAccessorSyntax): void {
            this.recordSourceMappingStart(accessor);
            this.writeToOutput("set ");

            var temp = this.setContainer(EmitContainer.Function);

            this.recordSourceMappingStart(accessor);

            var pullDecl = this.semanticInfoChain.getDeclForAST(accessor);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(accessor);

            var accessorSymbol = PullHelpers.getAccessorSymbol(accessor, this.semanticInfoChain);
            var container = accessorSymbol.getContainer();
            var containerKind = container.kind;

            this.recordSourceMappingNameStart(accessor.propertyName.text());
            this.writeToOutput(accessor.propertyName.text());

            this.emitParameterList(accessor.parameterList);

            this.emitFunctionBodyStatements(null, accessor, ASTHelpers.parametersFromParameterList(accessor.parameterList), accessor.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(accessor);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(accessor);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.recordSourceMappingEnd(accessor);
        }

        public emitFunctionExpression(funcDecl: FunctionExpressionSyntax): void {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(EmitContainer.Function);

            var funcName = funcDecl.identifier ? funcDecl.identifier.text() : null;//.getNameText();

            this.recordSourceMappingStart(funcDecl);

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToken(funcDecl.functionKeyword);
            this.writeToOutput(" ");

            //var id = funcDecl.getNameText();
            if (funcDecl.identifier) {
                this.writeToOutputWithSourceMapRecord(funcDecl.identifier.text(), funcDecl.identifier);
            }

            this.emitParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcName, funcDecl, ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList), funcDecl.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(funcDecl);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        }

        public emitFunction(funcDecl: FunctionDeclarationSyntax) {
            if (funcDecl.block === null) {
                return;
            }
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(EmitContainer.Function);

            var funcName = funcDecl.identifier.text();

            this.recordSourceMappingStart(funcDecl);

            var printName = funcDecl.identifier !== null
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.emitComments(funcDecl, true);

            this.recordSourceMappingStart(funcDecl);
            this.writeToken(funcDecl.functionKeyword);
            this.writeToOutput(" ");

            if (printName) {
                var id = funcDecl.identifier.text();
                if (id) {
                    if (funcDecl.identifier) {
                        this.recordSourceMappingStart(funcDecl.identifier);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.identifier) {
                        this.recordSourceMappingEnd(funcDecl.identifier);
                    }
                }
            }

            this.emitParameterList(funcDecl.callSignature.parameterList);

            var parameters = ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcDecl.identifier.text(), funcDecl, parameters, funcDecl.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(funcDecl);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;

            if (funcDecl.block) {
                var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
                if ((this.emitState.container === EmitContainer.Module || this.emitState.container === EmitContainer.DynamicModule) && pullFunctionDecl && hasFlag(pullFunctionDecl.flags, PullElementFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        }

        public emitAmbientVarDecl(varDecl: VariableDeclaratorSyntax) {
            this.recordSourceMappingStart(this.currentVariableDeclaration);
            if (varDecl.equalsValueClause) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);
                this.emitJavascript(varDecl.equalsValueClause, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        }

        // Emits "var " if it is allowed
        public emitVarDeclVar() {
            if (this.currentVariableDeclaration) {
                this.writeToOutput("var ");
            }
        }

        public emitVariableDeclaration(declaration: VariableDeclarationSyntax) {
            var varDecl = declaration.variableDeclarators[0];

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);

            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.kind : PullElementKind.None;

            this.emitComments(declaration, true);

            var pullVarDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            var isAmbientWithoutInit = pullVarDecl && hasFlag(pullVarDecl.flags, PullElementFlags.Ambient) && varDecl.equalsValueClause === null;
            if (!isAmbientWithoutInit) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.currentVariableDeclaration = declaration;

                for (var i = 0, n = declaration.variableDeclarators.length; i < n; i++) {
                    var declarator = declaration.variableDeclarators[i];

                    if (i > 0) {
                        this.writeToOutput(", ");
                    }

                    this.emit(declarator);
                }
                this.currentVariableDeclaration = prevVariableDeclaration;

                // Declarator emit would take care of emitting start of the variable declaration start
                this.recordSourceMappingEnd(declaration);
            }

            this.emitComments(declaration, false);
        }

        private emitMemberVariableDeclaration(varDecl: MemberVariableDeclarationSyntax) {
            Debug.assert(!hasModifier(varDecl.modifiers, PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause);

            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);

            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);

            var varDeclName = varDecl.variableDeclarator.propertyName.text();
            var quotedOrNumber = isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== SyntaxKind.IdentifierName;

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentDecl = pullDecl && pullDecl.getParentDecl();

            if (quotedOrNumber) {
                this.writeToOutput("this[");
            }
            else {
                this.writeToOutput("this.");
            }

            this.writeToOutputWithSourceMapRecord(varDecl.variableDeclarator.propertyName.text(), varDecl.variableDeclarator.propertyName);

            if (quotedOrNumber) {
                this.writeToOutput("]");
            }

            if (varDecl.variableDeclarator.equalsValueClause) {
                // Ensure we have a fresh var list count when recursing into the variable 
                // initializer.  We don't want our current list of variables to affect how we
                // emit nested variable lists.
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.emit(varDecl.variableDeclarator.equalsValueClause);
                this.currentVariableDeclaration = prevVariableDeclaration;
            }

            // class
            if (this.emitState.container !== EmitContainer.Args) {
                this.writeToOutput(";");
            }

            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);

            this.popDecl(pullDecl);
        }

        public emitVariableDeclarator(varDecl: VariableDeclaratorSyntax) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl);
            this.pushDecl(pullDecl);
            if (pullDecl && (pullDecl.flags & PullElementFlags.Ambient) === PullElementFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
            }
            else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(this.currentVariableDeclaration);
                this.recordSourceMappingStart(varDecl);

                var varDeclName = varDecl.propertyName.text();

                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentDecl = pullDecl && pullDecl.getParentDecl();
                var parentIsModule = parentDecl && (parentDecl.flags & PullElementFlags.SomeInitializedModule);

                if (parentIsModule) {
                    // module
                    if (!hasFlag(pullDecl.flags, PullElementFlags.Exported)/* && !varDecl.isProperty() */) {
                        this.emitVarDeclVar();
                    }
                    else {
                        if (this.emitState.container === EmitContainer.DynamicModule) {
                            this.writeToOutput("exports.");
                        }
                        else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                }
                else {
                    this.emitVarDeclVar();
                }

                this.writeToOutputWithSourceMapRecord(varDecl.propertyName.text(), varDecl.propertyName);

                if (varDecl.equalsValueClause) {
                    // Ensure we have a fresh var list count when recursing into the variable 
                    // initializer.  We don't want our current list of variables to affect how we
                    // emit nested variable lists.
                    var prevVariableDeclaration = this.currentVariableDeclaration;
                    this.emit(varDecl.equalsValueClause);
                    this.currentVariableDeclaration = prevVariableDeclaration;
                }

                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.currentVariableDeclaration = undefined;
            this.popDecl(pullDecl);
        }

        private symbolIsUsedInItsEnclosingContainer(symbol: PullSymbol, dynamic = false) {
            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        // compute the closing container of the symbol's declaration
                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.kind === (dynamic ? PullElementKind.DynamicModule : PullElementKind.Container)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        // if the symbol in question is not a global, compute the nearest
                        // enclosing declaration from the point of usage
                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.kind === (dynamic ? PullElementKind.DynamicModule : PullElementKind.Container)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;

                            // initialized module object variables are bound to their parent's decls
                            if (!same && symbol.anyDeclHasFlag(PullElementFlags.InitializedModule)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        }

        // In some cases, when emitting a name, the emitter needs to qualify a symbol
        // name by first emitting its parent's name. This generally happens when the
        // name referenced is in scope in TypeScript, but not in Javascript. This is true
        // in any of the following 3 cases:
        // - It is an enum member, even if accessed from within the enum declaration in which it is defined
        // - It is an exported var, even if accessed from within the module declaration in which it is defined
        // - It is an exported member of the current module, but is never defined in this particular module
        // declaration (i.e. it is only defined in other components of the same merged module)
        private shouldQualifySymbolNameWithParentName(symbol: PullSymbol): boolean {
            var enclosingContextDeclPath = this.declStack;
            var symbolDeclarations = symbol.getDeclarations();
            for (var i = 0; i < symbolDeclarations.length; i++) {
                var currentDecl = symbolDeclarations[i];
                var declParent = currentDecl.getParentDecl();

                if (currentDecl.kind === PullElementKind.EnumMember) {
                    return true;
                }

                // All decls of the same symbol must agree on whether they are exported
                // If one decl is not exported, none of them are, and it is safe to
                // assume it is just a local
                if (!hasFlag(currentDecl.flags, PullElementFlags.Exported)) {
                    return false;
                }

                // Section 10.6:
                // When a variable is exported, all references to the variable in the body of the
                // module are replaced with
                //    <ModuleName>.< VariableName>
                if (currentDecl.kind === PullElementKind.Variable && !hasFlag(currentDecl.flags, PullElementFlags.ImplicitVariable)) {
                    return true;
                }

                if (ArrayUtilities.contains(this.declStack, declParent)) {
                    return false;
                }
            }

            return true;
        }

        // Get the symbol information to be used for emitting the ast
        private getSymbolForEmit(ast: ISyntaxElement) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(ast);
            var pullSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(ast);
            if (pullSymbol && pullSymbolAlias) {
                var symbolToCompare = isTypesOnlyLocation(ast) ?
                    pullSymbolAlias.getExportAssignedTypeSymbol() :
                    pullSymbolAlias.getExportAssignedValueSymbol();

                if (pullSymbol === symbolToCompare) {
                    pullSymbol = pullSymbolAlias;
                    pullSymbolAlias = null;
                }
            }
            return { symbol: pullSymbol, aliasSymbol: pullSymbolAlias };
        }

        public emitName(name: ISyntaxToken, addThis: boolean) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (name.text().length > 0) {
                var symbolForEmit = this.getSymbolForEmit(name);
                var pullSymbol = symbolForEmit.symbol;
                if (!pullSymbol) {
                    pullSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                var pullSymbolAlias = symbolForEmit.aliasSymbol;
                var pullSymbolKind = pullSymbol.kind;
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() === this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== EmitContainer.Args) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();

                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.kind;

                        if (PullHelpers.symbolIsModule(pullSymbolContainer) || pullSymbolContainerKind === PullElementKind.Enum ||
                            pullSymbolContainer.anyDeclHasFlag(PullElementFlags.InitializedModule | PullElementFlags.Enum)) {
                            var needToEmitParentName = this.shouldQualifySymbolNameWithParentName(pullSymbol);
                            if (needToEmitParentName) {
                                var parentDecl = pullSymbol.getDeclarations()[0].getParentDecl();
                                Debug.assert(parentDecl && !parentDecl.isRootDecl());
                                this.writeToOutput(this.getModuleName(parentDecl, /* changeNameIfAnyDeclarationInContext */ true) + ".");
                            }
                        }
                        else if (pullSymbolContainerKind === PullElementKind.DynamicModule ||
                            pullSymbolContainer.anyDeclHasFlag(PullElementFlags.InitializedDynamicModule)) {
                            if (pullSymbolKind === PullElementKind.Property) {
                                // If dynamic module
                                this.writeToOutput("exports.");
                            }
                            else if (pullSymbol.anyDeclHasFlag(PullElementFlags.Exported) &&
                                !isLocalAlias &&
                                !pullSymbol.anyDeclHasFlag(PullElementFlags.ImplicitVariable) &&
                                pullSymbol.kind !== PullElementKind.ConstructorMethod &&
                                pullSymbol.kind !== PullElementKind.Class &&
                                pullSymbol.kind !== PullElementKind.Enum) {
                                this.writeToOutput("exports.");
                            }
                        }
                    }
                }

                this.writeToOutput(name.text());
            }

            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        }

        public recordSourceMappingNameStart(name: string) {
            if (this.sourceMapper) {
                var nameIndex = -1;
                if (name) {
                    if (this.sourceMapper.currentNameIndex.length > 0) {
                        var parentNameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                        if (parentNameIndex !== -1) {
                            name = this.sourceMapper.names[parentNameIndex] + "." + name;
                        }
                    }

                    // Look if there already exists name
                    var nameIndex = this.sourceMapper.names.length - 1;
                    for (nameIndex; nameIndex >= 0; nameIndex--) {
                        if (this.sourceMapper.names[nameIndex] === name) {
                            break;
                        }
                    }

                    if (nameIndex === -1) {
                        nameIndex = this.sourceMapper.names.length;
                        this.sourceMapper.names.push(name);
                    }
                }
                this.sourceMapper.currentNameIndex.push(nameIndex);
            }
        }

        public recordSourceMappingNameEnd() {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        }

        private recordSourceMappingStart(ast: ISyntaxElement) {
            if (this.sourceMapper && ASTHelpers.isValidAstNode(ast)) {
                this.recordSourceMappingSpanStart(ast, start(ast), end(ast));
            }
        }

        private recordSourceMappingCommentStart(comment: Comment) {
            this.recordSourceMappingSpanStart(comment, comment.start(), comment.end());
        }

        private recordSourceMappingSpanStart(ast: any, start: number, end: number) {
            if (this.sourceMapper && ast && start !== -1 && end !== -1) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                // REVIEW: check time consumed by this binary search (about two per leaf statement)
                var lineMap = this.document.lineMap();
                lineMap.fillLineAndCharacterFromPosition(start, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(end, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;

                Debug.assert(!isNaN(sourceMapping.start.emittedColumn));
                Debug.assert(!isNaN(sourceMapping.start.emittedLine));
                Debug.assert(!isNaN(sourceMapping.start.sourceColumn));
                Debug.assert(!isNaN(sourceMapping.start.sourceLine));
                Debug.assert(!isNaN(sourceMapping.end.sourceColumn));
                Debug.assert(!isNaN(sourceMapping.end.sourceLine));

                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                // Set parent and child relationship
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
                this.sourceMapper.increaseMappingLevel(ast);
            }
        }

        private recordSourceMappingEnd(ast: ISyntaxElement) {
            if (this.sourceMapper && ASTHelpers.isValidAstNode(ast)) {
                this.recordSourceMappingSpanEnd(ast, start(ast), end(ast));
            }
        }

        private recordSourceMappingCommentEnd(ast: Comment) {
            if (this.sourceMapper && ASTHelpers.isValidSpan(ast)) {
                this.recordSourceMappingSpanEnd(ast, ast.start(), ast.end());
            }
        }

        private recordSourceMappingSpanEnd(ast: any, start: number, end: number) {
            if (this.sourceMapper && ast && start !== -1 && end !== -1) {
                // Pop source mapping childs
                this.sourceMapper.currentMappings.pop();

                // Get the last source mapping from sibling list = which is the one we are recording end for
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;

                Debug.assert(!isNaN(sourceMapping.end.emittedColumn));
                Debug.assert(!isNaN(sourceMapping.end.emittedLine));

                this.sourceMapper.decreaseMappingLevel(ast);
            }
        }

        // Note: may throw exception.
        public getOutputFiles(): OutputFile[] {
            // Output a source mapping.  As long as we haven't gotten any errors yet.
            var result: OutputFile[] = [];
            if (this.sourceMapper !== null) {
                this.sourceMapper.emitSourceMapping();
                result.push(this.sourceMapper.getOutputFile());
            }

            result.push(this.outfile.getOutputFile());
            return result;
        }

        private emitParameterPropertyAndMemberVariableAssignments(): void {
            // emit any parameter properties first
            var constructorDecl = getLastConstructor(this.thisClassNode);

            if (constructorDecl) {
                for (var i = 0, n = constructorDecl.callSignature.parameterList.parameters.length; i < n; i++) {
                    var parameter = constructorDecl.callSignature.parameterList.parameters[i];

                    var parameterDecl = this.semanticInfoChain.getDeclForAST(parameter);
                    if (hasFlag(parameterDecl.flags, PullElementFlags.PropertyParameter)) {
                        this.emitIndent();
                        this.recordSourceMappingStart(parameter);
                        this.writeToOutputWithSourceMapRecord("this." + parameter.identifier.text(), parameter.identifier);
                        this.writeToOutput(" = ");
                        this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter.identifier);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(parameter);
                    }
                }
            }

            for (var i = 0, n = this.thisClassNode.classElements.length; i < n; i++) {
                if (this.thisClassNode.classElements[i].kind() === SyntaxKind.MemberVariableDeclaration) {
                    var varDecl = <MemberVariableDeclarationSyntax>this.thisClassNode.classElements[i];
                    if (!hasModifier(varDecl.modifiers, PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitIndent();
                        this.emitMemberVariableDeclaration(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        }

        private isOnSameLine(pos1: number, pos2: number): boolean {
            if (pos1 < 0 || pos2 < 0) {
                // Missing element.  Assume it's on the same line as the other element.
                return true;
            }

            var lineMap = this.document.lineMap();
            return lineMap.getLineNumberFromPosition(pos1) === lineMap.getLineNumberFromPosition(pos2);
        }

        private emitCommaSeparatedList<T extends ISyntaxNodeOrToken>(parent: ISyntaxElement, list: T[], buffer: string, preserveNewLines: boolean): void {
            if (list === null || list.length === 0) {
                return;
            }

            // If the first element isn't on hte same line as the parent node, then we need to 
            // start with a newline.
            var startLine = preserveNewLines && !this.isOnSameLine(end(parent), end(list[0]));

            if (preserveNewLines) {
                // Any elements on a new line will have to be indented.
                this.indenter.increaseIndent();
            }

            // If we're starting on a newline, then emit an actual newline. Otherwise write out
            // the buffer character before hte first element.
            if (startLine) {
                this.writeLineToOutput("");
            }
            else {
                this.writeToOutput(buffer);
            }

            for (var i = 0, n = list.length; i < n; i++) {
                var emitNode = list[i];

                // Write out the element, emitting an indent if we're on a new line.
                this.emitJavascript(emitNode, startLine);

                if (i < (n - 1)) {
                    // If the next element start on a different line than this element ended on, 
                    // then we want to start on a newline.  Emit the comma with a newline.  
                    // Otherwise, emit the comma with the space.
                    startLine = preserveNewLines && !this.isOnSameLine(end(emitNode), start(list[i + 1]));
                    if (startLine) {
                        this.writeLineToOutput(",");
                    }
                    else {
                        this.writeToOutput(", ");
                    }
                }
            }

            if (preserveNewLines) {
                // We're done with all the elements.  Return the indent back to where it was.
                this.indenter.decreaseIndent();
            }

            // If the last element isn't on the same line as the parent, then emit a newline
            // after the last element and emit our indent so the list's terminator will be
            // on the right line.  Otherwise, emit the buffer string between the last value
            // and the terminator.
            if (preserveNewLines && !this.isOnSameLine(end(parent), end(list[list.length - 1]))) {
                this.writeLineToOutput("");
                this.emitIndent();
            }
            else {
                this.writeToOutput(buffer);
            }
        }

        public emitList<T extends ISyntaxNodeOrToken>(list: T[], useNewLineSeparator = true, startInclusive = 0, endExclusive = list.length) {
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode: ISyntaxElement = null;

            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        }

        public emitSeparatedList<T extends ISyntaxNodeOrToken>(list: T[], useNewLineSeparator = true, startInclusive = 0, endExclusive = list.length) {
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode: ISyntaxElement = null;

            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        }

        private isDirectivePrologueElement(node: ISyntaxElement) {
            if (node.kind() === SyntaxKind.ExpressionStatement) {
                var exprStatement = <ExpressionStatementSyntax>node;
                return exprStatement.expression.kind() === SyntaxKind.StringLiteral;
            }

            return false;
        }

        // If these two constructs had more than one line between them originally, then emit at 
        // least one blank line between them.
        public emitSpaceBetweenConstructs(node1: ISyntaxElement, node2: ISyntaxElement): void {
            if (node1 === null || node2 === null) {
                return;
            }

            if (start(node1) === -1 || end(node1) === -1 || start(node2) === -1 || end(node2) === -1) {
                return;
            }

            var lineMap = this.document.lineMap();
            var node1EndLine = lineMap.getLineNumberFromPosition(end(node1));
            var node2StartLine = lineMap.getLineNumberFromPosition(start(node2));

            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("", /*force:*/ true);
            }
        }

        // We consider a sequence of comments to be a detached from an ast if there are no blank lines 
        // between them, and there is a blank line after the last one and the node they're attached 
        // to.
        private getDetachedComments(element: ISyntaxElement): Comment[] {
            var preComments = TypeScript.ASTHelpers.preComments(element);
            if (preComments) {
                var lineMap = this.document.lineMap();

                var detachedComments: Comment[] = [];
                var lastComment: Comment = null;

                for (var i = 0, n = preComments.length; i < n; i++) {
                    var comment = preComments[i];

                    if (lastComment) {
                        var lastCommentLine = lineMap.getLineNumberFromPosition(lastComment.end());
                        var commentLine = lineMap.getLineNumberFromPosition(comment.start());

                        if (commentLine >= lastCommentLine + 2) {
                            // There was a blank line between the last comment and this comment.  This
                            // comment is not part of the copyright comments.  Return what we have so 
                            // far.
                            return detachedComments;
                        }
                    }

                    detachedComments.push(comment);
                    lastComment = comment;
                }

                // All comments look like they could have been part of the copyright header.  Make
                // sure there is at least one blank line between it and the node.  If not, it's not
                // a copyright header.
                var lastCommentLine = lineMap.getLineNumberFromPosition(ArrayUtilities.last(detachedComments).end());
                var astLine = lineMap.getLineNumberFromPosition(start(element));
                if (astLine >= lastCommentLine + 2) {
                    return detachedComments;
                }
            }

            // No usable copyright comments found.
            return [];
        }

        private emitPossibleCopyrightHeaders(script: SourceUnitSyntax): void {
            this.emitDetachedComments(script.moduleElements);
        }

        private emitDetachedComments(list: ISyntaxNodeOrToken[]): void {
            if (list.length > 0) {
                var firstElement = childAt(list, 0);

                this.detachedCommentsElement = firstElement;
                this.emitCommentsArray(this.getDetachedComments(this.detachedCommentsElement), /*trailing:*/ false);
            }
        }

        public emitScriptElements(sourceUnit: SourceUnitSyntax) {
            var list = sourceUnit.moduleElements;

            this.emitPossibleCopyrightHeaders(sourceUnit);

            // First, emit all the prologue elements.
            for (var i = 0, n = list.length; i < n; i++) {
                var node = list[i];

                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }

                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }

            // Now emit __extends or a _this capture if necessary.
            this.emitPrologue(sourceUnit);

            var isExternalModule = this.document.isExternalModule();
            var isNonElidedExternalModule = isExternalModule && !ASTHelpers.scriptIsElided(sourceUnit);
            if (isNonElidedExternalModule) {
                this.recordSourceMappingStart(sourceUnit);

                if (this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous) { // AMD
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";

                    var importAndDependencyList = this.getModuleImportAndDependencyList(sourceUnit);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";

                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            }

            if (isExternalModule) {
                var temp = this.setContainer(EmitContainer.DynamicModule);

                var svModuleName = this.moduleName;
                this.moduleName = syntaxTree(sourceUnit).fileName();
                if (TypeScript.isTSFile(this.moduleName)) {
                    this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
                }

                // if the external module has an "export =" identifier, we'll
                // set it in the ExportAssignment emit method
                this.setExportAssignment(null);

                if(this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }

                var externalModule = this.semanticInfoChain.getDeclForAST(this.document.sourceUnit());

                if (hasFlag(externalModule.flags, PullElementFlags.MustCaptureThis)) {
                    this.writeCaptureThisStatement(sourceUnit);
                }

                this.pushDecl(externalModule);
            }

            this.emitList(list, /*useNewLineSeparator:*/ true, /*startInclusive:*/ i, /*endExclusive:*/ n);

            if (isExternalModule) {
                if (this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }

                if (isNonElidedExternalModule) {
                    var exportAssignment = this.getExportAssignment();
                    var exportAssignmentIdentifierText = exportAssignment ? exportAssignment.identifier.text() : null;
                    var exportAssignmentValueSymbol = (<PullContainerSymbol>externalModule.getSymbol(this.semanticInfoChain)).getExportAssignedValueSymbol();

                    if (this.emitOptions.compilationSettings().moduleGenTarget() === ModuleGenTarget.Asynchronous) { // AMD
                        if (exportAssignmentIdentifierText && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & PullElementKind.SomeTypeReference)) {
                            // indent was decreased for AMD above
                            this.indenter.increaseIndent();
                            this.emitIndent();
                            this.writeToOutputWithSourceMapRecord("return " + exportAssignmentIdentifierText, exportAssignment);
                            this.writeLineToOutput(";");
                            this.indenter.decreaseIndent();
                        }
                        this.writeToOutput("});");
                    }
                    else if (exportAssignmentIdentifierText && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & PullElementKind.SomeTypeReference)) {
                        this.emitIndent();
                        this.writeToOutputWithSourceMapRecord("module.exports = " + exportAssignmentIdentifierText, exportAssignment);
                        this.writeToOutput(";");
                    }

                    this.recordSourceMappingEnd(sourceUnit);
                    this.writeLineToOutput("");
                }

                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.popDecl(externalModule);
            }
        }

        public emitConstructorStatements(funcDecl: ConstructorDeclarationSyntax) {
            var list = funcDecl.block.statements;

            if (list === null) {
                return;
            }

            this.emitComments(list, true);

            var emitPropertyAssignmentsAfterSuperCall = ASTHelpers.getExtendsHeritageClause(this.thisClassNode.heritageClauses) !== null;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode: ISyntaxElement = null;

            for (var i = 0, n = list.length; i < n; i++) {
                // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor
                // call which, in these cases, must be the first statement in the constructor body
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }

                var node = list[i];

                if (this.shouldEmit(node)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }

            this.emitComments(list, false);
        }

        // tokenId is the id the preceding token
        public emitJavascript(ast: ISyntaxElement, startLine: boolean) {
            if (ast === null) {
                return;
            }

            if (startLine &&
                this.indenter.indentAmt > 0) {

                this.emitIndent();
            }

            this.emit(ast);
        }

        public emitAccessorMemberDeclaration(funcDecl: ISyntaxElement, name: ISyntaxToken, className: string, isProto: boolean) {
            if (funcDecl.kind() !== SyntaxKind.GetAccessor) {
                var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }

            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);

            this.writeToOutput("Object.defineProperty(" + className);
            if (isProto) {
                this.writeToOutput(".prototype, ");
            }
            else {
                this.writeToOutput(", ");
            }

            var functionName = name.text();
            if (isQuoted(functionName)) {
                this.writeToOutput(functionName);
            }
            else {
                this.writeToOutput('"' + functionName + '"');
            }

            this.writeLineToOutput(", {");

            this.indenter.increaseIndent();

            var accessors = PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.emitComments(accessors.getter, true);
                this.writeToOutput("get: ");
                this.emitAccessorBody(accessors.getter, accessors.getter.parameterList, accessors.getter.block);
                this.writeLineToOutput(",");
            }

            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.emitComments(accessors.setter, true);
                this.writeToOutput("set: ");
                this.emitAccessorBody(accessors.setter, accessors.setter.parameterList, accessors.setter.block);
                this.writeLineToOutput(",");
            }

            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        }

        private emitAccessorBody(funcDecl: ISyntaxElement, parameterList: ParameterListSyntax, block: BlockSyntax): void {
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");
            this.emitParameterList(parameterList);

            var parameters = ASTHelpers.parametersFromParameterList(parameterList);
            this.emitFunctionBodyStatements(null, funcDecl, parameters, block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(funcDecl);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);
        }

        public emitClass(classDecl: ClassDeclarationSyntax) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl);
            this.pushDecl(pullDecl);

            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.identifier.text();
            this.emitComments(classDecl, true);
            var temp = this.setContainer(EmitContainer.Class);

            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);

            var hasBaseClass = ASTHelpers.getExtendsHeritageClause(classDecl.heritageClauses) !== null;
            var baseTypeReference: ISyntaxElement = null;
            var varDecl: VariableDeclaratorSyntax = null;

            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            }
            else {
                this.writeLineToOutput(" = (function () {");
            }

            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();

            if (hasBaseClass) {
                baseTypeReference = ASTHelpers.getExtendsHeritageClause(classDecl.heritageClauses).typeNames[0];
                this.emitIndent();
                this.writeToOutputWithSourceMapRecord("__extends(" + className + ", _super)", baseTypeReference);
                this.writeLineToOutput(";");
            }

            this.emitIndent();

            var constrDecl = getLastConstructor(classDecl);

            // output constructor
            if (constrDecl) {
                // declared constructor
                this.emit(constrDecl);
                this.writeLineToOutput("");
            }
            else {
                this.recordSourceMappingStart(classDecl);
                // default constructor
                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.identifier.text() + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeToOutputWithSourceMapRecord("_super.apply(this, arguments)", baseTypeReference);
                    this.writeLineToOutput(";");
                }

                if (this.shouldCaptureThis(classDecl)) {
                    this.writeCaptureThisStatement(classDecl);
                }

                this.emitParameterPropertyAndMemberVariableAssignments();

                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeToken(classDecl.closeBraceToken);
                this.writeLineToOutput("");

                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }

            this.emitClassMembers(classDecl);

            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("return " + className + ";", classDecl.closeBraceToken);
            this.writeLineToOutput("");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(classDecl.closeBraceToken);
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.emitJavascript(baseTypeReference, /*startLine:*/ false);
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);

            if ((temp === EmitContainer.Module || temp === EmitContainer.DynamicModule) && hasFlag(pullDecl.flags, PullElementFlags.Exported)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === EmitContainer.Module ? this.moduleName : "exports";
                this.writeToOutputWithSourceMapRecord(modName + "." + className + " = " + className + ";", classDecl);
            }

            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;

            this.popDecl(pullDecl);
        }

        private emitClassMembers(classDecl: ClassDeclarationSyntax): void {
            // First, emit all the functions.
            var lastEmittedMember: ISyntaxElement = null;

            for (var i = 0, n = classDecl.classElements.length; i < n; i++) {
                var memberDecl = classDecl.classElements[i];

                if (memberDecl.kind() === SyntaxKind.GetAccessor) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var getter = <GetAccessorSyntax>memberDecl;
                    this.emitAccessorMemberDeclaration(getter, getter.propertyName, classDecl.identifier.text(),
                        !hasModifier(getter.modifiers, PullElementFlags.Static));
                    lastEmittedMember = memberDecl;
                }
                else if (memberDecl.kind() === SyntaxKind.SetAccessor) {
                    this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);
                    var setter = <SetAccessorSyntax>memberDecl;
                    this.emitAccessorMemberDeclaration(setter, setter.propertyName, classDecl.identifier.text(),
                        !hasModifier(setter.modifiers, PullElementFlags.Static));
                    lastEmittedMember = memberDecl;
                }
                else if (memberDecl.kind() === SyntaxKind.MemberFunctionDeclaration) {

                    var memberFunction = <MemberFunctionDeclarationSyntax>memberDecl;

                    if (memberFunction.block) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, memberDecl);

                        this.emitClassMemberFunctionDeclaration(classDecl, memberFunction);
                        lastEmittedMember = memberDecl;
                    }
                }
            }

            // Now emit all the statics.
            for (var i = 0, n = classDecl.classElements.length; i < n; i++) {
                var memberDecl = classDecl.classElements[i];

                if (memberDecl.kind() === SyntaxKind.MemberVariableDeclaration) {
                    var varDecl = <MemberVariableDeclarationSyntax>memberDecl;

                    if (hasModifier(varDecl.modifiers, PullElementFlags.Static) && varDecl.variableDeclarator.equalsValueClause) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);

                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);

                        var varDeclName = varDecl.variableDeclarator.propertyName.text();
                        if (isQuoted(varDeclName) || varDecl.variableDeclarator.propertyName.kind() !== SyntaxKind.IdentifierName) {
                            this.writeToOutput(classDecl.identifier.text() + "[" + varDeclName + "]");
                        }
                        else {
                            this.writeToOutput(classDecl.identifier.text() + "." + varDeclName);
                        }

                        this.emit(varDecl.variableDeclarator.equalsValueClause);

                        this.recordSourceMappingEnd(varDecl);
                        this.writeLineToOutput(";");

                        lastEmittedMember = varDecl;
                    }
                }
            }
        }

        private emitClassMemberFunctionDeclaration(classDecl: ClassDeclarationSyntax, funcDecl: MemberFunctionDeclarationSyntax): void {
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.emitComments(funcDecl, true);
            var functionName = funcDecl.propertyName.text();

            this.writeToOutput(classDecl.identifier.text());

            if (!hasModifier(funcDecl.modifiers, PullElementFlags.Static)) {
                this.writeToOutput(".prototype");
            }

            if (isQuoted(functionName) || funcDecl.propertyName.kind() !== SyntaxKind.IdentifierName) {
                this.writeToOutput("[" + functionName + "] = ");
            }
            else {
                this.writeToOutput("." + functionName + " = ");
            }

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcDecl);
            this.writeToOutput("function ");

            this.emitParameterList(funcDecl.callSignature.parameterList);

            var parameters = ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList);
            this.emitFunctionBodyStatements(funcDecl.propertyName.text(), funcDecl, parameters, funcDecl.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.recordSourceMappingEnd(funcDecl);
            this.popDecl(pullDecl);

            this.writeLineToOutput(";");
        }

        private requiresExtendsBlock(moduleElements: IModuleElementSyntax[]): boolean {
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var moduleElement = moduleElements[i];

                if (moduleElement.kind() === SyntaxKind.ModuleDeclaration) {
                    var moduleAST = <ModuleDeclarationSyntax>moduleElement;

                    if (!hasModifier(moduleAST.modifiers, PullElementFlags.Ambient) && this.requiresExtendsBlock(moduleAST.moduleElements)) {
                        return true;
                    }
                }
                else if (moduleElement.kind() === SyntaxKind.ClassDeclaration) {
                    var classDeclaration = <ClassDeclarationSyntax>moduleElement;

                    if (!hasModifier(classDeclaration.modifiers, PullElementFlags.Ambient) && ASTHelpers.getExtendsHeritageClause(classDeclaration.heritageClauses) !== null) {
                        return true;
                    }
                }
            }

            return false;
        }

        public emitPrologue(sourceUnit: SourceUnitSyntax) {
            if (!this.extendsPrologueEmitted) {
                if (this.requiresExtendsBlock(sourceUnit.moduleElements)) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(sourceUnit)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        }

        public emitThis() {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutput("_this");
            }
            else {
                this.writeToOutput("this");
            }
        }

        public emitBlockOrStatement(node: ISyntaxElement): void {
            if (node.kind() === SyntaxKind.Block) {
                this.emit(node);
            }
            else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        }

        public emitLiteralExpression(expression: ISyntaxToken): void {
            switch (expression.kind()) {
                case SyntaxKind.NullKeyword:
                    this.writeToken(expression);
                    break;
                case SyntaxKind.FalseKeyword:
                    this.writeToken(expression);
                    break;
                case SyntaxKind.TrueKeyword:
                    this.writeToken(expression);
                    break;
                default:
                    throw Errors.abstract();
            }
        }

        public emitThisExpression(expression: ISyntaxToken): void {
            if (!this.inWithBlock && this.inArrowFunction) {
                this.writeToOutputWithSourceMapRecord("_this", expression);
            }
            else {
                this.writeToken(expression);
            }
        }

        public emitSuperExpression(expression: ISyntaxToken): void {
            if (PullTypeResolver.isInStaticMemberContext(this.getEnclosingDecl())) {
                this.writeToOutputWithSourceMapRecord("_super", expression);
            }
            else {
                this.writeToOutputWithSourceMapRecord("_super.prototype", expression);
            }
        }

        public emitParenthesizedExpression(parenthesizedExpression: ParenthesizedExpressionSyntax): void {
            var omitParentheses = false;

            if (parenthesizedExpression.expression.kind() === SyntaxKind.CastExpression && !parenthesizedExpression.openParenToken.hasTrailingComment()) {
                var castedExpression = (<CastExpressionSyntax>parenthesizedExpression.expression).expression;

                // Make sure we consider all nested cast expressions, e.g.:
                // (<any><number><any>-A).x; 
                while (castedExpression.kind() == SyntaxKind.CastExpression) {
                    castedExpression = (<CastExpressionSyntax>castedExpression).expression;
                }

                // We have an expression of the form: (<Type>SubExpr)
                // Emitting this as (SubExpr) is really not desirable.  Just emit the subexpr as is.
                // We cannot generalize this rule however, as omitting the parentheses could cause change in the semantics of the generated
                // code if the casted expression has a lower precedence than the rest of the expression, e.g.: 
                //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo
                //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()
                //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()
                // Parenthesis can be safelly removed from:
                //      Literals
                //      MemberAccessExpressions
                //      ElementAccessExpressions
                //      InvocationExpression, only if they are not part of an object creation (new) expression; e.g.:
                //          new (<any>A()) removing the parentheses would result in calling A as a constructor, instead of calling the 
                //          result of the function invocation A() as a constructor
                switch (castedExpression.kind()) {
                    case SyntaxKind.ParenthesizedExpression:
                    case SyntaxKind.IdentifierName:
                    case SyntaxKind.NullKeyword:
                    case SyntaxKind.ThisKeyword:
                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.RegularExpressionLiteral:
                    case SyntaxKind.TrueKeyword:
                    case SyntaxKind.FalseKeyword:
                    case SyntaxKind.ArrayLiteralExpression:
                    case SyntaxKind.ObjectLiteralExpression:
                    case SyntaxKind.MemberAccessExpression:
                    case SyntaxKind.ElementAccessExpression:
                        omitParentheses = true;
                        break;

                    case SyntaxKind.InvocationExpression:
                        if (parenthesizedExpression.parent.kind() !== SyntaxKind.ObjectCreationExpression) {
                            omitParentheses = true;
                        }

                        break;
                }
            }

            if (omitParentheses) {
                this.emit(parenthesizedExpression.expression);
            }
            else {
                this.recordSourceMappingStart(parenthesizedExpression);
                this.writeToken(parenthesizedExpression.openParenToken);
                this.emitCommentsArray(ASTHelpers.convertTokenTrailingComments(parenthesizedExpression.openParenToken), /*trailing:*/ false);
                this.emit(parenthesizedExpression.expression);
                this.writeToken(parenthesizedExpression.closeParenToken);
                this.recordSourceMappingEnd(parenthesizedExpression);
            }
        }

        public emitCastExpression(expression: CastExpressionSyntax): void {
            this.emit(expression.expression);
        }

        public emitPrefixUnaryExpression(expression: PrefixUnaryExpressionSyntax): void {
            var nodeType = expression.kind();

            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case SyntaxKind.LogicalNotExpression:
                    this.writeToken(expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case SyntaxKind.BitwiseNotExpression:
                    this.writeToken(expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case SyntaxKind.NegateExpression:
                    this.writeToken(expression.operatorToken);
                    if (expression.operand.kind() === SyntaxKind.NegateExpression || expression.operand.kind() === SyntaxKind.PreDecrementExpression) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case SyntaxKind.PlusExpression:
                    this.writeToken(expression.operatorToken);
                    if (expression.operand.kind() === SyntaxKind.PlusExpression || expression.operand.kind() === SyntaxKind.PreIncrementExpression) {
                        this.writeToOutput(" ");
                    }
                    this.emit(expression.operand);
                    break;
                case SyntaxKind.PreIncrementExpression:
                    this.writeToOutputWithSourceMapRecord("++", expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                case SyntaxKind.PreDecrementExpression:
                    this.writeToOutputWithSourceMapRecord("--", expression.operatorToken);
                    this.emit(expression.operand);
                    break;
                default:
                    throw Errors.abstract();
            }

            this.recordSourceMappingEnd(expression);
        }

        public emitPostfixUnaryExpression(expression: PostfixUnaryExpressionSyntax): void {
            var nodeType = expression.kind();

            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case SyntaxKind.PostIncrementExpression:
                    this.emit(expression.operand);
                    this.writeToOutputWithSourceMapRecord("++", expression.operatorToken);
                    break;
                case SyntaxKind.PostDecrementExpression:
                    this.emit(expression.operand);
                    this.writeToOutputWithSourceMapRecord("--", expression.operatorToken);
                    break;
                default:
                    throw Errors.abstract();
            }

            this.recordSourceMappingEnd(expression);
        }

        public emitTypeOfExpression(expression: TypeOfExpressionSyntax): void {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.typeOfKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        }

        public emitDeleteExpression(expression: DeleteExpressionSyntax): void {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.deleteKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        }

        public emitVoidExpression(expression: VoidExpressionSyntax): void {
            this.recordSourceMappingStart(expression);
            this.writeToken(expression.voidKeyword);
            this.writeToOutput(" ");
            this.emit(expression.expression);
            this.recordSourceMappingEnd(expression);
        }

        private canEmitDottedNameMemberAccessExpression(expression: MemberAccessExpressionSyntax) {
            var memberExpressionNodeType = expression.expression.kind();

            // If the memberAccess is of Name or another member access, we could potentially emit the symbol using the this memberAccessSymol
            if (memberExpressionNodeType === SyntaxKind.IdentifierName || memberExpressionNodeType == SyntaxKind.MemberAccessExpression) {
                var memberAccessSymbol = this.getSymbolForEmit(expression).symbol;
                var memberAccessExpressionSymbol = this.getSymbolForEmit(expression.expression).symbol;
                if (memberAccessSymbol && memberAccessExpressionSymbol // We have symbols resolved for this expression and access
                    && !this.semanticInfoChain.getAliasSymbolForAST(expression.expression) // The access is not off alias
                    && (PullHelpers.symbolIsModule(memberAccessExpressionSymbol) || memberAccessExpressionSymbol.kind === PullElementKind.Enum ||
                    memberAccessExpressionSymbol.anyDeclHasFlag(PullElementFlags.InitializedModule | PullElementFlags.Enum))) { // container is module

                    // If the memberAccess is in the context of the container, we could use the symbol to emit this expression
                    var memberAccessSymbolKind = memberAccessSymbol.kind;
                    if (memberAccessSymbolKind === PullElementKind.Property
                        || memberAccessSymbolKind === PullElementKind.EnumMember
                        || (memberAccessSymbol.anyDeclHasFlag(PullElementFlags.Exported) && memberAccessSymbolKind === PullElementKind.Variable && !memberAccessSymbol.anyDeclHasFlag(PullElementFlags.InitializedModule | PullElementFlags.Enum))
                        || ((memberAccessSymbol.anyDeclHasFlag(PullElementFlags.Exported) && !this.symbolIsUsedInItsEnclosingContainer(memberAccessSymbol)))) {

                        // If the expression is member access, we need to verify it as well
                        if (memberExpressionNodeType === SyntaxKind.MemberAccessExpression) {
                            return this.canEmitDottedNameMemberAccessExpression(<MemberAccessExpressionSyntax>expression.expression);
                        }

                        return true;
                    }
                }
            }

            return false;
        }

        // Emit the member access expression using the declPath
        private emitDottedNameMemberAccessExpression(expression: MemberAccessExpressionSyntax) {
            this.recordSourceMappingStart(expression);
            if (expression.expression.kind() === SyntaxKind.MemberAccessExpression) {
                // Emit the dotted name access expression
                this.emitDottedNameMemberAccessExpressionRecurse(<MemberAccessExpressionSyntax>expression.expression);
            }
            else { // Name
                this.emitName(<ISyntaxToken>expression.expression, /*addThis*/ true);
            }

            this.writeToken(expression.dotToken);
            this.emitName(expression.name, /*addThis*/ false);

            this.recordSourceMappingEnd(expression);
        }

        // Set the right indices for the recursive member access expression before emitting it using the decl path
        private emitDottedNameMemberAccessExpressionRecurse(expression: MemberAccessExpressionSyntax) {
            this.emitComments(expression, true);
            this.emitDottedNameMemberAccessExpression(expression);
            this.emitComments(expression, false);
        }

        public emitMemberAccessExpression(expression: MemberAccessExpressionSyntax): void {
            if (!this.tryEmitConstant(expression)) {
                // If the expression is dotted name of the modules, emit it using decl path so the name could be resolved correctly.
                if (this.canEmitDottedNameMemberAccessExpression(expression)) {
                    this.emitDottedNameMemberAccessExpression(expression);
                }
                else {
                    this.recordSourceMappingStart(expression);
                    this.emit(expression.expression);
                    this.writeToken(expression.dotToken);
                    this.emitName(expression.name, false);
                    this.recordSourceMappingEnd(expression);
                }
            }
        }

        public emitQualifiedName(name: QualifiedNameSyntax): void {
            this.recordSourceMappingStart(name);

            this.emit(name.left);
            this.writeToken(name.dotToken);
            this.emitName(name.right, false);

            this.recordSourceMappingEnd(name);
        }

        public emitBinaryExpression(expression: BinaryExpressionSyntax): void {
            this.recordSourceMappingStart(expression);
            switch (expression.kind()) {
                case SyntaxKind.CommaExpression:
                    this.emit(expression.left);
                    this.writeToken(expression.operatorToken);
                    this.writeToOutput(" ");
                    this.emit(expression.right);
                    break;
                default:
                    {
                        this.emit(expression.left);
                        var binOp = SyntaxFacts.getText(SyntaxFacts.getOperatorTokenFromBinaryExpression(expression.kind()));
                        this.writeToOutput(" ");
                        this.writeToOutputWithSourceMapRecord(binOp, expression.operatorToken);
                        this.writeToOutput(" ");
                        this.emit(expression.right);
                    }
            }
            this.recordSourceMappingEnd(expression);
        }

        public emitSimplePropertyAssignment(property: SimplePropertyAssignmentSyntax): void {
            this.recordSourceMappingStart(property);
            this.emit(property.propertyName);

            this.writeToken(property.colonToken);
            this.writeToOutput(" ");
            this.emitCommentsArray(ASTHelpers.convertTokenTrailingComments(property.colonToken), /*trailing:*/ true, /*noLeadingSpace:*/ true);

            this.emit(property.expression);
            this.recordSourceMappingEnd(property);
        }

        public emitFunctionPropertyAssignment(funcProp: FunctionPropertyAssignmentSyntax): void {
            this.recordSourceMappingStart(funcProp);

            this.emit(funcProp.propertyName);
            this.writeToOutput(": ");

            var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcProp);

            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            var temp = this.setContainer(EmitContainer.Function);
            var funcName = funcProp.propertyName;

            var pullDecl = this.semanticInfoChain.getDeclForAST(funcProp);
            this.pushDecl(pullDecl);

            this.recordSourceMappingStart(funcProp);
            this.writeToOutput("function ");

            //this.recordSourceMappingStart(funcProp.propertyName);
            //this.writeToOutput(funcProp.propertyName.actualText);
            //this.recordSourceMappingEnd(funcProp.propertyName);

            this.emitParameterList(funcProp.callSignature.parameterList);

            this.emitFunctionBodyStatements(funcProp.propertyName.text(), funcProp,
                ASTHelpers.parametersFromParameterList(funcProp.callSignature.parameterList), funcProp.block, /*bodyExpression:*/ null);

            this.recordSourceMappingEnd(funcProp);

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcProp);

            this.emitComments(funcProp, false);

            this.popDecl(pullDecl);

            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        }

        public emitConditionalExpression(expression: ConditionalExpressionSyntax): void {
            this.emit(expression.condition);
            this.writeToOutput(" ");
            this.writeToken(expression.questionToken);
            this.writeToOutput(" ");
            this.emit(expression.whenTrue);
            this.writeToOutput(" ");
            this.writeToken(expression.colonToken);
            this.writeToOutput(" ");
            this.emit(expression.whenFalse);
        }

        public emitThrowStatement(statement: ThrowStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.throwKeyword);
            this.writeToOutput(" ");
            this.emit(statement.expression);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        }

        public emitExpressionStatement(statement: ExpressionStatementSyntax): void {
            var isArrowExpression = statement.expression.kind() === SyntaxKind.SimpleArrowFunctionExpression || statement.expression.kind() === SyntaxKind.ParenthesizedArrowFunctionExpression;

            this.recordSourceMappingStart(statement);
            if (isArrowExpression) {
                this.writeToOutput("(");
            }

            this.emit(statement.expression);

            if (isArrowExpression) {
                this.writeToOutput(")");
            }

            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        }

        public emitLabeledStatement(statement: LabeledStatementSyntax): void {
            this.writeToOutputWithSourceMapRecord(statement.identifier.text(), statement.identifier);
            this.writeToken(statement.colonToken);
            this.writeLineToOutput("");
            this.emitJavascript(statement.statement, /*startLine:*/ true);
        }

        public emitBlock(block: BlockSyntax): void {
            this.recordSourceMappingStart(block);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            if (block.statements) {
                this.emitList(block.statements);
            }
            this.emitCommentsArray(ASTHelpers.convertTokenLeadingComments(block.closeBraceToken), /*trailing:*/ false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(block.closeBraceToken);
            this.recordSourceMappingEnd(block);
        }

        public emitBreakStatement(jump: BreakStatementSyntax): void {
            this.recordSourceMappingStart(jump);
            this.writeToken(jump.breakKeyword);

            if (jump.identifier) {
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord(jump.identifier.text(), jump.identifier);
            }

            this.writeToOutputWithSourceMapRecord(";", jump.semicolonToken);
            this.recordSourceMappingEnd(jump);
        }

        public emitContinueStatement(jump: ContinueStatementSyntax): void {
            this.recordSourceMappingStart(jump);
            this.writeToken(jump.continueKeyword);

            if (jump.identifier) {
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord(jump.identifier.text(), jump.identifier);
            }

            this.writeToOutputWithSourceMapRecord(";", jump.semicolonToken);
            this.recordSourceMappingEnd(jump);
        }

        public emitWhileStatement(statement: WhileStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.whileKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        }

        public emitDoStatement(statement: DoStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.doKeyword);
            this.emitBlockOrStatement(statement.statement);
            this.writeToOutput(" ");
            this.writeToken(statement.whileKeyword);
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        }

        public emitIfStatement(statement: IfStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.ifKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.condition);
            this.writeToken(statement.closeParenToken);

            this.emitBlockOrStatement(statement.statement);

            if (statement.elseClause) {
                if (statement.statement.kind() !== SyntaxKind.Block) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
                else {
                    this.writeToOutput(" ");
                }

                this.emit(statement.elseClause);
            }
            this.recordSourceMappingEnd(statement);
        }

        public emitElseClause(elseClause: ElseClauseSyntax): void {
            this.writeToken(elseClause.elseKeyword);
            if (elseClause.statement.kind() === SyntaxKind.IfStatement) {
                this.writeToOutput(" ");
                this.emit(elseClause.statement);
            }
            else {
                this.emitBlockOrStatement(elseClause.statement);
            }
        }

        public emitReturnStatement(statement: ReturnStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.returnKeyword);
            if (statement.expression) {
                this.writeToOutput(" ");
                this.emit(statement.expression);
            }

            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
            this.recordSourceMappingEnd(statement);
        }

        public emitForInStatement(statement: ForInStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.forKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);

            if (statement.left) {
                this.emit(statement.left);
            }
            else {
                this.emit(statement.variableDeclaration);
            }
            this.writeToOutput(" ");
            this.writeToken(statement.inKeyword);
            this.writeToOutput(" ");
            this.emit(statement.expression);
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        }

        public emitForStatement(statement: ForStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.forKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);

            if (statement.variableDeclaration) {
                this.emit(statement.variableDeclaration);
            }
            else if (statement.initializer) {
                this.emit(statement.initializer);
            }

            this.writeToken(statement.firstSemicolonToken);
            this.writeToOutput(" ");
            this.emitJavascript(statement.condition, false);
            this.writeToken(statement.secondSemicolonToken);
            if (statement.incrementor) {
                this.writeToOutput(" ");
                this.emitJavascript(statement.incrementor, false);
            }
            this.writeToken(statement.closeParenToken);
            this.emitBlockOrStatement(statement.statement);
            this.recordSourceMappingEnd(statement);
        }

        public emitWithStatement(statement: WithStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.withKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            if (statement.condition) {
                this.emit(statement.condition);
            }

            this.writeToken(statement.closeParenToken);
            var prevInWithBlock = this.inWithBlock;
            this.inWithBlock = true;
            this.emitBlockOrStatement(statement.statement);
            this.inWithBlock = prevInWithBlock;
            this.recordSourceMappingEnd(statement);
        }

        public emitSwitchStatement(statement: SwitchStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.switchKeyword);
            this.writeToOutput(" ");
            this.writeToken(statement.openParenToken);
            this.emit(statement.expression);
            this.writeToken(statement.closeParenToken);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            this.emitList(statement.switchClauses, /*useNewLineSeparator:*/ false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToken(statement.closeBraceToken);
            this.recordSourceMappingEnd(statement);
        }

        public emitCaseSwitchClause(clause: CaseSwitchClauseSyntax): void {
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.caseKeyword);
            this.writeToOutput(" ");
            this.emit(clause.expression);
            this.writeToken(clause.colonToken);

            this.emitSwitchClauseBody(clause.statements);
            this.recordSourceMappingEnd(clause);
        }

        private emitSwitchClauseBody(body: IStatementSyntax[]): void {
            if (body.length === 1 && childAt(body, 0).kind() === SyntaxKind.Block) {
                // The case statement was written with curly braces, so emit it with the appropriate formatting
                this.emit(childAt(body, 0));
                this.writeLineToOutput("");
            }
            else {
                // No curly braces. Format in the expected way
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emit(body);
                this.indenter.decreaseIndent();
            }
        }

        public emitDefaultSwitchClause(clause: DefaultSwitchClauseSyntax): void {
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.defaultKeyword);
            this.writeToken(clause.colonToken);

            this.emitSwitchClauseBody(clause.statements);
            this.recordSourceMappingEnd(clause);
        }

        public emitTryStatement(statement: TryStatementSyntax): void {
            this.recordSourceMappingStart(statement);
            this.writeToken(statement.tryKeyword);
            this.writeToOutput(" ");
            this.emit(statement.block);
            this.emitJavascript(statement.catchClause, false);

            if (statement.finallyClause) {
                this.emit(statement.finallyClause);
            }
            this.recordSourceMappingEnd(statement);
        }

        public emitCatchClause(clause: CatchClauseSyntax): void {
            this.writeToOutput(" ");
            this.recordSourceMappingStart(clause);
            this.writeToken(clause.catchKeyword);
            this.writeToOutput(" ");
            this.writeToken(clause.openParenToken);
            this.emit(clause.identifier);
            this.writeToken(clause.closeParenToken);
            this.emit(clause.block);
            this.recordSourceMappingEnd(clause);
        }

        public emitFinallyClause(clause: FinallyClauseSyntax): void {
            this.writeToOutput(" ");
            this.writeToken(clause.finallyKeyword);
            this.emit(clause.block);
        }

        public emitDebuggerStatement(statement: DebuggerStatementSyntax): void {
            this.writeToken(statement.debuggerKeyword);
            this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
        }

        public emitNumericLiteral(literal: ISyntaxToken): void {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        }

        public emitRegularExpressionLiteral(literal: ISyntaxToken): void {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        }

        public emitStringLiteral(literal: ISyntaxToken): void {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        }

        public emitEqualsValueClause(clause: EqualsValueClauseSyntax): void {
            this.writeToOutput(" ");
            this.writeToken(clause.equalsToken);
            this.writeToOutput(" ");
            this.emitCommentsArray(ASTHelpers.convertTokenTrailingComments(clause.equalsToken), /*trailing:*/ true, /*noLeadingSpace:*/ true);

            this.emit(clause.value);
        }

        private emitParameter(parameter: ParameterSyntax): void {
            this.writeToOutputWithSourceMapRecord(parameter.identifier.text(), parameter);
        }

        public emitConstructorDeclaration(declaration: ConstructorDeclarationSyntax): void {
            if (declaration.block) {
                this.emitConstructor(declaration);
            }
            else {
                this.emitComments(declaration, /*pre:*/ true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        public shouldEmitFunctionDeclaration(declaration: FunctionDeclarationSyntax): boolean {
            return ASTHelpers.preComments(declaration) !== null || (!hasModifier(declaration.modifiers, PullElementFlags.Ambient) && declaration.block !== null);
        }

        public emitFunctionDeclaration(declaration: FunctionDeclarationSyntax): void {
            if (!hasModifier(declaration.modifiers, PullElementFlags.Ambient) && declaration.block !== null) {
                this.emitFunction(declaration);
            }
            else {
                this.emitComments(declaration, /*pre:*/ true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        private emitSourceUnit(sourceUnit: SourceUnitSyntax): void {
            if (!this.document.isDeclareFile()) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(sourceUnit);
                this.pushDecl(pullDecl);
                this.emitScriptElements(sourceUnit);
                this.popDecl(pullDecl);

                this.emitCommentsArray(ASTHelpers.convertTokenLeadingComments(sourceUnit.endOfFileToken), /*trailing:*/ false);
            }
        }

        public shouldEmitEnumDeclaration(declaration: EnumDeclarationSyntax): boolean {
            return ASTHelpers.preComments(declaration) !== null || !ASTHelpers.enumIsElided(declaration);
        }

        public emitEnumDeclaration(declaration: EnumDeclarationSyntax): void {
            if (!ASTHelpers.enumIsElided(declaration)) {
                this.emitComments(declaration, true);
                this.emitEnum(declaration);
                this.emitComments(declaration, false);
            }
            else {
                this.emitComments(declaration, true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        public shouldEmitModuleDeclaration(declaration: ModuleDeclarationSyntax): boolean {
            return ASTHelpers.preComments(declaration) !== null || !ASTHelpers.moduleIsElided(declaration);
        }

        private emitModuleDeclaration(declaration: ModuleDeclarationSyntax): void {
            if (!ASTHelpers.moduleIsElided(declaration)) {
                this.emitModuleDeclarationWorker(declaration);
            }
            else {
                this.emitComments(declaration, true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        public shouldEmitClassDeclaration(declaration: ClassDeclarationSyntax): boolean {
            return ASTHelpers.preComments(declaration) !== null || !hasModifier(declaration.modifiers, PullElementFlags.Ambient);
        }

        public emitClassDeclaration(declaration: ClassDeclarationSyntax): void {
            if (!hasModifier(declaration.modifiers, PullElementFlags.Ambient)) {
                this.emitClass(declaration);
            }
            else {
                this.emitComments(declaration, /*pre:*/ true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        public shouldEmitInterfaceDeclaration(declaration: InterfaceDeclarationSyntax): boolean {
            return ASTHelpers.preComments(declaration) !== null;
        }

        public emitInterfaceDeclaration(declaration: InterfaceDeclarationSyntax): void {
            this.emitComments(declaration, /*pre:*/ true, /*onlyPinnedOrTripleSlashComments:*/ true);
        }

        private firstVariableDeclarator(statement: VariableStatementSyntax): VariableDeclaratorSyntax {
            return statement.variableDeclaration.variableDeclarators[0];
        }

        private isNotAmbientOrHasInitializer(variableStatement: VariableStatementSyntax): boolean {
            return !hasModifier(variableStatement.modifiers, PullElementFlags.Ambient) || this.firstVariableDeclarator(variableStatement).equalsValueClause !== null;
        }

        public shouldEmitVariableStatement(statement: VariableStatementSyntax): boolean {
            return ASTHelpers.preComments(statement) !== null || this.isNotAmbientOrHasInitializer(statement);
        }

        public emitVariableStatement(statement: VariableStatementSyntax): void {
            if (this.isNotAmbientOrHasInitializer(statement)) {
                this.emitComments(statement, true);
                this.emit(statement.variableDeclaration);
                this.writeToOutputWithSourceMapRecord(";", statement.semicolonToken);
                this.emitComments(statement, false);
            }
            else {
                this.emitComments(statement, /*pre:*/ true, /*onlyPinnedOrTripleSlashComments:*/ true);
            }
        }

        public emitGenericType(type: GenericTypeSyntax): void {
            this.emit(type.name);
        }

        private shouldEmit(ast: ISyntaxElement): boolean {
            if (!ast) {
                return false;
            }

            switch (ast.kind()) {
                case SyntaxKind.ImportDeclaration:
                    return this.shouldEmitImportDeclaration(<ImportDeclarationSyntax>ast);
                case SyntaxKind.ClassDeclaration:
                    return this.shouldEmitClassDeclaration(<ClassDeclarationSyntax>ast);
                case SyntaxKind.InterfaceDeclaration:
                    return this.shouldEmitInterfaceDeclaration(<InterfaceDeclarationSyntax>ast);
                case SyntaxKind.FunctionDeclaration:
                    return this.shouldEmitFunctionDeclaration(<FunctionDeclarationSyntax>ast);
                case SyntaxKind.ModuleDeclaration:
                    return this.shouldEmitModuleDeclaration(<ModuleDeclarationSyntax>ast);
                case SyntaxKind.VariableStatement:
                    return this.shouldEmitVariableStatement(<VariableStatementSyntax>ast);
                case SyntaxKind.OmittedExpression:
                    return false;
                case SyntaxKind.EnumDeclaration:
                    return this.shouldEmitEnumDeclaration(<EnumDeclarationSyntax>ast);
            }

            return true;
        }

        private emit(ast: ISyntaxElement): void {
            if (!ast) {
                return;
            }

            switch (ast.kind()) {
                case SyntaxKind.SeparatedList:
                    return this.emitSeparatedList(<ISyntaxNodeOrToken[]>ast);
                case SyntaxKind.List:
                    return this.emitList(<ISyntaxNodeOrToken[]>ast);
                case SyntaxKind.SourceUnit:
                    return this.emitSourceUnit(<SourceUnitSyntax>ast);
                case SyntaxKind.ImportDeclaration:
                    return this.emitImportDeclaration(<ImportDeclarationSyntax>ast);
                case SyntaxKind.ExportAssignment:
                    return this.setExportAssignment(<ExportAssignmentSyntax>ast);
                case SyntaxKind.ClassDeclaration:
                    return this.emitClassDeclaration(<ClassDeclarationSyntax>ast);
                case SyntaxKind.InterfaceDeclaration:
                    return this.emitInterfaceDeclaration(<InterfaceDeclarationSyntax>ast);
                case SyntaxKind.IdentifierName:
                    return this.emitName(<ISyntaxToken>ast, true);
                case SyntaxKind.VariableDeclarator:
                    return this.emitVariableDeclarator(<VariableDeclaratorSyntax>ast);
                case SyntaxKind.SimpleArrowFunctionExpression:
                    return this.emitSimpleArrowFunctionExpression(<SimpleArrowFunctionExpressionSyntax>ast);
                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return this.emitParenthesizedArrowFunctionExpression(<ParenthesizedArrowFunctionExpressionSyntax>ast);
                case SyntaxKind.FunctionDeclaration:
                    return this.emitFunctionDeclaration(<FunctionDeclarationSyntax>ast);
                case SyntaxKind.ModuleDeclaration:
                    return this.emitModuleDeclaration(<ModuleDeclarationSyntax>ast);
                case SyntaxKind.VariableDeclaration:
                    return this.emitVariableDeclaration(<VariableDeclarationSyntax>ast);
                case SyntaxKind.GenericType:
                    return this.emitGenericType(<GenericTypeSyntax>ast);
                case SyntaxKind.ConstructorDeclaration:
                    return this.emitConstructorDeclaration(<ConstructorDeclarationSyntax>ast);
                case SyntaxKind.EnumDeclaration:
                    return this.emitEnumDeclaration(<EnumDeclarationSyntax>ast);
                case SyntaxKind.EnumElement:
                    return this.emitEnumElement(<EnumElementSyntax>ast);
                case SyntaxKind.FunctionExpression:
                    return this.emitFunctionExpression(<FunctionExpressionSyntax>ast);
                case SyntaxKind.VariableStatement:
                    return this.emitVariableStatement(<VariableStatementSyntax>ast);
            }

            this.emitComments(ast, true);
            this.emitWorker(ast);
            this.emitComments(ast, false);
        }

        private emitWorker(ast: ISyntaxElement): void {
            if (!ast) {
                return;
            }

            switch (ast.kind()) {
                case SyntaxKind.NumericLiteral:
                    return this.emitNumericLiteral(<ISyntaxToken>ast);
                case SyntaxKind.RegularExpressionLiteral:
                    return this.emitRegularExpressionLiteral(<ISyntaxToken>ast);
                case SyntaxKind.StringLiteral:
                    return this.emitStringLiteral(<ISyntaxToken>ast);
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.TrueKeyword:
                    return this.emitLiteralExpression(<ISyntaxToken>ast);
                case SyntaxKind.ThisKeyword:
                    return this.emitThisExpression(<ISyntaxToken>ast);
                case SyntaxKind.SuperKeyword:
                    return this.emitSuperExpression(<ISyntaxToken>ast);
                case SyntaxKind.ParenthesizedExpression:
                    return this.emitParenthesizedExpression(<ParenthesizedExpressionSyntax>ast);
                case SyntaxKind.ArrayLiteralExpression:
                    return this.emitArrayLiteralExpression(<ArrayLiteralExpressionSyntax>ast);
                case SyntaxKind.PostDecrementExpression:
                case SyntaxKind.PostIncrementExpression:
                    return this.emitPostfixUnaryExpression(<PostfixUnaryExpressionSyntax>ast);
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.NegateExpression:
                case SyntaxKind.PlusExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                    return this.emitPrefixUnaryExpression(<PrefixUnaryExpressionSyntax>ast);
                case SyntaxKind.InvocationExpression:
                    return this.emitInvocationExpression(<InvocationExpressionSyntax>ast);
                case SyntaxKind.ElementAccessExpression:
                    return this.emitElementAccessExpression(<ElementAccessExpressionSyntax>ast);
                case SyntaxKind.MemberAccessExpression:
                    return this.emitMemberAccessExpression(<MemberAccessExpressionSyntax>ast);
                case SyntaxKind.QualifiedName:
                    return this.emitQualifiedName(<QualifiedNameSyntax>ast);
                case SyntaxKind.CommaExpression: 
                case SyntaxKind.AssignmentExpression: 
                case SyntaxKind.AddAssignmentExpression: 
                case SyntaxKind.SubtractAssignmentExpression: 
                case SyntaxKind.MultiplyAssignmentExpression: 
                case SyntaxKind.DivideAssignmentExpression: 
                case SyntaxKind.ModuloAssignmentExpression: 
                case SyntaxKind.AndAssignmentExpression: 
                case SyntaxKind.ExclusiveOrAssignmentExpression: 
                case SyntaxKind.OrAssignmentExpression: 
                case SyntaxKind.LeftShiftAssignmentExpression: 
                case SyntaxKind.SignedRightShiftAssignmentExpression: 
                case SyntaxKind.UnsignedRightShiftAssignmentExpression: 
                case SyntaxKind.LogicalOrExpression: 
                case SyntaxKind.LogicalAndExpression: 
                case SyntaxKind.BitwiseOrExpression: 
                case SyntaxKind.BitwiseExclusiveOrExpression: 
                case SyntaxKind.BitwiseAndExpression: 
                case SyntaxKind.EqualsWithTypeConversionExpression: 
                case SyntaxKind.NotEqualsWithTypeConversionExpression: 
                case SyntaxKind.EqualsExpression: 
                case SyntaxKind.NotEqualsExpression: 
                case SyntaxKind.LessThanExpression: 
                case SyntaxKind.GreaterThanExpression: 
                case SyntaxKind.LessThanOrEqualExpression: 
                case SyntaxKind.GreaterThanOrEqualExpression: 
                case SyntaxKind.InstanceOfExpression: 
                case SyntaxKind.InExpression: 
                case SyntaxKind.LeftShiftExpression: 
                case SyntaxKind.SignedRightShiftExpression: 
                case SyntaxKind.UnsignedRightShiftExpression: 
                case SyntaxKind.MultiplyExpression: 
                case SyntaxKind.DivideExpression: 
                case SyntaxKind.ModuloExpression: 
                case SyntaxKind.AddExpression: 
                case SyntaxKind.SubtractExpression:
                    return this.emitBinaryExpression(<BinaryExpressionSyntax>ast);
                case SyntaxKind.ConditionalExpression:
                    return this.emitConditionalExpression(<ConditionalExpressionSyntax>ast);
                case SyntaxKind.EqualsValueClause:
                    return this.emitEqualsValueClause(<EqualsValueClauseSyntax>ast);
                case SyntaxKind.Parameter:
                    return this.emitParameter(<ParameterSyntax>ast);
                case SyntaxKind.Block:
                    return this.emitBlock(<BlockSyntax>ast);
                case SyntaxKind.ElseClause:
                    return this.emitElseClause(<ElseClauseSyntax>ast);
                case SyntaxKind.IfStatement:
                    return this.emitIfStatement(<IfStatementSyntax>ast);
                case SyntaxKind.ExpressionStatement:
                    return this.emitExpressionStatement(<ExpressionStatementSyntax>ast);
                case SyntaxKind.GetAccessor:
                    return this.emitGetAccessor(<GetAccessorSyntax>ast);
                case SyntaxKind.SetAccessor:
                    return this.emitSetAccessor(<SetAccessorSyntax>ast);
                case SyntaxKind.ThrowStatement:
                    return this.emitThrowStatement(<ThrowStatementSyntax>ast);
                case SyntaxKind.ReturnStatement:
                    return this.emitReturnStatement(<ReturnStatementSyntax>ast);
                case SyntaxKind.ObjectCreationExpression:
                    return this.emitObjectCreationExpression(<ObjectCreationExpressionSyntax>ast);
                case SyntaxKind.SwitchStatement:
                    return this.emitSwitchStatement(<SwitchStatementSyntax>ast);
                case SyntaxKind.CaseSwitchClause:
                    return this.emitCaseSwitchClause(<CaseSwitchClauseSyntax>ast);
                case SyntaxKind.DefaultSwitchClause:
                    return this.emitDefaultSwitchClause(<DefaultSwitchClauseSyntax>ast);
                case SyntaxKind.BreakStatement:
                    return this.emitBreakStatement(<BreakStatementSyntax>ast);
                case SyntaxKind.ContinueStatement:
                    return this.emitContinueStatement(<ContinueStatementSyntax>ast);
                case SyntaxKind.ForStatement:
                    return this.emitForStatement(<ForStatementSyntax>ast);
                case SyntaxKind.ForInStatement:
                    return this.emitForInStatement(<ForInStatementSyntax>ast);
                case SyntaxKind.WhileStatement:
                    return this.emitWhileStatement(<WhileStatementSyntax>ast);
                case SyntaxKind.WithStatement:
                    return this.emitWithStatement(<WithStatementSyntax>ast);
                case SyntaxKind.CastExpression:
                    return this.emitCastExpression(<CastExpressionSyntax>ast);
                case SyntaxKind.ObjectLiteralExpression:
                    return this.emitObjectLiteralExpression(<ObjectLiteralExpressionSyntax>ast);
                case SyntaxKind.SimplePropertyAssignment:
                    return this.emitSimplePropertyAssignment(<SimplePropertyAssignmentSyntax>ast);
                case SyntaxKind.FunctionPropertyAssignment:
                    return this.emitFunctionPropertyAssignment(<FunctionPropertyAssignmentSyntax>ast);
                case SyntaxKind.EmptyStatement:
                    return this.writeToken((<EmptyStatementSyntax>ast).semicolonToken);
                case SyntaxKind.TryStatement:
                    return this.emitTryStatement(<TryStatementSyntax>ast);
                case SyntaxKind.CatchClause:
                    return this.emitCatchClause(<CatchClauseSyntax>ast);
                case SyntaxKind.FinallyClause:
                    return this.emitFinallyClause(<FinallyClauseSyntax>ast);
                case SyntaxKind.LabeledStatement:
                    return this.emitLabeledStatement(<LabeledStatementSyntax>ast);
                case SyntaxKind.DoStatement:
                    return this.emitDoStatement(<DoStatementSyntax>ast);
                case SyntaxKind.TypeOfExpression:
                    return this.emitTypeOfExpression(<TypeOfExpressionSyntax>ast);
                case SyntaxKind.DeleteExpression:
                    return this.emitDeleteExpression(<DeleteExpressionSyntax>ast);
                case SyntaxKind.VoidExpression:
                    return this.emitVoidExpression(<VoidExpressionSyntax>ast);
                case SyntaxKind.DebuggerStatement:
                    return this.emitDebuggerStatement(<DebuggerStatementSyntax>ast);
            }
        }
    }

    export function getLastConstructor(classDecl: ClassDeclarationSyntax): ConstructorDeclarationSyntax {
        for (var i = classDecl.classElements.length - 1; i >= 0; i--) {
            var child = classDecl.classElements[i];

            if (child.kind() === SyntaxKind.ConstructorDeclaration) {
                return <ConstructorDeclarationSyntax>child;
            }
        }

        return null;
    }

    export function getTrimmedTextLines(comment: Comment): string[] {
        if (comment.kind() === SyntaxKind.MultiLineCommentTrivia) {
            return comment.fullText().split("\n").map(s => s.trim());
        }
        else {
            return [comment.fullText().trim()];
        }
    }
}
declare class Enumerator {
    public atEnd(): boolean;
    public moveNext(): boolean;
    public item(): any;
    constructor (o: any);
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export function hasFlag(val: number, flag: number): boolean {
        return (val & flag) !== 0;
    }

    export enum ModuleGenTarget {
        Unspecified = 0,
        Synchronous = 1,
        Asynchronous = 2,
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    var proto = "__proto__"

    class BlockIntrinsics<T> {
        public prototype: T = undefined;
        public toString: T = undefined;
        public toLocaleString: T = undefined;
        public valueOf: T = undefined;
        public hasOwnProperty: T = undefined;
        public propertyIsEnumerable: T = undefined;
        public isPrototypeOf: T = undefined;
        [s: string]: T;

        constructor() {
            // initialize the 'constructor' field
            this["constructor"] = undefined;

            // First we set it to null, because that's the only way to erase the value in node. Then we set it to undefined in case we are not in node, since
            // in StringHashTable below, we check for undefined explicitly.
            this[proto] = null;
            this[proto] = undefined;
        }
    }

    export function createIntrinsicsObject<T>(): IIndexable<T> {
        return new BlockIntrinsics<T>();
    }

    export interface IHashTable<T> {
        getAllKeys(): string[];
        add(key: string, data: T): boolean;
        addOrUpdate(key: string, data: T): boolean;
        map(fn: (k: string, value: T, context: any) => void , context: any): void;
        every(fn: (k: string, value: T, context: any) => void , context: any): boolean;
        some(fn: (k: string, value: T, context: any) => void , context: any): boolean;
        count(): number;
        lookup(key: string): T;
    }

    export class StringHashTable<T> implements IHashTable<T> {
        private itemCount = 0;
        private table: IIndexable<T> = createIntrinsicsObject<T>();

        public getAllKeys(): string[] {
            var result: string[] = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        }

        public add(key: string, data: T): boolean {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public addOrUpdate(key: string, data: T): boolean {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public map(fn: (k: string, value: T, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        }

        public every(fn: (k: string, value: T, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        }

        public some(fn: (k: string, value: T, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        }

        public count(): number {
            return this.itemCount;
        }

        public lookup(key: string) : T {
            var data = this.table[key];
            return data === undefined ? null : data;
        }

        public remove(key: string): void {
            if (this.table[key] !== undefined) {
                this.table[key] = undefined;
                this.itemCount--;
            }
        }
    }


    export class IdentiferNameHashTable<T> extends StringHashTable<T> {
        public getAllKeys(): string[]{
            var result: string[] = [];

            super.map((k, v, c) => {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);

            return result;
        }

        public add(key: string, data: T): boolean {
            return super.add("#" + key, data);
        }

        public addOrUpdate(key: string, data: T): boolean {
            return super.addOrUpdate("#" + key, data);
        }

        public map(fn: (k: string, value: T, context: any) => void , context: any) {
            return super.map((k, v, c) => fn(k.substring(1), v, c), context);
        }

        public every(fn: (k: string, value: T, context: any) => void , context: any) {
            return super.every((k, v, c) => fn(k.substring(1), v, c), context);
        }

        public some(fn: (k: string, value: any, context: any) => void , context: any) {
            return super.some((k, v, c) => fn(k.substring(1), v, c), context);
        }

        public lookup(key: string): T {
            return super.lookup("#" + key);
        }
    }
}
module TypeScript {    
    export class IdentifierWalker extends SyntaxWalker {
        constructor(public list: IIndexable<boolean>) {
            super();
        }

        public visitToken(token: ISyntaxToken): void {
            this.list[token.text()] = true;
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='enumerator.ts' />
///<reference path='process.ts' />
///<reference path='core\references.ts' />

module TypeScript {

    export interface IFindFileResult {
        fileInformation: FileInformation;
        path: string;
    }

    export interface IFileWatcher {
        close(): void;
    }

    export interface IIO {
        readFile(path: string, codepage: number): FileInformation;
        appendFile(path: string, contents: string): void;
        writeFile(path: string, contents: string, writeByteOrderMark: boolean): void;
        deleteFile(path: string): void;
        dir(path: string, re?: RegExp, options?: { recursive?: boolean; }): string[];
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        createDirectory(path: string): void;
        resolvePath(path: string): string;
        dirName(path: string): string;
        findFile(rootPath: string, partialFilePath: string): IFindFileResult;
        print(str: string): void;
        printLine(str: string): void;
        arguments: string[];
        stderr: ITextWriter;
        stdout: ITextWriter;
        watchFile(fileName: string, callback: (x: string) => void): IFileWatcher;
        getExecutingFilePath(): string;
        quit(exitCode?: number): void;
    }

    export module IOUtils {
        // Creates the directory including its parent if not already present
        function createDirectoryStructure(ioHost: IIO, dirName: string) {
            if (ioHost.directoryExists(dirName)) {
                return;
            }

            var parentDirectory = ioHost.dirName(dirName);
            if (parentDirectory != "") {
                createDirectoryStructure(ioHost, parentDirectory);
            }
            ioHost.createDirectory(dirName);
        }

        // Creates a file including its directory structure if not already present
        export function writeFileAndFolderStructure(ioHost: IIO, fileName: string, contents: string, writeByteOrderMark: boolean): void {
            var start = new Date().getTime();
            var path = ioHost.resolvePath(fileName);
            TypeScript.ioHostResolvePathTime += new Date().getTime() - start;

            var start = new Date().getTime();
            var dirName = ioHost.dirName(path);
            TypeScript.ioHostDirectoryNameTime += new Date().getTime() - start;

            var start = new Date().getTime();
            createDirectoryStructure(ioHost, dirName);
            TypeScript.ioHostCreateDirectoryStructureTime += new Date().getTime() - start;

            var start = new Date().getTime();
            ioHost.writeFile(path, contents, writeByteOrderMark);
            TypeScript.ioHostWriteFileTime += new Date().getTime() - start;
        }

        export function throwIOError(message: string, error: Error) {
            var errorMessage = message;
            if (error && error.message) {
                errorMessage += (" " + error.message);
            }
            throw new Error(errorMessage);
        }

        export function combine(prefix: string, suffix: string): string {
            return prefix + "/" + suffix;
        }

        export class BufferedTextWriter implements ITextWriter {
            public buffer = "";
            // Inner writer does not need a WriteLine method, since the BufferedTextWriter wraps it itself
            constructor(public writer: { Write: (str: string) => void; Close: () => void; }, public capacity = 1024) { }
            Write(str: string) {
                this.buffer += str;
                if (this.buffer.length >= this.capacity) {
                    this.writer.Write(this.buffer);
                    this.buffer = "";
                }
            }
            WriteLine(str: string) {
                this.Write(str + '\r\n');
            }
            Close() {
                this.writer.Write(this.buffer);
                this.writer.Close();
                this.buffer = null;
            }
        }
    }

    export var IO = (function () {

        // Create an IO object for use inside WindowsScriptHost hosts
        // Depends on WSCript and FileSystemObject
        function getWindowsScriptHostIO(): IIO {
            var fso = new ActiveXObject("Scripting.FileSystemObject");
            var streamObjectPool: any[] = [];

            function getStreamObject(): any {
                if (streamObjectPool.length > 0) {
                    return streamObjectPool.pop();
                } else {
                    return new ActiveXObject("ADODB.Stream");
                }
            }

            function releaseStreamObject(obj: any) {
                streamObjectPool.push(obj);
            }

            var args: any[] = [];
            for (var i = 0; i < WScript.Arguments.length; i++) {
                args[i] = WScript.Arguments.Item(i);
            }

            return {
                appendFile: function (path: string, content: string) {
                    var txtFile = fso.OpenTextFile(path, 8 /* append */, true /* create if file doesn't exist */);
                    txtFile.Write(content);
                    txtFile.Close();
                },
                readFile: function (path: string, codepage: number): FileInformation {
                    return Environment.readFile(path, codepage);
                },

                writeFile: function (path: string, contents: string, writeByteOrderMark: boolean) {
                    Environment.writeFile(path, contents, writeByteOrderMark);
                },

                fileExists: function (path: string): boolean {
                    return fso.FileExists(path);
                },

                resolvePath: function (path: string): string {
                    return fso.GetAbsolutePathName(path);
                },

                dirName: function (path: string): string {
                    return fso.GetParentFolderName(path);
                },

                findFile: function (rootPath: string, partialFilePath: string): IFindFileResult {
                    var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;

                    while (true) {
                        if (fso.FileExists(path)) {
                            return { fileInformation: this.readFile(path), path: path };
                        }
                        else {
                            rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));

                            if (rootPath == "") {
                                return null;
                            }
                            else {
                                path = fso.BuildPath(rootPath, partialFilePath);
                            }
                        }
                    }
                },

                deleteFile: function (path: string): void {
                    try {
                        if (fso.FileExists(path)) {
                            fso.DeleteFile(path, true); // true: delete read-only files
                        }
                    } catch (e) {
                        IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_delete_file_0, [path]), e);
                    }
                },

                directoryExists: function (path) {
                    return <boolean>fso.FolderExists(path);
                },

                createDirectory: function (path) {
                    try {
                        if (!this.directoryExists(path)) {
                            fso.CreateFolder(path);
                        }
                    } catch (e) {
                        IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                    }
                },

                dir: function (path, spec?, options?) {
                    options = options || <{ recursive?: boolean; }>{};
                    function filesInFolder(folder: any, root: string): string[] {
                        var paths: string[] = [];
                        var fc: Enumerator;

                        if (options.recursive) {
                            fc = new Enumerator(folder.subfolders);

                            for (; !fc.atEnd(); fc.moveNext()) {
                                paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                            }
                        }

                        fc = new Enumerator(folder.files);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            if (!spec || fc.item().Name.match(spec)) {
                                paths.push(root + "/" + fc.item().Name);
                            }
                        }

                        return paths;
                    }

                    var folder = fso.GetFolder(path);
                    var paths: string[] = [];

                    return filesInFolder(folder, path);
                },

                print: function (str) {
                    WScript.StdOut.Write(str);
                },

                printLine: function (str) {
                    WScript.Echo(str);
                },

                arguments: <string[]>args,
                stderr: WScript.StdErr,
                stdout: WScript.StdOut,
                watchFile: null,
                getExecutingFilePath: function () {
                    return WScript.ScriptFullName;
                },
                quit: function (exitCode: number = 0) {
                    try {
                        WScript.Quit(exitCode);
                    } catch (e) {
                    }
                }
            };

        };

        // Create an IO object for use inside Node.js hosts
        // Depends on 'fs' and 'path' modules
        function getNodeIO(): IIO {

            var _fs = require('fs');
            var _path = require('path');
            var _module = require('module');

            return {
                appendFile: function (path: string, content: string) {
                    _fs.appendFileSync(path, content);
                },
                readFile: function (file: string, codepage: number): FileInformation {
                    return Environment.readFile(file, codepage);
                },

                writeFile: function (path: string, contents: string, writeByteOrderMark: boolean) {
                    Environment.writeFile(path, contents, writeByteOrderMark);
                },

                deleteFile: function (path) {
                    try {
                        _fs.unlinkSync(path);
                    } catch (e) {
                        IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_delete_file_0, [path]), e);
                    }
                },
                fileExists: function (path: string): boolean {
                    return _fs.existsSync(path);
                },

                dir: function dir(path, spec?, options?) {
                    options = options || <{ recursive?: boolean; }>{};

                    function filesInFolder(folder: string): string[] {
                        var paths: string[] = [];

                        try {
                            var files = _fs.readdirSync(folder);
                            for (var i = 0; i < files.length; i++) {
                                var stat = _fs.statSync(folder + "/" + files[i]);
                                if (options.recursive && stat.isDirectory()) {
                                    paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                                } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                    paths.push(folder + "/" + files[i]);
                                }
                            }
                        } catch (err) {
                            /*
                            *   Skip folders that are inaccessible
                            */
                        }

                        return paths;
                    }

                    return filesInFolder(path);
                },
                createDirectory: function (path: string): void {
                    try {
                        if (!this.directoryExists(path)) {
                            _fs.mkdirSync(path);
                        }
                    } catch (e) {
                        IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                    }
                },

                directoryExists: function (path: string): boolean {
                    return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
                },
                resolvePath: function (path: string): string {
                    return _path.resolve(path);
                },
                dirName: function (path: string): string {
                    var dirPath = _path.dirname(path);

                    // Node will just continue to repeat the root path, rather than return null
                    if (dirPath === path) {
                        dirPath = null;
                    }

                    return dirPath;
                },
                findFile: function (rootPath: string, partialFilePath: string): IFindFileResult {
                    var path = rootPath + "/" + partialFilePath;

                    while (true) {
                        if (_fs.existsSync(path)) {
                            return { fileInformation: this.readFile(path), path: path };
                        }
                        else {
                            var parentPath = _path.resolve(rootPath, "..");

                            // Node will just continue to repeat the root path, rather than return null
                            if (rootPath === parentPath) {
                                return null;
                            }
                            else {
                                rootPath = parentPath;
                                path = _path.resolve(rootPath, partialFilePath);
                            }
                        }
                    }
                },
                print: function (str) { process.stdout.write(str); },
                printLine: function (str) { process.stdout.write(str + '\n') },
                arguments: process.argv.slice(2),
                stderr: {
                    Write: function (str) { process.stderr.write(str); },
                    WriteLine: function (str) { process.stderr.write(str + '\n'); },
                    Close: function () { }
                },
                stdout: {
                    Write: function (str) { process.stdout.write(str); },
                    WriteLine: function (str) { process.stdout.write(str + '\n'); },
                    Close: function () { }
                },
                watchFile: function (fileName: string, callback: (x: string) => void): IFileWatcher {
                    var firstRun = true;
                    var processingChange = false;

                    var fileChanged: any = function (curr: any, prev: any) {
                        if (!firstRun) {
                            if (curr.mtime < prev.mtime) {
                                return;
                            }

                            _fs.unwatchFile(fileName, fileChanged);
                            if (!processingChange) {
                                processingChange = true;
                                callback(fileName);
                                setTimeout(function () { processingChange = false; }, 100);
                            }
                        }
                        firstRun = false;
                        _fs.watchFile(fileName, { persistent: true, interval: 500 }, fileChanged);
                    };

                    fileChanged();
                    return {
                        fileName: fileName,
                        close: function () {
                            _fs.unwatchFile(fileName, fileChanged);
                        }
                    };
                },
                getExecutingFilePath: function () {
                    return process.mainModule.filename;
                },
                quit: function (code?: number) {
                    var stderrFlushed = process.stderr.write('');
                    var stdoutFlushed = process.stdout.write('');
                    process.stderr.on('drain', function () {
                        stderrFlushed = true;
                        if (stdoutFlushed) {
                            process.exit(code);
                        }
                    });
                    process.stdout.on('drain', function () {
                        stdoutFlushed = true;
                        if (stderrFlushed) {
                            process.exit(code);
                        }
                    });
                    setTimeout(function () {
                        process.exit(code);
                    }, 5);
                }
            }
    };

        if (typeof WScript !== "undefined" && typeof ActiveXObject === "function")
            return getWindowsScriptHostIO();
        else if (typeof module !== 'undefined' && module.exports)
            return getNodeIO();
        else
            return null; // Unsupported host
    })();
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path="io.ts" />

module TypeScript {
    export interface IOptions {
        name?: string;
        flag?: boolean;
        short?: string;
        usage?: {
            locCode: string; // DiagnosticCode
            args: string[]
        };
        set?: (s: string) => void;
        type?: string; // DiagnosticCode
        experimental?: boolean;
    }

    export class OptionsParser {
        private DEFAULT_SHORT_FLAG = "-";
        private DEFAULT_LONG_FLAG = "--";

        private printedVersion: boolean = false;

        // Find the option record for the given string. Returns null if not found.
        private findOption(arg: string) {
            var upperCaseArg = arg && arg.toUpperCase();

            for (var i = 0; i < this.options.length; i++) {
                var current = this.options[i];

                if (upperCaseArg === (current.short && current.short.toUpperCase()) ||
                    upperCaseArg === (current.name && current.name.toUpperCase())) {
                    return current;
                }
            }

            return null;
        }

        public unnamed: string[] = [];

        public options: IOptions[] = [];

        constructor(public host: IIO, public version: string) {
        }

        public printUsage() {
            this.printVersion();

            var optionsWord = getLocalizedText(DiagnosticCode.options, null);
            var fileWord = getLocalizedText(DiagnosticCode.file1, null);
            var tscSyntax = "tsc [" + optionsWord + "] [" + fileWord + " ..]";
            var syntaxHelp = getLocalizedText(DiagnosticCode.Syntax_0, [tscSyntax]);
            this.host.printLine(syntaxHelp);
            this.host.printLine("");
            this.host.printLine(getLocalizedText(DiagnosticCode.Examples, null) + " tsc hello.ts");
            this.host.printLine("          tsc --out foo.js foo.ts");
            this.host.printLine("          tsc @args.txt");
            this.host.printLine("");
            this.host.printLine(getLocalizedText(DiagnosticCode.Options, null));

            var output: string[][] = [];
            var maxLength = 0;
            var i = 0;

            this.options = this.options.sort(function (a, b) {
                var aName = a.name.toLowerCase();
                var bName = b.name.toLowerCase();

                if (aName > bName) {
                    return 1;
                } else if (aName < bName) {
                    return -1;
                } else {
                    return 0;
                }
            });

            // Build up output array
            for (i = 0; i < this.options.length; i++) {
                var option = this.options[i];

                if (option.experimental) {
                    continue;
                }

                if (!option.usage) {
                    break;
                }

                var usageString = "  ";
                var type = option.type ? (" " + TypeScript.getLocalizedText(option.type, null)) : "";

                if (option.short) {
                    usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
                }

                usageString += this.DEFAULT_LONG_FLAG + option.name + type;

                output.push([usageString, TypeScript.getLocalizedText(option.usage.locCode, option.usage.args)]);

                if (usageString.length > maxLength) {
                    maxLength = usageString.length;
                }
            }

            var fileDescription = getLocalizedText(DiagnosticCode.Insert_command_line_options_and_files_from_a_file, null);
            output.push(["  @<" + fileWord + ">", fileDescription]);

            // Print padded output
            for (i = 0; i < output.length; i++) {
                this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
            }
        }

        public printVersion() {
            if (!this.printedVersion) {
                this.host.printLine(getLocalizedText(DiagnosticCode.Version_0, [this.version]));
                this.printedVersion = true;
            }
        }

        public option(name: string, config: IOptions, short?: string) {
            if (!config) {
                config = <any>short;
                short = null;
            }

            config.name = name;
            config.short = short;
            config.flag = false;

            this.options.push(config);
        }

        public flag(name: string, config: IOptions, short?: string) {
            if (!config) {
                config = <any>short;
                short = null;
            }

            config.name = name;
            config.short = short;
            config.flag = true

        this.options.push(config);
        }

        // Parse an arguments string
        public parseString(argString: string) {
            var position = 0;
            var tokens = argString.match(/\s+|"|[^\s"]+/g);

            function peek() {
                return tokens[position];
            }

            function consume() {
                return tokens[position++];
            }

            function consumeQuotedString() {
                var value = '';
                consume(); // skip opening quote.

                var token = peek();

                while (token && token !== '"') {
                    consume();

                    value += token;

                    token = peek();
                }

                consume(); // skip ending quote;

                return value;
            }

            var args: string[] = [];
            var currentArg = '';

            while (position < tokens.length) {
                var token = peek();

                if (token === '"') {
                    currentArg += consumeQuotedString();
                } else if (token.match(/\s/)) {
                    if (currentArg.length > 0) {
                        args.push(currentArg);
                        currentArg = '';
                    }

                    consume();
                } else {
                    consume();
                    currentArg += token;
                }
            }

            if (currentArg.length > 0) {
                args.push(currentArg);
            }

            this.parse(args);
        }

        // Parse arguments as they come from the platform: split into arguments.
        public parse(args: string[]) {
            var position = 0;

            function consume() {
                return args[position++];
            }

            while (position < args.length) {
                var current = consume();
                var match = current.match(/^(--?|@)(.*)/);
                var value: any = null;

                if (match) {
                    if (match[1] === '@') {
                        this.parseString(this.host.readFile(match[2], null).contents);
                    } else {
                        var arg = match[2];
                        var option = this.findOption(arg);

                        if (option === null) {
                            this.host.printLine(getDiagnosticMessage(DiagnosticCode.Unknown_option_0, [arg]));
                            this.host.printLine(getLocalizedText(DiagnosticCode.Use_the_0_flag_to_see_options, ["--help"]));
                        } else {
                            if (!option.flag) {
                                value = consume();
                                if (value === undefined) {
                                    // No value provided
                                    this.host.printLine(getDiagnosticMessage(DiagnosticCode.Option_0_specified_without_1, [arg, getLocalizedText(option.type, null)]));
                                    this.host.printLine(getLocalizedText(DiagnosticCode.Use_the_0_flag_to_see_options, ["--help"]));
                                    continue;
                                }
                            }

                            option.set(value);
                        }
                    }
                } else {
                    this.unnamed.push(current);
                }
            }
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export function stripStartAndEndQuotes(str: string) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === CharacterCodes.singleQuote || firstCharCode === CharacterCodes.doubleQuote)) {
            return str.substring(1, str.length - 1);
        }

        return str;
    }

    export function isSingleQuoted(str: string) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === CharacterCodes.singleQuote;
    }

    export function isDoubleQuoted(str: string) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === CharacterCodes.doubleQuote;
    }

    export function isQuoted(str: string) {
        return isDoubleQuoted(str) || isSingleQuoted(str);
    }

    export function quoteStr(str: string) {
        return "\"" + str + "\"";
    }

    var switchToForwardSlashesRegEx = /\\/g;
    export function switchToForwardSlashes(path: string) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }

    export function trimModName(modName: string) {
        // in case's it's a declare file...
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        // in case's it's a .js file
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }

    export function getDeclareFilePath(fname: string) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }

    function isFileOfExtension(fname: string, ext: string) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }

    export function isTSFile(fname: string) {
        return isFileOfExtension(fname, ".ts");
    }

    export function isDTSFile(fname: string) {
        return isFileOfExtension(fname, ".d.ts");
    }

    export function getPrettyName(modPath: string, quote=true, treatAsFileName=false): any { 
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripStartAndEndQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }

    export function getPathComponents(path: string) {
        return path.split("/");
    }

    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string, isAbsoultePathURL = true) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        // Find the component that differs
        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }

        // Get the relative path
        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }

        return absoluteModPath;
    }

    export function changePathToDTS(modPath: string) {
        return trimModName(stripStartAndEndQuotes(modPath)) + ".d.ts";
    }

    export function isRelative(path: string) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    export function isRooted(path: string) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }

    export function getRootFilePath(outFname: string) {
        if (outFname === "") {
            return outFname;
        }
        else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }

    export function filePathComponents(fullPath: string) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }

    export function filePath(fullPath: string) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }

    export function convertToDirectoryPath(dirPath: string) {
        if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
            dirPath += "/";
        }

        return dirPath;
    }

    var normalizePathRegEx = /^\\\\[^\\]/;
    export function normalizePath(path: string): string {
        // If it's a UNC style path (i.e. \\server\share), convert to a URI style (i.e. file://server/share)
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts: string[] = [];

        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }

            if (normalizedParts.length > 0 && ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }

            normalizedParts.push(part);
        }

        return normalizedParts.join("/");
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    ///
    /// Preprocessing
    ///
    export interface IPreProcessedFileInfo {
        referencedFiles: IFileReference[];
        importedFiles: IFileReference[];
        diagnostics: Diagnostic[];
        isLibFile: boolean;
    }

    interface ITripleSlashDirectiveProperties {
        noDefaultLib: boolean;
        diagnostics: Diagnostic[];
        referencedFiles: IFileReference[];
    }

    function isNoDefaultLibMatch(comment: string): RegExpExecArray {
        var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
        return isNoDefaultLibRegex.exec(comment);
    }

    export var tripleSlashReferenceRegExp = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/;

    function getFileReferenceFromReferencePath(fileName: string, lineMap: LineMap, position: number, comment: string, diagnostics: Diagnostic[]): IFileReference {
        // First, just see if they've written: /// <reference\s+
        // If so, then we'll consider this a reference directive and we'll report errors if it's
        // malformed.  Otherwise, we'll completely ignore this.

        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            var isNoDefaultLib = isNoDefaultLibMatch(comment);

            if (!isNoDefaultLib) {
                var fullReferenceRegEx = tripleSlashReferenceRegExp;
                var fullReference = fullReferenceRegEx.exec(comment);

                if (!fullReference) {
                    // It matched the start of a reference directive, but wasn't well formed.  Report
                    // an appropriate error to the user.
                    diagnostics.push(new Diagnostic(fileName, lineMap, position, comment.length, DiagnosticCode.Invalid_reference_directive_syntax));
                }
                else {
                    var path: string = normalizePath(fullReference[3]);
                    var adjustedPath = normalizePath(path);

                    var isResident = fullReference.length >= 7 && fullReference[6] === "true";
                    if (isResident) {
                        CompilerDiagnostics.debugPrint(path + " is resident");
                    }
                    return {
                        line: 0,
                        character: 0,
                        position: 0,
                        length: 0,
                        path: switchToForwardSlashes(adjustedPath),
                        isResident: isResident
                    };
                }
            }
        }

        return null;
    }

    var reportDiagnostic = () => { };

    function processImports(lineMap: LineMap, scanner: Scanner, token: ISyntaxToken, importedFiles: IFileReference[]): void {
        var lineChar = { line: -1, character: -1 };

        var start = new Date().getTime();
        // Look for: 
        // import foo = module("foo")
        while (token.kind() !== SyntaxKind.EndOfFileToken) {
            if (token.kind() === SyntaxKind.ImportKeyword) {
                var importToken = token;
                token = scanner.scan(/*allowRegularExpression:*/ false);

                if (SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(/*allowRegularExpression:*/ false);

                    if (token.kind() === SyntaxKind.EqualsToken) {
                        token = scanner.scan(/*allowRegularExpression:*/ false);

                        if (token.kind() === SyntaxKind.ModuleKeyword || token.kind() === SyntaxKind.RequireKeyword) {
                            token = scanner.scan(/*allowRegularExpression:*/ false);

                            if (token.kind() === SyntaxKind.OpenParenToken) {
                                token = scanner.scan(/*allowRegularExpression:*/ false);

                                lineMap.fillLineAndCharacterFromPosition(TypeScript.start(importToken), lineChar);

                                if (token.kind() === SyntaxKind.StringLiteral) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: TypeScript.start(token),
                                        length: width(token),
                                        path: stripStartAndEndQuotes(switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            token = scanner.scan(/*allowRegularExpression:*/ false);
        }

        var totalTime = new Date().getTime() - start;
        TypeScript.fileResolutionScanImportsTime += totalTime;
    }

    function processTripleSlashDirectives(fileName: string, lineMap: LineMap, firstToken: ISyntaxToken): ITripleSlashDirectiveProperties {
        var leadingTrivia = firstToken.leadingTrivia();

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;
        var diagnostics: Diagnostic[] = [];
        var referencedFiles: IFileReference[] = [];

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === SyntaxKind.SingleLineCommentTrivia) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(fileName, lineMap, position, triviaText, diagnostics);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                // is it a lib file?
                var isNoDefaultLib = isNoDefaultLibMatch(triviaText);
                if (isNoDefaultLib) {
                    noDefaultLib = isNoDefaultLib[3] === "true";
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib, diagnostics: diagnostics, referencedFiles: referencedFiles };
    }

    export function preProcessFile(fileName: string, sourceText: IScriptSnapshot, readImportFiles = true): IPreProcessedFileInfo {
        var text = SimpleText.fromScriptSnapshot(sourceText);
        var scanner = createScanner(LanguageVersion.EcmaScript5, text, reportDiagnostic);

        var firstToken = scanner.scan(/*allowRegularExpression:*/ false);

        // only search out dynamic mods
        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies
        // var position

        var importedFiles: IFileReference[] = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }

        var properties = processTripleSlashDirectives(fileName, text.lineMap(), firstToken);

        return { referencedFiles: properties.referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib, diagnostics: properties.diagnostics };
    }

    export function getReferencedFiles(fileName: string, sourceText: IScriptSnapshot): IFileReference[] {
        return preProcessFile(fileName, sourceText, false).referencedFiles;
    }
} // Tools
declare module process {
    export var argv: string[];
    export var platform: string;
    export function on(event: string, handler: (arg: any) => void ): void;
    export module stdout {
        export function write(str: string): any;
        export function on(event: string, action: () => void ): void;
    }
    export module stderr {
        export function write(str: string): any;
        export function on(event: string, action: () => void): void;
    }
    export module mainModule {
        export var filename: string;
    }
    export function exit(exitCode?: number): any;
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {

    // Note: This is being using by the host (VS) and is marshaled back and forth. When changing this make sure the changes 
    // are reflected in the managed side as well.
    export interface IFileReference extends ILineAndCharacter {
        path: string;
        isResident: boolean;
        position: number;
        length: number;
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export interface IResolvedFile {
        path: string;
        referencedFiles: string[];
        importedFiles: string[];
    }

    export interface IReferenceResolverHost {
        getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        resolveRelativePath(path: string, directory: string): string;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        getParentDirectory(path: string): string;
    }

    export class ReferenceResolutionResult {
        resolvedFiles: IResolvedFile[] = [];
        diagnostics: TypeScript.Diagnostic[] = [];
        seenNoDefaultLibTag: boolean = false;
    }

    class ReferenceLocation {
        constructor(public filePath: string, public lineMap: LineMap, public position: number, public length: number, public isImported: boolean) {
        }
    }

    export class ReferenceResolver {
        private inputFileNames: string[];
        private host: IReferenceResolverHost;
        private visited: IIndexable<string>;

        constructor(inputFileNames: string[], host: IReferenceResolverHost, private useCaseSensitiveFileResolution: boolean) {
            this.inputFileNames = inputFileNames;
            this.host = host;
            this.visited = {};
        }

        public static resolve(inputFileNames: string[], host: IReferenceResolverHost, useCaseSensitiveFileResolution: boolean): ReferenceResolutionResult {
            var resolver = new ReferenceResolver(inputFileNames, host, useCaseSensitiveFileResolution);
            return resolver.resolveInputFiles();
        }

        public resolveInputFiles(): ReferenceResolutionResult {
            var result = new ReferenceResolutionResult();

            if (!this.inputFileNames || this.inputFileNames.length <= 0) {
                // Nothing to do.
                return result;
            }

            // Loop over the files and extract references
            var referenceLocation = new ReferenceLocation(null, null, 0, 0, false);
            this.inputFileNames.forEach(fileName =>
                this.resolveIncludedFile(fileName, referenceLocation, result));

            return result;
        }

        private resolveIncludedFile(path: string, referenceLocation: ReferenceLocation, resolutionResult: ReferenceResolutionResult): string {
            var normalizedPath = this.getNormalizedFilePath(path, referenceLocation.filePath);

            if (this.isSameFile(normalizedPath, referenceLocation.filePath)) {
                // Cannot reference self
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(
                        new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap,
                            referenceLocation.position, referenceLocation.length, DiagnosticCode.A_file_cannot_have_a_reference_to_itself, null));
                }

                return normalizedPath;
            }

            if (!isTSFile(normalizedPath) && !isDTSFile(normalizedPath)) {
                var dtsFile = normalizedPath + ".d.ts";
                var tsFile = normalizedPath + ".ts";

                if (this.host.fileExists(tsFile)) {
                    normalizedPath = tsFile;
                }
                else {
                    normalizedPath = dtsFile;
                }
            }

            if (!this.host.fileExists(normalizedPath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(
                        new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.lineMap,
                            referenceLocation.position, referenceLocation.length, DiagnosticCode.Cannot_resolve_referenced_file_0, [path]));
                }

                return normalizedPath;
            }

            // Preprocess the file and resolve its imports/references
            return this.resolveFile(normalizedPath, resolutionResult);
        }

        private resolveImportedFile(path: string, referenceLocation: ReferenceLocation, resolutionResult: ReferenceResolutionResult): string {
            var isRelativePath = TypeScript.isRelative(path);
            var isRootedPath = isRelativePath ? false : isRooted(path);

            if (isRelativePath || isRootedPath) {
                // Handle as a normal include file
                return this.resolveIncludedFile(path, referenceLocation, resolutionResult);
            }
            else {
                // Search for the file
                var parentDirectory = this.host.getParentDirectory(referenceLocation.filePath);
                var searchFilePath: string = null;
                var dtsFileName = path + ".d.ts";
                var tsFilePath = path + ".ts";

                var start = new Date().getTime();

                // SPEC: Nov 18
                // An external import declaration that specifies a relative external module name (section 11.2.1) resolves the name 
                // relative to the directory of the containing source file.
                // If a source file with the resulting path and file extension '.ts' exists, that file is added as a dependency.
                // Otherwise, if a source file with the resulting path and file extension '.d.ts' exists, that file is added as a dependency.
                do {
                    // Search for ".ts" file first
                    currentFilePath = this.host.resolveRelativePath(tsFilePath, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        // Found the file
                        searchFilePath = currentFilePath;
                        break;
                    }

                    // Search for ".d.ts" file
                    var currentFilePath = this.host.resolveRelativePath(dtsFileName, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        // Found the file
                        searchFilePath = currentFilePath;
                        break;
                    }

                    parentDirectory = this.host.getParentDirectory(parentDirectory);
                }
                while (parentDirectory);

                TypeScript.fileResolutionImportFileSearchTime += new Date().getTime() - start;

                if (!searchFilePath) {
                    // Cannot find file import, do not reprot an error, the typeChecker will report it later on
                    return path;
                }

                // Preprocess the file and resolve its imports/references
                return this.resolveFile(searchFilePath, resolutionResult);
            }
        }

        private resolveFile(normalizedPath: string, resolutionResult: ReferenceResolutionResult): string {
            // If we have processed this file before, skip it
            var visitedPath = this.isVisited(normalizedPath);
            if (!visitedPath) {
                // Record that we have seen it
                this.recordVisitedFile(normalizedPath);

                // Preprocess the file
                var start = new Date().getTime();
                var scriptSnapshot = this.host.getScriptSnapshot(normalizedPath);
                var totalTime = new Date().getTime() - start;
                TypeScript.fileResolutionIOTime += totalTime;

                var lineMap = LineMap1.fromScriptSnapshot(scriptSnapshot);
                var preprocessedFileInformation = TypeScript.preProcessFile(normalizedPath, scriptSnapshot);
                resolutionResult.diagnostics.push.apply(resolutionResult.diagnostics, preprocessedFileInformation.diagnostics);

                // If this file has a "no-default-lib = 'true'" tag
                if (preprocessedFileInformation.isLibFile) {
                    resolutionResult.seenNoDefaultLibTag = true;
                }

                // Resolve explicit references
                var normalizedReferencePaths: string[] = [];
                preprocessedFileInformation.referencedFiles.forEach(fileReference => {
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileReference.position, fileReference.length, /* isImported */ false);
                    var normalizedReferencePath = this.resolveIncludedFile(fileReference.path, currentReferenceLocation, resolutionResult);
                    normalizedReferencePaths.push(normalizedReferencePath);
                });

                // Resolve imports
                var normalizedImportPaths: string[] = [];
                for (var i = 0; i < preprocessedFileInformation.importedFiles.length; i++) {
                    var fileImport = preprocessedFileInformation.importedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, lineMap, fileImport.position, fileImport.length, /* isImported */ true);
                    var normalizedImportPath = this.resolveImportedFile(fileImport.path, currentReferenceLocation, resolutionResult);
                    normalizedImportPaths.push(normalizedImportPath);
                }

                // Add the file to the result list
                resolutionResult.resolvedFiles.push({
                    path: normalizedPath,
                    referencedFiles: normalizedReferencePaths,
                    importedFiles: normalizedImportPaths
                });
            }
            else {
                normalizedPath = visitedPath;
            }

            return normalizedPath;
        }

        private getNormalizedFilePath(path: string, parentFilePath: string): string {
            var parentFileDirectory = parentFilePath ? this.host.getParentDirectory(parentFilePath) : "";
            var normalizedPath = this.host.resolveRelativePath(path, parentFileDirectory);
            return normalizedPath;
        }

        private getUniqueFileId(filePath: string): string {
            return this.useCaseSensitiveFileResolution ? filePath : filePath.toLocaleUpperCase();
        }

        private recordVisitedFile(filePath: string): void {
            this.visited[this.getUniqueFileId(filePath)] = filePath;
        }

        private isVisited(filePath: string): string {
            return this.visited[this.getUniqueFileId(filePath)];
        }

        private isSameFile(filePath1: string, filePath2: string): boolean {
            if (!filePath1 || !filePath2) {
                return false;
            }

            if (this.useCaseSensitiveFileResolution) {
                return filePath1 === filePath2;
            }
            else {
                return filePath1.toLocaleUpperCase() === filePath2.toLocaleUpperCase();
            }
        }
    }
}
///<reference path='resources\references.ts' />
///<reference path='core\references.ts' />
///<reference path='text\references.ts' />
///<reference path='syntax\references.ts' />
///<reference path='diagnostics.ts' />
///<reference path='document.ts' />
///<reference path='flags.ts' />
///<reference path='hashTable.ts' />
///<reference path='ast.ts' />
///<reference path='astHelpers.ts' />
///<reference path='astWalker.ts' />
///<reference path='base64.ts' />
///<reference path='sourceMapping.ts' />
///<reference path='emitter.ts' />
///<reference path='types.ts' />
///<reference path='pathUtils.ts' />
///<reference path='referenceResolution.ts' />
///<reference path='precompile.ts' />
///<reference path='referenceResolver.ts' />
///<reference path='declarationEmitter.ts' />
///<reference path='bloomFilter.ts' />
///<reference path='identifierWalker.ts' />
///<reference path='settings.ts' />
///<reference path='typecheck\pullFlags.ts' />
///<reference path='typecheck\pullDecls.ts' />
///<reference path='typecheck\pullSymbols.ts' />
///<reference path='typecheck\pullTypeEnclosingTypeWalker.ts' />
///<reference path='typecheck\pullTypeResolutionContext.ts' />
///<reference path='typecheck\pullTypeResolution.ts' />
///<reference path='typecheck\pullSemanticInfo.ts' />
///<reference path='typecheck\pullDeclCollection.ts' />
///<reference path='typecheck\pullSymbolBinder.ts' />
///<reference path='typecheck\pullHelpers.ts' />
///<reference path='typecheck\pullInstantiationHelpers.ts' />

///<reference path='typecheck\pullTypeInstantiation.ts' />
///<reference path='typescript.ts' />
///<reference path='references.ts' />

module TypeScript {
    /// Compiler settings
    export class CompilationSettings {
        public propagateEnumConstants: boolean = false;
        public removeComments: boolean = false;
        public watch: boolean = false;
        public noResolve: boolean = false;
        public allowAutomaticSemicolonInsertion: boolean = true;
        public noImplicitAny: boolean = false;
        public noLib: boolean = false;
        public codeGenTarget: LanguageVersion = LanguageVersion.EcmaScript3;
        public moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Unspecified;
        public outFileOption: string = "";
        public outDirOption: string = "";
        public mapSourceFiles: boolean = false;
        public mapRoot: string = "";
        public sourceRoot: string = "";
        public generateDeclarationFiles: boolean = false;
        public useCaseSensitiveFileResolution: boolean = false;
        public gatherDiagnostics: boolean = false;
        public codepage: number = null
        public createFileLog: boolean = false;
    }

    export class ImmutableCompilationSettings {
        private static _defaultSettings: ImmutableCompilationSettings;

        private _propagateEnumConstants: boolean;
        private _removeComments: boolean;
        private _watch: boolean;
        private _noResolve: boolean;
        private _allowAutomaticSemicolonInsertion: boolean;
        private _noImplicitAny: boolean;
        private _noLib: boolean;
        private _codeGenTarget: LanguageVersion;
        private _moduleGenTarget: ModuleGenTarget;
        private _outFileOption: string;
        private _outDirOption: string;
        private _mapSourceFiles: boolean;
        private _mapRoot: string;
        private _sourceRoot: string;
        private _generateDeclarationFiles: boolean;
        private _useCaseSensitiveFileResolution: boolean;
        private _gatherDiagnostics: boolean;
        private _codepage: number;
        private _createFileLog: boolean;

        public propagateEnumConstants() { return this._propagateEnumConstants; }
        public removeComments() { return this._removeComments; }
        public watch() { return this._watch; }
        public noResolve() { return this._noResolve; }
        public allowAutomaticSemicolonInsertion() { return this._allowAutomaticSemicolonInsertion; }
        public noImplicitAny() { return this._noImplicitAny; }
        public noLib() { return this._noLib; }
        public codeGenTarget() { return this._codeGenTarget; }
        public moduleGenTarget() { return this._moduleGenTarget; }
        public outFileOption() { return this._outFileOption; }
        public outDirOption() { return this._outDirOption; }
        public mapSourceFiles() { return this._mapSourceFiles; }
        public mapRoot() { return this._mapRoot; }
        public sourceRoot() { return this._sourceRoot; }
        public generateDeclarationFiles() { return this._generateDeclarationFiles; }
        public useCaseSensitiveFileResolution() { return this._useCaseSensitiveFileResolution; }
        public gatherDiagnostics() { return this._gatherDiagnostics; }
        public codepage() { return this._codepage; }
        public createFileLog() { return this._createFileLog; }

        constructor(
            propagateEnumConstants: boolean,
            removeComments: boolean,
            watch: boolean,
            noResolve: boolean,
            allowAutomaticSemicolonInsertion: boolean,
            noImplicitAny: boolean,
            noLib: boolean,
            codeGenTarget: LanguageVersion,
            moduleGenTarget: ModuleGenTarget,
            outFileOption: string,
            outDirOption: string,
            mapSourceFiles: boolean,
            mapRoot: string,
            sourceRoot: string,
            generateDeclarationFiles: boolean,
            useCaseSensitiveFileResolution: boolean,
            gatherDiagnostics: boolean,
            codepage: number,
            createFileLog: boolean) {

            this._propagateEnumConstants = propagateEnumConstants;
            this._removeComments = removeComments;
            this._watch = watch;
            this._noResolve = noResolve;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
            this._noImplicitAny = noImplicitAny;
            this._noLib = noLib;
            this._codeGenTarget = codeGenTarget;
            this._moduleGenTarget = moduleGenTarget;
            this._outFileOption = outFileOption;
            this._outDirOption = outDirOption;
            this._mapSourceFiles = mapSourceFiles;
            this._mapRoot = mapRoot;
            this._sourceRoot = sourceRoot;
            this._generateDeclarationFiles = generateDeclarationFiles;
            this._useCaseSensitiveFileResolution = useCaseSensitiveFileResolution;
            this._gatherDiagnostics = gatherDiagnostics;
            this._codepage = codepage;
            this._createFileLog = createFileLog;
        }

        public static defaultSettings() {
            if (!ImmutableCompilationSettings._defaultSettings) {
                ImmutableCompilationSettings._defaultSettings = ImmutableCompilationSettings.fromCompilationSettings(new CompilationSettings());
            }

            return ImmutableCompilationSettings._defaultSettings;
        }

        public static fromCompilationSettings(settings: CompilationSettings): ImmutableCompilationSettings {
            return new ImmutableCompilationSettings(
                settings.propagateEnumConstants,
                settings.removeComments,
                settings.watch,
                settings.noResolve,
                settings.allowAutomaticSemicolonInsertion,
                settings.noImplicitAny,
                settings.noLib,
                settings.codeGenTarget,
                settings.moduleGenTarget,
                settings.outFileOption,
                settings.outDirOption,
                settings.mapSourceFiles,
                settings.mapRoot,
                settings.sourceRoot,
                settings.generateDeclarationFiles,
                settings.useCaseSensitiveFileResolution,
                settings.gatherDiagnostics,
                settings.codepage,
                settings.createFileLog);
        }

        public toCompilationSettings(): any {
            var result = new CompilationSettings();

            var thisAsIndexable: IIndexable<any> = <any>this;
            var resultAsIndexable: IIndexable<any> = <any>result
            for (var name in this) {
                if (this.hasOwnProperty(name) && StringUtilities.startsWith(name, "_")) {
                    resultAsIndexable[name.substr(1)] = thisAsIndexable[name];
                }
            }

            return result;
        }
    }

    export function settingsChangeAffectsSyntax(before: ImmutableCompilationSettings, after: ImmutableCompilationSettings): boolean {
        // If the automatic semicolon insertion option has changed, then we have to dump all
        // syntax trees in order to reparse them with the new option.
        //
        // If the language version changed, then that affects what types of things we parse. So
        // we have to dump all syntax trees.
        //
        // If propagateEnumConstants changes, then that affects the constant value data we've 
        // stored in the ISyntaxElement.
        return before.allowAutomaticSemicolonInsertion() !== after.allowAutomaticSemicolonInsertion() ||
            before.codeGenTarget() !== after.codeGenTarget() ||
            before.propagateEnumConstants() !== after.propagateEnumConstants();
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export class SourceMapPosition {
        public sourceLine: number;
        public sourceColumn: number;
        public emittedLine: number;
        public emittedColumn: number;
    }

    export class SourceMapping {
        public start = new SourceMapPosition();
        public end = new SourceMapPosition();
        public nameIndex: number = -1;
        public childMappings: SourceMapping[] = [];
    }

    export class SourceMapEntry {
        constructor(
            public emittedFile: string,
            public emittedLine: number,
            public emittedColumn: number,
            public sourceFile: string,
            public sourceLine: number,
            public sourceColumn: number,
            public sourceName: string) {

            Debug.assert(isFinite(emittedLine));
            Debug.assert(isFinite(emittedColumn));
            Debug.assert(isFinite(sourceColumn));
            Debug.assert(isFinite(sourceLine));
        }
    }

    export class SourceMapper {
        static MapFileExtension = ".map";

        private jsFileName: string;
        private sourceMapPath: string;
        private sourceMapDirectory: string;
        private sourceRoot: string;

        public names: string[] = [];

        private mappingLevel: ISpan[] = [];

        // Below two arrays represent the information about sourceFile at that index.
        private tsFilePaths: string[] = [];
        private allSourceMappings: SourceMapping[][] = [];

        public currentMappings: SourceMapping[][];
        public currentNameIndex: number[];

        private sourceMapEntries: SourceMapEntry[] = [];

        constructor(private jsFile: TextWriter,
                    private sourceMapOut: TextWriter,
                    document: Document,
                    jsFilePath: string,
                    emitOptions: EmitOptions,
                    resolvePath: (path: string) => string) {
            this.setSourceMapOptions(document, jsFilePath, emitOptions, resolvePath);
            this.setNewSourceFile(document, emitOptions);
        }

        public getOutputFile(): OutputFile {
            var result = this.sourceMapOut.getOutputFile();
            result.sourceMapEntries = this.sourceMapEntries;

            return result;
        }

        public increaseMappingLevel(ast: ISpan) {
            this.mappingLevel.push(ast);
        }

        public decreaseMappingLevel(ast: any) {
            Debug.assert(this.mappingLevel.length > 0, "Mapping level should never be less than 0. This suggests a missing start call.");
            var expectedAst = this.mappingLevel.pop();
            if (ast !== expectedAst) {
                var expectedAstInfo: any = (<any>expectedAst).kind ? SyntaxKind[(<any>expectedAst).kind] : [expectedAst.start(), expectedAst.end()];
                var astInfo: any = (<any>ast).kind ? SyntaxKind[(<any>ast).kind] : [ast.start(), ast.end()]
                Debug.fail(
                    "Provided ast is not the expected ISyntaxElement, Expected: " + expectedAstInfo + " Given: " + astInfo)

            }
        }

        public setNewSourceFile(document: Document, emitOptions: EmitOptions) {
            // Set new mappings
            var sourceMappings: SourceMapping[] = [];
            this.allSourceMappings.push(sourceMappings);
            this.currentMappings = [sourceMappings];
            this.currentNameIndex = [];

            // Set new source file path
            this.setNewSourceFilePath(document, emitOptions);
        }

        private setSourceMapOptions(document: Document, jsFilePath: string, emitOptions: EmitOptions, resolvePath: (path: string) => string) {
            // Decode mapRoot and sourceRoot

            // Js File Name = pretty name of js file
            var prettyJsFileName = TypeScript.getPrettyName(jsFilePath, false, true);
            var prettyMapFileName = prettyJsFileName + SourceMapper.MapFileExtension;
            this.jsFileName = prettyJsFileName;

            // Figure out sourceMapPath and sourceMapDirectory
            if (emitOptions.sourceMapRootDirectory()) {
                // Get the sourceMap Directory
                this.sourceMapDirectory = emitOptions.sourceMapRootDirectory();
                if (document.emitToOwnOutputFile()) {
                    // For modules or multiple emit files the mapRoot will have directory structure like the sources
                    // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                    this.sourceMapDirectory = this.sourceMapDirectory + switchToForwardSlashes(getRootFilePath((document.fileName)).replace(emitOptions.commonDirectoryPath(), ""));
                }

                if (isRelative(this.sourceMapDirectory)) {
                    // The relative paths are relative to the common directory
                    this.sourceMapDirectory = emitOptions.commonDirectoryPath() + this.sourceMapDirectory;
                    this.sourceMapDirectory = convertToDirectoryPath(switchToForwardSlashes(resolvePath(this.sourceMapDirectory)));
                    this.sourceMapPath = getRelativePathToFixedPath(getRootFilePath(jsFilePath), this.sourceMapDirectory + prettyMapFileName);
                }
                else {
                    this.sourceMapPath = this.sourceMapDirectory + prettyMapFileName;
                }
            }
            else {
                this.sourceMapPath = prettyMapFileName;
                this.sourceMapDirectory = getRootFilePath(jsFilePath);
            }
            this.sourceRoot = emitOptions.sourceRootDirectory();
        }

        private setNewSourceFilePath(document: Document, emitOptions: EmitOptions) {
            var tsFilePath = switchToForwardSlashes(document.fileName);
            if (emitOptions.sourceRootDirectory()) {
                // Use the relative path corresponding to the common directory path
                tsFilePath = getRelativePathToFixedPath(emitOptions.commonDirectoryPath(), tsFilePath);
            }
            else {
                // Source locations relative to map file location
                tsFilePath = getRelativePathToFixedPath(this.sourceMapDirectory, tsFilePath);
            }
            this.tsFilePaths.push(tsFilePath);
        }
        
        // Generate source mapping.
        // Creating files can cause exceptions, they will be caught higher up in TypeScriptCompiler.emit
        public emitSourceMapping(): void {
            Debug.assert(
                this.mappingLevel.length === 0,
                "Mapping level is not 0. This suggest a missing end call. Value: " +
                this.mappingLevel.map(item => ['Node of type', SyntaxKind[(<any>item).kind], 'at', item.start(), 'to', item.end()].join(' ')).join(', '));
            // Output map file name into the js file
            this.jsFile.WriteLine("//# sourceMappingURL=" + this.sourceMapPath);

            // Now output map file
            var mappingsString = "";

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var emitComma = false;

            var recordedPosition: SourceMapPosition = null;
            for (var sourceIndex = 0; sourceIndex < this.tsFilePaths.length; sourceIndex++) {
                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {

                    if (recordedPosition !== null &&
                        recordedPosition.emittedColumn === mappedPosition.emittedColumn &&
                        recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        // This position is already recorded
                        return;
                    }

                    // Record this position
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    }
                    else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    this.sourceMapEntries.push(new SourceMapEntry(
                        this.jsFileName,
                        mappedPosition.emittedLine + 1,
                        mappedPosition.emittedColumn + 1,
                        this.tsFilePaths[sourceIndex],
                        mappedPosition.sourceLine,
                        mappedPosition.sourceColumn + 1,
                        nameIndex >= 0 ? this.names[nameIndex] : undefined));

                    // 1. Relative Column
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    // 2. Relative sourceIndex 
                    mappingsString = mappingsString + Base64VLQFormat.encode(sourceIndex - prevSourceIndex);
                    prevSourceIndex = sourceIndex;

                    // 3. Relative sourceLine 0 based
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    // 4. Relative sourceColumn 0 based 
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    // 5. Relative namePosition 0 based
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + Base64VLQFormat.encode(nameIndex - prevNameIndex);
                        prevNameIndex = nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                };

                // Record starting spans
                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };

                recordSourceMappingSiblings(this.allSourceMappings[sourceIndex]);
            }

            // Write the actual map file
            this.sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: this.jsFileName,
                sourceRoot: this.sourceRoot,
                sources: this.tsFilePaths,
                names: this.names,
                mappings: mappingsString
            }));

            // Closing files could result in exceptions, report them if they occur
            this.sourceMapOut.Close();
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts'/>
///<reference path='io.ts'/>
///<reference path='optionsParser.ts'/>

module TypeScript {
    class SourceFile {
        constructor(public scriptSnapshot: IScriptSnapshot, public byteOrderMark: ByteOrderMark) {
        }
    }

    class DiagnosticsLogger implements ILogger {
        constructor(public ioHost: IIO) {
        }
        public information(): boolean { return false; }
        public debug(): boolean { return false; }
        public warning(): boolean { return false; }
        public error(): boolean { return false; }
        public fatal(): boolean { return false; }
        public log(s: string): void {
            this.ioHost.stdout.WriteLine(s);
        }
    }

    class FileLogger implements ILogger {

        private fileName: string;
        
        constructor(public ioHost: IIO) {
            var file = "tsc." + Date.now() + ".log";

            this.fileName = this.ioHost.resolvePath(file);
        }
        public information(): boolean { return false; }
        public debug(): boolean { return false; }
        public warning(): boolean { return false; }
        public error(): boolean { return false; }
        public fatal(): boolean { return false; }
        public log(s: string): void {
            this.ioHost.appendFile(this.fileName, s + '\r\n');
        }
    }

    export class BatchCompiler implements IReferenceResolverHost {
        public compilerVersion = "1.0.1.0";
        private inputFiles: string[] = [];
        private compilationSettings: ImmutableCompilationSettings;
        private resolvedFiles: IResolvedFile[] = [];
        private fileNameToSourceFile = new StringHashTable<SourceFile>();
        private hasErrors: boolean = false;
        private logger: ILogger = null;

        constructor(private ioHost: IIO) {
        }

        // Begin batch compilation
        public batchCompile() {
            CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } };

            // Parse command line options
            if (this.parseOptions()) {

                if (this.compilationSettings.createFileLog()) {
                    this.logger = new FileLogger(this.ioHost);
                } else if (this.compilationSettings.gatherDiagnostics()) {
                    this.logger = new DiagnosticsLogger(this.ioHost);
                } else {
                    this.logger = new NullLogger();
                }

                if (this.compilationSettings.watch()) {
                    // Watch will cause the program to stick around as long as the files exist
                    this.watchFiles();
                    return;
                }

                // Resolve the compilation environemnt
                this.resolve();

                this.compile();

                if (this.compilationSettings.createFileLog()) {
                    this.logger.log("Compilation settings:");
                    this.logger.log(" propagateEnumConstants " + this.compilationSettings.propagateEnumConstants());
                    this.logger.log(" removeComments " + this.compilationSettings.removeComments());
                    this.logger.log(" watch " + this.compilationSettings.watch());
                    this.logger.log(" noResolve " + this.compilationSettings.noResolve());
                    this.logger.log(" noImplicitAny " + this.compilationSettings.noImplicitAny());
                    this.logger.log(" nolib " + this.compilationSettings.noLib());
                    this.logger.log(" target " + this.compilationSettings.codeGenTarget());
                    this.logger.log(" module " + this.compilationSettings.moduleGenTarget());
                    this.logger.log(" out " + this.compilationSettings.outFileOption());
                    this.logger.log(" outDir " + this.compilationSettings.outDirOption());
                    this.logger.log(" sourcemap " + this.compilationSettings.mapSourceFiles());
                    this.logger.log(" mapRoot " + this.compilationSettings.mapRoot());
                    this.logger.log(" sourceroot " + this.compilationSettings.sourceRoot());
                    this.logger.log(" declaration " + this.compilationSettings.generateDeclarationFiles());
                    this.logger.log(" useCaseSensitiveFileResolution " + this.compilationSettings.useCaseSensitiveFileResolution());
                    this.logger.log(" diagnostics " + this.compilationSettings.gatherDiagnostics());
                    this.logger.log(" codepage " + this.compilationSettings.codepage());

                    this.logger.log("");

                    this.logger.log("Input files:");
                    this.inputFiles.forEach((file) => {
                        this.logger.log(" " + file);
                    });

                    this.logger.log("");

                    this.logger.log("Resolved Files:");
                    this.resolvedFiles.forEach((file) => {
                        file.importedFiles.forEach((file) => {
                            this.logger.log(" " + file);
                        });
                        file.referencedFiles.forEach((file) => {
                            this.logger.log(" " + file);
                        });
                    });
                }

                if (this.compilationSettings.gatherDiagnostics()) {
                    this.logger.log("");
                    this.logger.log("File resolution time:                     " + TypeScript.fileResolutionTime);
                    this.logger.log("           file read:                     " + TypeScript.fileResolutionIOTime);
                    this.logger.log("        scan imports:                     " + TypeScript.fileResolutionScanImportsTime);
                    this.logger.log("       import search:                     " + TypeScript.fileResolutionImportFileSearchTime);
                    this.logger.log("        get lib.d.ts:                     " + TypeScript.fileResolutionGetDefaultLibraryTime);

                    this.logger.log("SyntaxTree parse time:                    " + TypeScript.syntaxTreeParseTime);
                    this.logger.log("Syntax Diagnostics time:                  " + TypeScript.syntaxDiagnosticsTime);
                    this.logger.log("AST translation time:                     " + TypeScript.astTranslationTime);
                    this.logger.log("");
                    this.logger.log("Type check time:                          " + TypeScript.typeCheckTime);
                    this.logger.log("");
                    this.logger.log("Emit time:                                " + TypeScript.emitTime);
                    this.logger.log("Declaration emit time:                    " + TypeScript.declarationEmitTime);

                    this.logger.log("Total number of symbols created:          " + TypeScript.pullSymbolID);
                    this.logger.log("Specialized types created:                " + TypeScript.nSpecializationsCreated);
                    this.logger.log("Specialized signatures created:           " + TypeScript.nSpecializedSignaturesCreated);

                    this.logger.log("  IsExternallyVisibleTime:                " + TypeScript.declarationEmitIsExternallyVisibleTime);
                    this.logger.log("  TypeSignatureTime:                      " + TypeScript.declarationEmitTypeSignatureTime);
                    this.logger.log("  GetBoundDeclTypeTime:                   " + TypeScript.declarationEmitGetBoundDeclTypeTime);
                    this.logger.log("  IsOverloadedCallSignatureTime:          " + TypeScript.declarationEmitIsOverloadedCallSignatureTime);
                    this.logger.log("  FunctionDeclarationGetSymbolTime:       " + TypeScript.declarationEmitFunctionDeclarationGetSymbolTime);
                    this.logger.log("  GetBaseTypeTime:                        " + TypeScript.declarationEmitGetBaseTypeTime);
                    this.logger.log("  GetAccessorFunctionTime:                " + TypeScript.declarationEmitGetAccessorFunctionTime);
                    this.logger.log("  GetTypeParameterSymbolTime:             " + TypeScript.declarationEmitGetTypeParameterSymbolTime);
                    this.logger.log("  GetImportDeclarationSymbolTime:         " + TypeScript.declarationEmitGetImportDeclarationSymbolTime);

                    this.logger.log("Emit write file time:                     " + TypeScript.emitWriteFileTime);

                    this.logger.log("Compiler resolve path time:               " + TypeScript.compilerResolvePathTime);
                    this.logger.log("Compiler directory name time:             " + TypeScript.compilerDirectoryNameTime);
                    this.logger.log("Compiler directory exists time:           " + TypeScript.compilerDirectoryExistsTime);
                    this.logger.log("Compiler file exists time:                " + TypeScript.compilerFileExistsTime);

                    this.logger.log("IO host resolve path time:                " + TypeScript.ioHostResolvePathTime);
                    this.logger.log("IO host directory name time:              " + TypeScript.ioHostDirectoryNameTime);
                    this.logger.log("IO host create directory structure time:  " + TypeScript.ioHostCreateDirectoryStructureTime);
                    this.logger.log("IO host write file time:                  " + TypeScript.ioHostWriteFileTime);

                    this.logger.log("Node make directory time:                 " + TypeScript.nodeMakeDirectoryTime);
                    this.logger.log("Node writeFileSync time:                  " + TypeScript.nodeWriteFileSyncTime);
                    this.logger.log("Node createBuffer time:                   " + TypeScript.nodeCreateBufferTime);
                }
            }

            // Exit with the appropriate error code
            this.ioHost.quit(this.hasErrors ? 1 : 0);
        }

        private resolve() {
            // Resolve file dependencies, if requested
            var includeDefaultLibrary = !this.compilationSettings.noLib();
            var resolvedFiles: IResolvedFile[] = [];

            var start = new Date().getTime();

            if (!this.compilationSettings.noResolve()) {
                // Resolve references
                var resolutionResults = ReferenceResolver.resolve(this.inputFiles, this, this.compilationSettings.useCaseSensitiveFileResolution());
                resolvedFiles = resolutionResults.resolvedFiles;

                // Only include the library if useDefaultLib is set to true and did not see any 'no-default-lib' comments
                includeDefaultLibrary = !this.compilationSettings.noLib() && !resolutionResults.seenNoDefaultLibTag;

                // Populate any diagnostic messages generated during resolution
                resolutionResults.diagnostics.forEach(d => this.addDiagnostic(d));
            }
            else {
                for (var i = 0, n = this.inputFiles.length; i < n; i++) {
                    var inputFile = this.inputFiles[i];
                    var referencedFiles: string[] = [];
                    var importedFiles: string[] = [];

                    // If declaration files are going to be emitted, preprocess the file contents and add in referenced files as well
                    if (this.compilationSettings.generateDeclarationFiles()) {
                        var references = getReferencedFiles(inputFile, this.getScriptSnapshot(inputFile));
                        for (var j = 0; j < references.length; j++) {
                            referencedFiles.push(references[j].path);
                        }

                        inputFile = this.resolvePath(inputFile);
                    }

                    resolvedFiles.push({
                        path: inputFile,
                        referencedFiles: referencedFiles,
                        importedFiles: importedFiles
                    });
                }
            }

            var defaultLibStart = new Date().getTime();
            if (includeDefaultLibrary) {
                var libraryResolvedFile: IResolvedFile = {
                    path: this.getDefaultLibraryFilePath(),
                    referencedFiles: [],
                    importedFiles: []
                };

                // Prepend the library to the resolved list
                resolvedFiles = [libraryResolvedFile].concat(resolvedFiles);
            }
            TypeScript.fileResolutionGetDefaultLibraryTime += new Date().getTime() - defaultLibStart;

            this.resolvedFiles = resolvedFiles;

            TypeScript.fileResolutionTime = new Date().getTime() - start;
        }

        // Returns true if compilation failed from some reason.
        private compile(): void {
            var compiler = new TypeScriptCompiler(this.logger, this.compilationSettings);

            this.resolvedFiles.forEach(resolvedFile => {
                var sourceFile = this.getSourceFile(resolvedFile.path);
                compiler.addFile(resolvedFile.path, sourceFile.scriptSnapshot, sourceFile.byteOrderMark, /*version:*/ 0, /*isOpen:*/ false, resolvedFile.referencedFiles);
            });

            for (var it = compiler.compile((path: string) => this.resolvePath(path)); it.moveNext();) {
                var result = it.current();

                result.diagnostics.forEach(d => this.addDiagnostic(d));
                if (!this.tryWriteOutputFiles(result.outputFiles)) {
                    return;
                }
            }
        }

        // Parse command line options
        private parseOptions() {
            var opts = new OptionsParser(this.ioHost, this.compilerVersion);

            var mutableSettings = new CompilationSettings();
            opts.option('out', {
                usage: {
                    locCode: DiagnosticCode.Concatenate_and_emit_output_to_single_file,
                    args: null
                },
                type: DiagnosticCode.file2,
                set: (str) => {
                    mutableSettings.outFileOption = str;
                }
            });

            opts.option('outDir', {
                usage: {
                    locCode: DiagnosticCode.Redirect_output_structure_to_the_directory,
                    args: null
                },
                type: DiagnosticCode.DIRECTORY,
                set: (str) => {
                    mutableSettings.outDirOption = str;
                }
            });

            opts.flag('sourcemap', {
                usage: {
                    locCode: DiagnosticCode.Generates_corresponding_0_file,
                    args: ['.map']
                },
                set: () => {
                    mutableSettings.mapSourceFiles = true;
                }
            });

            opts.option('mapRoot', {
                usage: {
                    locCode: DiagnosticCode.Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,
                    args: null
                },
                type: DiagnosticCode.LOCATION,
                set: (str) => {
                    mutableSettings.mapRoot = str;
                }
            });

            opts.option('sourceRoot', {
                usage: {
                    locCode: DiagnosticCode.Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,
                    args: null
                },
                type: DiagnosticCode.LOCATION,
                set: (str) => {
                    mutableSettings.sourceRoot = str;
                }
            });

            opts.flag('declaration', {
                usage: {
                    locCode: DiagnosticCode.Generates_corresponding_0_file,
                    args: ['.d.ts']
                },
                set: () => {
                    mutableSettings.generateDeclarationFiles = true;
                }
            }, 'd');

            if (this.ioHost.watchFile) {
                opts.flag('watch', {
                    usage: {
                        locCode: DiagnosticCode.Watch_input_files,
                        args: null
                    },
                    set: () => {
                        mutableSettings.watch = true;
                    }
                }, 'w');
            }

            opts.flag('propagateEnumConstants', {
                experimental: true,
                set: () => { mutableSettings.propagateEnumConstants = true; }
            });

            opts.flag('removeComments', {
                usage: {
                    locCode: DiagnosticCode.Do_not_emit_comments_to_output,
                    args: null
                },
                set: () => {
                    mutableSettings.removeComments = true;
                }
            });

            opts.flag('noResolve', {
                experimental: true,
                usage: {
                    locCode: DiagnosticCode.Skip_resolution_and_preprocessing,
                    args: null
                },
                set: () => {
                    mutableSettings.noResolve = true;
                }
            });

            opts.flag('noLib', {
                experimental: true,
                set: () => {
                    mutableSettings.noLib = true;
                }
            });

            opts.flag('diagnostics', {
                experimental: true,
                set: () => {
                    mutableSettings.gatherDiagnostics = true;
                }
            });

            opts.flag('logFile', {
                experimental: true,
                set: () => {
                    mutableSettings.createFileLog = true;
                }
            });

            opts.option('target', {
                usage: {
                    locCode: DiagnosticCode.Specify_ECMAScript_target_version_0_default_or_1,
                    args: ['ES3', 'ES5']
                },
                type: DiagnosticCode.VERSION,
                set: (type) => {
                    type = type.toLowerCase();

                    if (type === 'es3') {
                        mutableSettings.codeGenTarget = LanguageVersion.EcmaScript3;
                    }
                    else if (type === 'es5') {
                        mutableSettings.codeGenTarget = LanguageVersion.EcmaScript5;
                    }
                    else {
                        this.addDiagnostic(
                            new Diagnostic(null, null, 0, 0, DiagnosticCode.ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2, [type, "ES3", "ES5"]));
                    }
                }
            }, 't');

            opts.option('module', {
                usage: {
                    locCode: DiagnosticCode.Specify_module_code_generation_0_or_1,
                    args: ['commonjs', 'amd']
                },
                type: DiagnosticCode.KIND,
                set: (type) => {
                    type = type.toLowerCase();

                    if (type === 'commonjs') {
                        mutableSettings.moduleGenTarget = ModuleGenTarget.Synchronous;
                    }
                    else if (type === 'amd') {
                        mutableSettings.moduleGenTarget = ModuleGenTarget.Asynchronous;
                    }
                    else {
                        this.addDiagnostic(
                            new Diagnostic(null, null, 0, 0, DiagnosticCode.Module_code_generation_0_not_supported, [type]));
                    }
                }
            }, 'm');

            var needsHelp = false;
            opts.flag('help', {
                usage: {
                    locCode: DiagnosticCode.Print_this_message,
                    args: null
                },
                set: () => {
                    needsHelp = true;
                }
            }, 'h');

            opts.flag('useCaseSensitiveFileResolution', {
                experimental: true,
                set: () => {
                    mutableSettings.useCaseSensitiveFileResolution = true;
                }
            });
            var shouldPrintVersionOnly = false;
            opts.flag('version', {
                usage: {
                    locCode: DiagnosticCode.Print_the_compiler_s_version_0,
                    args: [this.compilerVersion]
                },
                set: () => {
                    shouldPrintVersionOnly = true;
                }
            }, 'v');

            var locale: string = null;
            opts.option('locale', {
                experimental: true,
                usage: {
                    locCode: DiagnosticCode.Specify_locale_for_errors_and_messages_For_example_0_or_1,
                    args: ['en', 'ja-jp']
                },
                type: DiagnosticCode.STRING,
                set: (value) => {
                    locale = value;
                }
            });

            opts.flag('noImplicitAny', {
                usage: {
                    locCode: DiagnosticCode.Warn_on_expressions_and_declarations_with_an_implied_any_type,
                    args: null
                },
                set: () => {
                    mutableSettings.noImplicitAny = true;
                }
            });

            if (Environment.supportsCodePage()) {
                opts.option('codepage', {
                    usage: {
                        locCode: DiagnosticCode.Specify_the_codepage_to_use_when_opening_source_files,
                        args: null
                    },
                    type: DiagnosticCode.NUMBER,
                    set: (arg) => {
                        mutableSettings.codepage = parseInt(arg, 10);
                    }
                });
            }

            opts.parse(this.ioHost.arguments);

            this.compilationSettings = ImmutableCompilationSettings.fromCompilationSettings(mutableSettings);

            if (locale) {
                if (!this.setLocale(locale)) {
                    return false;
                }
            }

            this.inputFiles.push.apply(this.inputFiles, opts.unnamed);

            if (shouldPrintVersionOnly) {
                opts.printVersion();
                return false;
            }
            // If no source files provided to compiler - print usage information
            else if (this.inputFiles.length === 0 || needsHelp) {
                opts.printUsage();
                return false;
            }

            return !this.hasErrors;
        }

        private setLocale(locale: string): boolean {
            var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(locale.toLowerCase());
            if (!matchResult) {
                this.addDiagnostic(new Diagnostic(null, null, 0, 0, DiagnosticCode.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, ['en', 'ja-jp']));
                return false;
            }

            var language = matchResult[1];
            var territory = matchResult[3];

            // First try the entire locale, then fall back to just language if that's all we have.
            if (!this.setLanguageAndTerritory(language, territory) &&
                !this.setLanguageAndTerritory(language, null)) {

                this.addDiagnostic(new Diagnostic(null, null, 0, 0, DiagnosticCode.Unsupported_locale_0, [locale]));
                return false;
            }

            return true;
        }

        private setLanguageAndTerritory(language: string, territory: string): boolean {

            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var containingDirectoryPath = this.ioHost.dirName(compilerFilePath);

            var filePath = IOUtils.combine(containingDirectoryPath, language);
            if (territory) {
                filePath = filePath + "-" + territory;
            }

            filePath = this.resolvePath(IOUtils.combine(filePath, "diagnosticMessages.generated.json"));

            if (!this.fileExists(filePath)) {
                return false;
            }

            var fileContents = this.ioHost.readFile(filePath, this.compilationSettings.codepage());
            TypeScript.LocalizedDiagnosticMessages = JSON.parse(fileContents.contents);
            return true;
        }

        // Handle -watch switch
        private watchFiles() {
            if (!this.ioHost.watchFile) {
                this.addDiagnostic(
                    new Diagnostic(null, null, 0, 0, DiagnosticCode.Current_host_does_not_support_0_option, ['-w[atch]']));
                return;
            }

            var lastResolvedFileSet: string[] = []
            var watchers: { [x: string]: IFileWatcher; } = {};
            var firstTime = true;

            var addWatcher = (fileName: string) => {
                if (!watchers[fileName]) {
                    var watcher = this.ioHost.watchFile(fileName, onWatchedFileChange);
                    watchers[fileName] = watcher;
                }
                else {
                    CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
                }
            };

            var removeWatcher = (fileName: string) => {
                if (watchers[fileName]) {
                    watchers[fileName].close();
                    delete watchers[fileName];
                }
                else {
                    CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
                }
            };

            var onWatchedFileChange = () => {
                // Clean errors for previous compilation
                this.hasErrors = false;

                // Clear out any source file data we've cached.
                this.fileNameToSourceFile = new StringHashTable<SourceFile>();

                // Resolve file dependencies, if requested
                this.resolve();

                // Check if any new files were added to the environment as a result of the file change
                var oldFiles = lastResolvedFileSet;
                var newFiles = this.resolvedFiles.map(resolvedFile => resolvedFile.path).sort();

                var i = 0, j = 0;
                while (i < oldFiles.length && j < newFiles.length) {

                    var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                    if (compareResult === 0) {
                        // No change here
                        i++;
                        j++;
                    }
                    else if (compareResult < 0) {
                        // Entry in old list does not exist in the new one, it was removed
                        removeWatcher(oldFiles[i]);
                        i++;
                    }
                    else {
                        // Entry in new list does exist in the new one, it was added
                        addWatcher(newFiles[j]);
                        j++;
                    }
                }

                // All remaining unmatched items in the old list have been removed
                for (var k = i; k < oldFiles.length; k++) {
                    removeWatcher(oldFiles[k]);
                }

                // All remaing unmatched items in the new list have been added
                for (k = j; k < newFiles.length; k++) {
                    addWatcher(newFiles[k]);
                }

                // Update the state
                lastResolvedFileSet = newFiles;

                // Print header
                if (!firstTime) {
                    var fileNames = "";
                    for (var k = 0; k < lastResolvedFileSet.length; k++) {
                        fileNames += Environment.newLine + "    " + lastResolvedFileSet[k];
                    }
                    this.ioHost.printLine(getLocalizedText(DiagnosticCode.NL_Recompiling_0, [fileNames]));
                }
                else {
                    firstTime = false;
                }

                // Trigger a new compilation
                this.compile();
            };

            // Switch to using stdout for all error messages
            this.ioHost.stderr = this.ioHost.stdout;

            onWatchedFileChange();
        }

        private getSourceFile(fileName: string): SourceFile {
            var sourceFile: SourceFile = this.fileNameToSourceFile.lookup(fileName);
            if (!sourceFile) {
                // Attempt to read the file
                var fileInformation: FileInformation;

                try {
                    fileInformation = this.ioHost.readFile(fileName, this.compilationSettings.codepage());
                }
                catch (e) {
                    this.addDiagnostic(new Diagnostic(null, null, 0, 0, DiagnosticCode.Cannot_read_file_0_1, [fileName, e.message]));
                    fileInformation = new FileInformation("", ByteOrderMark.None);
                }

                var snapshot = ScriptSnapshot.fromString(fileInformation.contents);
                var sourceFile = new SourceFile(snapshot, fileInformation.byteOrderMark);
                this.fileNameToSourceFile.add(fileName, sourceFile);
            }

            return sourceFile;
        }

        private getDefaultLibraryFilePath(): string {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var containingDirectoryPath = this.ioHost.dirName(compilerFilePath);
            var libraryFilePath = this.resolvePath(IOUtils.combine(containingDirectoryPath, "lib.d.ts"));

            return libraryFilePath;
        }

        /// IReferenceResolverHost methods
        getScriptSnapshot(fileName: string): IScriptSnapshot {
            return this.getSourceFile(fileName).scriptSnapshot;
        }

        resolveRelativePath(path: string, directory: string): string {
            var unQuotedPath = stripStartAndEndQuotes(path);
            var normalizedPath: string;

            if (isRooted(unQuotedPath) || !directory) {
                normalizedPath = unQuotedPath;
            } else {
                normalizedPath = IOUtils.combine(directory, unQuotedPath);
            }

            // get the absolute path
            normalizedPath = this.resolvePath(normalizedPath);

            // Switch to forward slashes
            normalizedPath = switchToForwardSlashes(normalizedPath);

            return normalizedPath;
        }

        private fileExistsCache = createIntrinsicsObject<boolean>();

        fileExists(path: string): boolean {
            var exists = this.fileExistsCache[path];
            if (exists === undefined) {
                var start = new Date().getTime();
                exists = this.ioHost.fileExists(path);
                this.fileExistsCache[path] = exists;
                TypeScript.compilerFileExistsTime += new Date().getTime() - start;
            }

            return exists;
        }

        getParentDirectory(path: string): string {
            var start = new Date().getTime();
            var result = this.ioHost.dirName(path);
            TypeScript.compilerDirectoryNameTime += new Date().getTime() - start;

            return result;
        }


        private addDiagnostic(diagnostic: Diagnostic): void {
            var diagnosticInfo = diagnostic.info();
            if (diagnosticInfo.category === DiagnosticCategory.Error) {
                this.hasErrors = true;
            }

            this.ioHost.stderr.Write(TypeScriptCompiler.getFullDiagnosticText(diagnostic, path => this.resolvePath(path)));
        }

        private tryWriteOutputFiles(outputFiles: OutputFile[]): boolean {
            for (var i = 0, n = outputFiles.length; i < n; i++) {
                var outputFile = outputFiles[i];

                try {
                    this.writeFile(outputFile.name, outputFile.text, outputFile.writeByteOrderMark);
                }
                catch (e) {
                    this.addDiagnostic(
                        new Diagnostic(outputFile.name, null, 0, 0, DiagnosticCode.Emit_Error_0, [e.message]));
                    return false;
                }
            }

            return true;
        }

        writeFile(fileName: string, contents: string, writeByteOrderMark: boolean): void {
            var start = new Date().getTime();
            IOUtils.writeFileAndFolderStructure(this.ioHost, fileName, contents, writeByteOrderMark);
            TypeScript.emitWriteFileTime += new Date().getTime() - start;
        }

        directoryExists(path: string): boolean {
            var start = new Date().getTime();
            var result = this.ioHost.directoryExists(path);
            TypeScript.compilerDirectoryExistsTime += new Date().getTime() - start;
            return result;
        }

        // For performance reasons we cache the results of resolvePath.  This avoids costly lookup
        // on the disk once we've already resolved a path once.
        private resolvePathCache = createIntrinsicsObject<string>();

        resolvePath(path: string): string {
            var cachedValue = this.resolvePathCache[path];
            if (!cachedValue) {
                var start = new Date().getTime();
                cachedValue = this.ioHost.resolvePath(path);
                this.resolvePathCache[path] = cachedValue;
                TypeScript.compilerResolvePathTime += new Date().getTime() - start;
            }

            return cachedValue;
        }
    }

    // Start the batch compilation using the current hosts IO
    var batch = new TypeScript.BatchCompiler(IO);
    batch.batchCompile();
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

module TypeScript {
    export class MemberName {
        public prefix: string = "";
        public suffix: string = "";

        public isString() { return false; }
        public isArray() { return false; }
        public isMarker() { return !this.isString() && !this.isArray(); }

        public toString(): string {
            return MemberName.memberNameToString(this);
        }

        static memberNameToString(memberName: MemberName, markerInfo?: number[], markerBaseLength: number = 0): string {
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += (<MemberNameString>memberName).text;
            }
            else if (memberName.isArray()) {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }

                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        }

        static create(text: string): MemberName;
        static create(entry: MemberName, prefix: string, suffix: string): MemberName;
        static create(arg1: any, arg2?: any, arg3?: any): MemberName {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            }
            else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        }
    }

    export class MemberNameString extends MemberName {
        constructor(public text: string) {
            super();
        }

        public isString() { return true; }
    }

    export class MemberNameArray extends MemberName {
        public delim: string = "";
        public entries: MemberName[] = [];

        public isArray() { return true; }

        public add(entry: MemberName) {
            this.entries.push(entry);
        }

        public addAll(entries: MemberName[]) {
            for (var i = 0 ; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        }

        constructor() {
            super();
        }
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='references.ts' />

if (Error) (<any>Error).stackTraceLimit = 1000;

module TypeScript {

    declare var IO: any;

    export var fileResolutionTime = 0;
    export var fileResolutionIOTime = 0;
    export var fileResolutionScanImportsTime = 0;
    export var fileResolutionImportFileSearchTime = 0;
    export var fileResolutionGetDefaultLibraryTime = 0;
    export var sourceCharactersCompiled = 0;
    export var syntaxTreeParseTime = 0;
    export var syntaxDiagnosticsTime = 0;
    export var astTranslationTime = 0;
    export var typeCheckTime = 0;

    export var compilerResolvePathTime = 0;
    export var compilerDirectoryNameTime = 0;
    export var compilerDirectoryExistsTime = 0;
    export var compilerFileExistsTime = 0;

    export var emitTime = 0;
    export var emitWriteFileTime = 0;

    export var declarationEmitTime = 0;
    export var declarationEmitIsExternallyVisibleTime = 0;
    export var declarationEmitTypeSignatureTime = 0;
    export var declarationEmitGetBoundDeclTypeTime = 0;
    export var declarationEmitIsOverloadedCallSignatureTime = 0;
    export var declarationEmitFunctionDeclarationGetSymbolTime = 0;
    export var declarationEmitGetBaseTypeTime = 0;
    export var declarationEmitGetAccessorFunctionTime = 0;
    export var declarationEmitGetTypeParameterSymbolTime = 0;
    export var declarationEmitGetImportDeclarationSymbolTime = 0;

    export var ioHostResolvePathTime = 0;
    export var ioHostDirectoryNameTime = 0;
    export var ioHostCreateDirectoryStructureTime = 0;
    export var ioHostWriteFileTime = 0;

    export interface PullSymbolInfo {
        symbol: PullSymbol;
        aliasSymbol: PullTypeAliasSymbol;
        ast: ISyntaxElement;
        enclosingScopeSymbol: PullSymbol;
    }

    export interface PullCallSymbolInfo {
        targetSymbol: PullSymbol;
        resolvedSignatures: TypeScript.PullSignatureSymbol[];
        candidateSignature: TypeScript.PullSignatureSymbol;
        isConstructorCall: boolean;
        ast: ISyntaxElement;
        enclosingScopeSymbol: PullSymbol;
    }

    export interface PullVisibleSymbolsInfo {
        symbols: PullSymbol[];
        enclosingScopeSymbol: PullSymbol;
    }

    export enum EmitOutputResult {
        Succeeded,
        FailedBecauseOfSyntaxErrors,
        FailedBecauseOfCompilerOptionsErrors,
        FailedToGenerateDeclarationsBecauseOfSemanticErrors
    }

    export class EmitOutput {
        public outputFiles: OutputFile[] = [];
        public emitOutputResult: EmitOutputResult;
        constructor(emitOutputResult = EmitOutputResult.Succeeded) {
            this.emitOutputResult = emitOutputResult;
        }
    }

    export enum OutputFileType {
        JavaScript,
        SourceMap,
        Declaration
    }

    export class OutputFile {
        constructor(public name: string,
            public writeByteOrderMark: boolean,
            public text: string,
            public fileType: OutputFileType,
            public sourceMapEntries: SourceMapEntry[] = []) {
        }
    }

    // Represents the results of the last "pull" on the compiler when using the streaming
    // 'compile' method.  The compile result for a single pull can have diagnostics (if 
    // something went wrong), and/or OutputFiles that need to get written.
    export class CompileResult {
        public diagnostics: Diagnostic[] = [];
        public outputFiles: OutputFile[] = [];

        public static fromDiagnostics(diagnostics: Diagnostic[]): CompileResult {
            var result = new CompileResult();
            result.diagnostics = diagnostics;
            return result;
        }

        public static fromOutputFiles(outputFiles: OutputFile[]): CompileResult {
            var result = new CompileResult();
            result.outputFiles = outputFiles;
            return result;
        }
    }
    
    export interface ICancellationToken {
        isCancellationRequested(): boolean;
    }

    export class OperationCanceledException { }

    export class CancellationToken {

        public static None: CancellationToken = new CancellationToken(null)

        constructor(private cancellationToken: ICancellationToken) {
        }

        public isCancellationRequested() {
            return this.cancellationToken && this.cancellationToken.isCancellationRequested();
        }

        public throwIfCancellationRequested(): void {
            if (this.isCancellationRequested()) {
                throw new OperationCanceledException();
            }
        }
    }    

    class DocumentRegistryEntry {
        public refCount: number = 0;
        public owners: string[] = [];
        constructor(public document: Document) {
        }
    }

    export interface IDocumentRegistry {
        acquireDocument(
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            byteOrderMark: ByteOrderMark,
            version: number,
            isOpen: boolean,
            referencedFiles: string[]): TypeScript.Document;

        updateDocument(
            document: Document,
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            version: number,
            isOpen: boolean,
            textChangeRange: TextChangeRange
            ): TypeScript.Document;

        releaseDocument(fileName: string, compilationSettings: ImmutableCompilationSettings): void
    }

    export class NonCachingDocumentRegistry implements IDocumentRegistry {

        public static Instance: IDocumentRegistry = new NonCachingDocumentRegistry();

        public acquireDocument(
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            byteOrderMark: ByteOrderMark,
            version: number,
            isOpen: boolean,
            referencedFiles: string[]= []): TypeScript.Document {
            return Document.create(compilationSettings, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);
        }

        public updateDocument(
            document: Document,
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            version: number,
            isOpen: boolean,
            textChangeRange: TextChangeRange
            ): TypeScript.Document {
            return document.update(scriptSnapshot, version, isOpen, textChangeRange);
        }

        public releaseDocument(fileName: string, compilationSettings: ImmutableCompilationSettings): void {
            // no op since this class doesn't cache anything
        }
    }

    export class DocumentRegistry implements IDocumentRegistry {
        private buckets: IIndexable<StringHashTable<DocumentRegistryEntry>> = {};

        private getKeyFromCompilationSettings(settings: ImmutableCompilationSettings): string {
            return "_" + settings.propagateEnumConstants().toString() + "|" + settings.allowAutomaticSemicolonInsertion().toString() + "|" + LanguageVersion[settings.codeGenTarget()];
        }

        private getBucketForCompilationSettings(settings: ImmutableCompilationSettings, createIfMissing: boolean): StringHashTable<DocumentRegistryEntry> {
            var key = this.getKeyFromCompilationSettings(settings);
            var bucket = this.buckets[key];
            if (!bucket && createIfMissing) {
                this.buckets[key] = bucket = new StringHashTable<DocumentRegistryEntry>();
            }
            return bucket;
        }

        public reportStats() {
            var bucketInfoArray = Object.keys(this.buckets).filter(name => name && name.charAt(0) === '_').map(name => {
                var entries = this.buckets[name];
                var documents = entries.getAllKeys().map((name) => {
                    var entry = entries.lookup(name);
                    return {
                        name: name,
                        refCount: entry.refCount,
                        references: entry.owners.slice(0)
                    };
                });
                documents.sort((x, y) => y.refCount - x.refCount);
                return { bucket: name, documents: documents }
            });
            return JSON.stringify(bucketInfoArray, null, 2);
        }

        public acquireDocument(
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            byteOrderMark: ByteOrderMark,
            version: number,
            isOpen: boolean,
            referencedFiles: string[]= []): TypeScript.Document {

            var bucket = this.getBucketForCompilationSettings(compilationSettings, /*createIfMissing*/ true);
            var entry = bucket.lookup(fileName);
            if (!entry) {
                var document = Document.create(compilationSettings, fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);

                entry = new DocumentRegistryEntry(document);
                bucket.add(fileName, entry);
            }
            entry.refCount++;

            return entry.document;
        }

        public updateDocument(
            document: Document,
            fileName: string,
            compilationSettings: ImmutableCompilationSettings,
            scriptSnapshot: IScriptSnapshot,
            version: number,
            isOpen: boolean,
            textChangeRange: TextChangeRange
            ): TypeScript.Document {

            var bucket = this.getBucketForCompilationSettings(compilationSettings, /*createIfMissing*/ false);
            Debug.assert(bucket);
            var entry = bucket.lookup(fileName);
            Debug.assert(entry);

            if (entry.document.isOpen === isOpen && entry.document.version === version) {
                return entry.document;
            }

            entry.document = entry.document.update(scriptSnapshot, version, isOpen, textChangeRange);
            return entry.document;
        }

        public releaseDocument(fileName: string, compilationSettings: ImmutableCompilationSettings): void {
            var bucket = this.getBucketForCompilationSettings(compilationSettings, false);
            Debug.assert(bucket);

            var entry = bucket.lookup(fileName);
            entry.refCount--;

            Debug.assert(entry.refCount >= 0);
            if (entry.refCount === 0) {
                bucket.remove(fileName);
            }
        }
    }

    interface IExpressionWithArgumentListSyntax extends IExpressionSyntax {
        expression: IExpressionSyntax;
        argumentList: ArgumentListSyntax;
    }

    export class TypeScriptCompiler {
        private semanticInfoChain: SemanticInfoChain = null;

        constructor(public logger: ILogger = new NullLogger(),
                    private _settings: ImmutableCompilationSettings = ImmutableCompilationSettings.defaultSettings()) {
            this.semanticInfoChain = new SemanticInfoChain(this, logger);
        }

        public getSemanticInfoChain() {
            return this.semanticInfoChain;
        }

        public compilationSettings(): ImmutableCompilationSettings {
            return this._settings;
        }

        public setCompilationSettings(newSettings: ImmutableCompilationSettings) {
            var oldSettings = this._settings;
            this._settings = newSettings;

            if (!compareDataObjects(oldSettings, newSettings)) {
                // If our options have changed at all, we have to consider any cached semantic 
                // data we have invalid.
                this.semanticInfoChain.invalidate(oldSettings, newSettings);
            }
        }

        public getDocument(fileName: string): Document {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.semanticInfoChain.getDocument(fileName);
        }

        public cleanupSemanticCache(): void {
            this.semanticInfoChain.invalidate();
        }

        public addOrUpdateFile(document: Document): void {
            // TODO: TypeScript.sourceCharactersCompiled += document. scriptSnapshot.getLength();
            // Note: the semantic info chain will recognize that this is a replacement of an
            // existing script, and will handle it appropriately.
            this.semanticInfoChain.addDocument(document);
        }

        public addFile(
            fileName: string,
            scriptSnapshot: IScriptSnapshot,
            byteOrderMark: ByteOrderMark,
            version: number,
            isOpen: boolean,
            referencedFiles: string[]= []): void {

            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = Document.create(this.compilationSettings(), fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles);
            this.addOrUpdateFile(document);
        }

        public updateFile(fileName: string, scriptSnapshot: IScriptSnapshot, version: number, isOpen: boolean, textChangeRange: TextChangeRange): void {
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var document = this.getDocument(fileName);
            var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange);

            // Note: the semantic info chain will recognize that this is a replacement of an
            // existing script, and will handle it appropriately.
            this.addOrUpdateFile(updatedDocument);
        }

        public removeFile(fileName: string): void {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            this.semanticInfoChain.removeDocument(fileName);
        }

        public mapOutputFileName(document: Document, emitOptions: EmitOptions, extensionChanger: (fname: string, wholeFileNameReplaced: boolean) => string) {
            if (document.emitToOwnOutputFile()) {
                var updatedFileName = document.fileName;
                if (emitOptions.outputDirectory() !== "") {
                    // Replace the common directory path with the option specified
                    updatedFileName = document.fileName.replace(emitOptions.commonDirectoryPath(), "");
                    updatedFileName = emitOptions.outputDirectory() + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            }
            else {
                return extensionChanger(emitOptions.sharedOutputFile(), true);
            }
        }

        private writeByteOrderMarkForDocument(document: Document) {
            // Set this to 'true' if you want to know why the compiler emitted a document with a 
            // byte order mark.
            var printReason = false;

            // If module its always emitted in its own file
            if (document.emitToOwnOutputFile()) {
                var result = document.byteOrderMark !== ByteOrderMark.None;
                if (printReason) {
                    Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                }
                return result;
            }
            else {
                var fileNames = this.fileNames();

                var result = false;
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = this.getDocument(fileNames[i]);

                    if (document.isExternalModule()) {
                        // Dynamic module never contributes to the single file
                        continue;
                    }

                    if (document.byteOrderMark !== ByteOrderMark.None) {
                        if (printReason) {
                            Environment.standardOut.WriteLine("Emitting byte order mark because of: " + document.fileName);
                            result = true;
                        }
                        else {
                            return true;
                        }
                    }
                }

                return result;
            }
        }

        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: boolean) {
            return getDeclareFilePath(fileName);
        }

        public _shouldEmit(document: Document) {
            // If its already a declare file or is resident or does not contain body 
            return !document.isDeclareFile();
        }

        public _shouldEmitDeclarations(document: Document) {
            if (!this.compilationSettings().generateDeclarationFiles()) {
                return false;
            }

            return this._shouldEmit(document);
        }

        // Does the actual work of emittin the declarations from the provided document into the
        // provided emitter.  If no emitter is provided a new one is created.  
        private emitDocumentDeclarationsWorker(
            document: Document,
            emitOptions: EmitOptions,
            declarationEmitter?: DeclarationEmitter): DeclarationEmitter {

            var sourceUnit = document.sourceUnit();
            Debug.assert(this._shouldEmitDeclarations(document));

            if (declarationEmitter) {
                declarationEmitter.document = document;
            }
            else {
                var declareFileName = this.mapOutputFileName(document, emitOptions, TypeScriptCompiler.mapToDTSFileName);
                declarationEmitter = new DeclarationEmitter(declareFileName, document, this, emitOptions, this.semanticInfoChain);
            }

            declarationEmitter.emitDeclarations(sourceUnit);
            return declarationEmitter;
        }

        public _emitDocumentDeclarations(
            document: Document,
            emitOptions: EmitOptions,
            onSingleFileEmitComplete: (files: OutputFile) => void,
            sharedEmitter: DeclarationEmitter): DeclarationEmitter {

            if (this._shouldEmitDeclarations(document)) {
                if (document.emitToOwnOutputFile()) {
                    var singleEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFile());
                    }
                }
                else {
                    // Create or reuse file
                    sharedEmitter = this.emitDocumentDeclarationsWorker(document, emitOptions, sharedEmitter);
                }
            }

            return sharedEmitter;
        }

        // Will not throw exceptions.
        public emitAllDeclarations(resolvePath: (path: string) => string): EmitOutput {
            var start = new Date().getTime();
            var emitOutput = new EmitOutput();

            var emitOptions = new EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = EmitOutputResult.FailedBecauseOfCompilerOptionsErrors;
                return emitOutput;
            }

            var sharedEmitter: DeclarationEmitter = null;
            var fileNames = this.fileNames();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileNames[i]);

                sharedEmitter = this._emitDocumentDeclarations(document, emitOptions,
                    file => emitOutput.outputFiles.push(file), sharedEmitter);
            }

            if (sharedEmitter) {
                emitOutput.outputFiles.push(sharedEmitter.getOutputFile());
            }

            declarationEmitTime += new Date().getTime() - start;

            return emitOutput;
        }

        // Will not throw exceptions.
        public emitDeclarations(fileName: string, resolvePath: (path: string) => string): EmitOutput {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();

            var emitOptions = new EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = EmitOutputResult.FailedBecauseOfCompilerOptionsErrors;
                return emitOutput;
            }

            var document = this.getDocument(fileName);

            // Emitting module or multiple files, always goes to single file
            if (document.emitToOwnOutputFile()) {
                this._emitDocumentDeclarations(document, emitOptions,
                    file => emitOutput.outputFiles.push(file), /*sharedEmitter:*/ null);
                return emitOutput;
            }
            else {
                return this.emitAllDeclarations(resolvePath);
            }
        }

        public canEmitDeclarations(fileName: string) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.getDocument(fileName);
            return this._shouldEmitDeclarations(document);
        }

        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: boolean) {
            if (wholeFileNameReplaced) {
                // The complete output is redirected in this file so do not change extension
                return fileName;
            }
            else {
                // Change the extension of the file
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        }

        static mapToJSFileName(fileName: string, wholeFileNameReplaced: boolean) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        }

        // Caller is responsible for closing the returned emitter.
        // May throw exceptions.
        private emitDocumentWorker(document: Document, emitOptions: EmitOptions, emitter?: Emitter): Emitter {
            var sourceUnit = document.sourceUnit();
            Debug.assert(this._shouldEmit(document));

            var typeScriptFileName = document.fileName;
            if (!emitter) {
                var javaScriptFileName = this.mapOutputFileName(document, emitOptions, TypeScriptCompiler.mapToJSFileName);
                var outFile = new TextWriter(javaScriptFileName, this.writeByteOrderMarkForDocument(document), OutputFileType.JavaScript);

                emitter = new Emitter(javaScriptFileName, outFile, emitOptions, this.semanticInfoChain);

                if (this.compilationSettings().mapSourceFiles()) {
                    // We always create map files next to the jsFiles
                    var sourceMapFile = new TextWriter(javaScriptFileName + SourceMapper.MapFileExtension, /*writeByteOrderMark:*/ false, OutputFileType.SourceMap); 
                    emitter.createSourceMapper(document, javaScriptFileName, outFile, sourceMapFile, emitOptions.resolvePath);
                }
            }
            else if (this.compilationSettings().mapSourceFiles()) {
                // Already emitting into js file, update the mapper for new source info
                emitter.setSourceMapperNewSourceFile(document);
            }

            // Set location info
            emitter.setDocument(document);
            emitter.emitJavascript(sourceUnit, /*startLine:*/false);

            return emitter;
        }

        // Private.  only for use by compiler or CompilerIterator
        public _emitDocument(
            document: Document,
            emitOptions: EmitOptions,
            onSingleFileEmitComplete: (files: OutputFile[]) => void,
            sharedEmitter: Emitter): Emitter {

            // Emitting module or multiple files, always goes to single file
                if (this._shouldEmit(document)) {
                if (document.emitToOwnOutputFile()) {
                    // We're outputting to mulitple files.  We don't want to reuse an emitter in that case.
                    var singleEmitter = this.emitDocumentWorker(document, emitOptions);
                    if (singleEmitter) {
                        onSingleFileEmitComplete(singleEmitter.getOutputFiles());
                    }
                }
                else {
                    // We're not outputting to multiple files.  Keep using the same emitter and don't
                    // close until below.
                    sharedEmitter = this.emitDocumentWorker(document, emitOptions, sharedEmitter);
                }
            }

            return sharedEmitter;
        }

        // Will not throw exceptions.
        public emitAll(resolvePath: (path: string) => string): EmitOutput {
            var start = new Date().getTime();
            var emitOutput = new EmitOutput();

            var emitOptions = new EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = EmitOutputResult.FailedBecauseOfCompilerOptionsErrors;
                return emitOutput;
            }

            var fileNames = this.fileNames();
            var sharedEmitter: Emitter = null;

            // Iterate through the files, as long as we don't get an error.
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileName);

                sharedEmitter = this._emitDocument(document, emitOptions,
                    files => emitOutput.outputFiles.push.apply(emitOutput.outputFiles, files),
                    sharedEmitter);
            }

            if (sharedEmitter) {
                emitOutput.outputFiles.push.apply(emitOutput.outputFiles, sharedEmitter.getOutputFiles());
            }

            emitTime += new Date().getTime() - start;
            return emitOutput;
        }

        // Emit single file if outputMany is specified, else emit all
        // Will not throw exceptions.
        public emit(fileName: string, resolvePath: (path: string) => string): EmitOutput {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var emitOutput = new EmitOutput();

            var emitOptions = new EmitOptions(this, resolvePath);
            if (emitOptions.diagnostic()) {
                emitOutput.emitOutputResult = EmitOutputResult.FailedBecauseOfCompilerOptionsErrors;
                return emitOutput;
            }

            var document = this.getDocument(fileName);
            // Emitting module or multiple files, always goes to single file
            if (document.emitToOwnOutputFile()) {
                this._emitDocument(document, emitOptions,
                    files => emitOutput.outputFiles.push.apply(emitOutput.outputFiles, files), /*sharedEmitter:*/ null);
                return emitOutput;
            }
            else {
                // In output Single file mode, emit everything
                return this.emitAll(resolvePath);
            }
        }

        // Returns an iterator that will stream compilation results from this compiler.  Syntactic
        // diagnostics will be returned first, then semantic diagnostics, then emit results, then
        // declaration emit results.
        //
        // The continueOnDiagnostics flag governs whether or not iteration follows the batch compiler
        // logic and doesn't perform further analysis once diagnostics are produced.  For example,
        // in batch compilation nothing is done if there are any syntactic diagnostics.  Clients
        // can override this if they still want to procede in those cases.
        public compile(resolvePath: (path: string) => string, continueOnDiagnostics = false): Iterator<CompileResult> {
            return new CompilerIterator(this, resolvePath, continueOnDiagnostics);
        }

        //
        // Pull typecheck infrastructure
        //

        public getSyntacticDiagnostics(fileName: string): Diagnostic[] {
            fileName = TypeScript.switchToForwardSlashes(fileName)
            return this.getDocument(fileName).diagnostics();
        }

        /** Used for diagnostics in tests */
        private getSyntaxTree(fileName: string): SyntaxTree {
            return this.getDocument(fileName).syntaxTree();
        }

        private getSourceUnit(fileName: string): SourceUnitSyntax {
            return this.getDocument(fileName).sourceUnit();
        }

        public getSemanticDiagnostics(fileName: string): Diagnostic[] {
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var document = this.getDocument(fileName);

            var startTime = (new Date()).getTime();
            PullTypeResolver.typeCheck(this.compilationSettings(), this.semanticInfoChain, document)
            var endTime = (new Date()).getTime();

            typeCheckTime += endTime - startTime;

            var errors = this.semanticInfoChain.getDiagnostics(fileName);

            errors = ArrayUtilities.distinct(errors, Diagnostic.equals);
            errors.sort((d1, d2) => {
                if (d1.fileName() < d2.fileName()) {
                    return -1;
                }
                else if (d1.fileName() > d2.fileName()) {
                    return 1;
                }

                if (d1.start() < d2.start()) {
                    return -1;
                }
                else if (d1.start() > d2.start()) {
                    return 1;
                }

                // For multiple errors reported on the same file at the same position.
                var code1 = diagnosticInformationMap[d1.diagnosticKey()].code;
                var code2 = diagnosticInformationMap[d2.diagnosticKey()].code;
                if (code1 < code2) {
                    return -1;
                }
                else if (code1 > code2) {
                    return 1;
                }

                return 0;
            });

            return errors;
        }

        public getCompilerOptionsDiagnostics(resolvePath: (path: string) => string): Diagnostic[] {
            var emitOptions = new EmitOptions(this, resolvePath);
            var emitDiagnostic = emitOptions.diagnostic();
            if (emitDiagnostic) {
                return [emitDiagnostic];
            }
            return sentinelEmptyArray;
        }

        public resolveAllFiles() {
            var fileNames = this.fileNames();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                this.getSemanticDiagnostics(fileNames[i]);
            }
        }

        public getSymbolOfDeclaration(decl: PullDecl): PullSymbol {
            if (!decl) {
                return null;
            }

            var resolver = this.semanticInfoChain.getResolver();
            var ast = this.semanticInfoChain.getASTForDecl(decl);
            if (!ast) {
                return null;
            }

            var enclosingDecl = resolver.getEnclosingDecl(decl);
            if (ast.kind() === SyntaxKind.GetAccessor || ast.kind() === SyntaxKind.SetAccessor) {
                return this.getSymbolOfDeclaration(enclosingDecl);
            }

            return resolver.resolveAST(ast, /*inContextuallyTypedAssignment:*/false, new PullTypeResolutionContext(resolver));
        }

        private extractResolutionContextFromAST(resolver: PullTypeResolver, ast: ISyntaxElement, document: Document, propagateContextualTypes: boolean): { ast: ISyntaxElement; enclosingDecl: PullDecl; resolutionContext: PullTypeResolutionContext; inContextuallyTypedAssignment: boolean; inWithBlock: boolean; } {
            var scriptName = document.fileName;

            var enclosingDecl: PullDecl = null;
            var enclosingDeclAST: ISyntaxElement = null;
            var inContextuallyTypedAssignment = false;
            var inWithBlock = false;

            var resolutionContext = new PullTypeResolutionContext(resolver);

            if (!ast) {
                return null;
            }

            var path = this.getASTPath(ast);

            // Extract infromation from path
            for (var i = 0 , n = path.length; i < n; i++) {
                var current = path[i];

                switch (current.kind()) {
                    case SyntaxKind.FunctionExpression:
                    case SyntaxKind.SimpleArrowFunctionExpression:
                    case SyntaxKind.ParenthesizedArrowFunctionExpression:
                        if (propagateContextualTypes) {
                            resolver.resolveAST(current, /*inContextuallyTypedAssignment*/ true, resolutionContext);
                        }
                        break;

                    //case SyntaxKind.Parameter:
                    //    var parameter = <ParameterSyntax> current;
                    //    inContextuallyTypedAssignment = parameter.typeExpr !== null;

                    //    this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, parameter, parameter.init);
                    //    break;

                    case SyntaxKind.MemberVariableDeclaration:
                        var memberVariable = <MemberVariableDeclarationSyntax> current;
                        inContextuallyTypedAssignment = memberVariable.variableDeclarator.typeAnnotation !== null;

                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, memberVariable, memberVariable.variableDeclarator.equalsValueClause);
                        break;

                    case SyntaxKind.VariableDeclarator:
                        var variableDeclarator = <VariableDeclaratorSyntax>current;
                        inContextuallyTypedAssignment = variableDeclarator.typeAnnotation !== null;

                        this.extractResolutionContextForVariable(inContextuallyTypedAssignment, propagateContextualTypes, resolver, resolutionContext, enclosingDecl, variableDeclarator, variableDeclarator.equalsValueClause);
                        break;

                    case SyntaxKind.InvocationExpression:
                    case SyntaxKind.ObjectCreationExpression:
                        if (propagateContextualTypes) {
                            var isNew = current.kind() === SyntaxKind.ObjectCreationExpression;
                            var callExpression = <IExpressionWithArgumentListSyntax>current;
                            var contextualType: PullTypeSymbol = null;

                            // Check if we are in an argumnt for a call, propagate the contextual typing
                            if ((i + 2 < n) && callExpression.argumentList === path[i + 1] && callExpression.argumentList.arguments === path[i + 2]) {
                                var callResolutionResults = new PullAdditionalCallResolutionData();
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(<ObjectCreationExpressionSyntax>callExpression, resolutionContext, callResolutionResults);
                                }
                                else {
                                    resolver.resolveInvocationExpression(<InvocationExpressionSyntax>callExpression, resolutionContext, callResolutionResults);
                                }

                                // Find the index in the arguments list
                                if (callResolutionResults.actualParametersContextTypeSymbols) {
                                    var argExpression = path[i + 3];
                                    if (argExpression) {
                                        for (var j = 0, m = callExpression.argumentList.arguments.length; j < m; j++) {
                                            if (callExpression.argumentList.arguments[j] === argExpression) {
                                                var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                                if (callContextualType) {
                                                    contextualType = callContextualType;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                // Just resolve the call expression
                                if (isNew) {
                                    resolver.resolveObjectCreationExpression(<ObjectCreationExpressionSyntax>callExpression, resolutionContext);
                                }
                                else {
                                    resolver.resolveInvocationExpression(<InvocationExpressionSyntax>callExpression, resolutionContext);
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case SyntaxKind.ArrayLiteralExpression:
                        if (propagateContextualTypes) {
                            // Propagate the child element type
                            var contextualType: PullTypeSymbol = null;
                            var currentContextualType = resolutionContext.getContextualType();
                            if (currentContextualType && currentContextualType.isArrayNamedTypeReference()) {
                                contextualType = currentContextualType.getElementType();
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case SyntaxKind.ObjectLiteralExpression:
                        if (propagateContextualTypes) {
                            var objectLiteralExpression = <ObjectLiteralExpressionSyntax>current;
                            var objectLiteralResolutionContext = new PullAdditionalObjectLiteralResolutionData();
                            resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, resolutionContext, objectLiteralResolutionContext);

                            // find the member in the path
                            var memeberAST = (path[i + 1] && path[i + 1].kind() === SyntaxKind.SeparatedList) ? path[i + 2] : path[i + 1];
                            if (memeberAST) {
                                // Propagate the member contextual type
                                var contextualType: PullTypeSymbol = null;
                                var memberDecls = objectLiteralExpression.propertyAssignments;
                                if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                    for (var j = 0, m = memberDecls.length; j < m; j++) {
                                        if (memberDecls[j] === memeberAST) {
                                            var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                            if (memberContextualType) {
                                                contextualType = memberContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }

                                resolutionContext.pushNewContextualType(contextualType);
                            }
                        }

                        break;

                    case SyntaxKind.AssignmentExpression:
                        if (propagateContextualTypes) {
                            var assignmentExpression = <BinaryExpressionSyntax>current;
                            var contextualType: PullTypeSymbol = null;

                            if (path[i + 1] && path[i + 1] === assignmentExpression.right) {
                                // propagate the left hand side type as a contextual type
                                var leftType = resolver.resolveAST(assignmentExpression.left, inContextuallyTypedAssignment, resolutionContext).type;
                                if (leftType) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = leftType;
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case SyntaxKind.CastExpression:
                        var castExpression = <CastExpressionSyntax>current;
                        if (!(i + 1 < n && path[i + 1] === castExpression.type)) {
                            // We are outside the cast term
                            if (propagateContextualTypes) {
                                var contextualType: PullTypeSymbol = null;
                                var typeSymbol = resolver.resolveAST(castExpression, inContextuallyTypedAssignment, resolutionContext).type;

                                // Set the context type
                                if (typeSymbol) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = typeSymbol;
                                }

                                resolutionContext.pushNewContextualType(contextualType);
                            }
                        }

                        break;

                    case SyntaxKind.ReturnStatement:
                        if (propagateContextualTypes) {
                            var returnStatement = <ReturnStatementSyntax>current;
                            var contextualType: PullTypeSymbol = null;

                            if (enclosingDecl && (enclosingDecl.kind & PullElementKind.SomeFunction)) {
                                var typeAnnotation = ASTHelpers.getType(enclosingDeclAST);
                                if (typeAnnotation) {
                                    // The containing function has a type annotation, propagate it as the contextual type
                                    var returnTypeSymbol = resolver.resolveTypeReference(typeAnnotation, resolutionContext);
                                    if (returnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = returnTypeSymbol;
                                    }
                                }
                                else {
                                    // No type annotation, check if there is a contextual type enforced on the function, and propagate that
                                    var currentContextualType = resolutionContext.getContextualType();
                                if (currentContextualType && currentContextualType.isFunction()) {
                                    var contextualSignatures = currentContextualType.kind == PullElementKind.ConstructorType
                                        ? currentContextualType.getConstructSignatures()
                                        : currentContextualType.getCallSignatures();
                                    var currentContextualTypeSignatureSymbol = contextualSignatures[0];
                                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                                        if (currentContextualTypeReturnTypeSymbol) {
                                            inContextuallyTypedAssignment = true;
                                            contextualType = currentContextualTypeReturnTypeSymbol;
                                        }
                                    }
                                }
                            }

                            resolutionContext.pushNewContextualType(contextualType);
                        }

                        break;

                    case SyntaxKind.ObjectType:
                        // ObjectType are just like Object Literals are bound when needed, ensure we have a decl, by forcing it to be 
                        // resolved before descending into it.
                        if (propagateContextualTypes && TypeScript.isTypesOnlyLocation(current)) {
                            resolver.resolveAST(current, /*inContextuallyTypedAssignment*/ false, resolutionContext);
                        }

                        break;

                    case SyntaxKind.WithStatement:
                        inWithBlock = true;
                        break;

                    case SyntaxKind.Block:
                        inContextuallyTypedAssignment = false;
                        break;
                }

                // Record enclosing Decl
                var decl = this.semanticInfoChain.getDeclForAST(current);
                if (decl) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }

            // if the found ISyntaxElement is a named, we want to check for previous dotted expressions,
            // since those will give us the right typing
            if (ast && ast.parent && ast.kind() === SyntaxKind.IdentifierName) {
                if (ast.parent.kind() === SyntaxKind.MemberAccessExpression) {
                    if ((<MemberAccessExpressionSyntax>ast.parent).name === ast) {
                        ast = ast.parent;
                    }
                }
                else if (ast.parent.kind() === SyntaxKind.QualifiedName) {
                    if ((<QualifiedNameSyntax>ast.parent).right === ast) {
                        ast = ast.parent;
                    }
                }
            }

            return {
                ast: ast,
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment,
                inWithBlock: inWithBlock
            };
        }

        private extractResolutionContextForVariable(
            inContextuallyTypedAssignment: boolean,
            propagateContextualTypes: boolean,
            resolver: PullTypeResolver,
            resolutionContext: PullTypeResolutionContext,
            enclosingDecl: PullDecl,
            assigningAST: ISyntaxElement,
            init: ISyntaxElement): void {
            if (inContextuallyTypedAssignment) {
                if (propagateContextualTypes) {
                    resolver.resolveAST(assigningAST, /*inContextuallyTypedAssignment*/false, resolutionContext);
                    var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST);

                    var contextualType: PullTypeSymbol = null;
                    if (varSymbol && inContextuallyTypedAssignment) {
                        contextualType = varSymbol.type;
                    }

                    resolutionContext.pushNewContextualType(contextualType);

                    if (init) {
                        resolver.resolveAST(init, inContextuallyTypedAssignment, resolutionContext);
                    }
                }
            }
        }

        private getASTPath(ast: ISyntaxElement): ISyntaxElement[] {
            var result: ISyntaxElement[] = [];

            while (ast) {
                result.unshift(ast);
                ast = ast.parent;
            }

            return result;
        }

        public pullGetSymbolInformationFromAST(ast: ISyntaxElement, document: Document): PullSymbolInfo {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ true);
            if (!context || context.inWithBlock) {
                return null;
            }

            ast = context.ast;
            var symbol = resolver.resolveAST(ast, context.inContextuallyTypedAssignment, context.resolutionContext);

            if (!symbol) {
                Debug.assert(
                    ast.kind() === SyntaxKind.SourceUnit,
                    "No symbol was found for ast and ast was not source unit. Ast Kind: " + SyntaxKind[ast.kind()] );
                return null;
            }

            if (symbol.isTypeReference()) {
                symbol = (<TypeReferenceSymbol>symbol).getReferencedTypeSymbol();
            }

            var aliasSymbol = this.semanticInfoChain.getAliasSymbolForAST(ast);

            return {
                symbol: symbol,
                aliasSymbol: aliasSymbol,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public pullGetCallInformationFromAST(ast: ISyntaxElement, document: Document): PullCallSymbolInfo {
            // ISyntaxElement has to be a call expression
            if (ast.kind() !== SyntaxKind.InvocationExpression && ast.kind() !== SyntaxKind.ObjectCreationExpression) {
                return null;
            }

            var isNew = ast.kind() === SyntaxKind.ObjectCreationExpression;

            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var callResolutionResults = new PullAdditionalCallResolutionData();

            if (isNew) {
                resolver.resolveObjectCreationExpression(<ObjectCreationExpressionSyntax>ast, context.resolutionContext, callResolutionResults);
            }
            else {
                resolver.resolveInvocationExpression(<InvocationExpressionSyntax>ast, context.resolutionContext, callResolutionResults);
            }

            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        }

        public pullGetVisibleMemberSymbolsFromAST(ast: ISyntaxElement, document: Document): PullVisibleSymbolsInfo {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var symbols = resolver.getVisibleMembersFromExpression(ast, context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public pullGetVisibleDeclsFromAST(ast: ISyntaxElement, document: Document): PullDecl[] {
            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ false);
            if (!context || context.inWithBlock) {
                return null;
            }

            return resolver.getVisibleDecls(context.enclosingDecl);
        }

        public pullGetContextualMembersFromAST(ast: ISyntaxElement, document: Document): PullVisibleSymbolsInfo {
            // Input has to be an object literal
            if (ast.kind() !== SyntaxKind.ObjectLiteralExpression) {
                return null;
            }

            var resolver = this.semanticInfoChain.getResolver();
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var members = resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);

            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public pullGetDeclInformation(decl: PullDecl, ast: ISyntaxElement, document: Document): PullSymbolInfo {
            var resolver = this.semanticInfoChain.getResolver();

            // Note: we not only need to resolve down to the path the ast is at, but we also need to 
            // resolve the path to where the decl is at.  This is because, currently, some decls 
            // can't fin their symbols unless they are first resolved.  For example, a property of 
            // an object literal must be resolved before its symbol can be retrieved.
            var context = this.extractResolutionContextFromAST(resolver, ast, document, /*propagateContextualTypes*/ true);
            if (!context || context.inWithBlock) {
                return null;
            }

            var astForDecl = decl.ast();
            if (!astForDecl) {
                return null;
            }

            var astForDeclContext = this.extractResolutionContextFromAST(
                resolver, astForDecl, this.getDocument(syntaxTree(astForDecl).fileName()), /*propagateContextualTypes*/ true);
            if (!astForDeclContext) {
                return null;
            }

            var symbol = decl.getSymbol(this.semanticInfoChain);
            resolver.resolveDeclaredSymbol(symbol, context.resolutionContext);
            symbol.setUnresolved();

            return {
                symbol: symbol,
                aliasSymbol: null,
                ast: ast,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public topLevelDeclaration(fileName: string) : PullDecl {
            return this.semanticInfoChain.topLevelDecl(fileName);
        }

        public getDeclForAST(ast: ISyntaxElement): PullDecl {
            return this.semanticInfoChain.getDeclForAST(ast);
        }

        public fileNames(): string[] {
            return this.semanticInfoChain.fileNames();
        }

        public topLevelDecl(fileName: string): PullDecl {
            return this.semanticInfoChain.topLevelDecl(fileName);
        }

        private static getLocationText(location: Location, resolvePath: (path: string) => string): string {
            return resolvePath(location.fileName()) + "(" + (location.line() + 1) + "," + (location.character() + 1) + ")";
        }

        public static getFullDiagnosticText(diagnostic: Diagnostic, resolvePath: (path: string) => string): string {
            var result = "";
            if (diagnostic.fileName()) {
                result += this.getLocationText(diagnostic, resolvePath) + ": ";
            }

            result += diagnostic.message();

            var additionalLocations = diagnostic.additionalLocations();
            if (additionalLocations.length > 0) {
                result += " " + getLocalizedText(DiagnosticCode.Additional_locations, null) + Environment.newLine;

                for (var i = 0, n = additionalLocations.length; i < n; i++) {
                    result += "\t" + this.getLocationText(additionalLocations[i], resolvePath) + Environment.newLine;
                }
            }
            else {
                result += Environment.newLine;
            }

            return result;
        }
    }

    enum CompilerPhase {
        Syntax,
        Semantics,
        EmitOptionsValidation,
        Emit,
        DeclarationEmit,
    }

    class CompilerIterator implements Iterator<CompileResult> {
        private compilerPhase: CompilerPhase;
        private index: number = -1;
        private fileNames: string[] = null;
        private _current: CompileResult = null;
        private _emitOptions: EmitOptions = null;
        private _sharedEmitter: Emitter = null;
        private _sharedDeclarationEmitter: DeclarationEmitter = null;
        private hadSyntacticDiagnostics: boolean = false;
        private hadSemanticDiagnostics: boolean = false;
        private hadEmitDiagnostics: boolean = false;

        constructor(private compiler: TypeScriptCompiler,
                    private resolvePath: (path: string) => string,
                    private continueOnDiagnostics: boolean,
                    startingPhase = CompilerPhase.Syntax) {
            this.fileNames = compiler.fileNames();
            this.compilerPhase = startingPhase;
        }

        public current(): CompileResult {
            return this._current;
        }

        public moveNext(): boolean {
            this._current = null;

            // Attempt to move the iterator 'one step' forward.  Note: this may produce no result
            // (for example, if we're emitting everything to a single file).  So only return once
            // we actually have a result, or we're done enumerating.
            while (this.moveNextInternal()) {
                if (this._current) {
                    return true;
                }
            }

            return false;
        }

        private moveNextInternal(): boolean {
            this.index++;

            // If we're at the end of hte set of files the compiler knows about, then move to the
            // next phase of compilation.
            while (this.shouldMoveToNextPhase()) {
                this.index = 0;
                this.compilerPhase++;
            }

            if (this.compilerPhase > CompilerPhase.DeclarationEmit) {
                // We're totally done.
                return false;
            }

            switch (this.compilerPhase) {
                case CompilerPhase.Syntax:
                    return this.moveNextSyntaxPhase();
                case CompilerPhase.Semantics:
                    return this.moveNextSemanticsPhase();
                case CompilerPhase.EmitOptionsValidation:
                    return this.moveNextEmitOptionsValidationPhase();
                case CompilerPhase.Emit:
                    return this.moveNextEmitPhase();
                case CompilerPhase.DeclarationEmit:
                    return this.moveNextDeclarationEmitPhase();
            }
        }

        private shouldMoveToNextPhase(): boolean {
            switch (this.compilerPhase) {
                case CompilerPhase.EmitOptionsValidation:
                    // Only one step in emit validation.  We're done once we do that step.
                    return this.index === 1;

                case CompilerPhase.Syntax:
                case CompilerPhase.Semantics:
                    // Each of these phases are done when we've processed the last file.
                    return this.index === this.fileNames.length;

                case CompilerPhase.Emit:
                case CompilerPhase.DeclarationEmit:
                    // Emitting is done when we get 'one' past the end of hte file list.  This is
                    // because we use that step to collect the results from the shared emitter.
                    return this.index === (this.fileNames.length + 1);
            }

            return false;
        }

        private moveNextSyntaxPhase(): boolean {
            Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];

            var diagnostics = this.compiler.getSyntacticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSyntacticDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics(diagnostics);
            }

            return true;
        }

        private moveNextSemanticsPhase(): boolean {
            // Don't move forward if there were syntax diagnostics.
            if (this.hadSyntacticDiagnostics) {
                return false;
            }

            Debug.assert(this.index >= 0 && this.index < this.fileNames.length);
            var fileName = this.fileNames[this.index];
            var diagnostics = this.compiler.getSemanticDiagnostics(fileName);
            if (diagnostics.length) {
                if (!this.continueOnDiagnostics) {
                    this.hadSemanticDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics(diagnostics);
            }

            return true;
        }

        private moveNextEmitOptionsValidationPhase(): boolean {
            Debug.assert(!this.hadSyntacticDiagnostics);

            if (!this._emitOptions) {
                this._emitOptions = new EmitOptions(this.compiler, this.resolvePath);
            }

            if (this._emitOptions.diagnostic()) {
                if (!this.continueOnDiagnostics) {
                    this.hadEmitDiagnostics = true;
                }

                this._current = CompileResult.fromDiagnostics([this._emitOptions.diagnostic()]);
            }

            return true;
        }

        private moveNextEmitPhase(): boolean {
            Debug.assert(!this.hadSyntacticDiagnostics);
            Debug.assert(this._emitOptions);

            if (this.hadEmitDiagnostics) {
                return false;
            }

            Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);

                // Try to emit this single document.  It will either get emitted to its own file
                // (in which case we'll have our call back triggered), or it will get added to the
                // shared emitter (and we'll take care of it after all the files are done.
                this._sharedEmitter = this.compiler._emitDocument(
                    document, this._emitOptions,
                    outputFiles => { this._current = CompileResult.fromOutputFiles(outputFiles) },
                    this._sharedEmitter);
                return true;
            }

            // If we've moved past all the files, and we have a multi-input->single-output
            // emitter set up.  Then add the outputs of that emitter to the results.
            if (this.index === this.fileNames.length && this._sharedEmitter) {
                // Collect shared emit result.
                this._current = CompileResult.fromOutputFiles(this._sharedEmitter.getOutputFiles());
            }

            return true;
        }

        private moveNextDeclarationEmitPhase(): boolean {
            Debug.assert(!this.hadSyntacticDiagnostics);
            Debug.assert(!this.hadEmitDiagnostics);
            if (this.hadSemanticDiagnostics) {
                return false;
            }

            if (!this.compiler.compilationSettings().generateDeclarationFiles()) {
                return false;
            }

            Debug.assert(this.index >= 0 && this.index <= this.fileNames.length);
            if (this.index < this.fileNames.length) {
                var fileName = this.fileNames[this.index];
                var document = this.compiler.getDocument(fileName);

                this._sharedDeclarationEmitter = this.compiler._emitDocumentDeclarations(
                    document, this._emitOptions,
                    file => { this._current = CompileResult.fromOutputFiles([file]); },
                    this._sharedDeclarationEmitter);
                return true;
            }

            // If we've moved past all the files, and we have a multi-input->single-output
            // emitter set up.  Then add the outputs of that emitter to the results.
            if (this.index === this.fileNames.length && this._sharedDeclarationEmitter) {
                this._current = CompileResult.fromOutputFiles([this._sharedDeclarationEmitter.getOutputFile()]);
            }

            return true;
        }
    }

    export function compareDataObjects(dst: any, src: any): boolean {
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e]))
                    return false;
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e])
                    return false;
            }
        }
        return true;
    }
}
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module Tools {
    export interface IWalkContext {
        goChildren: boolean;
        goNextSibling: boolean;
        // visit siblings in reverse execution order
        reverseSiblings: boolean;
    }

    export class BaseWalkContext implements IWalkContext {
        public goChildren = true;
        public goNextSibling = true;
        public reverseSiblings = false;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class ArrayUtilities {
        public static isArray(value: any): boolean {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        }

        public static sequenceEquals<T>(array1: T[], array2: T[], equals: (v1: T, v2: T) => boolean) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        }

        public static contains<T>(array: T[], value: T): boolean {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        }

        public static groupBy<T>(array: T[], func: (v: T) => string): any {
            var result: IIndexable<T[]> = {};

            for (var i = 0, n = array.length; i < n; i++) {
                var v: any = array[i];
                var k = func(v);

                var list: T[] = result[k] || [];
                list.push(v);
                result[k] = list;
            }

            return result;
        }


        // Gets unique element array
        public static distinct<T>(array: T[], equalsFn?: (a: T, b: T) => boolean): T[] {
            var result: T[] = [];

            // TODO: use map when available
            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }

                if (j === result.length) {
                    result.push(current);
                }
            }

            return result;
        }

        public static min<T>(array: T[], func: (v: T) => number): number {
            // Debug.assert(array.length > 0);
            var min = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }

            return min;
        }

        public static max<T>(array: T[], func: (v: T) => number): number {
            // Debug.assert(array.length > 0);
            var max = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }

            return max;
        }

        public static last<T>(array: T[]): T {
            if (array.length === 0) {
                throw Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        }

        public static lastOrDefault<T>(array: T[], predicate: (v: T, index: number) => boolean): T {
            for (var i = array.length - 1; i >= 0; i--) {
                var v = array[i];
                if (predicate(v, i)) {
                    return v;
                }
            }

            return null;
        }

        public static firstOrDefault<T>(array: T[], func: (v: T, index: number) => boolean): T {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value, i)) {
                    return value;
                }
            }

            return null;
        }

        public static first<T>(array: T[], func?: (v: T, index: number) => boolean): T {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (!func || func(value, i)) {
                    return value;
                }
            }

            throw Errors.invalidOperation();
        }

        public static sum<T>(array: T[], func: (v: T) => number): number {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        }

        public static select<T,S>(values: T[], func: (v: T) => S): S[] {
            var result: S[] = new Array<S>(values.length);

            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }

            return result;
        }

        public static where<T>(values: T[], func: (v: T) => boolean): T[] {
            var result = new Array<T>();

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        }

        public static any<T>(array: T[], func: (v: T) => boolean): boolean {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        }

        public static all<T>(array: T[], func: (v: T) => boolean): boolean {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        }

        public static binarySearch(array: number[], value: number): number {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                }
                else if (midValue > value) {
                    high = middle - 1;
                }
                else {
                    low = middle + 1;
                }
            }

            return ~low;
        }

        public static createArray<T>(length: number, defaultValue: any): T[] {
            var result = new Array<T>(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }

            return result;
        }

        public static grow<T>(array: T[], length: number, defaultValue: T): void {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        }

        public static copy<T>(sourceArray: T[], sourceIndex: number, destinationArray: T[], destinationIndex: number, length: number): void {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        }

        public static indexOf<T>(array: T[], predicate: (v: T) => boolean): number {
            for (var i = 0, n = array.length; i < n; i++) {
                if (predicate(array[i])) {
                    return i;
                }
            }

            return -1;
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface IBitMatrix {
        // Returns true if the bit at the specified indices is set.  False otherwise.
        valueAt(x: number, y: number): boolean;

        // Sets the value at this specified indices.
        setValueAt(x: number, y: number, value: boolean): void;

        // Releases the bit matrix, allowing its resources to be used by another matrix.
        // This instance cannot be used after it is released.
        release(): void;
    }

    export module BitMatrix {
        var pool: BitMatrixImpl[] = [];

        class BitMatrixImpl implements IBitMatrix {
            public isReleased = false;
            private vectors: IBitVector[] = [];

            constructor(public allowUndefinedValues: boolean) {
            }

            public valueAt(x: number, y: number): boolean {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    return this.allowUndefinedValues ? undefined : false;
                }

                return vector.valueAt(y);
            }

            public setValueAt(x: number, y: number, value: boolean): void {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                var vector = this.vectors[x];
                if (!vector) {
                    if (value === undefined) {
                        // If they're storing an undefined value, and we don't even have a vector,
                        // then we can short circuit early here.
                        return;
                    }

                    vector = BitVector.getBitVector(this.allowUndefinedValues);
                    this.vectors[x] = vector;
                }

                vector.setValueAt(y, value);
            }

            public release() {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;

                // Release all the vectors back.
                for (var name in this.vectors) {
                    if (this.vectors.hasOwnProperty(name)) {
                        var vector = this.vectors[name];
                        vector.release();
                    }
                }

                this.vectors.length = 0;
                pool.push(this);
            }
        }

        export function getBitMatrix(allowUndefinedValues: boolean): IBitMatrix {
            if (pool.length === 0) {
                return new BitMatrixImpl(allowUndefinedValues);
            }

            var matrix = pool.pop();
            matrix.isReleased = false;
            matrix.allowUndefinedValues = allowUndefinedValues;

            return matrix;
        }
    }
}
///<reference path='references.ts'/>

module TypeScript {
    export interface IBitVector {
        // Returns the value at the specified index.  If this is a bi-state vector, then the result
        // will only be 'true' or 'false'.  If this is a tri-state vector, then the result can be 
        // 'true', 'false', or 'undefined'.
        valueAt(index: number): boolean;

        // Sets the value at this specified bit.  For a bi-state vector the value must be 'true' or
        // 'false'.  For a tri-state vector, it can be 'true', 'false', or 'undefined'.
        setValueAt(index: number, value: boolean): void;

        // Releases the bit vector, allowing its resources to be used by another BitVector.
        // This instance cannot be used after it is released.
        release(): void;
    }

    export module BitVector {
        var pool: BitVectorImpl[] = [];
        enum Constants {
            // We only use up to 30 bits in a number.  That way the encoded value can always fit
            // within an int so that the underlying engine doesn't use a 64bit float here.
            MaxBitsPerEncodedNumber = 30,
            BitsPerEncodedBiStateValue = 1,

            // For a tri state vector we need 2 bits per encoded value.  00 for 'undefined',
            // '01' for 'false' and '10' for true.
            BitsPerEncodedTriStateValue = 2,

            BiStateEncodedTrue    = 1, // 1
            BiStateClearBitsMask  = 1, // 1

            TriStateEncodedFalse  = 1, // 01
            TriStateEncodedTrue   = 2, // 10
            TriStateClearBitsMask = 3, // 11
        }

        class BitVectorImpl implements IBitVector {
            public isReleased = false;
            private bits: number[] = [];

            constructor(public allowUndefinedValues: boolean) {
            }

            private computeTriStateArrayIndex(index: number): number {
                // The number of values that can be encoded in a single number.
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedTriStateValue;

                return (index / encodedValuesPerNumber) >>> 0;
            }

            private computeBiStateArrayIndex(index: number): number {
                // The number of values that can be encoded in a single number.
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedBiStateValue;

                return (index / encodedValuesPerNumber) >>> 0;
            }

            private computeTriStateEncodedValueIndex(index: number): number {
                // The number of values that can be encoded in a single number.
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedTriStateValue;

                return (index % encodedValuesPerNumber) * Constants.BitsPerEncodedTriStateValue;
            }

            private computeBiStateEncodedValueIndex(index: number): number {
                // The number of values that can be encoded in a single number.
                var encodedValuesPerNumber = Constants.MaxBitsPerEncodedNumber / Constants.BitsPerEncodedBiStateValue;

                return (index % encodedValuesPerNumber) * Constants.BitsPerEncodedBiStateValue;
            }

            public valueAt(index: number): boolean {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    // tri-state bit vector.  2 bits per value.

                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        // We don't even have an encoded value at this array position.  That's
                        // equivalent to 'undefined' for a tri-state vector.
                        return undefined;
                    }
                    
                    var bitIndex = this.computeTriStateEncodedValueIndex(index);
                    if (encoded & (Constants.TriStateEncodedTrue << bitIndex)) {
                        return true;
                    }
                    else if (encoded & (Constants.TriStateEncodedFalse << bitIndex)) {
                        return false;
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    // Normal bitvector.  One bit per value stored.

                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        // We don't even have an encoded value at this array position.  That's
                        // equivalent to 'false' for a bi-state vector.
                        return false;
                    }

                    // If we don't support undefined values, then we use one bit per value. Just
                    // index to that bit and see if it's set or not.
                    var bitIndex = this.computeBiStateEncodedValueIndex(index);
                    if (encoded & (Constants.BiStateEncodedTrue << bitIndex)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            public setValueAt(index: number, value: boolean): void {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                if (this.allowUndefinedValues) {
                    Debug.assert(value === true || value === false || value === undefined, "value must only be true, false or undefined.");

                    var arrayIndex = this.computeTriStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === undefined) {
                            // They're trying to set a bit to undefined that we don't even have an entry 
                            // for.  We can bail out quickly here.
                            return;
                        }

                        encoded = 0;
                    }

                    // First, we clear out any bits set at the appropriate index.  
                    var bitIndex = this.computeTriStateEncodedValueIndex(index);

                    // Create a mask similar to: 11111111100111111
                    // i.e. all 1's except for 2 zeroes in the appropriate place.
                    var clearMask = ~(Constants.TriStateClearBitsMask << bitIndex)
                    encoded = encoded & clearMask;

                    if (value === true) {
                        encoded = encoded | (Constants.TriStateEncodedTrue << bitIndex);
                    }
                    else if (value === false) {
                        encoded = encoded | (Constants.TriStateEncodedFalse << bitIndex);
                    }
                    // else {
                    //   They're setting the value to 'undefined'.  We already cleared the value
                    //   so there's nothing we need to do here.
                    // }

                    this.bits[arrayIndex] = encoded;
                }
                else {
                    Debug.assert(value === true || value === false, "value must only be true or false.");

                    var arrayIndex = this.computeBiStateArrayIndex(index);
                    var encoded = this.bits[arrayIndex];
                    if (encoded === undefined) {
                        if (value === false) {
                            // They're trying to set a bit to false that we don't even have an entry 
                            // for.  We can bail out quickly here.
                            return;
                        }

                        encoded = 0;
                    }

                    var bitIndex = this.computeBiStateEncodedValueIndex(index);
                    // First, clear out the bit at this location.
                    encoded = encoded & ~(Constants.BiStateClearBitsMask << bitIndex);

                    if (value) {
                        encoded = encoded | (Constants.BiStateEncodedTrue << bitIndex);
                    }
                    // else {
                    //   They're setting the value to 'false'.  We already cleared the value
                    //   so there's nothing we need to do here.
                    // }

                    this.bits[arrayIndex] = encoded;
                }
            }

            public release() {
                Debug.assert(!this.isReleased, "Should not use a released bitvector");
                this.isReleased = true;
                this.bits.length = 0;
                pool.push(this);
            }
        }

        export function getBitVector(allowUndefinedValues: boolean): IBitVector {
            if (pool.length === 0) {
                return new BitVectorImpl(allowUndefinedValues);
            }

            var vector = pool.pop();
            vector.isReleased = false;
            vector.allowUndefinedValues = allowUndefinedValues;

            return vector;
        }
    }
}
interface ICancellationToken {
    isCancellationRequested(): boolean;
}
///<reference path='ICancellationToken.ts' />

interface ICancellationTokenSource {
    token(): ICancellationToken;

    cancel(): void;
}
///<reference path='references.ts' />

module TypeScript {
    export enum Constants {
        // 2^30-1
        Max31BitInteger = 1073741823,
        Min31BitInteger = -1073741824,
    }
}
///<reference path='references.ts' />

module TypeScript {
    export enum AssertionLevel {
        None = 0,
        Normal = 1,
        Aggressive = 2,
        VeryAggressive = 3,
    }

    export class Debug {
        private static currentAssertionLevel = AssertionLevel.None;
        public static shouldAssert(level: AssertionLevel): boolean {
            return this.currentAssertionLevel >= level;
        }

        public static assert(expression: any, message: string = "", verboseDebugInfo: () => string = null): void {
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information:" + verboseDebugInfo();
                }

                throw new Error("Debug Failure. False expression: " + message + verboseDebugString);
            }
        }

        public static fail(message?: string): void {
            Debug.assert(false, message);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export enum DiagnosticCategory {
        Warning,
        Error,
        Message,
        NoPrefix,
    }
}
///<reference path='references.ts' />

module TypeScript {
    export var LocalizedDiagnosticMessages: IIndexable<any> = null;

    export class Location {
        private _fileName: string;
        private _lineMap: LineMap;
        private _start: number;
        private _length: number;

        constructor(fileName: string, lineMap: LineMap, start: number, length: number) {
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._start = start;
            this._length = length;
        }

        public fileName(): string {
            return this._fileName;
        }

        public lineMap(): LineMap {
            return this._lineMap;
        }

        public line(): number {
            return this._lineMap ? this._lineMap.getLineNumberFromPosition(this.start()) : 0;
        }

        public character(): number {
            return this._lineMap ? this._lineMap.getLineAndCharacterFromPosition(this.start()).character() : 0;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public static equals(location1: Location, location2: Location): boolean {
            return location1._fileName === location2._fileName &&
                location1._start === location2._start &&
                location1._length === location2._length;
        }
    }

    export class Diagnostic extends Location {
        private _diagnosticKey: string;
        private _arguments: any[];
        private _additionalLocations: Location[];

        constructor(fileName: string, lineMap: LineMap, start: number, length: number, diagnosticKey: string, _arguments: any[]= null, additionalLocations: Location[] = null) {
            super(fileName, lineMap, start, length);
            this._diagnosticKey = diagnosticKey;
            this._arguments = (_arguments && _arguments.length > 0) ? _arguments : null;
            this._additionalLocations = (additionalLocations && additionalLocations.length > 0) ? additionalLocations : null;
        }

        public toJSON(key: any): any {
            var result: any = {};
            result.start = this.start();
            result.length = this.length();

            result.diagnosticCode = this._diagnosticKey;

            var _arguments: any[] = (<any>this).arguments();
            if (_arguments && _arguments.length > 0) {
                result.arguments = _arguments;
            }

            return result;
        }

        public diagnosticKey(): string {
            return this._diagnosticKey;
        }

        public arguments(): any[] {
            return this._arguments;
        }

        /**
         * Get the text of the message in the given language.
         */
        public text(): string {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        }

        /**
         * Get the text of the message including the error code in the given language.
         */
        public message(): string {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        }

        /**
         * If a derived class has additional information about other referenced symbols, it can
         * expose the locations of those symbols in a general way, so they can be reported along
         * with the error.
         */
        public additionalLocations(): Location[] {
            return this._additionalLocations || [];
        }

        public static equals(diagnostic1: Diagnostic, diagnostic2: Diagnostic): boolean {
            return Location.equals(diagnostic1, diagnostic2) &&
                diagnostic1._diagnosticKey === diagnostic2._diagnosticKey &&
                ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, (v1, v2) => v1 === v2);
        }

        public info(): DiagnosticInfo {
            return getDiagnosticInfoFromKey(this.diagnosticKey());
        }
    }

    export function newLine(): string {
        // TODO: We need to expose an extensibility point on our hosts to have them tell us what 
        // they want the newline string to be.  That way we can get the correct result regardless
        // of which host we use
        return Environment ? Environment.newLine : "\r\n";
    }

    function getLargestIndex(diagnostic: string): number {
        var largest = -1;
        var regex = /\{(\d+)\}/g;

        var match: RegExpExecArray;
        while (match = regex.exec(diagnostic)) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }

        return largest;
    }

    function getDiagnosticInfoFromKey(diagnosticKey: string): DiagnosticInfo {
        var result: DiagnosticInfo = diagnosticInformationMap[diagnosticKey];
        Debug.assert(result);
        return result;
    }

    export function getLocalizedText(diagnosticKey: string, args: any[]): string {
        if (LocalizedDiagnosticMessages) {
            //Debug.assert(LocalizedDiagnosticMessages.hasOwnProperty(diagnosticKey));
        }

        var diagnosticMessageText: string = LocalizedDiagnosticMessages ? LocalizedDiagnosticMessages[diagnosticKey] : diagnosticKey;
        Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);

        var actualCount = args ? args.length : 0;
        // We have a string like "foo_0_bar_1".  We want to find the largest integer there.
        // (i.e.'1').  We then need one more arg than that to be correct.
        var expectedCount = 1 + getLargestIndex(diagnosticKey);

        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }

        // This should also be the same number of arguments as the message text
        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }

        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num?) {
            return typeof args[num] !== 'undefined'
                ? args[num]
                : match;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });

        return diagnosticMessageText;
    }

    export function getDiagnosticMessage(diagnosticKey: string, args: any[]): string {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);

        var message: string;
        if (diagnostic.category === DiagnosticCategory.Error) {
            message = getLocalizedText(DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else if (diagnostic.category === DiagnosticCategory.Warning) {
            message = getLocalizedText(DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else {
            message = diagnosticMessageText;
        }

        return message;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface DiagnosticInfo {
        category: DiagnosticCategory;
        message: string;
        code: number;
    }
}
///<reference path='references.ts' />
///<reference path='..\enumerator.ts' />
///<reference path='..\process.ts' />

declare var Buffer: {
    new (str: string, encoding?: string): any;
}

module TypeScript {
    export var nodeMakeDirectoryTime = 0;
    export var nodeCreateBufferTime = 0;
    export var nodeWriteFileSyncTime = 0;

    export enum ByteOrderMark {
        None = 0,
        Utf8 = 1,
        Utf16BigEndian = 2,
        Utf16LittleEndian = 3,
    }

    export class FileInformation {
        constructor(public contents: string, public byteOrderMark: ByteOrderMark) {
        }
    }

    export interface IEnvironment {
        supportsCodePage(): boolean;
        readFile(path: string, codepage: number): FileInformation;
        writeFile(path: string, contents: string, writeByteOrderMark: boolean): void;
        deleteFile(path: string): void;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        listFiles(path: string, re?: RegExp, options?: { recursive?: boolean; }): string[];

        arguments: string[];
        standardOut: ITextWriter;

        currentDirectory(): string;
        newLine: string;
    }

    export var Environment = (function () {
        // Create an IO object for use inside WindowsScriptHost hosts
        // Depends on WSCript and FileSystemObject
        function getWindowsScriptHostEnvironment(): IEnvironment {
            try {
                var fso = new ActiveXObject("Scripting.FileSystemObject");
            } catch (e) {
                return null;
            }

            var streamObjectPool: any[] = [];

            function getStreamObject(): any {
                if (streamObjectPool.length > 0) {
                    return streamObjectPool.pop();
                }
                else {
                    return new ActiveXObject("ADODB.Stream");
                }
            }

            function releaseStreamObject(obj: any) {
                streamObjectPool.push(obj);
            }

            var args: string[] = [];
            for (var i = 0; i < WScript.Arguments.length; i++) {
                args[i] = WScript.Arguments.Item(i);
            }

            return {
                // On windows, the newline sequence is always "\r\n";
                newLine: "\r\n",

                currentDirectory: (): string => {
                    return (<any>WScript).CreateObject("WScript.Shell").CurrentDirectory;
                },

                supportsCodePage: () => {
                    return (<any>WScript).ReadFile;
                },

                readFile: function (path: string, codepage: number): FileInformation {
                    try {
                        // If a codepage is requested, defer to our host to do the reading.  If it
                        // fails, fall back to our normal BOM/utf8 logic.
                        if (codepage !== null && this.supportsCodePage()) {
                            try {
                                var contents = (<any>WScript).ReadFile(path, codepage);
                                return new FileInformation(contents, ByteOrderMark.None);
                            }
                            catch (e) {
                                // We couldn't read it with that code page.  Fall back to the normal
                                // BOM/utf8 logic below.
                            }
                        }

                        // Initially just read the first two bytes of the file to see if there's a bom.
                        var streamObj = getStreamObject();
                        streamObj.Open();
                        streamObj.Type = 2; // Text data

                        // Start reading individual chars without any interpretation.  That way we can check for a bom.
                        streamObj.Charset = 'x-ansi';

                        streamObj.LoadFromFile(path);
                        var bomChar = streamObj.ReadText(2); // Read the BOM char

                        // Position has to be at 0 before changing the encoding
                        streamObj.Position = 0;

                        var byteOrderMark = ByteOrderMark.None;

                        if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = ByteOrderMark.Utf16BigEndian;
                        }
                        else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                            streamObj.Charset = 'unicode';
                            byteOrderMark = ByteOrderMark.Utf16LittleEndian;
                        }
                        else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                            streamObj.Charset = 'utf-8';
                            byteOrderMark = ByteOrderMark.Utf8;
                        }
                        else {
                            // Always read a file as utf8 if it has no bom.
                            streamObj.Charset = 'utf-8';
                        }

                        // Read the whole file
                        var contents = streamObj.ReadText(-1 /* read from the current position to EOS */);
                        streamObj.Close();
                        releaseStreamObject(streamObj);
                        return new FileInformation(contents, byteOrderMark);
                    }
                    catch (err) {
                        // -2147024809 is the javascript value for 0x80070057 which is the HRESULT for 
                        // "the parameter is incorrect".
                        var message: string;
                        if (err.number === -2147024809) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unsupported_file_encoding, null);
                        }
                        else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_read_file_0_1, [path, err.message]);
                        }

                        throw new Error(message);
                    }
                },

                writeFile: function (path: string, contents: string, writeByteOrderMark: boolean) {
                    // First, convert the text contents passed in to binary in UTF8 format.
                    var textStream = getStreamObject();
                    textStream.Charset = 'utf-8';
                    textStream.Open();
                    textStream.WriteText(contents, 0 /*do not add newline*/);

                    // If they don't want the BOM, then skip it (it will be added automatically
                    // when we write the utf8 bytes out above).
                    if (!writeByteOrderMark) {
                        textStream.Position = 3;
                    }
                    else {
                        textStream.Position = 0;
                    }

                    // Now, write all those bytes out to a file.
                    var fileStream = getStreamObject();
                    fileStream.Type = 1; //binary data.
                    fileStream.Open();

                    textStream.CopyTo(fileStream);

                    // Flush and save the file.
                    fileStream.Flush();
                    fileStream.SaveToFile(path, 2 /*overwrite*/);
                    fileStream.Close();

                    textStream.Flush();
                    textStream.Close();
                },

                fileExists: function (path: string): boolean {
                    return fso.FileExists(path);
                },

                deleteFile: function (path: string): void {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true); // true: delete read-only files
                    }
                },

                directoryExists: function (path) {
                    return <boolean>fso.FolderExists(path);
                },

                listFiles: function (path, spec?, options?) {
                    options = options || <{ recursive?: boolean; }>{};
                    function filesInFolder(folder: any, root: string): string[] {
                        var paths: string[] = [];
                        var fc: Enumerator;

                        if (options.recursive) {
                            fc = new Enumerator(folder.subfolders);

                            for (; !fc.atEnd(); fc.moveNext()) {
                                paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                            }
                        }

                        fc = new Enumerator(folder.files);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            if (!spec || fc.item().Name.match(spec)) {
                                paths.push(root + "\\" + fc.item().Name);
                            }
                        }

                        return paths;
                    }

                    var folder: any = fso.GetFolder(path);
                    var paths: string[] = [];

                    return filesInFolder(folder, path);
                },

                arguments: <string[]>args,

                standardOut: WScript.StdOut,
            };
        };

        function getNodeEnvironment(): IEnvironment {
            var _fs = require('fs');
            var _path = require('path');
            var _module = require('module');
            var _os = require('os');

            return {
                // On node pick up the newline character from the OS
                newLine: _os.EOL,

                currentDirectory: (): string => {
                    return (<any>process).cwd();
                },

                supportsCodePage: () => false,

                readFile: function (file: string, codepage: number): FileInformation {
                    if (codepage !== null) {
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.codepage_option_not_supported_on_current_platform, null));
                    }

                    var buffer = _fs.readFileSync(file);
                    switch (buffer[0]) {
                        case 0xFE:
                            if (buffer[1] === 0xFF) {
                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to 
                                // Little Endian first
                                var i = 0;
                                while ((i + 1) < buffer.length) {
                                    var temp = buffer[i];
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return new FileInformation(buffer.toString("ucs2", 2), ByteOrderMark.Utf16BigEndian);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] === 0xFE) {
                                // utf16-le 
                                return new FileInformation(buffer.toString("ucs2", 2), ByteOrderMark.Utf16LittleEndian);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] === 0xBB) {
                                // utf-8
                                return new FileInformation(buffer.toString("utf8", 3), ByteOrderMark.Utf8);
                            }
                    }

                    // Default behaviour
                    return new FileInformation(buffer.toString("utf8", 0), ByteOrderMark.None);
                },

                writeFile: function (path: string, contents: string, writeByteOrderMark: boolean) {
                    function mkdirRecursiveSync(path: string) {
                        var stats = _fs.statSync(path);
                        if (stats.isFile()) {
                            throw "\"" + path + "\" exists but isn't a directory.";
                        }
                        else if (stats.isDirectory()) {
                            return;
                        }
                        else {
                            mkdirRecursiveSync(_path.dirname(path));
                            _fs.mkdirSync(path, 509 /*775 in octal*/);
                        }
                    }
                    var start = new Date().getTime();
                    mkdirRecursiveSync(_path.dirname(path));
                    TypeScript.nodeMakeDirectoryTime += new Date().getTime() - start;

                    if (writeByteOrderMark) {
                        contents = '\uFEFF' + contents;
                    }

                    var start = new Date().getTime();

                    var chunkLength = 4 * 1024;
                    var fileDescriptor = _fs.openSync(path, "w");
                    try {
                        for (var index = 0; index < contents.length; index += chunkLength) {
                            var bufferStart = new Date().getTime();
                            var buffer = new Buffer(contents.substr(index, chunkLength), "utf8");
                            TypeScript.nodeCreateBufferTime += new Date().getTime() - bufferStart;

                            _fs.writeSync(fileDescriptor, buffer, 0, buffer.length, null);
                        }
                    }
                    finally {
                        _fs.closeSync(fileDescriptor);
                    }

                    TypeScript.nodeWriteFileSyncTime += new Date().getTime() - start;
                },

                fileExists: function (path: string): boolean {
                    return _fs.existsSync(path);
                },

                deleteFile: function (path) {
                    try {
                        _fs.unlinkSync(path);
                    } catch (e) {
                    }
                },

                directoryExists: function (path: string): boolean {
                    return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
                },

                listFiles: function dir(path, spec?, options?) {
                    options = options || <{ recursive?: boolean; }>{};

                    function filesInFolder(folder: string): string[] {
                        var paths: string[] = [];

                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var stat = _fs.statSync(folder + "\\" + files[i]);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(folder + "\\" + files[i]));
                            }
                            else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(folder + "\\" + files[i]);
                            }
                        }

                        return paths;
                    }

                    return filesInFolder(path);
                },

                arguments: process.argv.slice(2),

                standardOut: {
                    Write: function (str) { process.stdout.write(str); },
                    WriteLine: function (str) { process.stdout.write(str + '\n'); },
                    Close: function () { }
                },
            };
        };

        if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
            return getWindowsScriptHostEnvironment();
        }
        else if (typeof module !== 'undefined' && module.exports) {
            return getNodeEnvironment();
        }
        else {
            return null; // Unsupported host
        }
    })();
}
///<reference path='references.ts' />

module TypeScript {
    export class Errors {
        public static argument(argument: string, message?: string): Error {
            return new Error("Invalid argument: " + argument + ". " + message);
        }

        public static argumentOutOfRange(argument: string): Error {
            return new Error("Argument out of range: " + argument);
        }

        public static argumentNull(argument: string): Error {
            return new Error("Argument null: " + argument);
        }

        public static abstract(): Error {
            return new Error("Operation not implemented properly by subclass.");
        }

        public static notYetImplemented(): Error {
            return new Error("Not yet implemented.");
        }

        public static invalidOperation(message?: string): Error {
            return new Error("Invalid operation: " + message);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class Hash {
        // This table uses FNV1a as a string hash
        private static FNV_BASE = 2166136261;
        private static FNV_PRIME = 16777619;

        private static computeFnv1aCharArrayHashCode(text: number[], start: number, len: number): number {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = IntegerUtilities.integerMultiplyLow32Bits(hashCode ^ text[i], Hash.FNV_PRIME);
            }

            return hashCode;
        }

        public static computeSimple31BitCharArrayHashCode(key: number[], start: number, len: number): number {
            // Start with an int.
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
                // V8 recognize this as not needing to go past the 53 bits needed for the float 
                // mantissa.  Or'ing with 0 keeps this 32 bits.
                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
            // allocation.
            return hash & 0x7FFFFFFF;
        }

        public static computeSimple31BitStringHashCode(key: string): number {
            // Start with an int.
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
                // V8 recognize this as not needing to go past the 53 bits needed for the float 
                // mantissa.  Or'ing with 0 keeps this 32 bits.
                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
            // allocation.
            return hash & 0x7FFFFFFF;
        }

        public static computeMurmur2StringHashCode(key: string, seed: number): number {
            // 'm' and 'r' are mixing constants generated offline.
            // They're not really 'magic', they just happen to work well.

            var m: number = 0x5bd1e995;
            var r: number = 24;

            // Initialize the hash to a 'random' value

            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);

            // Mix 4 bytes at a time into the hash.  NOTE: 4 bytes is two chars, so we iterate
            // through the string two chars at a time.
            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = Math.abs(c1 | (c2 << 16));

                k = IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = IntegerUtilities.integerMultiplyLow32Bits(k, m);

                h = IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            // Handle the last char (or 2 bytes) if they exist.  This happens if the original string had
            // odd length.
            if (numberOfCharsLeft === 1) {
                h ^= key.charCodeAt(index);
                h = IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }

            // Do a few final mixes of the hash to ensure the last few bytes are well-incorporated.

            h ^= h >> 13;
            h = IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;

            return h;
        }

        private static primes =
            [3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
              631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419,
              10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431,
              90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689,
              672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899,
              4166287, 4999559, 5999471, 7199369];

        public static getPrime(min: number): number {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }

            throw Errors.notYetImplemented();
        }

        public static expandPrime(oldSize: number): number {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                // NOTE: 2146435069 fits in 31 bits.
                return 2146435069;
            }
            return Hash.getPrime(num);
        }

        public static combine(value: number, currentHash: number): number {
            // Ensure we stay within 31 bits.
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        }
    }
}
///<reference path='references.ts' />

module TypeScript.Collections {
    export var DefaultHashTableCapacity = 1024;

    class HashTableEntry<TEntryKey, TEntryValue> {
        constructor(public Key: TEntryKey,
                    public Value: TEntryValue,
                    public HashCode: number,
                    public Next: HashTableEntry<TEntryKey,TEntryValue>) {
        }
    }

    export class HashTable<TKey, TValue> {
        private entries: HashTableEntry<TKey, TValue>[];
        private count: number = 0;

        constructor(capacity: number,
                    private hash: (k: TKey) => number) {
            var size = Hash.getPrime(capacity);
            this.entries = ArrayUtilities.createArray<HashTableEntry<TKey, TValue>>(size, null);
        }

        // Maps 'key' to 'value' in this table.  Does not throw if 'key' is already in the table.
        public set (key: TKey, value: TValue): void {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ false);
        }

        // Maps 'key' to 'value' in this table.  Throws if 'key' is already in the table.
        public add(key: TKey, value: TValue): void {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ true);
        }

        public containsKey(key: TKey): boolean {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            return entry !== null;
        }

        public get (key: TKey): TValue {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);

            return entry === null ? null : entry.Value;
        }

        private computeHashCode(key: TKey): number {
            var hashCode: number = this.hash === null
                ? (<any>key).hashCode
                : this.hash(key);

            hashCode = hashCode & 0x7FFFFFFF;
            Debug.assert(hashCode >= 0);

            return hashCode;
        }

        private addOrSet(key: TKey, value: TValue, throwOnExistingEntry: boolean): TKey {
            // Compute the hash for this key.  Also ensure that it's non negative.
            var hashCode = this.computeHashCode(key);

            var entry = this.findEntry(key, hashCode);
            if (entry !== null) {
                if (throwOnExistingEntry) {
                    throw Errors.argument('key', "Key was already in table.");
                }

                entry.Key = key;
                entry.Value = value;
                return;
            }

            return this.addEntry(key, value, hashCode);
        }

        private findEntry(key: TKey, hashCode: number): HashTableEntry<TKey, TValue> {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode &&
                    key === e.Key) {

                    return e;
                }
            }

            return null;
        }

        private addEntry(key: TKey, value: TValue, hashCode: number): TKey {
            var index = hashCode % this.entries.length;

            var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

            this.entries[index] = e;

            if (this.count >= (this.entries.length / 2)) {
                this.grow();
            }

            this.count++;
            return e.Key;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("Hash table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            //this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: HashTableEntry<TKey, TValue>[] = ArrayUtilities.createArray<HashTableEntry<TKey, TValue>>(newSize, null);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];

                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            //this.dumpStats();
        }
    }

    export function createHashTable<TKey,TValue>(capacity: number = DefaultHashTableCapacity,
                                                 hash: (k: TKey) => number = null): HashTable<TKey,TValue> {
        return new HashTable<TKey,TValue>(capacity, hash);
    }

    var currentHashCode = 1;
    export function identityHashCode(value: any): number {
        if (value.__hash === undefined) {
            value.__hash = currentHashCode;
            currentHashCode++;
        }

        return value.__hash;
    }
}
///<reference path='references.ts'/>

module TypeScript {
    export interface IIndexable<T> {
        [s: string]: T;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export module IntegerUtilities {
        export function integerDivide(numerator: number, denominator: number): number {
            return (numerator / denominator) >> 0;
        }

        export function integerMultiplyLow32Bits(n1: number, n2: number): number {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }

        export function integerMultiplyHigh32Bits(n1: number, n2: number): number {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        }

        export function isInteger(text: string): boolean {
            return /^[0-9]+$/.test(text);
        }

        export function isHexInteger(text: string): boolean {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
    }
}
/// <reference path='references.ts' />

module TypeScript {
    export interface Iterator<T> {
        moveNext(): boolean;
        current(): T;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ILineAndCharacter {
        line: number;
        character: number;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class LineMap {
        public static empty = new LineMap(() => [0], 0);
        private _lineStarts: number[] = null;

        constructor(private _computeLineStarts: () => number[], private length: number) {
        }

        public toJSON(key: any) {
            return { lineStarts: this.lineStarts(), length: this.length };
        }

        public equals(other: LineMap): boolean {
            return this.length === other.length &&
                   ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), (v1, v2) => v1 === v2);
        }

        public lineStarts(): number[] {
            if (this._lineStarts === null) {
                this._lineStarts = this._computeLineStarts();
            }

            return this._lineStarts;
        }

        public lineCount(): number {
            return this.lineStarts().length;
        }

        public getPosition(line: number, character: number): number {
            return this.lineStarts()[line] + character;
        }

        public getLineNumberFromPosition(position: number): number {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }

            // Binary search to find the right line
            var lineNumber = ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        }

        public getLineStartPosition(lineNumber: number): number {
            return this.lineStarts()[lineNumber];
        }

        public fillLineAndCharacterFromPosition(position: number, lineAndCharacter: ILineAndCharacter): void {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        }

        public getLineAndCharacterFromPosition(position: number): LineAndCharacter {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class LineAndCharacter {
        private _line: number = 0;
        private _character: number = 0;

        /**
         * Initializes a new instance of a LinePosition with the given line and character. ArgumentOutOfRangeException if "line" or "character" is less than zero.
         * @param line The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
         * @param character The character position in the line.
         */
        
        constructor(line: number, character: number) {
            if (line < 0) {
                throw Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }

        public line(): number {
            return this._line;
        }

        public character(): number {
            return this._character;
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class MathPrototype {
        public static max(a: number, b: number): number {
            return a >= b ? a : b;
        }

        public static min(a: number, b: number): number {
            return a <= b ? a : b;
        }
    }
}
///<reference path='require.ts' />

///<reference path='..\resources\references.ts' />

///<reference path='arrayUtilities.ts' />
///<reference path='bitVector.ts' />
///<reference path='bitMatrix.ts' />
///<reference path='constants.ts' />
///<reference path='debug.ts' />
///<reference path='diagnosticCategory.ts' />
///<reference path='diagnosticCore.ts' />
///<reference path='diagnosticInfo.ts' />
///<reference path='errors.ts' />
///<reference path='hash.ts' />
// ///<reference path='hashTable.ts' />
///<reference path='environment.ts' />
///<reference path='indexable.ts' />
///<reference path='integerUtilities.ts' />
///<reference path='iterator.ts' />
///<reference path='lineAndCharacter.ts' />
///<reference path='lineMap.ts' />
///<reference path='linePosition.ts' />
///<reference path='mathPrototype.ts' />
// ///<reference path='stringTable.ts' />
///<reference path='stringUtilities.ts' />
///<reference path='timer.ts' />
///<reference path='references.ts' />

// Forward declarations of the variables we use from 'node'.
declare var require: any;
declare var module: any;
///<reference path='references.ts' />

module TypeScript.Collections {
    export var DefaultStringTableCapacity = 256;

    class StringTableEntry {
        constructor(public Text: string,
                    public HashCode: number,
                    public Next: StringTableEntry) {
        }
    }

    // A table of interned strings.  Faster and better than an arbitrary hashtable for the needs of the
    // scanner. Specifically, the scanner operates over a sliding window of characters, with a start 
    // and end pointer for the current lexeme.  The scanner then wants to get the *interned* string
    // represented by that subsection.
    //
    // Importantly, if the string is already interned, then it wants ask "is the string represented by 
    // this section of a char array contained within the table" in a non-allocating fashion.  i.e. if 
    // you have "[' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ']" and you ask to get the string represented by
    //  range [1, 7), then this table will return "public" without any allocations if that value was 
    // already in the table.
    //
    // Of course, if the value is not in the table then there will be an initial cost to allocate the 
    // string and the bucket for the table.  However, that is only incurred the first time each unique 
    // string is added.
    export class StringTable {
        // TODO: uncomment this once typecheck bug is fixed.
        private entries: StringTableEntry[];
        private count: number = 0;

        constructor(capacity: number) {
            var size = Hash.getPrime(capacity);
            this.entries = ArrayUtilities.createArray<StringTableEntry>(size, null);
        }

        public addCharArray(key: number[], start: number, len: number): string {
            // Compute the hash for this key.  Also ensure that it fits within 31 bits  (so that it 
            // stays a non-heap integer, and so we can index into the array safely).
            var hashCode = Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
            // Debug.assert(hashCode > 0);

            // First see if we already have the string represented by "key[start, start + len)" already
            // present in this table.  If we do, just return that string.  Do this without any 
            // allocations
            var entry = this.findCharArrayEntry(key, start, len, hashCode);
            if (entry !== null) {
                return entry.Text;
            }

            // We don't have an entry for that string in our table.  Convert that 
            var slice: number[] = key.slice(start, start + len);
            return this.addEntry(StringUtilities.fromCharCodeArray(slice), hashCode);
        }

        private findCharArrayEntry(key: number[], start: number, len: number, hashCode: number) {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                    return e;
                }
            }

            return null;
        }

        private addEntry(text: string, hashCode: number): string {
            var index = hashCode % this.entries.length;

            var e = new StringTableEntry(text, hashCode, this.entries[index]);

            this.entries[index] = e;

            // We grow when our load factor equals 1.  I tried different load factors (like .75 and 
            // .5), however they seemed to have no effect on running time.  With a load factor of 1
            // we seem to get about 80% slot fill rate with an average of around 1.25 table entries 
            // per slot.
            if (this.count === this.entries.length) {
                this.grow();
            }

            this.count++;
            return e.Text;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("String table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var longestSlot = 0;
        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;

        //            var current = this.entries[i];
        //            var slotCount = 0;
        //            while (current !== null) {
        //                slotCount++;
        //                current = current.Next;
        //            }

        //            longestSlot = MathPrototype.max(longestSlot, slotCount);
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Longest  slot    : " + longestSlot);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            // this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: StringTableEntry[] = ArrayUtilities.createArray<StringTableEntry>(newSize, null);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];
                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            // this.dumpStats();
        }

        private static textCharArrayEquals(text: string, array: number[], start: number, length: number): boolean {
            if (text.length !== length) {
                return false;
            }

            var s = start;
            for (var i = 0; i < length; i++) {
                if (text.charCodeAt(i) !== array[s]) {
                    return false;
                }

                s++;
            }

            return true;
        }
    }

    export var DefaultStringTable = new StringTable(DefaultStringTableCapacity);
}
///<reference path='references.ts' />

module TypeScript {
    export class StringUtilities {
        public static isString(value: any): boolean {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        }

        public static endsWith(string: string, value: string): boolean {
            return string.substring(string.length - value.length, string.length) === value;
        }

        public static startsWith(string: string, value: string): boolean {
            return string.substr(0, value.length) === value;
        }

        public static copyTo(source: string, sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        }

        public static repeat(value: string, count: number) {
            return Array(count + 1).join(value);
        }
    }
}
///<reference path='references.ts' />

var global: any = <any>Function("return this").call(null);

module TypeScript {
    module Clock {
        export var now: () => number;
        export var resolution: number;

        declare module WScript {
            export function InitializeProjection(): void;
        }

        declare module TestUtilities {
            export function QueryPerformanceCounter(): number;
            export function QueryPerformanceFrequency(): number;
        }

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            // Running in JSHost.
            global['WScript'].InitializeProjection();

            now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };

            resolution = TestUtilities.QueryPerformanceFrequency();
        }
         else {
            now = function () {
                return Date.now();
            };

            resolution = 1000;
        }
    }

    export class Timer {
        public startTime: number;
        public time = 0;

        public start() {
            this.time = 0;
            this.startTime = Clock.now();
        }

        public end() {
            // Set time to MS.
            this.time = (Clock.now() - this.startTime);
        }
    }
}
// <auto-generated />
module TypeScript {
    export var DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_separator_not_allowed: "Trailing separator not allowed.",
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        Rest_parameter_must_be_last_in_list: "Rest parameter must be last in list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        Required_parameter_cannot_follow_optional_parameter: "Required parameter cannot follow optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        Implementations_are_not_allowed_in_ambient_contexts: "Implementations are not allowed in ambient contexts.",
        declare_modifier_not_allowed_for_code_already_in_an_ambient_context: "'declare' modifier not allowed for code already in an ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        Parameter_property_declarations_can_only_be_used_in_a_non_ambient_constructor_declaration: "Parameter property declarations can only be used in a non-ambient constructor declaration.",
        Function_implementation_expected: "Function implementation expected.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        declare_modifier_cannot_appear_on_an_interface_declaration: "'declare' modifier cannot appear on an interface declaration.",
        declare_modifier_required_for_top_level_element: "'declare' modifier required for top level element.",
        Rest_parameter_cannot_be_optional: "Rest parameter cannot be optional.",
        Rest_parameter_cannot_have_an_initializer: "Rest parameter cannot have an initializer.",
        set_accessor_must_have_one_and_only_one_parameter: "'set' accessor must have one and only one parameter.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        Module_cannot_have_multiple_export_assignments: "Module cannot have multiple export assignments.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        declare_modifier_not_allowed_on_import_declaration: "'declare' modifier not allowed on import declaration.",
        Function_overload_must_be_static: "Function overload must be static.",
        Function_overload_must_not_be_static: "Function overload must not be static.",
        Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: "Parameter property declarations cannot be used in a constructor overload.",
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: "Octal literals are not available when targeting ECMAScript 5 and higher.",
        Accessors_are_not_allowed_in_ambient_contexts: "Accessors are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_constructor_declaration: "'{0}' modifier cannot appear on a constructor declaration.",
        _0_modifier_cannot_appear_on_a_parameter: "'{0}' modifier cannot appear on a parameter.",
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: "Only a single variable declaration is allowed in a 'for...in' statement.",
        Type_parameters_cannot_appear_on_a_constructor_declaration: "Type parameters cannot appear on a constructor declaration.",
        Type_annotation_cannot_appear_on_a_constructor_declaration: "Type annotation cannot appear on a constructor declaration.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        Value_of_type_0_is_not_indexable_by_type_1: "Value of type '{0}' is not indexable by type '{1}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2_3: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
        Cannot_convert_0_to_1: "Cannot convert '{0}' to '{1}'.",
        Cannot_convert_0_to_1_NL_2: "Cannot convert '{0}' to '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Operator_0_cannot_be_applied_to_type_1: "Operator '{0}' cannot be applied to type '{1}'.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Unable_to_resolve_external_module_0: "Unable to resolve external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_another_class_or_interface: "An interface may only extend another class or interface.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Invalid_new_expression: "Invalid 'new' expression.",
        Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: "Call signatures used in a 'new' expression must have a 'void' return type.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        The_property_0_does_not_exist_on_value_of_type_1: "The property '{0}' does not exist on value of type '{1}'.",
        Could_not_find_symbol_0: "Could not find symbol '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_members_cannot_reference_class_type_parameters: "Static members cannot reference class type parameters.",
        Class_0_is_recursively_referenced_as_a_base_type_of_itself: "Class '{0}' is recursively referenced as a base type of itself.",
        Interface_0_is_recursively_referenced_as_a_base_type_of_itself: "Interface '{0}' is recursively referenced as a base type of itself.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_cannot_be_referenced_in_non_derived_classes: "'super' cannot be referenced in non-derived classes.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: "Super calls are not permitted outside constructors or in nested functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_within_module_bodies: "'this' cannot be referenced within module bodies.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Type_0_does_not_have_type_parameters: "Type '{0}' does not have type parameters.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_static_initializers_in_a_class_body: "'this' cannot be referenced in static initializers in a class body.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_not_exported: "Overload signatures must all be exported or not exported.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: "Specialized overload signature is not assignable to any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        Rest_parameters_must_be_array_types: "Rest parameters must be array types.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0: "All numerically named properties must be assignable to numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1: "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_assignable_to_string_indexer_type_0: "All named properties must be assignable to string indexer type '{0}'.",
        All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1: "All named properties must be assignable to string indexer type '{0}':{NL}{1}",
        Generic_type_references_must_include_all_type_arguments: "Generic type references must include all type arguments.",
        Default_arguments_are_only_allowed_in_implementation: "Default arguments are only allowed in implementation.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Could_not_find_symbol_0_in_module_1: "Could not find symbol '{0}' in module '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1: "Type name '{0}' in extends clause does not reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: "Ambient external module declaration cannot be reopened.",
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: "Return type of constructor signature must be assignable to the instance type of the class.",
        Ambient_external_module_declaration_must_be_defined_in_global_context: "Ambient external module declaration must be defined in global context.",
        Ambient_external_module_declaration_cannot_specify_relative_module_name: "Ambient external module declaration cannot specify relative module name.",
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.",
        Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions: "Could not find the best common type of types of all return statement expressions.",
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: "Import declaration cannot refer to external module reference when --noResolve option is set.",
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: "Jump target not found.",
        Jump_target_cannot_cross_function_boundary: "Jump target cannot cross function boundary.",
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.",
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.",
        Type_of_conditional_0_must_be_identical_to_1_or_2: "Type of conditional '{0}' must be identical to '{1}' or '{2}'.",
        Type_of_conditional_0_must_be_identical_to_1_2_or_3: "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.",
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.",
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.",
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.",
        Parameter_0_cannot_be_referenced_in_its_initializer: "Parameter '{0}' cannot be referenced in its initializer.",
        Duplicate_string_index_signature: "Duplicate string index signature.",
        Duplicate_number_index_signature: "Duplicate number index signature.",
        All_declarations_of_an_interface_must_have_identical_type_parameters: "All declarations of an interface must have identical type parameters.",
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element: "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: "Variable declaration cannot have the same name as an import declaration.",
        Signature_expected_0_type_arguments_got_1_instead: "Signature expected {0} type arguments, got {1} instead.",
        Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type: "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}",
        Named_properties_0_of_types_1_and_2_are_not_identical: "Named properties '{0}' of types '{1}' and '{2}' are not identical.",
        Types_of_string_indexer_of_types_0_and_1_are_not_identical: "Types of string indexer of types '{0}' and '{1}' are not identical.",
        Types_of_number_indexer_of_types_0_and_1_are_not_identical: "Types of number indexer of types '{0}' and '{1}' are not identical.",
        Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2: "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}",
        Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}",
        Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}",
        Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_static_property_2_as_private: "Types '{0}' and '{1}' define static property '{2}' as private.",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Module_code_generation_0_not_supported: "Module code generation '{0}' not supported.",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Unknown_option_0: "Unknown option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead.",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file.",
        Generates_corresponding_0_file: "Generates corresponding {0} file.",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files.",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory.",
        Do_not_emit_comments_to_output: "Do not emit comments to output.",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing.",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: "Print this message.",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file1: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        file2: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        NUMBER: "NUMBER",
        Specify_the_codepage_to_use_when_opening_source_files: "Specify the codepage to use when opening source files.",
        Additional_locations: "Additional locations:",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Unknown_rule: "Unknown rule.",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening.",
        _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.",
        Index_signature_of_object_type_implicitly_has_an_any_type: "Index signature of object type implicitly has an 'any' type.",
        Object_literal_s_property_0_implicitly_has_an_any_type_from_widening: "Object literal's property '{0}' implicitly has an 'any' type from widening.",
    };
}
// <auto-generated />
/// <reference path="..\core\diagnosticCategory.ts" />
module TypeScript {
  export var diagnosticInformationMap: IIndexable<any> = {
    "error TS{0}: {1}": { "code": 0, "category": DiagnosticCategory.NoPrefix },
    "warning TS{0}: {1}": { "code": 1, "category": DiagnosticCategory.NoPrefix },
    "Unrecognized escape sequence.": { "code": 1000, "category": DiagnosticCategory.Error },
    "Unexpected character {0}.": { "code": 1001, "category": DiagnosticCategory.Error },
    "Missing close quote character.": { "code": 1002, "category": DiagnosticCategory.Error },
    "Identifier expected.": { "code": 1003, "category": DiagnosticCategory.Error },
    "'{0}' keyword expected.": { "code": 1004, "category": DiagnosticCategory.Error },
    "'{0}' expected.": { "code": 1005, "category": DiagnosticCategory.Error },
    "Identifier expected; '{0}' is a keyword.": { "code": 1006, "category": DiagnosticCategory.Error },
    "Automatic semicolon insertion not allowed.": { "code": 1007, "category": DiagnosticCategory.Error },
    "Unexpected token; '{0}' expected.": { "code": 1008, "category": DiagnosticCategory.Error },
    "Trailing separator not allowed.": { "code": 1009, "category": DiagnosticCategory.Error },
    "'*/' expected.": { "code": 1010, "category": DiagnosticCategory.Error },
    "'public' or 'private' modifier must precede 'static'.": { "code": 1011, "category": DiagnosticCategory.Error },
    "Unexpected token.": { "code": 1012, "category": DiagnosticCategory.Error },
    "Catch clause parameter cannot have a type annotation.": { "code": 1013, "category": DiagnosticCategory.Error },
    "Rest parameter must be last in list.": { "code": 1014, "category": DiagnosticCategory.Error },
    "Parameter cannot have question mark and initializer.": { "code": 1015, "category": DiagnosticCategory.Error },
    "Required parameter cannot follow optional parameter.": { "code": 1016, "category": DiagnosticCategory.Error },
    "Index signatures cannot have rest parameters.": { "code": 1017, "category": DiagnosticCategory.Error },
    "Index signature parameter cannot have accessibility modifiers.": { "code": 1018, "category": DiagnosticCategory.Error },
    "Index signature parameter cannot have a question mark.": { "code": 1019, "category": DiagnosticCategory.Error },
    "Index signature parameter cannot have an initializer.": { "code": 1020, "category": DiagnosticCategory.Error },
    "Index signature must have a type annotation.": { "code": 1021, "category": DiagnosticCategory.Error },
    "Index signature parameter must have a type annotation.": { "code": 1022, "category": DiagnosticCategory.Error },
    "Index signature parameter type must be 'string' or 'number'.": { "code": 1023, "category": DiagnosticCategory.Error },
    "'extends' clause already seen.": { "code": 1024, "category": DiagnosticCategory.Error },
    "'extends' clause must precede 'implements' clause.": { "code": 1025, "category": DiagnosticCategory.Error },
    "Classes can only extend a single class.": { "code": 1026, "category": DiagnosticCategory.Error },
    "'implements' clause already seen.": { "code": 1027, "category": DiagnosticCategory.Error },
    "Accessibility modifier already seen.": { "code": 1028, "category": DiagnosticCategory.Error },
    "'{0}' modifier must precede '{1}' modifier.": { "code": 1029, "category": DiagnosticCategory.Error },
    "'{0}' modifier already seen.": { "code": 1030, "category": DiagnosticCategory.Error },
    "'{0}' modifier cannot appear on a class element.": { "code": 1031, "category": DiagnosticCategory.Error },
    "Interface declaration cannot have 'implements' clause.": { "code": 1032, "category": DiagnosticCategory.Error },
    "'super' invocation cannot have type arguments.": { "code": 1034, "category": DiagnosticCategory.Error },
    "Only ambient modules can use quoted names.": { "code": 1035, "category": DiagnosticCategory.Error },
    "Statements are not allowed in ambient contexts.": { "code": 1036, "category": DiagnosticCategory.Error },
    "Implementations are not allowed in ambient contexts.": { "code": 1037, "category": DiagnosticCategory.Error },
    "'declare' modifier not allowed for code already in an ambient context.": { "code": 1038, "category": DiagnosticCategory.Error },
    "Initializers are not allowed in ambient contexts.": { "code": 1039, "category": DiagnosticCategory.Error },
    "Parameter property declarations can only be used in a non-ambient constructor declaration.": { "code": 1040, "category": DiagnosticCategory.Error },
    "Function implementation expected.": { "code": 1041, "category": DiagnosticCategory.Error },
    "Constructor implementation expected.": { "code": 1042, "category": DiagnosticCategory.Error },
    "Function overload name must be '{0}'.": { "code": 1043, "category": DiagnosticCategory.Error },
    "'{0}' modifier cannot appear on a module element.": { "code": 1044, "category": DiagnosticCategory.Error },
    "'declare' modifier cannot appear on an interface declaration.": { "code": 1045, "category": DiagnosticCategory.Error },
    "'declare' modifier required for top level element.": { "code": 1046, "category": DiagnosticCategory.Error },
    "Rest parameter cannot be optional.": { "code": 1047, "category": DiagnosticCategory.Error },
    "Rest parameter cannot have an initializer.": { "code": 1048, "category": DiagnosticCategory.Error },
    "'set' accessor must have one and only one parameter.": { "code": 1049, "category": DiagnosticCategory.Error },
    "'set' accessor parameter cannot be optional.": { "code": 1051, "category": DiagnosticCategory.Error },
    "'set' accessor parameter cannot have an initializer.": { "code": 1052, "category": DiagnosticCategory.Error },
    "'set' accessor cannot have rest parameter.": { "code": 1053, "category": DiagnosticCategory.Error },
    "'get' accessor cannot have parameters.": { "code": 1054, "category": DiagnosticCategory.Error },
    "Modifiers cannot appear here.": { "code": 1055, "category": DiagnosticCategory.Error },
    "Accessors are only available when targeting ECMAScript 5 and higher.": { "code": 1056, "category": DiagnosticCategory.Error },
    "Class name cannot be '{0}'.": { "code": 1057, "category": DiagnosticCategory.Error },
    "Interface name cannot be '{0}'.": { "code": 1058, "category": DiagnosticCategory.Error },
    "Enum name cannot be '{0}'.": { "code": 1059, "category": DiagnosticCategory.Error },
    "Enum member must have initializer.": { "code": 1061, "category": DiagnosticCategory.Error },
    "Export assignment cannot be used in internal modules.": { "code": 1063, "category": DiagnosticCategory.Error },
    "Export assignment not allowed in module with exported element.": { "code": 1064, "category": DiagnosticCategory.Error },
    "Module cannot have multiple export assignments.": { "code": 1065, "category": DiagnosticCategory.Error },
    "Ambient enum elements can only have integer literal initializers.": { "code": 1066, "category": DiagnosticCategory.Error },
    "module, class, interface, enum, import or statement": { "code": 1067, "category": DiagnosticCategory.NoPrefix },
    "constructor, function, accessor or variable": { "code": 1068, "category": DiagnosticCategory.NoPrefix },
    "statement": { "code": 1069, "category": DiagnosticCategory.NoPrefix },
    "case or default clause": { "code": 1070, "category": DiagnosticCategory.NoPrefix },
    "identifier": { "code": 1071, "category": DiagnosticCategory.NoPrefix },
    "call, construct, index, property or function signature": { "code": 1072, "category": DiagnosticCategory.NoPrefix },
    "expression": { "code": 1073, "category": DiagnosticCategory.NoPrefix },
    "type name": { "code": 1074, "category": DiagnosticCategory.NoPrefix },
    "property or accessor": { "code": 1075, "category": DiagnosticCategory.NoPrefix },
    "parameter": { "code": 1076, "category": DiagnosticCategory.NoPrefix },
    "type": { "code": 1077, "category": DiagnosticCategory.NoPrefix },
    "type parameter": { "code": 1078, "category": DiagnosticCategory.NoPrefix },
    "'declare' modifier not allowed on import declaration.": { "code": 1079, "category": DiagnosticCategory.Error },
    "Function overload must be static.": { "code": 1080, "category": DiagnosticCategory.Error },
    "Function overload must not be static.": { "code": 1081, "category": DiagnosticCategory.Error },
    "Parameter property declarations cannot be used in a constructor overload.": { "code": 1083, "category": DiagnosticCategory.Error },
    "Invalid 'reference' directive syntax.": { "code": 1084, "category": DiagnosticCategory.Error },
    "Octal literals are not available when targeting ECMAScript 5 and higher.": { "code": 1085, "category": DiagnosticCategory.Error },
    "Accessors are not allowed in ambient contexts.": { "code": 1086, "category": DiagnosticCategory.Error },
    "'{0}' modifier cannot appear on a constructor declaration.": { "code": 1089, "category": DiagnosticCategory.Error },
    "'{0}' modifier cannot appear on a parameter.": { "code": 1090, "category": DiagnosticCategory.Error },
    "Only a single variable declaration is allowed in a 'for...in' statement.": { "code": 1091, "category": DiagnosticCategory.Error },
    "Type parameters cannot appear on a constructor declaration.": { "code": 1091, "category": DiagnosticCategory.Error },
    "Type annotation cannot appear on a constructor declaration.": { "code": 1092, "category": DiagnosticCategory.Error },
    "Duplicate identifier '{0}'.": { "code": 2000, "category": DiagnosticCategory.Error },
    "The name '{0}' does not exist in the current scope.": { "code": 2001, "category": DiagnosticCategory.Error },
    "The name '{0}' does not refer to a value.": { "code": 2002, "category": DiagnosticCategory.Error },
    "'super' can only be used inside a class instance method.": { "code": 2003, "category": DiagnosticCategory.Error },
    "The left-hand side of an assignment expression must be a variable, property or indexer.": { "code": 2004, "category": DiagnosticCategory.Error },
    "Value of type '{0}' is not callable. Did you mean to include 'new'?": { "code": 2161, "category": DiagnosticCategory.Error },
    "Value of type '{0}' is not callable.": { "code": 2006, "category": DiagnosticCategory.Error },
    "Value of type '{0}' is not newable.": { "code": 2007, "category": DiagnosticCategory.Error },
    "Value of type '{0}' is not indexable by type '{1}'.": { "code": 2008, "category": DiagnosticCategory.Error },
    "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": { "code": 2009, "category": DiagnosticCategory.Error },
    "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": { "code": 2010, "category": DiagnosticCategory.Error },
    "Cannot convert '{0}' to '{1}'.": { "code": 2011, "category": DiagnosticCategory.Error },
    "Cannot convert '{0}' to '{1}':{NL}{2}": { "code": 2012, "category": DiagnosticCategory.Error },
    "Expected var, class, interface, or module.": { "code": 2013, "category": DiagnosticCategory.Error },
    "Operator '{0}' cannot be applied to type '{1}'.": { "code": 2014, "category": DiagnosticCategory.Error },
    "Getter '{0}' already declared.": { "code": 2015, "category": DiagnosticCategory.Error },
    "Setter '{0}' already declared.": { "code": 2016, "category": DiagnosticCategory.Error },
    "Exported class '{0}' extends private class '{1}'.": { "code": 2018, "category": DiagnosticCategory.Error },
    "Exported class '{0}' implements private interface '{1}'.": { "code": 2019, "category": DiagnosticCategory.Error },
    "Exported interface '{0}' extends private interface '{1}'.": { "code": 2020, "category": DiagnosticCategory.Error },
    "Exported class '{0}' extends class from inaccessible module {1}.": { "code": 2021, "category": DiagnosticCategory.Error },
    "Exported class '{0}' implements interface from inaccessible module {1}.": { "code": 2022, "category": DiagnosticCategory.Error },
    "Exported interface '{0}' extends interface from inaccessible module {1}.": { "code": 2023, "category": DiagnosticCategory.Error },
    "Public static property '{0}' of exported class has or is using private type '{1}'.": { "code": 2024, "category": DiagnosticCategory.Error },
    "Public property '{0}' of exported class has or is using private type '{1}'.": { "code": 2025, "category": DiagnosticCategory.Error },
    "Property '{0}' of exported interface has or is using private type '{1}'.": { "code": 2026, "category": DiagnosticCategory.Error },
    "Exported variable '{0}' has or is using private type '{1}'.": { "code": 2027, "category": DiagnosticCategory.Error },
    "Public static property '{0}' of exported class is using inaccessible module {1}.": { "code": 2028, "category": DiagnosticCategory.Error },
    "Public property '{0}' of exported class is using inaccessible module {1}.": { "code": 2029, "category": DiagnosticCategory.Error },
    "Property '{0}' of exported interface is using inaccessible module {1}.": { "code": 2030, "category": DiagnosticCategory.Error },
    "Exported variable '{0}' is using inaccessible module {1}.": { "code": 2031, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": { "code": 2032, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": { "code": 2033, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": { "code": 2034, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2035, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2036, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2037, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2038, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2039, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2040, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": { "code": 2041, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": { "code": 2042, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": { "code": 2043, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2044, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2045, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2046, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2047, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2048, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2049, "category": DiagnosticCategory.Error },
    "Return type of public static property getter from exported class has or is using private type '{0}'.": { "code": 2050, "category": DiagnosticCategory.Error },
    "Return type of public property getter from exported class has or is using private type '{0}'.": { "code": 2051, "category": DiagnosticCategory.Error },
    "Return type of constructor signature from exported interface has or is using private type '{0}'.": { "code": 2052, "category": DiagnosticCategory.Error },
    "Return type of call signature from exported interface has or is using private type '{0}'.": { "code": 2053, "category": DiagnosticCategory.Error },
    "Return type of index signature from exported interface has or is using private type '{0}'.": { "code": 2054, "category": DiagnosticCategory.Error },
    "Return type of public static method from exported class has or is using private type '{0}'.": { "code": 2055, "category": DiagnosticCategory.Error },
    "Return type of public method from exported class has or is using private type '{0}'.": { "code": 2056, "category": DiagnosticCategory.Error },
    "Return type of method from exported interface has or is using private type '{0}'.": { "code": 2057, "category": DiagnosticCategory.Error },
    "Return type of exported function has or is using private type '{0}'.": { "code": 2058, "category": DiagnosticCategory.Error },
    "Return type of public static property getter from exported class is using inaccessible module {0}.": { "code": 2059, "category": DiagnosticCategory.Error },
    "Return type of public property getter from exported class is using inaccessible module {0}.": { "code": 2060, "category": DiagnosticCategory.Error },
    "Return type of constructor signature from exported interface is using inaccessible module {0}.": { "code": 2061, "category": DiagnosticCategory.Error },
    "Return type of call signature from exported interface is using inaccessible module {0}.": { "code": 2062, "category": DiagnosticCategory.Error },
    "Return type of index signature from exported interface is using inaccessible module {0}.": { "code": 2063, "category": DiagnosticCategory.Error },
    "Return type of public static method from exported class is using inaccessible module {0}.": { "code": 2064, "category": DiagnosticCategory.Error },
    "Return type of public method from exported class is using inaccessible module {0}.": { "code": 2065, "category": DiagnosticCategory.Error },
    "Return type of method from exported interface is using inaccessible module {0}.": { "code": 2066, "category": DiagnosticCategory.Error },
    "Return type of exported function is using inaccessible module {0}.": { "code": 2067, "category": DiagnosticCategory.Error },
    "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": { "code": 2068, "category": DiagnosticCategory.Error },
    "A parameter list must follow a generic type argument list. '(' expected.": { "code": 2069, "category": DiagnosticCategory.Error },
    "Multiple constructor implementations are not allowed.": { "code": 2070, "category": DiagnosticCategory.Error },
    "Unable to resolve external module '{0}'.": { "code": 2071, "category": DiagnosticCategory.Error },
    "Module cannot be aliased to a non-module type.": { "code": 2072, "category": DiagnosticCategory.Error },
    "A class may only extend another class.": { "code": 2073, "category": DiagnosticCategory.Error },
    "A class may only implement another class or interface.": { "code": 2074, "category": DiagnosticCategory.Error },
    "An interface may only extend another class or interface.": { "code": 2075, "category": DiagnosticCategory.Error },
    "Unable to resolve type.": { "code": 2077, "category": DiagnosticCategory.Error },
    "Unable to resolve type of '{0}'.": { "code": 2078, "category": DiagnosticCategory.Error },
    "Unable to resolve type parameter constraint.": { "code": 2079, "category": DiagnosticCategory.Error },
    "Type parameter constraint cannot be a primitive type.": { "code": 2080, "category": DiagnosticCategory.Error },
    "Supplied parameters do not match any signature of call target.": { "code": 2081, "category": DiagnosticCategory.Error },
    "Supplied parameters do not match any signature of call target:{NL}{0}": { "code": 2082, "category": DiagnosticCategory.Error },
    "Invalid 'new' expression.": { "code": 2083, "category": DiagnosticCategory.Error },
    "Call signatures used in a 'new' expression must have a 'void' return type.": { "code": 2084, "category": DiagnosticCategory.Error },
    "Could not select overload for 'new' expression.": { "code": 2085, "category": DiagnosticCategory.Error },
    "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": { "code": 2086, "category": DiagnosticCategory.Error },
    "Could not select overload for 'call' expression.": { "code": 2087, "category": DiagnosticCategory.Error },
    "Cannot invoke an expression whose type lacks a call signature.": { "code": 2088, "category": DiagnosticCategory.Error },
    "Calls to 'super' are only valid inside a class.": { "code": 2089, "category": DiagnosticCategory.Error },
    "Generic type '{0}' requires {1} type argument(s).": { "code": 2090, "category": DiagnosticCategory.Error },
    "Type of array literal cannot be determined. Best common type could not be found for array elements.": { "code": 2092, "category": DiagnosticCategory.Error },
    "Could not find enclosing symbol for dotted name '{0}'.": { "code": 2093, "category": DiagnosticCategory.Error },
    "The property '{0}' does not exist on value of type '{1}'.": { "code": 2094, "category": DiagnosticCategory.Error },
    "Could not find symbol '{0}'.": { "code": 2095, "category": DiagnosticCategory.Error },
    "'get' and 'set' accessor must have the same type.": { "code": 2096, "category": DiagnosticCategory.Error },
    "'this' cannot be referenced in current location.": { "code": 2097, "category": DiagnosticCategory.Error },
    "Static members cannot reference class type parameters.": { "code": 2099, "category": DiagnosticCategory.Error },
    "Class '{0}' is recursively referenced as a base type of itself.": { "code": 2100, "category": DiagnosticCategory.Error },
    "Interface '{0}' is recursively referenced as a base type of itself.": { "code": 2101, "category": DiagnosticCategory.Error },
    "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": { "code": 2102, "category": DiagnosticCategory.Error },
    "'super' cannot be referenced in non-derived classes.": { "code": 2103, "category": DiagnosticCategory.Error },
    "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": { "code": 2104, "category": DiagnosticCategory.Error },
    "Constructors for derived classes must contain a 'super' call.": { "code": 2105, "category": DiagnosticCategory.Error },
    "Super calls are not permitted outside constructors or in nested functions inside constructors.": { "code": 2106, "category": DiagnosticCategory.Error },
    "'{0}.{1}' is inaccessible.": { "code": 2107, "category": DiagnosticCategory.Error },
    "'this' cannot be referenced within module bodies.": { "code": 2108, "category": DiagnosticCategory.Error },
    "Invalid '+' expression - types not known to support the addition operator.": { "code": 2111, "category": DiagnosticCategory.Error },
    "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2112, "category": DiagnosticCategory.Error },
    "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2113, "category": DiagnosticCategory.Error },
    "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": { "code": 2114, "category": DiagnosticCategory.Error },
    "Variable declarations of a 'for' statement cannot use a type annotation.": { "code": 2115, "category": DiagnosticCategory.Error },
    "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": { "code": 2116, "category": DiagnosticCategory.Error },
    "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": { "code": 2117, "category": DiagnosticCategory.Error },
    "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": { "code": 2118, "category": DiagnosticCategory.Error },
    "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": { "code": 2119, "category": DiagnosticCategory.Error },
    "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": { "code": 2120, "category": DiagnosticCategory.Error },
    "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": { "code": 2121, "category": DiagnosticCategory.Error },
    "Setters cannot return a value.": { "code": 2122, "category": DiagnosticCategory.Error },
    "Tried to query type of uninitialized module '{0}'.": { "code": 2123, "category": DiagnosticCategory.Error },
    "Tried to set variable type to uninitialized module type '{0}'.": { "code": 2124, "category": DiagnosticCategory.Error },
    "Type '{0}' does not have type parameters.": { "code": 2125, "category": DiagnosticCategory.Error },
    "Getters must return a value.": { "code": 2126, "category": DiagnosticCategory.Error },
    "Getter and setter accessors do not agree in visibility.": { "code": 2127, "category": DiagnosticCategory.Error },
    "Invalid left-hand side of assignment expression.": { "code": 2130, "category": DiagnosticCategory.Error },
    "Function declared a non-void return type, but has no return expression.": { "code": 2131, "category": DiagnosticCategory.Error },
    "Cannot resolve return type reference.": { "code": 2132, "category": DiagnosticCategory.Error },
    "Constructors cannot have a return type of 'void'.": { "code": 2133, "category": DiagnosticCategory.Error },
    "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": { "code": 2134, "category": DiagnosticCategory.Error },
    "All symbols within a with block will be resolved to 'any'.": { "code": 2135, "category": DiagnosticCategory.Error },
    "Import declarations in an internal module cannot reference an external module.": { "code": 2136, "category": DiagnosticCategory.Error },
    "Class {0} declares interface {1} but does not implement it:{NL}{2}": { "code": 2137, "category": DiagnosticCategory.Error },
    "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": { "code": 2138, "category": DiagnosticCategory.Error },
    "The operand of an increment or decrement operator must be a variable, property or indexer.": { "code": 2139, "category": DiagnosticCategory.Error },
    "'this' cannot be referenced in static initializers in a class body.": { "code": 2140, "category": DiagnosticCategory.Error },
    "Class '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2141, "category": DiagnosticCategory.Error },
    "Interface '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2142, "category": DiagnosticCategory.Error },
    "Interface '{0}' cannot extend interface '{1}':{NL}{2}": { "code": 2143, "category": DiagnosticCategory.Error },
    "Overload signature is not compatible with function definition.": { "code": 2148, "category": DiagnosticCategory.Error },
    "Overload signature is not compatible with function definition:{NL}{0}": { "code": 2149, "category": DiagnosticCategory.Error },
    "Overload signatures must all be public or private.": { "code": 2150, "category": DiagnosticCategory.Error },
    "Overload signatures must all be exported or not exported.": { "code": 2151, "category": DiagnosticCategory.Error },
    "Overload signatures must all be ambient or non-ambient.": { "code": 2152, "category": DiagnosticCategory.Error },
    "Overload signatures must all be optional or required.": { "code": 2153, "category": DiagnosticCategory.Error },
    "Specialized overload signature is not assignable to any non-specialized signature.": { "code": 2154, "category": DiagnosticCategory.Error },
    "'this' cannot be referenced in constructor arguments.": { "code": 2155, "category": DiagnosticCategory.Error },
    "Instance member cannot be accessed off a class.": { "code": 2157, "category": DiagnosticCategory.Error },
    "Untyped function calls may not accept type arguments.": { "code": 2158, "category": DiagnosticCategory.Error },
    "Non-generic functions may not accept type arguments.": { "code": 2159, "category": DiagnosticCategory.Error },
    "A generic type may not reference itself with a wrapped form of its own type parameters.": { "code": 2160, "category": DiagnosticCategory.Error },
    "Rest parameters must be array types.": { "code": 2162, "category": DiagnosticCategory.Error },
    "Overload signature implementation cannot use specialized type.": { "code": 2163, "category": DiagnosticCategory.Error },
    "Export assignments may only be used at the top-level of external modules.": { "code": 2164, "category": DiagnosticCategory.Error },
    "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2165, "category": DiagnosticCategory.Error },
    "Only public methods of the base class are accessible via the 'super' keyword.": { "code": 2166, "category": DiagnosticCategory.Error },
    "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": { "code": 2167, "category": DiagnosticCategory.Error },
    "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": { "code": 2168, "category": DiagnosticCategory.Error },
    "All numerically named properties must be assignable to numeric indexer type '{0}'.": { "code": 2169, "category": DiagnosticCategory.Error },
    "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": { "code": 2170, "category": DiagnosticCategory.Error },
    "All named properties must be assignable to string indexer type '{0}'.": { "code": 2171, "category": DiagnosticCategory.Error },
    "All named properties must be assignable to string indexer type '{0}':{NL}{1}": { "code": 2172, "category": DiagnosticCategory.Error },
    "Generic type references must include all type arguments.": { "code": 2173, "category": DiagnosticCategory.Error },
    "Default arguments are only allowed in implementation.": { "code": 2174, "category": DiagnosticCategory.Error },
    "Function expression declared a non-void return type, but has no return expression.": { "code": 2176, "category": DiagnosticCategory.Error },
    "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2177, "category": DiagnosticCategory.Error },
    "Could not find symbol '{0}' in module '{1}'.": { "code": 2178, "category": DiagnosticCategory.Error },
    "Unable to resolve module reference '{0}'.": { "code": 2179, "category": DiagnosticCategory.Error },
    "Could not find module '{0}' in module '{1}'.": { "code": 2180, "category": DiagnosticCategory.Error },
    "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": { "code": 2181, "category": DiagnosticCategory.Error },
    "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": { "code": 2182, "category": DiagnosticCategory.Error },
    "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": { "code": 2183, "category": DiagnosticCategory.Error },
    "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": { "code": 2184, "category": DiagnosticCategory.Error },
    "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": { "code": 2185, "category": DiagnosticCategory.Error },
    "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": { "code": 2186, "category": DiagnosticCategory.Error },
    "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": { "code": 2187, "category": DiagnosticCategory.Error },
    "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": { "code": 2188, "category": DiagnosticCategory.Error },
    "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": { "code": 2189, "category": DiagnosticCategory.Error },
    "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": { "code": 2190, "category": DiagnosticCategory.Error },
    "Ambient external module declaration cannot be reopened.": { "code": 2191, "category": DiagnosticCategory.Error },
    "All declarations of merged declaration '{0}' must be exported or not exported.": { "code": 2192, "category": DiagnosticCategory.Error },
    "'super' cannot be referenced in constructor arguments.": { "code": 2193, "category": DiagnosticCategory.Error },
    "Return type of constructor signature must be assignable to the instance type of the class.": { "code": 2194, "category": DiagnosticCategory.Error },
    "Ambient external module declaration must be defined in global context.": { "code": 2195, "category": DiagnosticCategory.Error },
    "Ambient external module declaration cannot specify relative module name.": { "code": 2196, "category": DiagnosticCategory.Error },
    "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": { "code": 2197, "category": DiagnosticCategory.Error },
    "Could not find the best common type of types of all return statement expressions.": { "code": 2198, "category": DiagnosticCategory.Error },
    "Import declaration cannot refer to external module reference when --noResolve option is set.": { "code": 2199, "category": DiagnosticCategory.Error },
    "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": { "code": 2200, "category": DiagnosticCategory.Error },
    "'continue' statement can only be used within an enclosing iteration statement.": { "code": 2201, "category": DiagnosticCategory.Error },
    "'break' statement can only be used within an enclosing iteration or switch statement.": { "code": 2202, "category": DiagnosticCategory.Error },
    "Jump target not found.": { "code": 2203, "category": DiagnosticCategory.Error },
    "Jump target cannot cross function boundary.": { "code": 2204, "category": DiagnosticCategory.Error },
    "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": { "code": 2205, "category": DiagnosticCategory.Error },
    "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": { "code": 2206, "category": DiagnosticCategory.Error },
    "Expression resolves to '_super' that compiler uses to capture base class reference.": { "code": 2207, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2208, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2209, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2210, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2211, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2212, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2213, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2214, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2215, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2216, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2217, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2218, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2219, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported class has or is using private type '{1}'.": { "code": 2220, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": { "code": 2221, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported class is using inaccessible module {1}.": { "code": 2222, "category": DiagnosticCategory.Error },
    "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": { "code": 2223, "category": DiagnosticCategory.Error },
    "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": { "code": 2224, "category": DiagnosticCategory.Error },
    "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": { "code": 2225, "category": DiagnosticCategory.Error },
    "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": { "code": 2226, "category": DiagnosticCategory.Error },
    "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": { "code": 2227, "category": DiagnosticCategory.Error },
    "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": { "code": 2228, "category": DiagnosticCategory.Error },
    "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": { "code": 2229, "category": DiagnosticCategory.Error },
    "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": { "code": 2230, "category": DiagnosticCategory.Error },
    "Parameter '{0}' cannot be referenced in its initializer.": { "code": 2231, "category": DiagnosticCategory.Error },
    "Duplicate string index signature.": { "code": 2232, "category": DiagnosticCategory.Error },
    "Duplicate number index signature.": { "code": 2233, "category": DiagnosticCategory.Error },
    "All declarations of an interface must have identical type parameters.": { "code": 2234, "category": DiagnosticCategory.Error },
    "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": { "code": 2235, "category": DiagnosticCategory.Error },
    "Type '{0}' is missing property '{1}' from type '{2}'.": { "code": 4000, "category": DiagnosticCategory.NoPrefix },
    "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": { "code": 4001, "category": DiagnosticCategory.NoPrefix },
    "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": { "code": 4002, "category": DiagnosticCategory.NoPrefix },
    "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4003, "category": DiagnosticCategory.NoPrefix },
    "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4004, "category": DiagnosticCategory.NoPrefix },
    "Types '{0}' and '{1}' define property '{2}' as private.": { "code": 4005, "category": DiagnosticCategory.NoPrefix },
    "Call signatures of types '{0}' and '{1}' are incompatible.": { "code": 4006, "category": DiagnosticCategory.NoPrefix },
    "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4007, "category": DiagnosticCategory.NoPrefix },
    "Type '{0}' requires a call signature, but type '{1}' lacks one.": { "code": 4008, "category": DiagnosticCategory.NoPrefix },
    "Construct signatures of types '{0}' and '{1}' are incompatible.": { "code": 4009, "category": DiagnosticCategory.NoPrefix },
    "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4010, "category": DiagnosticCategory.NoPrefix },
    "Type '{0}' requires a construct signature, but type '{1}' lacks one.": { "code": 4011, "category": DiagnosticCategory.NoPrefix },
    "Index signatures of types '{0}' and '{1}' are incompatible.": { "code": 4012, "category": DiagnosticCategory.NoPrefix },
    "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4013, "category": DiagnosticCategory.NoPrefix },
    "Call signature expects {0} or fewer parameters.": { "code": 4014, "category": DiagnosticCategory.NoPrefix },
    "Could not apply type '{0}' to argument {1} which is of type '{2}'.": { "code": 4015, "category": DiagnosticCategory.NoPrefix },
    "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4016, "category": DiagnosticCategory.NoPrefix },
    "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4017, "category": DiagnosticCategory.NoPrefix },
    "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": { "code": 4018, "category": DiagnosticCategory.NoPrefix },
    "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": { "code": 4019, "category": DiagnosticCategory.NoPrefix },
    "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": { "code": 4020, "category": DiagnosticCategory.NoPrefix },
    "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": { "code": 4021, "category": DiagnosticCategory.NoPrefix },
    "Type reference cannot refer to container '{0}'.": { "code": 4022, "category": DiagnosticCategory.Error },
    "Type reference must refer to type.": { "code": 4023, "category": DiagnosticCategory.Error },
    "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": { "code": 4024, "category": DiagnosticCategory.Error },
    " (+ {0} overload(s))": { "code": 4025, "category": DiagnosticCategory.Message },
    "Variable declaration cannot have the same name as an import declaration.": { "code": 4026, "category": DiagnosticCategory.Error },
    "Signature expected {0} type arguments, got {1} instead.": { "code": 4027, "category": DiagnosticCategory.Error },
    "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": { "code": 4028, "category": DiagnosticCategory.NoPrefix },
    "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": { "code": 4029, "category": DiagnosticCategory.NoPrefix },
    "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": { "code": 4030, "category": DiagnosticCategory.NoPrefix },
    "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": { "code": 4031, "category": DiagnosticCategory.NoPrefix },
    "Named properties '{0}' of types '{1}' and '{2}' are not identical.": { "code": 4032, "category": DiagnosticCategory.NoPrefix },
    "Types of string indexer of types '{0}' and '{1}' are not identical.": { "code": 4033, "category": DiagnosticCategory.NoPrefix },
    "Types of number indexer of types '{0}' and '{1}' are not identical.": { "code": 4034, "category": DiagnosticCategory.NoPrefix },
    "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": { "code": 4035, "category": DiagnosticCategory.NoPrefix },
    "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": { "code": 4036, "category": DiagnosticCategory.NoPrefix },
    "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": { "code": 4037, "category": DiagnosticCategory.NoPrefix },
    "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4038, "category": DiagnosticCategory.NoPrefix },
    "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4039, "category": DiagnosticCategory.NoPrefix },
    "Types '{0}' and '{1}' define static property '{2}' as private.": { "code": 4040, "category": DiagnosticCategory.NoPrefix },
    "Current host does not support '{0}' option.": { "code": 5001, "category": DiagnosticCategory.Error },
    "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": { "code": 5002, "category": DiagnosticCategory.Error },
    "Module code generation '{0}' not supported.": { "code": 5003, "category": DiagnosticCategory.Error },
    "Could not find file: '{0}'.": { "code": 5004, "category": DiagnosticCategory.Error },
    "A file cannot have a reference to itself.": { "code": 5006, "category": DiagnosticCategory.Error },
    "Cannot resolve referenced file: '{0}'.": { "code": 5007, "category": DiagnosticCategory.Error },
    "Cannot find the common subdirectory path for the input files.": { "code": 5009, "category": DiagnosticCategory.Error },
    "Emit Error: {0}.": { "code": 5011, "category": DiagnosticCategory.Error },
    "Cannot read file '{0}': {1}": { "code": 5012, "category": DiagnosticCategory.Error },
    "Unsupported file encoding.": { "code": 5013, "category": DiagnosticCategory.NoPrefix },
    "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": { "code": 5014, "category": DiagnosticCategory.Error },
    "Unsupported locale: '{0}'.": { "code": 5015, "category": DiagnosticCategory.Error },
    "Execution Failed.{NL}": { "code": 5016, "category": DiagnosticCategory.Error },
    "Invalid call to 'up'": { "code": 5019, "category": DiagnosticCategory.Error },
    "Invalid call to 'down'": { "code": 5020, "category": DiagnosticCategory.Error },
    "Base64 value '{0}' finished with a continuation bit.": { "code": 5021, "category": DiagnosticCategory.Error },
    "Unknown option '{0}'": { "code": 5023, "category": DiagnosticCategory.Error },
    "Expected {0} arguments to message, got {1} instead.": { "code": 5024, "category": DiagnosticCategory.Error },
    "Expected the message '{0}' to have {1} arguments, but it had {2}": { "code": 5025, "category": DiagnosticCategory.Error },
    "Could not delete file '{0}'": { "code": 5034, "category": DiagnosticCategory.Error },
    "Could not create directory '{0}'": { "code": 5035, "category": DiagnosticCategory.Error },
    "Error while executing file '{0}': ": { "code": 5036, "category": DiagnosticCategory.Error },
    "Cannot compile external modules unless the '--module' flag is provided.": { "code": 5037, "category": DiagnosticCategory.Error },
    "Option mapRoot cannot be specified without specifying sourcemap option.": { "code": 5038, "category": DiagnosticCategory.Error },
    "Option sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5039, "category": DiagnosticCategory.Error },
    "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5040, "category": DiagnosticCategory.Error },
    "Option '{0}' specified without '{1}'": { "code": 5041, "category": DiagnosticCategory.Error },
    "'codepage' option not supported on current platform.": { "code": 5042, "category": DiagnosticCategory.Error },
    "Concatenate and emit output to single file.": { "code": 6001, "category": DiagnosticCategory.Message },
    "Generates corresponding {0} file.": { "code": 6002, "category": DiagnosticCategory.Message },
    "Specifies the location where debugger should locate map files instead of generated locations.": { "code": 6003, "category": DiagnosticCategory.Message },
    "Specifies the location where debugger should locate TypeScript files instead of source locations.": { "code": 6004, "category": DiagnosticCategory.Message },
    "Watch input files.": { "code": 6005, "category": DiagnosticCategory.Message },
    "Redirect output structure to the directory.": { "code": 6006, "category": DiagnosticCategory.Message },
    "Do not emit comments to output.": { "code": 6009, "category": DiagnosticCategory.Message },
    "Skip resolution and preprocessing.": { "code": 6010, "category": DiagnosticCategory.Message },
    "Specify ECMAScript target version: '{0}' (default), or '{1}'": { "code": 6015, "category": DiagnosticCategory.Message },
    "Specify module code generation: '{0}' or '{1}'": { "code": 6016, "category": DiagnosticCategory.Message },
    "Print this message.": { "code": 6017, "category": DiagnosticCategory.Message },
    "Print the compiler's version: {0}": { "code": 6019, "category": DiagnosticCategory.Message },
    "Allow use of deprecated '{0}' keyword when referencing an external module.": { "code": 6021, "category": DiagnosticCategory.Message },
    "Specify locale for errors and messages. For example '{0}' or '{1}'": { "code": 6022, "category": DiagnosticCategory.Message },
    "Syntax:   {0}": { "code": 6023, "category": DiagnosticCategory.Message },
    "options": { "code": 6024, "category": DiagnosticCategory.Message },
    "file1": { "code": 6025, "category": DiagnosticCategory.Message },
    "Examples:": { "code": 6026, "category": DiagnosticCategory.Message },
    "Options:": { "code": 6027, "category": DiagnosticCategory.Message },
    "Insert command line options and files from a file.": { "code": 6030, "category": DiagnosticCategory.Message },
    "Version {0}": { "code": 6029, "category": DiagnosticCategory.Message },
    "Use the '{0}' flag to see options.": { "code": 6031, "category": DiagnosticCategory.Message },
    "{NL}Recompiling ({0}):": { "code": 6032, "category": DiagnosticCategory.Message },
    "STRING": { "code": 6033, "category": DiagnosticCategory.Message },
    "KIND": { "code": 6034, "category": DiagnosticCategory.Message },
    "file2": { "code": 6035, "category": DiagnosticCategory.Message },
    "VERSION": { "code": 6036, "category": DiagnosticCategory.Message },
    "LOCATION": { "code": 6037, "category": DiagnosticCategory.Message },
    "DIRECTORY": { "code": 6038, "category": DiagnosticCategory.Message },
    "NUMBER": { "code": 6039, "category": DiagnosticCategory.Message },
    "Specify the codepage to use when opening source files.": { "code": 6040, "category": DiagnosticCategory.Message },
    "Additional locations:": { "code": 6041, "category": DiagnosticCategory.Message },
    "This version of the Javascript runtime does not support the '{0}' function.": { "code": 7000, "category": DiagnosticCategory.Error },
    "Unknown rule.": { "code": 7002, "category": DiagnosticCategory.Error },
    "Invalid line number ({0})": { "code": 7003, "category": DiagnosticCategory.Error },
    "Warn on expressions and declarations with an implied 'any' type.": { "code": 7004, "category": DiagnosticCategory.Message },
    "Variable '{0}' implicitly has an 'any' type.": { "code": 7005, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of '{1}' implicitly has an 'any' type.": { "code": 7006, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of function type implicitly has an 'any' type.": { "code": 7007, "category": DiagnosticCategory.Error },
    "Member '{0}' of object type implicitly has an 'any' type.": { "code": 7008, "category": DiagnosticCategory.Error },
    "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": { "code": 7009, "category": DiagnosticCategory.Error },
    "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7010, "category": DiagnosticCategory.Error },
    "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7011, "category": DiagnosticCategory.Error },
    "Parameter '{0}' of lambda function implicitly has an 'any' type.": { "code": 7012, "category": DiagnosticCategory.Error },
    "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7013, "category": DiagnosticCategory.Error },
    "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7014, "category": DiagnosticCategory.Error },
    "Array Literal implicitly has an 'any' type from widening.": { "code": 7015, "category": DiagnosticCategory.Error },
    "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": { "code": 7016, "category": DiagnosticCategory.Error },
    "Index signature of object type implicitly has an 'any' type.": { "code": 7017, "category": DiagnosticCategory.Error },
    "Object literal's property '{0}' implicitly has an 'any' type from widening.": { "code": 7018, "category": DiagnosticCategory.Error },
  };
}
/// <reference path='diagnosticCode.generated.ts' />
/// <reference path='diagnosticInformationMap.generated.ts' />
///<reference path='references.ts' />

module TypeScript {
    export module CharacterInfo {
        export function isDecimalDigit(c: number): boolean {
            return c >= CharacterCodes._0 && c <= CharacterCodes._9;
        }

        export function isOctalDigit(c: number): boolean {
            return c >= CharacterCodes._0 && c <= CharacterCodes._7;
        }

        export function isHexDigit(c: number): boolean {
            return CharacterInfo.isDecimalDigit(c) ||
                   (c >= CharacterCodes.A && c <= CharacterCodes.F) ||
                   (c >= CharacterCodes.a && c <= CharacterCodes.f);
        }

        export function hexValue(c: number): number {
            // Debug.assert(isHexDigit(c));
            return CharacterInfo.isDecimalDigit(c)
                ? (c - CharacterCodes._0)
                : (c >= CharacterCodes.A && c <= CharacterCodes.F)
                    ? c - CharacterCodes.A + 10
                    : c - CharacterCodes.a + 10;
        }

        export function isWhitespace(ch: number): boolean {
            switch (ch) {
                // Unicode 3.0 space characters.
                case CharacterCodes.space:
                case CharacterCodes.nonBreakingSpace:
                case CharacterCodes.enQuad:
                case CharacterCodes.emQuad:
                case CharacterCodes.enSpace:
                case CharacterCodes.emSpace:
                case CharacterCodes.threePerEmSpace:
                case CharacterCodes.fourPerEmSpace:
                case CharacterCodes.sixPerEmSpace:
                case CharacterCodes.figureSpace:
                case CharacterCodes.punctuationSpace:
                case CharacterCodes.thinSpace:
                case CharacterCodes.hairSpace:
                case CharacterCodes.zeroWidthSpace:
                case CharacterCodes.narrowNoBreakSpace:
                case CharacterCodes.ideographicSpace:

                case CharacterCodes.tab:
                case CharacterCodes.verticalTab:
                case CharacterCodes.formFeed:
                case CharacterCodes.byteOrderMark:
                    return true;
            }

            return false;
        }

        export function isLineTerminator(ch: number): boolean {
            switch (ch) {
                case CharacterCodes.carriageReturn:
                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    return true;
            }

            return false;
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export enum SyntaxConstants {
        None = 0,

        // Masks that we use to place information about a node into a single int.  The first bit tells
        // us if we've computed the data for a node.
        //
        // The second bit tells us if the node is incrementally reusable if it does not
        // containe any skipped tokens, zero width tokens, regex tokens in it ("/", "/=" or "/.../"), 
        // and contains no tokens that were parser generated.
        //
        // The next bit lets us know if the nodes was parsed in a strict context or node.  A node can
        // only be used by the incremental parser if it is parsed in the same strict context as before.
        // last masks off the part of the int
        //
        // The width of the node is stored in the remainder of the int.  This allows us up to 512MB
        // for a node by using all 29 bits.  However, in the common case, we'll use less than 29 bits
        // for the width.  Thus, the info will be stored in a single int in chakra.
        NodeDataComputed              = 0x00000001, // 0000 0000 0000 0000 0000 0000 0000 0001
        NodeIncrementallyUnusableMask = 0x00000002, // 0000 0000 0000 0000 0000 0000 0000 0010
        NodeParsedInStrictModeMask    = 0x00000004, // 0000 0000 0000 0000 0000 0000 0000 0100
        NodeFullWidthShift            = 3,          // 1111 1111 1111 1111 1111 1111 1111 1000
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class DepthLimitedWalker extends SyntaxWalker {
        private _depth: number = 0;
        private _maximumDepth: number = 0;

        constructor(maximumDepth: number) {
            super();
            this._maximumDepth = maximumDepth;
        }

        public visitNode(node: ISyntaxNode): void {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                super.visitNode(node);
                this._depth--;
            }
        }
    }
}
///<reference path='references.ts' />

module TypeScript.Emitter1 {
    function callSignature(parameter: ParameterSyntax): CallSignatureSyntax {
        return CallSignatureSyntax.create1().withParameterList(
            ParameterListSyntax.create1().withParameter(parameter));
    }

    // Class that makes sure we're not reusing tokens in a tree
    class EnsureTokenUniquenessRewriter extends SyntaxRewriter {
        private tokenTable = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

        public visitToken(token: ISyntaxToken): ISyntaxToken {
            if (this.tokenTable.containsKey(token)) {
                // already saw this token.  so clone it and return a new one. so that the tree stays
                // unique/
                return token.clone();
            }

            this.tokenTable.add(token, token);
            return token;
        }
    }

    class EmitterImpl extends SyntaxRewriter {
        private space: ISyntaxTriviaList;
        private newLine: ISyntaxTriviaList;
        private factory: Syntax.IFactory = Syntax.normalModeFactory;

        // A copy of the syntax tree we keep around so that we can determine where tokens were
        // before we started moving them around.
        private syntaxTreeCopy: SyntaxTree;

        constructor(syntaxTree: SyntaxTree, private options: FormattingOptions) {
            super();

            this.options = options || FormattingOptions.defaultOptions;

            // TODO: use proper new line based on options.
            this.space = Syntax.spaceTriviaList;
            this.newLine = Syntax.triviaList([Syntax.carriageReturnLineFeedTrivia]);

            this.syntaxTreeCopy = Parser.parse(syntaxTree.fileName(), SimpleText.fromString(syntaxTree.sourceUnit().fullText()), syntaxTree.isDeclaration(), syntaxTree.parseOptions());
        }

        private columnForStartOfToken(token: ISyntaxToken): number {
            return Indentation.columnForStartOfTokenAtPosition(this.syntaxTreeCopy, token.fullStart(), this.options);
        }

        private columnForEndOfToken(token: ISyntaxToken): number {
            return Indentation.columnForEndOfTokenAtPosition(this.syntaxTreeCopy, token.fullStart(), this.options);
        }

        private indentationTrivia(column: number): ISyntaxTriviaList {
            var triviaArray = column === 0 ? null : [Indentation.indentationTrivia(column, this.options)];
            return Syntax.triviaList(triviaArray);
        }

        private indentationTriviaForStartOfNode(node: ISyntaxNodeOrToken): ISyntaxTriviaList {
            var column = this.columnForStartOfToken(node.firstToken());
            return this.indentationTrivia(column);
        }

        private changeIndentation<T extends ISyntaxNode>(node: T, changeFirstToken: boolean, indentAmount: number): T {
            if (indentAmount === 0) {
                return node;
            }
            else if (indentAmount > 0) {
                return <T><any>SyntaxIndenter.indentNode(node,
                /*indentFirstToken:*/ changeFirstToken, /*indentAmount:*/ indentAmount,
                    this.options);
            }
            else {
                // Dedent the node.  But don't allow it go before the minimum indent amount.
                return <T><any>SyntaxDedenter.dedentNode(node,
                /*dedentFirstToken:*/ changeFirstToken, /*dedentAmount:*/-indentAmount,
                    /*minimumColumn:*/this.options.indentSpaces, this.options);
            }
        }

        private withNoTrivia(token: ISyntaxToken): ISyntaxToken {
            return token.withLeadingTrivia(Syntax.emptyTriviaList).withTrailingTrivia(Syntax.emptyTriviaList);
        }

        public visitSourceUnit(node: SourceUnitSyntax): SourceUnitSyntax {
            return node.withModuleElements(Syntax.list(
                this.convertModuleElements(node.moduleElements)));
        }

        private convertModuleElements(list: ISyntaxList<IModuleElementSyntax>): IModuleElementSyntax[] {
            var moduleElements: IModuleElementSyntax[] = [];

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var moduleElement = list.childAt(i);

                var converted = this.visitNode(<SyntaxNode>moduleElement);
                if (converted !== null) {
                    if (ArrayUtilities.isArray(converted)) {
                        moduleElements.push.apply(moduleElements, converted);
                    }
                    else {
                        moduleElements.push(<IModuleElementSyntax>converted);
                    }
                }
            }

            return moduleElements;
        }

        private static splitModuleName(name: INameSyntax): ISyntaxToken[] {
            var result: ISyntaxToken[] = [];
            while (true) {
                if (name.kind() === SyntaxKind.IdentifierName) {
                    result.unshift(<ISyntaxToken>name);
                    return result;
                }
                else if (name.kind() === SyntaxKind.QualifiedName) {
                    var qualifiedName = <QualifiedNameSyntax>name;
                    result.unshift(qualifiedName.right);
                    name = qualifiedName.left;
                }
                else {
                    throw Errors.invalidOperation();
                }
            }
        }

        private leftmostName(name: INameSyntax): ISyntaxToken {
            while (name.kind() === SyntaxKind.QualifiedName) {
                name = (<QualifiedNameSyntax>name).left;
            }

            return <ISyntaxToken>name;
        }

        private rightmostName(name: INameSyntax): ISyntaxToken {
            if (name.kind() === SyntaxKind.QualifiedName) {
                return (<QualifiedNameSyntax>name).right;
            }

            return <ISyntaxToken>name;
        }

        private containsToken(list: ISyntaxList<ISyntaxToken>, kind: SyntaxKind): boolean {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (list.childAt(i).kind() === kind) {
                    return true;
                }
            }

            return false;
        }

        private exportModuleElement(moduleIdentifier: ISyntaxToken,
            moduleElement: IModuleElementSyntax,
            elementIdentifier: ISyntaxToken): ExpressionStatementSyntax {
            elementIdentifier = this.withNoTrivia(elementIdentifier);

            // M1.e = e;
            return ExpressionStatementSyntax.create1(
                this.factory.binaryExpression(
                    SyntaxKind.AssignmentExpression,
                    MemberAccessExpressionSyntax.create1(
                        this.withNoTrivia(moduleIdentifier),
                        elementIdentifier.withTrailingTrivia(Syntax.spaceTriviaList)),
                    Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                    elementIdentifier))
                .withLeadingTrivia(this.indentationTriviaForStartOfNode(moduleElement))
                .withTrailingTrivia(this.newLine);
        }

        private handleExportedModuleElement(parentModule: ISyntaxToken,
            moduleElement: IModuleElementSyntax,
            elements: IModuleElementSyntax[]): void {
            if (moduleElement.kind() === SyntaxKind.VariableStatement) {
                var variableStatement = <VariableStatementSyntax>moduleElement;
                if (this.containsToken(variableStatement.modifiers, SyntaxKind.ExportKeyword)) {
                    var declarators = variableStatement.variableDeclaration.variableDeclarators;
                    for (var i = 0, n = declarators.nonSeparatorCount(); i < n; i++) {
                        var declarator = declarators.nonSeparatorAt(i);
                        elements.push(this.exportModuleElement(parentModule, moduleElement, declarator.propertyName));
                    }
                }
            }
            else if (moduleElement.kind() === SyntaxKind.FunctionDeclaration) {
                var functionDeclaration = <FunctionDeclarationSyntax>moduleElement;
                if (this.containsToken(functionDeclaration.modifiers, SyntaxKind.ExportKeyword)) {
                    elements.push(this.exportModuleElement(
                        parentModule, moduleElement, functionDeclaration.identifier));
                }
            }
            else if (moduleElement.kind() === SyntaxKind.ClassDeclaration) {
                var classDeclaration = <ClassDeclarationSyntax>moduleElement;
                if (this.containsToken(classDeclaration.modifiers, SyntaxKind.ExportKeyword)) {
                    elements.push(this.exportModuleElement(parentModule, moduleElement, classDeclaration.identifier));
                }
            }
            else if (moduleElement.kind() === SyntaxKind.ModuleDeclaration) {
                var childModule = <ModuleDeclarationSyntax>moduleElement;
                if (this.containsToken(childModule.modifiers, SyntaxKind.ExportKeyword)) {
                    elements.push(this.exportModuleElement(
                        parentModule, moduleElement, this.leftmostName(childModule.name)));
                }
            }
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): IModuleElementSyntax[] {
            var _this = this;

            // Recurse downwards and get the rewritten children.
            var moduleElements = this.convertModuleElements(node.moduleElements);

            if (this.mustCaptureThisInModule(node)) {
                // TODO: determine the right column for the 'this capture' statment.
                moduleElements.unshift(this.generateThisCaptureStatement(0));
            }

            // Handle the case where the child is an export.
            var parentModule = this.rightmostName(node.name);
            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                this.handleExportedModuleElement(
                    parentModule, node.moduleElements.childAt(i), moduleElements);
            }

            // Break up the dotted name into pieces.
            var names = EmitterImpl.splitModuleName(node.name);

            // Then, for all the names left of that name, wrap what we've created in a larger module.
            for (var nameIndex = names.length - 1; nameIndex >= 0; nameIndex--) {
                moduleElements = this.convertModuleDeclaration(
                    node, names[nameIndex], moduleElements, nameIndex === 0);

                if (nameIndex > 0) {
                    // We're popping out and generate each outer module.  As we do so, we have to
                    // indent whatever we've created so far appropriately.
                    moduleElements.push(this.exportModuleElement(
                        names[nameIndex - 1], node, names[nameIndex]));

                    moduleElements = <IModuleElementSyntax[]>ArrayUtilities.select(moduleElements,
                        e => _this.changeIndentation(e, /*indentFirstToken:*/ true, _this.options.indentSpaces));
                }
            }

            return moduleElements;
        }

        private initializedVariable(name: ISyntaxToken): BinaryExpressionSyntax {
            return this.factory.binaryExpression(SyntaxKind.LogicalOrExpression,
                name,
                Syntax.token(SyntaxKind.BarBarToken),
                ParenthesizedExpressionSyntax.create1(
                    Syntax.assignmentExpression(
                        name,
                        Syntax.token(SyntaxKind.EqualsToken),
                        ObjectLiteralExpressionSyntax.create1())));
        }

        private convertModuleDeclaration(moduleDeclaration: ModuleDeclarationSyntax,
            moduleName: ISyntaxToken,
            moduleElements: IModuleElementSyntax[],
            outermost: boolean): IModuleElementSyntax[] {
            moduleName = moduleName.withLeadingTrivia(Syntax.emptyTriviaList).withTrailingTrivia(Syntax.emptyTriviaList);
            var moduleIdentifier = moduleName;

            var moduleIndentation = this.indentationTriviaForStartOfNode(moduleDeclaration);
            var leadingTrivia = outermost ? moduleDeclaration.leadingTrivia() : moduleIndentation;

            // var M;
            var variableStatement = VariableStatementSyntax.create1(this.factory.variableDeclaration(
                Syntax.token(SyntaxKind.VarKeyword).withTrailingTrivia(this.space),
                Syntax.separatedList<VariableDeclaratorSyntax>(
                    [VariableDeclaratorSyntax.create(moduleIdentifier)])))
                .withLeadingTrivia(leadingTrivia).withTrailingTrivia(this.newLine);

            // function(M) { ... }
            var functionExpression = FunctionExpressionSyntax.create1()
                .withCallSignature(callSignature(ParameterSyntax.create(moduleIdentifier)).withTrailingTrivia(this.space))
                .withBlock(this.factory.block(
                    Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                    Syntax.list(<IStatementSyntax[]>moduleElements),
                    Syntax.token(SyntaxKind.CloseBraceToken).withLeadingTrivia(moduleIndentation)));

            // (function(M) { ... })(M||(M={}));
            var expressionStatement = ExpressionStatementSyntax.create1(
                this.factory.invocationExpression(
                    ParenthesizedExpressionSyntax.create1(functionExpression),
                    ArgumentListSyntax.create1().withArgument(this.initializedVariable(moduleName))))
                .withLeadingTrivia(moduleIndentation).withTrailingTrivia(this.newLine);

            return [<IModuleElementSyntax>variableStatement, expressionStatement];
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): ExpressionStatementSyntax {
            // Can't have an expression statement with an anonymous function expression in it.
            var rewritten: ExpressionStatementSyntax = super.visitExpressionStatement(node);

            // convert: function() { ... };  to (function() { ... });
            if (rewritten.expression.kind() === SyntaxKind.FunctionExpression) {
                // Wasn a function expression
                var functionExpression = <FunctionExpressionSyntax>rewritten.expression;
                if (functionExpression.identifier === null) {
                    // Was anonymous.

                    // Remove the leading trivia from the function keyword.  We'll put it on the open paren 
                    // token instead.

                    // Now, wrap the function expression in parens to make it legal in javascript.
                    var parenthesizedExpression = ParenthesizedExpressionSyntax.create1(
                        functionExpression.withLeadingTrivia(Syntax.emptyTriviaList)).withLeadingTrivia(functionExpression.leadingTrivia());

                    return rewritten.withExpression(parenthesizedExpression);
                }
            }

            return rewritten;
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): FunctionExpressionSyntax {
            return FunctionExpressionSyntax.create1()
                .withCallSignature(callSignature(ParameterSyntax.create(this.withNoTrivia(node.identifier))).withTrailingTrivia(this.space))
                .withBlock(this.convertArrowFunctionBody(node)).withLeadingTrivia(node.leadingTrivia());
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): FunctionExpressionSyntax {
            return FunctionExpressionSyntax.create1()
                .withCallSignature(CallSignatureSyntax.create(node.callSignature.parameterList.accept(this)))
                .withBlock(this.convertArrowFunctionBody(node)).withLeadingTrivia(node.leadingTrivia());
        }

        private convertArrowFunctionBody(arrowFunction: IArrowFunctionExpressionSyntax): BlockSyntax {
            var rewrittenBody = arrowFunction.block ? this.visitNode(arrowFunction.block) : this.visitNodeOrToken(arrowFunction.expression);

            if (rewrittenBody.kind() === SyntaxKind.Block) {
                return <BlockSyntax>rewrittenBody;
            }

            var arrowToken = arrowFunction.equalsGreaterThanToken;

            // first, attach the expression to the return statement
            var returnStatement = this.factory.returnStatement(
                Syntax.token(SyntaxKind.ReturnKeyword, { trailingTrivia: arrowToken.trailingTrivia().toArray() }),
                <IExpressionSyntax>rewrittenBody,
                Syntax.token(SyntaxKind.SemicolonToken)).withTrailingTrivia(this.newLine);

            // We want to adjust the indentation of the expression so that is aligns as it 
            // did before.  For example, if we started with:
            //
            //          a => foo().bar()
            //                    .baz()
            //
            // Then we want to end up with:
            //
            //          return foo().bar()
            //                      .baz()
            //
            // To do this we look at where the previous token (=>) used to end and where the new pevious
            // token (return) ends.  The difference (in this case '2') is our offset.

            var difference = 0;
            if (arrowToken.hasTrailingNewLine()) {
                // The expression is on the next line.  i.e. 
                //
                //      foo =>
                //          expr
                //
                // So we want it to immediately follow the return statement. i.e.:
                //
                //      return
                //          expr;
                //
                // and we adjust based on the column difference between the start of the arrow function
                // and the start of the expr.
                var arrowFunctionStart = this.columnForStartOfToken(arrowFunction.firstToken());
                difference = -arrowFunctionStart;
            }
            else {
                // the expression immediately follows the arrow. i.e.:
                //
                //      foo => expr
                //
                // So we want it to immediately follow the return statement. i.e.:
                //
                //      return expr;
                //
                // and we adjust based on the column difference between the end of the arrow token and 
                // the end of the return statement.
                var arrowEndColumn = this.columnForEndOfToken(arrowToken);
                var returnKeywordEndColumn = returnStatement.returnKeyword.width();
                difference = returnKeywordEndColumn - arrowEndColumn;
            }

            returnStatement = <ReturnStatementSyntax>this.changeIndentation(
                returnStatement, /*changeFirstToken:*/ false, difference);

            // Next, indent the return statement.  It's going in a block, so it needs to be properly
            // indented.  Note we do this *after* we've ensured the expression aligns properly.

            returnStatement = <ReturnStatementSyntax>this.changeIndentation(
                returnStatement, /*indentFirstToken:*/ true, this.options.indentSpaces);

            // Now wrap the return statement in a block.
            var block = this.factory.block(
                Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                Syntax.list([returnStatement]),
                Syntax.token(SyntaxKind.CloseBraceToken));

            // Note: if we started with something like:
            //
            //      var v = a => 1;
            //
            // Then we want to convert that to:
            //
            //      var v = function(a) {
            //          return 1;
            //      };
            //
            // However, right now what we've created is:
            //
            // {
            //     return 1;
            // }
            //
            // So we need to indent the block with our current column indent so that it aligns with the
            // parent structure.  Note: we don't wan to adjust the leading brace as that's going to go
            // after the function sigature.

            return <BlockSyntax>this.changeIndentation(block, /*indentFirstToken:*/ false,
                Indentation.columnForStartOfFirstTokenInLineContainingPosition(
                    this.syntaxTreeCopy, arrowFunction.firstToken().fullStart(), this.options));
        }

        private static methodSignatureDefaultParameters(signature: MethodSignatureSyntax): ParameterSyntax[] {
            return EmitterImpl.callSignatureDefaultParameters(signature.callSignature);
        }

        private static callSignatureDefaultParameters(callSignature: CallSignatureSyntax): ParameterSyntax[] {
            return EmitterImpl.parameterListDefaultParameters(callSignature.parameterList);
        }

        private static parameterListDefaultParameters(parameterList: ParameterListSyntax): ParameterSyntax[] {
            return ArrayUtilities.where(<ParameterSyntax[]>parameterList.parameters.toNonSeparatorArray(), p => p.equalsValueClause !== null);
        }

        private generatePropertyAssignmentStatement(parameter: ParameterSyntax): ExpressionStatementSyntax {
            var identifier = this.withNoTrivia(parameter.identifier);

            // this.foo = foo;
            return ExpressionStatementSyntax.create1(
                Syntax.assignmentExpression(
                    MemberAccessExpressionSyntax.create1(
                        Syntax.token(SyntaxKind.ThisKeyword),
                        identifier.withTrailingTrivia(Syntax.spaceTriviaList)),
                    Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                    identifier)).withTrailingTrivia(this.newLine);
        }

        private generateDefaultValueAssignmentStatement(parameter: ParameterSyntax): IfStatementSyntax {
            var identifierName = this.withNoTrivia(parameter.identifier).withTrailingTrivia(this.space);

            // typeof foo === 'undefined'
            var condition = this.factory.binaryExpression(
                SyntaxKind.EqualsExpression,
                this.factory.typeOfExpression(
                    Syntax.token(SyntaxKind.TypeOfKeyword).withTrailingTrivia(this.space),
                    identifierName),
                Syntax.token(SyntaxKind.EqualsEqualsEqualsToken).withTrailingTrivia(this.space),
                Syntax.stringLiteralExpression('"undefined"'));

            // foo = expr; 
            var assignmentStatement = ExpressionStatementSyntax.create1(
                Syntax.assignmentExpression(
                    identifierName,
                    Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                    parameter.equalsValueClause.value.accept(this))).withTrailingTrivia(this.space);

            var block = this.factory.block(
                Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.space),
                Syntax.list([assignmentStatement]),
                Syntax.token(SyntaxKind.CloseBraceToken)).withTrailingTrivia(this.newLine);

            // if (typeof foo === 'undefined') { foo = expr; }
            return this.factory.ifStatement(
                Syntax.token(SyntaxKind.IfKeyword).withTrailingTrivia(this.space),
                Syntax.token(SyntaxKind.OpenParenToken),
                condition,
                Syntax.token(SyntaxKind.CloseParenToken).withTrailingTrivia(this.space),
                block, null);
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): FunctionDeclarationSyntax {
            if (node.block === null) {
                // Function overloads aren't emitted.
                return null;
            }

            var rewritten = <FunctionDeclarationSyntax>super.visitFunctionDeclaration(node);
            var parametersWithDefaults = EmitterImpl.callSignatureDefaultParameters(node.callSignature);

            if (parametersWithDefaults.length !== 0) {
                var defaultValueAssignmentStatements = ArrayUtilities.select(
                    parametersWithDefaults, p => this.generateDefaultValueAssignmentStatement(p));

                var statementColumn = this.columnForStartOfToken(node.firstToken()) + this.options.indentSpaces;
                var statements = <IStatementSyntax[]>ArrayUtilities.select(defaultValueAssignmentStatements,
                    s => this.changeIndentation(s, /*indentFirstToken:*/ true, statementColumn));

                // Capture _this if necessary
                if (this.mustCaptureThisInFunction(node)) {
                    statements.push(this.generateThisCaptureStatement(statementColumn));
                }

                statements.push.apply(statements, rewritten.block.statements.toArray());

                rewritten = rewritten.withBlock(rewritten.block.withStatements(
                    Syntax.list(statements)));
            }

            return rewritten.withModifiers(Syntax.emptyList<ISyntaxToken>())
                .withLeadingTrivia(rewritten.leadingTrivia());
        }

        public visitParameter(node: ParameterSyntax): ParameterSyntax {
            // transfer the trivia from the first token to the the identifier.
            return ParameterSyntax.create(node.identifier)
                .withLeadingTrivia(node.leadingTrivia())
                .withTrailingTrivia(node.trailingTrivia())
        }

        private generatePropertyAssignment(classDeclaration: ClassDeclarationSyntax,
            static: boolean,
            memberDeclaration: MemberVariableDeclarationSyntax): ExpressionStatementSyntax {
            var isStatic = this.containsToken(memberDeclaration.modifiers, SyntaxKind.StaticKeyword);
            var declarator = memberDeclaration.variableDeclarator;
            if (static !== isStatic || declarator.equalsValueClause === null) {
                return null;
            }

            // this.foo = expr;
            var receiver = MemberAccessExpressionSyntax.create1(
                static ? <ILeftHandSideExpressionSyntax>this.withNoTrivia(classDeclaration.identifier)
                       : Syntax.token(SyntaxKind.ThisKeyword),
                this.withNoTrivia(declarator.propertyName)).withTrailingTrivia(Syntax.spaceTriviaList);

            return ExpressionStatementSyntax.create1(
                Syntax.assignmentExpression(
                    receiver,
                    Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                    declarator.equalsValueClause.value.accept(this).withTrailingTrivia(Syntax.emptyTriviaList)))
                .withLeadingTrivia(memberDeclaration.leadingTrivia()).withTrailingTrivia(this.newLine);
        }

        private generatePropertyAssignments(classDeclaration: ClassDeclarationSyntax,
            static: boolean): ExpressionStatementSyntax[] {
            var result: ExpressionStatementSyntax[] = [];

            // TODO: handle alignment here.
            for (var i = 0, n = classDeclaration.classElements.childCount(); i < n; i++) {
                var classElement = classDeclaration.classElements.childAt(i);

                if (classElement.kind() === SyntaxKind.MemberVariableDeclaration) {
                    var statement = this.generatePropertyAssignment(
                        classDeclaration, static, <MemberVariableDeclarationSyntax>classElement);
                    if (statement !== null) {
                        result.push(statement);
                    }
                }
            }

            return result;
        }

        private createDefaultConstructorDeclaration(classDeclaration: ClassDeclarationSyntax): FunctionDeclarationSyntax {
            var classIndentationColumn = this.columnForStartOfToken(classDeclaration.firstToken());
            var statementIndentationColumn = classIndentationColumn + this.options.indentSpaces;

            var statements: IStatementSyntax[] = [];
            if (classDeclaration.heritageClauses.childCount() > 0) {
                statements.push(ExpressionStatementSyntax.create1(
                    this.factory.invocationExpression(
                        MemberAccessExpressionSyntax.create1(
                            Syntax.identifierName("_super"), Syntax.identifierName("apply")),
                        ArgumentListSyntax.create1().withArguments(
                            Syntax.separatedList<IExpressionSyntax>([
                                Syntax.token(SyntaxKind.ThisKeyword),
                                Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space),
                                Syntax.identifierName("arguments")])))
                    ).withLeadingTrivia(this.indentationTrivia(statementIndentationColumn))
                    .withTrailingTrivia(this.newLine));
            }

            if (this.mustCaptureThisInClass(classDeclaration)) {
                statements.push(this.generateThisCaptureStatement(statementIndentationColumn));
            }

            statements.push.apply(statements, this.generatePropertyAssignments(classDeclaration, /*static:*/ false));

            var indentationTrivia = this.indentationTrivia(classIndentationColumn);

            var functionDeclaration = FunctionDeclarationSyntax.create(
                Syntax.token(SyntaxKind.FunctionKeyword).withLeadingTrivia(indentationTrivia).withTrailingTrivia(this.space),
                this.withNoTrivia(classDeclaration.identifier),
                CallSignatureSyntax.create1().withTrailingTrivia(this.space))
                .withBlock(this.factory.block(
                    Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                    Syntax.list(statements),
                    Syntax.token(SyntaxKind.CloseBraceToken).withLeadingTrivia(indentationTrivia))).withTrailingTrivia(this.newLine);

            return <FunctionDeclarationSyntax>this.changeIndentation(
                functionDeclaration, /*indentFirstToken:*/ true, this.options.indentSpaces);
        }

        private convertConstructorDeclaration(classDeclaration: ClassDeclarationSyntax,
            constructorDeclaration: ConstructorDeclarationSyntax): FunctionDeclarationSyntax {
            if (constructorDeclaration.block === null) {
                return null;
            }

            var i: number;
            var identifier = this.withNoTrivia(classDeclaration.identifier);

            var constructorIndentationColumn = this.columnForStartOfToken(constructorDeclaration.firstToken());
            var originalParameterListindentation = this.columnForStartOfToken(constructorDeclaration.callSignature.firstToken());

            // The original indent + "function" + <space> + "ClassName"
            var newParameterListIndentation =
                constructorIndentationColumn + SyntaxFacts.getText(SyntaxKind.FunctionKeyword).length + 1 + identifier.width();

            var callSignature = constructorDeclaration.callSignature.accept(this);
            callSignature= this.changeIndentation(
                callSignature, /*changeFirstToken:*/ false, newParameterListIndentation - originalParameterListindentation);

            var block = constructorDeclaration.block;
            var allStatements = <SyntaxNode[]>block.statements.toArray();

            var normalStatements: IStatementSyntax[] = ArrayUtilities.select<any, any>(ArrayUtilities.where(allStatements,
                s => !Syntax.isSuperInvocationExpressionStatement(s)), s => s.accept(this));

            var instanceAssignments = this.generatePropertyAssignments(classDeclaration, /*static:*/ false);

            for (i = instanceAssignments.length - 1; i >= 0; i--) {
                normalStatements.unshift(<ExpressionStatementSyntax>this.changeIndentation(
                    instanceAssignments[i], /*changeFirstToken:*/ true, this.options.indentSpaces));
            }

            var parameterPropertyAssignments = <ExpressionStatementSyntax[]>ArrayUtilities.select(
                ArrayUtilities.where(<ParameterSyntax[]>constructorDeclaration.callSignature.parameterList.parameters.toNonSeparatorArray(), p => p.modifiers.childCount() > 0),
                p => this.generatePropertyAssignmentStatement(p));

            for (i = parameterPropertyAssignments.length - 1; i >= 0; i--) {
                normalStatements.unshift(<IStatementSyntax>this.changeIndentation(
                    parameterPropertyAssignments[i], /*changeFirstToken:*/ true, this.options.indentSpaces + constructorIndentationColumn));
            }

            var superStatements: IStatementSyntax[] = ArrayUtilities.select<any, any>(ArrayUtilities.where(allStatements,
                s => Syntax.isSuperInvocationExpressionStatement(s)), s => s.accept(this));

            normalStatements.unshift.apply(normalStatements, superStatements);

            // TODO: use typecheck to determine if 'this' needs to be captured.
            if (this.mustCaptureThisInConstructor(constructorDeclaration)) {
                normalStatements.unshift(this.generateThisCaptureStatement(this.options.indentSpaces + constructorIndentationColumn));
            }

            var defaultValueAssignments = <IfStatementSyntax[]>ArrayUtilities.select(
                EmitterImpl.parameterListDefaultParameters(constructorDeclaration.callSignature.parameterList),
                p => this.generateDefaultValueAssignmentStatement(p));

            for (i = defaultValueAssignments.length - 1; i >= 0; i--) {
                normalStatements.unshift(<IStatementSyntax>this.changeIndentation(
                    defaultValueAssignments[i], /*changeFirstToken:*/ true, this.options.indentSpaces + constructorIndentationColumn));
            }

            // function C(...) { ... }
            return FunctionDeclarationSyntax.create(
                Syntax.token(SyntaxKind.FunctionKeyword).withTrailingTrivia(this.space),
                identifier, callSignature)
                    .withBlock(block.withStatements(Syntax.list(normalStatements))).withLeadingTrivia(constructorDeclaration.leadingTrivia());
        }

        private convertMemberFunctionDeclaration(classDeclaration: ClassDeclarationSyntax,
            functionDeclaration: MemberFunctionDeclarationSyntax): ExpressionStatementSyntax {
            var _this = this;
            if (functionDeclaration.block === null) {
                return null;
            }

            var classIdentifier = this.withNoTrivia(classDeclaration.identifier);
            var functionIdentifier = this.withNoTrivia(functionDeclaration.propertyName);

            var receiver: ILeftHandSideExpressionSyntax = classIdentifier.withLeadingTrivia(functionDeclaration.leadingTrivia());

            receiver = this.containsToken(functionDeclaration.modifiers, SyntaxKind.StaticKeyword)
                ? receiver
                : MemberAccessExpressionSyntax.create1(receiver, Syntax.identifierName("prototype"));

            receiver = MemberAccessExpressionSyntax.create1(
                receiver, functionIdentifier.withTrailingTrivia(Syntax.spaceTriviaList));

            var block: BlockSyntax = functionDeclaration.block.accept(this);
            var blockTrailingTrivia = block.trailingTrivia();

            block = block.withTrailingTrivia(Syntax.emptyTriviaList);

            var defaultValueAssignments = <IStatementSyntax[]>ArrayUtilities.select(
                EmitterImpl.callSignatureDefaultParameters(functionDeclaration.callSignature),
                p => _this.generateDefaultValueAssignmentStatement(p));

            var functionColumn = this.columnForStartOfToken(functionDeclaration.firstToken());

            var blockStatements = block.statements.toArray();
            for (var i = defaultValueAssignments.length - 1; i >= 0; i--) {
                blockStatements.unshift(this.changeIndentation(
                    defaultValueAssignments[i], /*changeFirstToken:*/ true, functionColumn + this.options.indentSpaces));
            }

            var callSignatureParameterList = <ParameterListSyntax>functionDeclaration.callSignature.parameterList.accept(this);
            if (!callSignatureParameterList.hasTrailingTrivia()) {
                callSignatureParameterList = <ParameterListSyntax>callSignatureParameterList.withTrailingTrivia(Syntax.spaceTriviaList);
            }

            // C.prototype.f = function (p1, p2) { ...  };
            return ExpressionStatementSyntax.create1(Syntax.assignmentExpression(
                receiver,
                Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                FunctionExpressionSyntax.create1()
                    .withCallSignature(CallSignatureSyntax.create(callSignatureParameterList))
                    .withBlock(block.withStatements(
                        Syntax.list(blockStatements))))).withTrailingTrivia(blockTrailingTrivia);
        }

        private convertMemberAccessor(memberAccessor: SyntaxNode): SimplePropertyAssignmentSyntax {
            var propertyName = memberAccessor.kind() === SyntaxKind.GetAccessor
                ? "get" : "set";

            var parameterList = <ParameterListSyntax>(<any>memberAccessor).parameterList.accept(this);
            if (!parameterList.hasTrailingTrivia()) {
                parameterList = parameterList.withTrailingTrivia(Syntax.spaceTriviaList);
            }

            return this.factory.simplePropertyAssignment(
                Syntax.identifier(propertyName),
                Syntax.token(SyntaxKind.ColonToken).withTrailingTrivia(this.space),
                FunctionExpressionSyntax.create(
                    Syntax.token(SyntaxKind.FunctionKeyword),
                    CallSignatureSyntax.create(parameterList),
                    (<any>memberAccessor).block.accept(this).withTrailingTrivia(Syntax.emptyTriviaList)))
                .withLeadingTrivia(this.indentationTriviaForStartOfNode(memberAccessor));
        }

        private convertMemberAccessorDeclaration(classDeclaration: ClassDeclarationSyntax,
            memberAccessor: SyntaxNode,
            classElements: IClassElementSyntax[]): IStatementSyntax {
            var name = (<any>memberAccessor).propertyName.valueText();
            var i: number;

            // Find all the accessors with that name.
            var accessors: any[] = [memberAccessor];

            for (i = classElements.length - 1; i >= 0; i--) {
                var element = classElements[i];
                if (element.kind() === SyntaxKind.GetAccessor ||
                    element.kind() === SyntaxKind.SetAccessor) {

                    var otherAccessor = <SyntaxNode>element;
                    if ((<any>otherAccessor).propertyName.value() === name &&
                        (<any>otherAccessor).block !== null) {
                        accessors.push(otherAccessor);
                        classElements.splice(i, 1);
                    }
                }
            }

            var arguments = [
                <any>MemberAccessExpressionSyntax.create1(
                    this.withNoTrivia(classDeclaration.identifier), Syntax.identifierName("prototype")),
                Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space),
                Syntax.stringLiteralExpression('"' + (<any>memberAccessor).propertyName.text() + '"'),
                Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space)
            ];

            var propertyAssignments: ISyntaxNodeOrToken[] = [];
            for (i = 0; i < accessors.length; i++) {
                var converted = this.convertMemberAccessor(accessors[i]);
                converted = <SimplePropertyAssignmentSyntax>this.changeIndentation(
                    converted, /*changeFirstToken:*/ true, this.options.indentSpaces);
                propertyAssignments.push(converted);
                propertyAssignments.push(
                    Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.newLine));
            }

            var accessorColumn = this.columnForStartOfToken(memberAccessor.firstToken());
            var accessorTrivia = this.indentationTrivia(accessorColumn);
            var propertyTrivia = this.indentationTrivia(accessorColumn + this.options.indentSpaces);

            propertyAssignments.push(this.factory.simplePropertyAssignment(
                Syntax.identifier("enumerable"),
                Syntax.token(SyntaxKind.ColonToken).withTrailingTrivia(this.space),
                Syntax.trueExpression()).withLeadingTrivia(propertyTrivia));
            propertyAssignments.push(Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.newLine));

            propertyAssignments.push(this.factory.simplePropertyAssignment(
                Syntax.identifier("configurable"),
                Syntax.token(SyntaxKind.ColonToken).withTrailingTrivia(this.space),
                Syntax.trueExpression()).withLeadingTrivia(propertyTrivia).withTrailingTrivia(this.newLine));

            arguments.push(this.factory.objectLiteralExpression(
                Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                Syntax.separatedList<IPropertyAssignmentSyntax>(propertyAssignments),
                Syntax.token(SyntaxKind.CloseBraceToken).withLeadingTrivia(accessorTrivia)));

            return ExpressionStatementSyntax.create1(
                this.factory.invocationExpression(
                    MemberAccessExpressionSyntax.create1(Syntax.identifierName("Object"), Syntax.identifierName("defineProperty")),
                    ArgumentListSyntax.create1().withArguments(Syntax.separatedList<IExpressionSyntax>(arguments))))
                .withLeadingTrivia(memberAccessor.leadingTrivia()).withTrailingTrivia(this.newLine);
        }

        private convertClassElements(classDeclaration: ClassDeclarationSyntax): IStatementSyntax[] {
            var result: IStatementSyntax[] = [];

            var classElements = <IClassElementSyntax[]>classDeclaration.classElements.toArray();
            while (classElements.length > 0) {
                var classElement = classElements.shift();

                var converted: IStatementSyntax = null;
                if (classElement.kind() === SyntaxKind.MemberFunctionDeclaration) {
                    converted = this.convertMemberFunctionDeclaration(classDeclaration, <MemberFunctionDeclarationSyntax>classElement);
                }
                else if (classElement.kind() === SyntaxKind.MemberVariableDeclaration) {
                    converted = this.generatePropertyAssignment(classDeclaration, /*static:*/ true, <MemberVariableDeclarationSyntax>classElement);
                }
                else if (classElement.kind() === SyntaxKind.GetAccessor ||
                    classElement.kind() === SyntaxKind.SetAccessor) {
                    converted = this.convertMemberAccessorDeclaration(classDeclaration, <SyntaxNode>classElement, classElements);
                }

                if (converted !== null) {
                    result.push(converted);
                }
            }

            return result;
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): VariableStatementSyntax {
            var identifier = this.withNoTrivia(node.identifier);

            var statements: IStatementSyntax[] = [];
            var statementIndentation = this.indentationTrivia(this.options.indentSpaces + this.columnForStartOfToken(node.firstToken()));

            if (node.heritageClauses.childCount() > 0) {
                // __extends(C, _super);
                statements.push(ExpressionStatementSyntax.create1(
                    this.factory.invocationExpression(
                        Syntax.identifierName("__extends"),
                        ArgumentListSyntax.create1().withArguments(Syntax.separatedList<IExpressionSyntax>([
                            <ISyntaxNodeOrToken>identifier,
                            Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space),
                            Syntax.identifierName("_super")])))).withLeadingTrivia(statementIndentation).withTrailingTrivia(this.newLine));
            }

            var constructorDeclaration = <ConstructorDeclarationSyntax>ArrayUtilities.firstOrDefault(
                node.classElements.toArray(), c => c.kind() === SyntaxKind.ConstructorDeclaration);

            var constructorFunctionDeclaration = constructorDeclaration === null
                ? this.createDefaultConstructorDeclaration(node)
                : this.convertConstructorDeclaration(node, constructorDeclaration);

            if (constructorFunctionDeclaration !== null) {
                statements.push(constructorFunctionDeclaration)
            }

            statements.push.apply(statements, this.convertClassElements(node));

            // return C;
            statements.push(this.factory.returnStatement(
                Syntax.token(SyntaxKind.ReturnKeyword).withTrailingTrivia(this.space),
                identifier,
                Syntax.token(SyntaxKind.SemicolonToken))
                .withLeadingTrivia(statementIndentation).withTrailingTrivia(this.newLine));

            var block = this.factory.block(
                Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                Syntax.list(statements),
                Syntax.token(SyntaxKind.CloseBraceToken).withLeadingTrivia(this.indentationTriviaForStartOfNode(node)));

            var callParameters: ParameterSyntax[] = [];
            if (node.heritageClauses.childCount() > 0) {
                callParameters.push(ParameterSyntax.create(Syntax.identifier("_super")));
            }

            var callSignature = CallSignatureSyntax.create(
                ParameterListSyntax.create1().withParameters(
                    Syntax.separatedList<ParameterSyntax>(callParameters))).withTrailingTrivia(this.space);

            var invocationParameters: ISyntaxNodeOrToken[] = [];
            if (node.heritageClauses.childCount() > 0) {
                var heritageClause = node.heritageClauses.childAt(0);
                if (heritageClause.typeNames.nonSeparatorCount() > 0) {
                    invocationParameters.push(heritageClause.typeNames.nonSeparatorAt(0)
                        .withLeadingTrivia(Syntax.emptyTriviaList)
                        .withTrailingTrivia(Syntax.emptyTriviaList));
                }
            }

            // (function(_super) { ... })(BaseType)
            var invocationExpression = this.factory.invocationExpression(
                ParenthesizedExpressionSyntax.create1(FunctionExpressionSyntax.create1()
                    .withCallSignature(callSignature)
                    .withBlock(block)),
                ArgumentListSyntax.create1().withArguments(
                    Syntax.separatedList<IExpressionSyntax>(invocationParameters)));

            // C = (function(_super) { ... })(BaseType)
            var variableDeclarator = VariableDeclaratorSyntax.create(
                identifier.withTrailingTrivia(Syntax.spaceTriviaList)).withEqualsValueClause(
                this.factory.equalsValueClause(
                    Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                    invocationExpression));

            // var C = (function(_super) { ... })(BaseType);
            return VariableStatementSyntax.create1(this.factory.variableDeclaration(
                Syntax.token(SyntaxKind.VarKeyword).withTrailingTrivia(this.space),
                Syntax.separatedList<VariableDeclaratorSyntax>([variableDeclarator])))
                .withLeadingTrivia(node.leadingTrivia()).withTrailingTrivia(this.newLine);
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): VariableDeclaratorSyntax {
            var result: VariableDeclaratorSyntax = super.visitVariableDeclarator(node);
            if (result.typeAnnotation === null) {
                return result;
            }

            var newTrailingTrivia = result.propertyName.trailingTrivia().concat(result.typeAnnotation.trailingTrivia());

            return result.withTypeAnnotation(null)
                .withPropertyName(result.propertyName.withTrailingTrivia(newTrailingTrivia));
        }

        public visitCallSignature(node: CallSignatureSyntax): CallSignatureSyntax {
            var result: CallSignatureSyntax = super.visitCallSignature(node);
            if (result.typeAnnotation === null) {
                return result;
            }

            var newTrailingTrivia = result.parameterList.trailingTrivia().concat(
                result.typeAnnotation.trailingTrivia());

            return result.withTypeAnnotation(null).withTrailingTrivia(newTrailingTrivia);
        }

        public visitCastExpression(node: CastExpressionSyntax): IExpressionSyntax {
            var result: CastExpressionSyntax = super.visitCastExpression(node);

            var subExpression = result.expression;
            var totalTrivia = result.leadingTrivia().concat(subExpression.leadingTrivia());

            return subExpression.withLeadingTrivia(totalTrivia);
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): InterfaceDeclarationSyntax {
            // TODO: transfer trivia if important.
            return null;
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): TypeParameterListSyntax {
            return null;
        }

        private generateEnumValueExpression(enumDeclaration: EnumDeclarationSyntax,
            enumElement: EnumElementSyntax,
            assignDefaultValues: boolean,
            index: number): IExpressionSyntax {
            if (enumElement.equalsValueClause !== null) {
                // Use the value if one is provided.
                return enumElement.equalsValueClause.value.accept(this).withTrailingTrivia(Syntax.emptyTriviaList);
            }

            // Didn't have a value.  Synthesize one if we're doing that, or use the previous item's value
            // (plus one).
            if (assignDefaultValues) {
                return Syntax.numericLiteralExpression(index.toString());
            }

            // Add one to the previous value.
            var enumIdentifier = this.withNoTrivia(enumDeclaration.identifier);
            var previousEnumElement = enumDeclaration.enumElements.nonSeparatorAt(index - 1);
            var variableIdentifier = this.withNoTrivia(previousEnumElement.propertyName);

            var receiver = variableIdentifier.kind() === SyntaxKind.StringLiteral
                ? ElementAccessExpressionSyntax.create1(enumIdentifier, variableIdentifier)
                : <IExpressionSyntax>MemberAccessExpressionSyntax.create1(enumIdentifier, variableIdentifier);

            return this.factory.binaryExpression(SyntaxKind.PlusExpression,
                receiver.withTrailingTrivia(Syntax.spaceTriviaList),
                Syntax.token(SyntaxKind.PlusToken).withTrailingTrivia(this.space),
                Syntax.numericLiteralExpression("1"));
        }

        private generateEnumFunctionExpression(node: EnumDeclarationSyntax): FunctionExpressionSyntax {
            var identifier = this.withNoTrivia(node.identifier);

            var enumColumn = this.columnForStartOfToken(node.firstToken());

            var statements: IStatementSyntax[] = [];

            var initIndentationColumn = enumColumn + this.options.indentSpaces;
            var initIndentationTrivia = this.indentationTrivia(initIndentationColumn);

            if (node.enumElements.nonSeparatorCount() > 0) {
                var assignDefaultValues = { value: true };
                for (var i = 0, n = node.enumElements.nonSeparatorCount(); i < n; i++) {
                    var enumElement = node.enumElements.nonSeparatorAt(i)
                    var variableIdentifier = this.withNoTrivia(enumElement.propertyName);

                    assignDefaultValues.value = assignDefaultValues.value && (enumElement.equalsValueClause === null);

                    // "E.Foo = 1" or "E['A B'] = 1"
                    var left = variableIdentifier.kind() === SyntaxKind.StringLiteral
                        ? ElementAccessExpressionSyntax.create1(identifier, variableIdentifier)
                        : <IExpressionSyntax>MemberAccessExpressionSyntax.create1(identifier, variableIdentifier);
                    var innerAssign = Syntax.assignmentExpression(
                        left.withTrailingTrivia(this.space),
                        Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                        this.generateEnumValueExpression(node, enumElement, assignDefaultValues.value, i))

                    // E[E.Foo = 1]
                    var elementAccessExpression = ElementAccessExpressionSyntax.create1(identifier, innerAssign)
                        .withLeadingTrivia(enumElement.leadingTrivia()).withTrailingTrivia(this.space);

                    // E[E.Foo = 1] = "Foo"
                    var outerAssign = Syntax.assignmentExpression(
                        elementAccessExpression,
                        Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                        variableIdentifier.kind() === SyntaxKind.StringLiteral
                        ? variableIdentifier
                        : Syntax.stringLiteralExpression('"' + variableIdentifier.text() + '"'));

                    var expressionStatement = ExpressionStatementSyntax.create1(
                        outerAssign).withTrailingTrivia(this.newLine);

                    statements.push(expressionStatement);
                }
            }

            var block = this.factory.block(
                Syntax.token(SyntaxKind.OpenBraceToken).withTrailingTrivia(this.newLine),
                Syntax.list(statements),
                Syntax.token(SyntaxKind.CloseBraceToken)
                    .withLeadingTrivia(this.indentationTrivia(enumColumn)));

            var parameterList = ParameterListSyntax.create1().withParameter(ParameterSyntax.create1(identifier)).withTrailingTrivia(this.space);

            return FunctionExpressionSyntax.create1()
                .withCallSignature(CallSignatureSyntax.create(parameterList))
                .withBlock(block);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): IStatementSyntax[] {
            var identifier = this.withNoTrivia(node.identifier);

            // Copy existing leading trivia of the enum declaration to this node.
            // var E;
            var variableStatement: IStatementSyntax = VariableStatementSyntax.create1(this.factory.variableDeclaration(
                Syntax.token(SyntaxKind.VarKeyword).withTrailingTrivia(this.space),
                Syntax.separatedList<VariableDeclaratorSyntax>([VariableDeclaratorSyntax.create(identifier)])))
                .withLeadingTrivia(node.leadingTrivia()).withTrailingTrivia(this.newLine);

            // (function(E) { E[E.e1 = ... })(E||(E={}));
            var expressionStatement: IStatementSyntax = ExpressionStatementSyntax.create1(
                this.factory.invocationExpression(
                    ParenthesizedExpressionSyntax.create1(this.generateEnumFunctionExpression(node)),
                    ArgumentListSyntax.create1().withArgument(this.initializedVariable(identifier))))
                .withLeadingTrivia(this.indentationTriviaForStartOfNode(node))
                .withTrailingTrivia(this.newLine);

            return [variableStatement, expressionStatement];
        }

        private convertSuperInvocationExpression(node: InvocationExpressionSyntax): InvocationExpressionSyntax {
            var result: InvocationExpressionSyntax = super.visitInvocationExpression(node);

            var expression = MemberAccessExpressionSyntax.create1(Syntax.identifierName("_super"), Syntax.identifierName("call"));

            var arguments = result.argumentList.arguments.toArray();
            if (arguments.length > 0) {
                arguments.unshift(Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space));
            }

            arguments.unshift(Syntax.token(SyntaxKind.ThisKeyword));

            return result.withExpression(expression)
                .withArgumentList(result.argumentList.withArguments(Syntax.separatedList<IExpressionSyntax>(arguments)))
                .withLeadingTrivia(result.leadingTrivia());
        }

        private convertSuperMemberAccessInvocationExpression(node: InvocationExpressionSyntax): InvocationExpressionSyntax {
            var result: InvocationExpressionSyntax = super.visitInvocationExpression(node);

            var arguments = result.argumentList.arguments.toArray();
            if (arguments.length > 0) {
                arguments.unshift(Syntax.token(SyntaxKind.CommaToken).withTrailingTrivia(this.space));
            }

            arguments.unshift(Syntax.token(SyntaxKind.ThisKeyword));

            var expression = MemberAccessExpressionSyntax.create1(result.expression, Syntax.identifierName("call"));
            return result.withExpression(expression)
                .withArgumentList(result.argumentList.withArguments(Syntax.separatedList<IExpressionSyntax>(arguments)));
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): InvocationExpressionSyntax {
            if (Syntax.isSuperInvocationExpression(node)) {
                return this.convertSuperInvocationExpression(node);
            }
            else if (Syntax.isSuperMemberAccessInvocationExpression(node)) {
                return this.convertSuperMemberAccessInvocationExpression(node);
            }

            return super.visitInvocationExpression(node);
        }

        public visitVariableStatement(node: VariableStatementSyntax): VariableStatementSyntax {
            var result: VariableStatementSyntax = super.visitVariableStatement(node);

            return result.withModifiers(Syntax.emptyList<ISyntaxToken>())
                .withLeadingTrivia(result.leadingTrivia());
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): MemberAccessExpressionSyntax {
            var result: MemberAccessExpressionSyntax = super.visitMemberAccessExpression(node);

            if (Syntax.isSuperMemberAccessExpression(result)) {
                return MemberAccessExpressionSyntax.create1(
                    MemberAccessExpressionSyntax.create1(Syntax.identifierName("_super"), Syntax.identifierName("prototype")),
                    result.name).withLeadingTrivia(result.leadingTrivia());
            }

            return result;
        }

        public visitToken(token: ISyntaxToken): ISyntaxToken {
            if (token.kind() === SyntaxKind.IdentifierName) {
                return <any>this.visitIdentifierName(token);
            }

            if (token.kind() === SyntaxKind.ThisKeyword) {
                return this.visitThisKeyword(token);
            }

            return token;
        }

        public visitThisKeyword(token: ISyntaxToken): ISyntaxToken {
            // TODO: use typecheck information to tell if we're accessing 'this' in a lambda and 
            // should use "_this" instead.
            return token;
        }

        public visitIdentifierName(token: ISyntaxToken): INameSyntax {
            // Check if a name token needs to become fully qualified.
            var parent = token.parent;

            // We never qualify in a qualified name.  A qualified name only shows up in type 
            // contexts, and will be removed anyways.
            if (parent.kind() === SyntaxKind.QualifiedName) {
                return token;
            }

            // Same issue for a generic name.
            if (parent.kind() === SyntaxKind.GenericType) {
                return token;
            }

            // We never qualify the right hand side of a dot.
            if (parent.kind() === SyntaxKind.MemberAccessExpression && (<MemberAccessExpressionSyntax>parent).name === token) {
                return token;
            }

            // TODO(cyrusn): Implement this when we have type check support.

            // Ok.  We're a name token that isn't on the right side of a dot.  We may need to be 
            // qualified.   Get the symbol that this token binds to.  If it is a module/class and
            // has a full name that is larger than this token, then return the full name as a 
            // member access expression. 
            return token;
        }

        private generateThisCaptureStatement(indentationColumn: number): VariableStatementSyntax {
            // var _this = this;
            return VariableStatementSyntax.create1(this.factory.variableDeclaration(
                Syntax.token(SyntaxKind.VarKeyword).withTrailingTrivia(this.space),
                Syntax.separatedList<VariableDeclaratorSyntax>([
                    this.factory.variableDeclarator(
                        Syntax.identifier("_this").withTrailingTrivia(this.space),
                        null,
                        this.factory.equalsValueClause(
                            Syntax.token(SyntaxKind.EqualsToken).withTrailingTrivia(this.space),
                            Syntax.token(SyntaxKind.ThisKeyword)))
                ]))).withLeadingTrivia(this.indentationTrivia(indentationColumn)).withTrailingTrivia(this.newLine);
        }

        private mustCaptureThisInConstructor(constructorDeclaration: ConstructorDeclarationSyntax): boolean {
            // TODO: use typecheck to answer this question properly.
            return false;
        }

        private mustCaptureThisInClass(classDeclaratoin: ClassDeclarationSyntax): boolean {
            // TODO: use typecheck to answer this question properly.
            return false;
        }

        private mustCaptureThisInModule(moduleDeclaration: ModuleDeclarationSyntax): boolean {
            // TODO: use typecheck to answer this question properly.
            return false;
        }

        private mustCaptureThisInFunction(functionDeclaration: FunctionDeclarationSyntax): boolean {
            // TODO: use typecheck to answer this question properly.
            return false;
        }
    }

    export function emit(input: SourceUnitSyntax, options: FormattingOptions = null): SourceUnitSyntax {
        // Make sure no one is passing us a bogus tree.
        SyntaxNodeInvariantsChecker.checkInvariants(input);

        // If there's nothing typescript specific about this node, then just return it as is.
        if (!input.isTypeScriptSpecific()) {
            return input;
        }

        // Do the initial conversion. Note: the result at this point may be 'bogus'.  For example,
        // it make contain the same token instance multiple times in the tree.
        var output: SourceUnitSyntax = input.accept(new EmitterImpl(input.syntaxTree(), options));

        // Make sure we clone any nodes/tokens we used in multiple places in the result.  That way
        // we don't break the invariant that all tokens in a tree are unique.
        output = output.accept(new EnsureTokenUniquenessRewriter());

        SyntaxNodeInvariantsChecker.checkInvariants(output);
        Debug.assert(!output.isTypeScriptSpecific());

        return output;
    }
}
///<reference path='references.ts' />

class FormattingOptions {
    constructor(public useTabs: boolean,
                public spacesPerTab: number,
                public indentSpaces: number,
                public newLineCharacter: string) {
    }

    public static defaultOptions = new FormattingOptions(/*useTabs:*/ false, /*spacesPerTab:*/ 4, /*indentSpaces:*/ 4, /*newLineCharacter*/ "\r\n");
}
module TypeScript {
    export enum LanguageVersion {
        EcmaScript3 = 0,
        EcmaScript5 = 1,
    }
}
///<reference path='references.ts' />

module TypeScript.Parser {
    // Information the parser needs to effectively rewind.
    interface IParserRewindPoint {
        // Information used by normal parser source.
        absolutePosition: number;
        slidingWindowIndex: number;

        // Information used by the incremental parser source.
        oldSourceUnitCursor: SyntaxCursor;
        changeDelta: number;
        changeRange: TextChangeRange;

        // Information used by the parser itself.

        // As we speculatively parse, we may build up diagnostics.  When we rewind we want to 
        // 'forget' that information.In order to do that we store the count of diagnostics and 
        // when we start speculating, and we reset to that count when we're done.  That way the
        // speculative parse does not affect any further results.
        diagnosticsCount: number;

        // For debug purposes only, we also track the following information. They help us assert 
        // that we're not doing anything unexpected.

        // Rewind points should work like a stack.  The first rewind point given out should be the
        // last one released.  By keeping track of the count of points out when this was created, 
        // we can ensure that invariant was preserved.
        pinCount: number;

        // isInStrictMode and listParsingState should not have to be tracked by a rewind point.
        // Because they are naturally mutated and restored based on the normal stack movement of 
        // the parser, they should automatically return to whatever value they had to begin with
        // if the parser decides to rewind or not.  However, to ensure that this is true, we track
        // these variables and check if they have the same value when we're rewinding/releasing.
        isInStrictMode: boolean;
        listParsingState: ListParsingState;
    }

    // The precedence of expressions in typescript.  While we're parsing an expression, we will 
    // continue to consume and form new trees if the precedence is *strictly* greater than our current
    // precedence.  For example, if we have: a + b * c, we will first parse 'a' with precedence 1 (Lowest). 
    // We will then see the + with precedence 10.  10 is greater than 1 so we will decide to create
    // a binary expression with the result of parsing the sub expression "b * c".  We'll then parse
    // the term 'b' (passing in precedence 10).  We will then see the * with precedence 11.  11 is
    // greater than 10, so we will create a binary expression from "b" and "c", return that, and 
    // join it with "a" producing:
    //
    //      +
    //     / \
    //    a   *
    //       / \
    //      b   c
    //
    // If we instead had: "a * b + c", we would first parser 'a' with precedence 1 (lowest).  We would then see 
    // the * with precedence 11.  11 is greater than 1 so we will decide to create a binary expression
    // with the result of parsing the sub expression "b + c".  We'll then parse the term 'b' (passing in
    // precedence 11).  We will then see the + with precedence 10.  10 is less than 11, so we won't 
    // continue parsing subexpressions and will just return the expression 'b'.  The caller will join 
    // that into "a * b" (and will be back at precedence 1). It will then see the + with precedence 10.
    // 10 is greater than 1 so it will parse the sub expression and make a binary expression out of it
    // producing:
    //
    //        +
    //       / \
    //      *   c
    //     / \
    //    a   b
    //
    // Note: because all these binary expressions have left-to-right precedence, if we see a * b * c 
    // then we parse it as:
    //
    //        *
    //       / \
    //      *   c
    //     / \
    //    a   b
    //
    // The code to do this uses the above logic.  It will see an operator with the same precedence,
    // and so it won't consume it.
    enum BinaryExpressionPrecedence {
        Lowest = 1,

        // Intuitively, logical || have the lowest precedence.  "a || b && c" is "a || (b && c)", not
        // "(a || b) && c"
        LogicalOrExpressionPrecedence = 2,
        LogicalAndExpressionPrecedence = 3,
        BitwiseOrExpressionPrecedence = 4,
        BitwiseExclusiveOrExpressionPrecedence = 5,
        BitwiseAndExpressionPrecedence = 6,
        EqualityExpressionPrecedence = 7,
        RelationalExpressionPrecedence = 8,
        ShiftExpressionPrecdence = 9,
        AdditiveExpressionPrecedence = 10,

        // Intuitively, multiplicative expressions have the highest precedence.  After all, if you have:
        //   a + b * c
        //
        // Then you have "a + (b * c)" not "(a + b) * c"
        MultiplicativeExpressionPrecedence = 11,
    }

    // The current state of the parser wrt to list parsing.  The way to read these is as:
    // CurrentProduction_SubList.  i.e. "Block_Statements" means "we're parsing a Block, and we're 
    // currently parsing list of statements within it".  This is used by the list parsing mechanism
    // to parse the elements of the lists, and recover from errors we encounter when we run into 
    // unexpected code.
    // 
    // For example, when we are in ArgumentList_Arguments, we will continue trying to consume code 
    // as long as "isArgument" is true.  If we run into a token for which "isArgument" is not true 
    // we will do the following:
    //
    // If the token is a StopToken for ArgumentList_Arguments (like ")" ) then we will stop parsing
    // the list of arguments with no error.
    //
    // Otherwise, we *do* report an error for this unexpected token, and then enter error recovery 
    // mode to decide how to try to recover from this unexpected token.
    //
    // Error recovery will walk up the list of states we're in seeing if the token is a stop token
    // for that construct *or* could start another element within what construct.  For example, if
    // the unexpected token was '}' then that would be a stop token for Block_Statements. 
    // Alternatively, if the unexpected token was 'return', then that would be a start token for 
    // the next statment in Block_Statements.
    // 
    // If either of those cases are true, We will then return *without* consuming  that token. 
    // (Remember, we've already reported an error).  Now we're just letting the higher up parse 
    // constructs eventually try to consume that token.
    //
    // If none of the higher up states consider this a stop or start token, then we will simply 
    // consume the token and add it to our list of 'skipped tokens'.  We will then repeat the 
    // above algorithm until we resynchronize at some point.
    enum ListParsingState {
        SourceUnit_ModuleElements = 1 << 0,
        ClassDeclaration_ClassElements = 1 << 1,
        ModuleDeclaration_ModuleElements = 1 << 2,
        SwitchStatement_SwitchClauses = 1 << 3,
        SwitchClause_Statements = 1 << 4,
        Block_Statements = 1 << 5,
        TryBlock_Statements = 1 << 6,
        CatchBlock_Statements = 1 << 7,
        EnumDeclaration_EnumElements = 1 << 8,
        ObjectType_TypeMembers = 1 << 9,
        ClassOrInterfaceDeclaration_HeritageClauses = 1 << 10,
        HeritageClause_TypeNameList = 1 << 11,
        VariableDeclaration_VariableDeclarators_AllowIn = 1 << 12,
        VariableDeclaration_VariableDeclarators_DisallowIn = 1 << 13,
        ArgumentList_AssignmentExpressions = 1 << 14,
        ObjectLiteralExpression_PropertyAssignments = 1 << 15,
        ArrayLiteralExpression_AssignmentExpressions = 1 << 16,
        ParameterList_Parameters = 1 << 17,
        TypeArgumentList_Types = 1 << 18,
        TypeParameterList_TypeParameters = 1 << 19,

        FirstListParsingState = SourceUnit_ModuleElements,
        LastListParsingState = TypeParameterList_TypeParameters,
    }

    class SyntaxCursorPiece {
        constructor(public element: ISyntaxElement,
                    public indexInParent: number) {
        }
    }

    // Pool syntax cursors so we don't churn too much memory when we need temporary cursors.  
    // i.e. when we're speculatively parsing, we can cheaply get a pooled cursor and then
    // return it when we no longer need it.
    var syntaxCursorPool: SyntaxCursor[] = [];
    var syntaxCursorPoolCount: number = 0;

    function returnSyntaxCursor(cursor: SyntaxCursor): void {
        // Make sure the cursor isn't holding onto any syntax elements.  We don't want to leak 
        // them when we return the cursor to the pool.
        cursor.clean();

        syntaxCursorPool[syntaxCursorPoolCount] = cursor;
        syntaxCursorPoolCount++;
    }

    function getSyntaxCursor(): SyntaxCursor {
        // Get an existing cursor from the pool if we have one.  Or create a new one if we don't.
        var cursor = syntaxCursorPoolCount > 0
            ? syntaxCursorPool[syntaxCursorPoolCount - 1]
            : new SyntaxCursor();

        if (syntaxCursorPoolCount > 0) {
            // If we reused an existing cursor, take it out of the pool so no one else uses it.
            syntaxCursorPoolCount--;
            syntaxCursorPool[syntaxCursorPoolCount] = null;
        }

        return cursor;
    }

    function cloneSyntaxCursor(cursor: SyntaxCursor): SyntaxCursor {
        var newCursor = getSyntaxCursor();

        // Make the new cursor a *deep* copy of the cursor passed in.  This ensures each cursor can
        // be moved without affecting the other.
        newCursor.deepCopyFrom(cursor);

        return newCursor;
    }

    class SyntaxCursor {
        // Our list of path pieces.  The piece pointed to by 'currentPieceIndex' must be a node or
        // token.  However, pieces earlier than that may point to list nodes.
        //
        // For perf we reuse pieces as much as possible.  i.e. instead of popping items off the 
        // list, we just will change currentPieceIndex so we can reuse that piece later.
        private pieces: SyntaxCursorPiece[] = [];
        private currentPieceIndex: number = -1;

        // Cleans up this cursor so that it doesn't have any references to actual syntax nodes.
        // This sould be done before returning the cursor to the pool so that the Parser module
        // doesn't unnecessarily keep old syntax trees alive.
        public clean(): void {
            for (var i = 0, n = this.pieces.length; i < n; i++) {
                var piece = this.pieces[i];

                if (piece.element === null) {
                    break;
                }

                piece.element = null;
                piece.indexInParent = -1;
            }

            this.currentPieceIndex = -1;
        }

        // Makes this cursor into a deep copy of the cursor passed in.
        public deepCopyFrom(other: SyntaxCursor): void {
            // Debug.assert(this.currentPieceIndex === -1);
            for (var i = 0, n = other.pieces.length; i < n; i++) {
                var piece = other.pieces[i];

                if (piece.element === null) {
                    break;
                }

                this.pushElement(piece.element, piece.indexInParent);
            }

            // Debug.assert(this.currentPieceIndex === other.currentPieceIndex);
        }

        public isFinished(): boolean {
            return this.currentPieceIndex < 0;
        }

        public currentNodeOrToken(): ISyntaxNodeOrToken {
            if (this.isFinished()) {
                return null;
            }

            var result = this.pieces[this.currentPieceIndex].element;

            // The current element must always be a node or a token.
            // Debug.assert(result !== null);
            // Debug.assert(result.isNode() || result.isToken());

            return <ISyntaxNodeOrToken>result;
        }

        public currentNode(): ISyntaxNode {
            var element = this.currentNodeOrToken();
            return isNode(element) ? <ISyntaxNode>element : null;
        }

        public moveToFirstChild() {
            var nodeOrToken = this.currentNodeOrToken();
            if (nodeOrToken === null) {
                return;
            }

            if (isToken(nodeOrToken)) {
                // If we're already on a token, there's nothing to do.
                return;
            }

            // The last element must be a token or a node.
            // Debug.assert(isNode(nodeOrToken));

            // Either the node has some existent child, then move to it.  if it doesn't, then it's
            // an empty node.  Conceptually the first child of an empty node is really just the 
            // next sibling of the empty node.
            for (var i = 0, n = childCount(nodeOrToken); i < n; i++) {
                var child = childAt(nodeOrToken, i);
                if (child !== null && !isShared(child)) {
                    // Great, we found a real child.  Push that.
                    this.pushElement(child, /*indexInParent:*/ i);

                    // If it was a list, make sure we're pointing at its first element.  We know we
                    // must have one because this is a non-shared list.
                    this.moveToFirstChildIfList();
                    return;
                }
            }

            // This element must have been an empty node.  Moving to its 'first child' is equivalent to just
            // moving to the next sibling.

            // Debug.assert(fullWidth(nodeOrToken) === 0);
            this.moveToNextSibling();
        }

        public moveToNextSibling(): void {
            while (!this.isFinished()) {
                // first look to our parent and see if it has a sibling of us that we can move to.
                var currentPiece = this.pieces[this.currentPieceIndex];
                var parent = currentPiece.element.parent;

                // We start searching at the index one past our own index in the parent.
                for (var i = currentPiece.indexInParent + 1, n = childCount(parent); i < n; i++) {
                    var sibling = childAt(parent, i);

                    if (sibling !== null && !isShared(sibling)) {
                        // We found a good sibling that we can move to.  Just reuse our existing piece
                        // so we don't have to push/pop.
                        currentPiece.element = sibling;
                        currentPiece.indexInParent = i;

                        // The sibling might have been a list.  Move to it's first child.  it must have
                        // one since this was a non-shared element.
                        this.moveToFirstChildIfList();
                        return;
                    }
                }

                // Didn't have a sibling for this element.  Go up to our parent and get its sibling.

                // Clear the data from the old piece.  We don't want to keep any elements around
                // unintentionally.
                currentPiece.element = null;
                currentPiece.indexInParent = -1;

                // Point at the parent.  if we move past the top of the path, then we're finished.
                this.currentPieceIndex--;
            }
        }

        private moveToFirstChildIfList(): void {
            var element = this.pieces[this.currentPieceIndex].element;

            if (isList(element) || isSeparatedList(element)) {
                // We cannot ever get an empty list in our piece path.  Empty lists are 'shared' and
                // we make sure to filter that out before pushing any children.
                // Debug.assert(childCount(element) > 0);

                this.pushElement(childAt(element, 0), /*indexInParent:*/ 0);
            }
        }

        public pushElement(element: ISyntaxElement, indexInParent: number): void {
            // Debug.assert(element !== null);
            // Debug.assert(indexInParent >= 0);
            this.currentPieceIndex++;

            // Reuse an existing piece if we have one.  Otherwise, push a new piece to our list.
            if (this.currentPieceIndex === this.pieces.length) {
                this.pieces.push(new SyntaxCursorPiece(element, indexInParent));
            }
            else {
                var piece = this.pieces[this.currentPieceIndex];
                piece.element = element;
                piece.indexInParent = indexInParent;
            }
        }

        public moveToFirstToken(): void {
            while (!this.isFinished()) {
                var element = this.pieces[this.currentPieceIndex].element;
                if (isNode(element)) {
                    this.moveToFirstChild();
                    continue;
                }

                // Debug.assert(isToken(element));
                return;
            }
        }

        public currentToken(): ISyntaxToken {
            this.moveToFirstToken();

            var element = this.currentNodeOrToken();
            // Debug.assert(element === null || element.isToken());
            return element === null ? null : <ISyntaxToken>element;
        }
    }

    // Interface that represents the source that the parser pulls tokens from.  Essentially, this 
    // is the interface that the parser needs an underlying scanner to provide.  This allows us to
    // separate out "what" the parser does with the tokens it retrieves versus "how" it obtains
    // the tokens.  i.e. all the logic for parsing language constructs sits in ParserImpl, while 
    // all the logic for retrieving tokens sits in individual IParserSources.
    //
    // By separating out this interface, we also make incremental parsing much easier.  Instead of
    // having the parser directly sit on top of the scanner, we sit it on this abstraction.  Then
    // in incremental scenarios, we can use the IncrementalParserSource to pull tokens (or even 
    // full nodes) from the previous tree when possible.  Of course, we'll still end up using a 
    // scanner for new text.  But that can all happen inside the source, with none of the logic in
    // the parser having to be aware of it.
    //
    // In general terms, a parser source represents a position within a text.  At that position, 
    // one can ask for the 'currentToken' that the source is pointing at.  Then, once the parser 
    // consumes that token it can ask the source to 'moveToNextToken'.
    //
    // Additional special abilities include:
    //  1) Being able to peek an arbitrary number of tokens ahead efficiently.
    //  2) Being able to retrieve fully parsed nodes from the source, not just tokens. This happens
    //     in incremental scenarios when the source is certain that the node is completley safe to
    //     reuse.
    //  3) Being able to get a 'rewind point' to the current location.  This allows the parser to
    //     speculatively parse as much as it wants, and then reset itself back to that point, 
    //     ensuring that no state changes that occurred after getting the 'rewing point' are 
    //     observable.
    //  4) Being able to reinterpret the current token being pointed at as a regular expression 
    //     token.  This is necessary as the scanner does not have enough information to correctly
    //     distinguish "/" or "/=" as divide tokens, versus "/..../" as a regex token.  If the 
    //     parser sees a "/" in a place where a divide is not allowed, but a regex would be, then
    //     it can call into the source and ask if a regex token could be returned instead.  The 
    //     sources are smart enough to do that and not be affected by any additional work they may
    //     have done when they originally scanned that token.
    interface IParserSource {
        // The text we are parsing.
        text: ISimpleText;

        // The current syntax node the source is pointing at.  Only available in incremental settings.
        // The source can point at a node if that node doesn't intersect any of the text changes in
        // the file, and doesn't contain certain unacceptable constructs.  For example, if the node
        // contains skipped text, then it will not be reused.
        currentNode(): ISyntaxNode;

        // The current token the source is pointing at.
        currentToken(): ISyntaxToken;

        // The current token reinterpretted contextually based on where the parser is.  If the
        // source is on a / or /= token, then it can be reinterpretted as a regex token.  If the
        // source is on a > token, it may be reinterpretted to: >>  >>>  >=  >>=  >>>=
        currentContextualToken(): ISyntaxToken;

        // Peek any number of tokens ahead from the current location in source.  peekToken(0) is
        // equivalent to 'currentToken', peekToken(1) is the next token, peekToken(2) the token
        // after that, etc.  If the caller peeks past the end of the text, then EndOfFile tokens
        // will be returned.
        peekToken(n: number): ISyntaxToken;

        // Called to move the source to the next node or token once the parser has consumed the 
        // current one.
        consumeNode(node: ISyntaxNode): void;
        consumeToken(token: ISyntaxToken): void;

        // Gets a rewind point that the parser can use to move back to after it speculatively 
        // parses something.  The source guarantees that if the parser calls 'rewind' with that 
        // point that it will be mostly in the same state that it was in when 'getRewindPoint'
        // was called.  i.e. calling currentToken, peekToken, tokenDiagnostics, etc. will result
        // in the same values.  One allowed exemption to this is 'currentNode'.  If a rewind point
        // is requested and rewound, then getting the currentNode may not be possible.  However,
        // as this is purely a performance optimization, it will not affect correctness.
        //
        // Note: that rewind points are not free (but they should also not be too expensive).  So
        // they should be used judiciously.  While a rewind point is held by the parser, the source
        // is not free to do things that it would normally do.  For example, it cannot throw away
        // tokens that it has scanned on or after the rewind point as it must keep them alive for
        // the parser to move back to.
        //
        // Rewind points also work in a stack fashion.  The first rewind point given out must be
        // the last rewind point released.  Do not release them out of order, or bad things can 
        // happen.
        //
        // Do *NOT* forget to release a rewind point.  Always put them in a finally block to ensure
        // that they are released.  If they are not released, things will still work, you will just
        // consume far more memory than necessary.
        getRewindPoint(): IParserRewindPoint;

        // Rewinds the source to the position and state it was at when this rewind point was created.
        // This does not need to be called if the parser decides it does not need to rewind.  For 
        // example, the parser may speculatively parse out a lambda expression when it sees something
        // ambiguous like "(a = b, c = ...".  If it succeeds parsing that as a lambda, then it will
        // just return that result.  However, if it fails *then* it will rewind and try it again as
        // a parenthesized expression.  
        rewind(rewindPoint: IParserRewindPoint): void;

        // Called when the parser is done speculative parsing and no longer needs the rewind point.
        // Must be called for every rewind point retrived.
        releaseRewindPoint(rewindPoint: IParserRewindPoint): void;

        // Retrieves the diagnostics generated while the source was producing nodes or tokens. 
        // Should generally only be called after the document has been completely parsed.
        tokenDiagnostics(): Diagnostic[];

        release(): void;
    }

    // Parser source used in batch scenarios.  Directly calls into an underlying text scanner and
    // supports none of the functionality to reuse nodes.  Good for when you just want want to do
    // a single parse of a file.
    class NormalParserSource implements IParserSource {
        // The sliding window that we store tokens in.
        private slidingWindow: SlidingWindow;

        // The scanner we're pulling tokens from.
        private scanner: Scanner;

        // The absolute position we're at in the text we're reading from.
        private _absolutePosition: number = 0;

        // The diagnostics we get while scanning.  Note: this never gets rewound when we do a normal
        // rewind.  That's because rewinding doesn't affect the tokens created.  It only affects where
        // in the token stream we're pointing at.  However, it will get modified if we we decide to
        // reparse a / or /= as a regular expression.
        private _tokenDiagnostics: Diagnostic[] = [];

        // Pool of rewind points we give out if the parser needs one.
        private rewindPointPool: IParserRewindPoint[] = [];
        private rewindPointPoolCount = 0;

        private lastDiagnostic: Diagnostic = null;
        private reportDiagnostic = (position: number, fullWidth: number, diagnosticKey: string, args: any[]) => {
            this.lastDiagnostic = new Diagnostic(this.fileName, this.text.lineMap(), position, fullWidth, diagnosticKey, args);
        }

        public release() {
            this.slidingWindow = null;
            this.scanner = null;
            this._tokenDiagnostics = [];
            this.rewindPointPool = [];
            this.lastDiagnostic = null;
            this.reportDiagnostic = null;
        }

        constructor(private fileName: string,
                    languageVersion: LanguageVersion,
                    public text: ISimpleText) {
            this.slidingWindow = new SlidingWindow(this, ArrayUtilities.createArray(/*defaultWindowSize:*/ 1024, null), null);
            this.scanner = createScanner(languageVersion, text, this.reportDiagnostic);
        }

        public currentNode(): ISyntaxNode {
            // The normal parser source never returns nodes.  They're only returned by the 
            // incremental parser source.
            return null;
        }

        public consumeNode(node: ISyntaxNode): void {
            // Should never get called.
            throw Errors.invalidOperation();
        }

        public absolutePosition() {
            return this._absolutePosition;
        }

        public tokenDiagnostics(): Diagnostic[] {
            return this._tokenDiagnostics;
        }

        private getOrCreateRewindPoint(): IParserRewindPoint {
            if (this.rewindPointPoolCount === 0) {
                return <IParserRewindPoint>{};
            }

            this.rewindPointPoolCount--;
            var result = this.rewindPointPool[this.rewindPointPoolCount];
            this.rewindPointPool[this.rewindPointPoolCount] = null;
            return result;
        }

        public getRewindPoint(): IParserRewindPoint {
            var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var rewindPoint = this.getOrCreateRewindPoint();

            rewindPoint.slidingWindowIndex = slidingWindowIndex;
            rewindPoint.absolutePosition = this._absolutePosition;

            rewindPoint.pinCount = this.slidingWindow.pinCount();

            return rewindPoint;
        }

        public isPinned(): boolean {
            return this.slidingWindow.pinCount() > 0;
        }

        public rewind(rewindPoint: IParserRewindPoint): void {
            this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

            this._absolutePosition = rewindPoint.absolutePosition;
        }

        public releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Debug.assert(this.slidingWindow.pinCount() === rewindPoint.pinCount);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex((<any>rewindPoint).absoluteIndex);

            this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
            this.rewindPointPoolCount++;
        }

        public fetchNextItem(allowContextualToken: boolean): ISyntaxToken {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(spaceAvailable > 0);
            var token = this.scanner.scan(allowContextualToken);

            var lastDiagnostic = this.lastDiagnostic;
            if (lastDiagnostic === null) {
                return token;
            }

            // If we produced any diagnostics while creating this token, then realize the token so 
            // it won't be reused in incremental scenarios.

            this._tokenDiagnostics.push(lastDiagnostic);
            this.lastDiagnostic = null;
            return Syntax.realizeToken(token);
        }

        public peekToken(n: number): ISyntaxToken {
            return this.slidingWindow.peekItemN(n);
        }

        public consumeToken(token: ISyntaxToken): void {
            // Debug.assert(this.currentToken() === token);
            this._absolutePosition += token.fullWidth();

            this.slidingWindow.moveToNextItem();
        }

        public currentToken(): ISyntaxToken {
            return this.slidingWindow.currentItem(/*allowContextualToken:*/ false);
        }

        private removeDiagnosticsOnOrAfterPosition(position: number): void {
            // walk backwards, removing any diagnostics that came after the the current token's
            // full start position.
            var tokenDiagnosticsLength = this._tokenDiagnostics.length;
            while (tokenDiagnosticsLength > 0) {
                var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                if (diagnostic.start() >= position) {
                    tokenDiagnosticsLength--;
                }
                else {
                    break;
                }
            }

            this._tokenDiagnostics.length = tokenDiagnosticsLength;
        }

        public resetToPosition(absolutePosition: number): void {
            this._absolutePosition = absolutePosition;

            // First, remove any diagnostics that came after this position.
            this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

            // Now, tell our sliding window to throw away all tokens after this position as well.
            this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

            // Now tell the scanner to reset its position to this position as well.  That way
            // when we try to scan the next item, we'll be at the right location.
            this.scanner.setIndex(absolutePosition);
        }

        public currentContextualToken(): ISyntaxToken {
            // We better be on a / or > token right now.
            // Debug.assert(SyntaxFacts.isAnyDivideToken(this.currentToken().kind()));

            // First, we're going to rewind all our data to the point where this / or /= token started.
            // That's because if it does turn out to be a regular expression, then any tokens or token 
            // diagnostics we produced after the original / may no longer be valid.  This would actually
            // be a  fairly expected case.  For example, if you had:  / ... gibberish ... /, we may have 
            // produced several diagnostics in the process of scanning the tokens after the first / as
            // they may not have been legal javascript okens.
            //
            // We also need to remove all the tokens we've gotten from the slash and onwards.  They may
            // not have been what the scanner would have produced if it decides that this is actually
            // a regular expresion.
            this.resetToPosition(this._absolutePosition);

            // Now actually fetch the token again from the scanner. This time let it know that it
            // can scan it as a regex token if it wants to.
            var token = this.slidingWindow.currentItem(/*allowContextualToken:*/ true);

            // We have better gotten some sort of regex token.  Otherwise, something *very* wrong has
            // occurred.
            // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.kind()));

            return token;
        }
    }

    // Parser source used in incremental scenarios. This parser source wraps an old tree, text 
    // change and new text, and uses all three to provide nodes and tokens to the parser.  In
    // general, nodes from the old tree are returned as long as they do not intersect with the text 
    // change.  Then, once the text change is reached, tokens from the old tree are returned as 
    // long as they do not intersect with the text change.  Then, the text that is actually changed
    // will be scanned using a normal scanner.  Then, once the new text is scanned, the source will
    // attempt to sync back up with nodes or tokens that started where the new tokens end. Once it
    // can do that, then all subsequent data will come from the original tree.
    //
    // This allows for an enormous amount of tree reuse in common scenarios.  Situations that 
    // prevent this level of reuse include substantially destructive operations like introducing
    // "/*" without a "*/" nearby to terminate the comment.
    class IncrementalParserSource implements IParserSource {
        // The underlying parser source that we will use to scan tokens from any new text, or any 
        // tokens from the old tree that we decide we can't use for any reason.  We will also 
        // continue scanning tokens from this source until we've decided that we're resynchronized
        // and can read in subsequent data from the old tree.
        //
        // This parser source also keeps track of the absolute position in the text that we're in,
        // and any token diagnostics produced.  That way we dont' have to track that ourselves.
        private _normalParserSource: NormalParserSource;

        // The range of text in the *original* text that was changed, and the new length of it after
        // the change.
        private _changeRange: TextChangeRange;

        // Cached value of _changeRange.newSpan().  Cached for performance.
        private _changeRangeNewSpan: TextSpan;

        // This number represents how our position in the old tree relates to the position we're 
        // pointing at in the new text.  If it is 0 then our positions are in sync and we can read
        // nodes or tokens from the old tree.  If it is non-zero, then our positions are not in 
        // sync and we cannot use nodes or tokens from the old tree.
        //
        // Now, changeDelta could be negative or positive.  Negative means 'the position we're at
        // in the original tree is behind the position we're at in the text'.  In this case we 
        // keep throwing out old nodes or tokens (and thus move forward in the original tree) until
        // changeDelta becomes 0 again or positive.  If it becomes 0 then we are resynched and can
        // read nodes or tokesn from the tree.
        //
        // If changeDelta is positive, that means the current node or token we're pointing at in 
        // the old tree is at a further ahead position than the position we're pointing at in the
        // new text.  In this case we have no choice but to scan tokens from teh new text.  We will
        // continue to do so until, again, changeDelta becomes 0 and we've resynced, or change delta
        // becomes negative and we need to skip nodes or tokes in the original tree.
        private _changeDelta: number = 0;

        // The cursor we use to navigate through and retrieve nodes and tokens from the old tree.
        private _oldSourceUnitCursor: SyntaxCursor;

        public release() {
            this._normalParserSource.release();
            this._normalParserSource = null;
            this._oldSourceUnitCursor = null;
        }

        constructor(oldSyntaxTree: SyntaxTree, textChangeRange: TextChangeRange, public text: ISimpleText) {
            var newText = text;

            var oldSourceUnit = oldSyntaxTree.sourceUnit();
            this._oldSourceUnitCursor = getSyntaxCursor();

            // Start the cursor pointing at the first element in the source unit (if it exists).
            if (oldSourceUnit.moduleElements.length > 0) {
                this._oldSourceUnitCursor.pushElement(childAt(oldSourceUnit.moduleElements, 0), /*indexInParent:*/ 0);
            }

            // In general supporting multiple individual edits is just not that important.  So we 
            // just collapse this all down to a single range to make the code here easier.  The only
            // time this could be problematic would be if the user made a ton of discontinuous edits.
            // For example, doing a column select on a *large* section of a code.  If this is a 
            // problem, we can always update this code to handle multiple changes.
            this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);
            this._changeRangeNewSpan = this._changeRange.newSpan();

            // The old tree's length, plus whatever length change was caused by the edit
            // Had better equal the new text's length!
            if (Debug.shouldAssert(AssertionLevel.Aggressive)) {
                Debug.assert((fullWidth(oldSourceUnit) - this._changeRange.span().length() + this._changeRange.newLength()) === newText.length());
            }

            // Set up a scanner so that we can scan tokens out of the new text.
            this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), oldSyntaxTree.languageVersion(), text);
        }

        private static extendToAffectedRange(changeRange:TextChangeRange,
                                             sourceUnit: SourceUnitSyntax): TextChangeRange {
            // Consider the following code:
            //      void foo() { /; }
            //
            // If the text changes with an insertion of / just before the semicolon then we end up with:
            //      void foo() { //; }
            //
            // If we were to just use the changeRange a is, then we would not rescan the { token 
            // (as it does not intersect the actual original change range).  Because an edit may
            // change the token touching it, we actually need to look back *at least* one token so
            // that the prior token sees that change.  
            //
            // Note: i believe (outside of regex tokens) max lookahead is just one token for 
            // TypeScript.  However, if this turns out to be wrong, we may have to increase how much
            // futher we look back. 
            //
            // Note: lookahead handling for regex characters is handled specially in during 
            // incremental parsing, and does not need to be handled here.

            var maxLookahead = 1;

            var start = changeRange.span().start();

            // the first iteration aligns us with the change start. subsequent iteration move us to
            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the
            // start of the tree.
            for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                var token = findToken(sourceUnit, start);

                // Debug.assert(token.kind !== SyntaxKind.None);
                // Debug.assert(token.kind() === SyntaxKind.EndOfFileToken || token.fullWidth() > 0);

                var position = token.fullStart();

                start = MathPrototype.max(0, position - 1);
            }

            var finalSpan = TextSpan.fromBounds(start, changeRange.span().end());
            var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

            return new TextChangeRange(finalSpan, finalLength);
        }

        private absolutePosition() {
            return this._normalParserSource.absolutePosition();
        }

        public tokenDiagnostics(): Diagnostic[] {
            return this._normalParserSource.tokenDiagnostics();
        }

        public getRewindPoint(): IParserRewindPoint {
            // Get a rewind point for our new text reader and for our old source unit cursor.
            var rewindPoint = this._normalParserSource.getRewindPoint();

            // Clone our cursor.  That way we can restore to that point if hte parser needs to rewind.
            var oldSourceUnitCursorClone = cloneSyntaxCursor(this._oldSourceUnitCursor);

            // Store where we were when the rewind point was created.
            rewindPoint.changeDelta = this._changeDelta;
            rewindPoint.changeRange = this._changeRange;
            rewindPoint.oldSourceUnitCursor = this._oldSourceUnitCursor;

            this._oldSourceUnitCursor = oldSourceUnitCursorClone;

            // Debug.assert(rewindPoint.pinCount === this._oldSourceUnitCursor.pinCount());

            return rewindPoint;
        }

        public rewind(rewindPoint: IParserRewindPoint): void {
            // Restore our state to the values when the rewind point was created.
            this._changeRange = rewindPoint.changeRange;
            this._changeDelta = rewindPoint.changeDelta;

            // Reset the cursor to what it was when we got the rewind point.  Make sure to return 
            // our existing cursor to the pool so it can be reused.
            returnSyntaxCursor(this._oldSourceUnitCursor);
            this._oldSourceUnitCursor = rewindPoint.oldSourceUnitCursor;

            // Null out the cursor that the rewind point points to.  This way we don't try
            // to return it in 'releaseRewindPoint'.
            rewindPoint.oldSourceUnitCursor = null;

            this._normalParserSource.rewind(rewindPoint);
        }

        public releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            if (rewindPoint.oldSourceUnitCursor !== null) {
                returnSyntaxCursor(rewindPoint.oldSourceUnitCursor);
            }

            this._normalParserSource.releaseRewindPoint(rewindPoint);
        }

        private canReadFromOldSourceUnit() {
            // If we're currently pinned, then do not want to touch the cursor.  If we end up 
            // reading from the old source unit, we'll try to then set the position of the normal
            // parser source to an absolute position (in moveToNextToken).  Doing is unsupported
            // while the underlying source is pinned.
            if (this._normalParserSource.isPinned()) {
                return false;
            }

            // If our current absolute position is in the middle of the changed range in the new text
            // then we definitely can't read from the old source unit right now.
            if (this._changeRange !== null && this._changeRangeNewSpan.intersectsWithPosition(this.absolutePosition())) {
                return false;
            }

            // First, try to sync up with the new text if we're behind.
            this.syncCursorToNewTextIfBehind();

            // Now, if we're synced up *and* we're not currently pinned in the new text scanner,
            // then we can read a node from the cursor.  If we're pinned in the scanner then we
            // can't read a node from the cursor because we will mess up the pinned scanner when
            // we try to move it forward past this node.
            return this._changeDelta === 0 &&
                   !this._oldSourceUnitCursor.isFinished();
        }

        private updateTokens(nodeOrToken: ISyntaxNodeOrToken): void {
            // If we got a node or token, and we're past the range of edited text, then walk its
            // constituent tokens, making sure all their positions are correct.  We don't need to
            // do this for the tokens before the edited range (since their positions couldn't have 
            // been affected by the edit), and we don't need to do this for the tokens in the 
            // edited range, as their positions will be correct when the underlying parser source 
            // creates them.

            var position = this.absolutePosition();
            var tokenWasMoved = this.isPastChangeRange() && fullStart(nodeOrToken) !== position;

            if (tokenWasMoved) {
                setTokenTextAndFullStartWalker.text = this.text;
                setTokenTextAndFullStartWalker.position = position;

                visitNodeOrToken(setTokenTextAndFullStartWalker, nodeOrToken);
            }
        }

        public currentNode(): ISyntaxNode {
            if (this.canReadFromOldSourceUnit()) {
                // Try to read a node.  If we can't then our caller will call back in and just try
                // to get a token.
                var node = this.tryGetNodeFromOldSourceUnit();
                if (node !== null) {
                    // Make sure the positions for the tokens in this node are correct.
                    this.updateTokens(node);
                    return node;
                }
            }

            // Either we were ahead of the old text, or we were pinned.  No node can be read here.
            return null;
        }

        public currentToken(): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryGetTokenFromOldSourceUnit();
                if (token !== null) {
                    // Make sure the token's position/text is correct.
                    this.updateTokens(token);
                    return token;
                }
            }

            // Either we couldn't read from the old source unit, or we weren't able to successfully
            // get a token from it.  In this case we need to read a token from the underlying text.
            return this._normalParserSource.currentToken();
        }

        public currentContextualToken(): ISyntaxToken {
            // Just delegate to the underlying source to handle this.
            return this._normalParserSource.currentContextualToken();
        }

        private syncCursorToNewTextIfBehind() {
            while (true) {
                if (this._oldSourceUnitCursor.isFinished()) {
                    // Can't sync up if the cursor is finished.
                    break;
                }

                if (this._changeDelta >= 0) {
                    // Nothing to do if we're synced up or ahead of the text.
                    break;
                }

                // We're behind in the original tree.  Throw out a node or token in an attempt to 
                // catch up to the position we're at in the new text.

                var currentNodeOrToken = this._oldSourceUnitCursor.currentNodeOrToken();

                // If we're pointing at a node, and that node's width is less than our delta,
                // then we can just skip that node.  Otherwise, if we're pointing at a node
                // whose width is greater than the delta, then crumble it and try again.
                // Otherwise, we must be pointing at a token.  Just skip it and try again.
                    
                if (isNode(currentNodeOrToken) && (fullWidth(currentNodeOrToken) > Math.abs(this._changeDelta))) {
                    // We were pointing at a node whose width was more than changeDelta.  Crumble the 
                    // node and try again.  Note: we haven't changed changeDelta.  So the callers loop
                    // will just repeat this until we get to a node or token that we can skip over.
                    this._oldSourceUnitCursor.moveToFirstChild();
                }
                else {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    // Get our change delta closer to 0 as we skip past this item.
                    this._changeDelta += fullWidth(currentNodeOrToken);

                    // If this was a node, then our changeDelta is 0 or negative.  If this was a 
                    // token, then we could still be negative (and we have to read another token),
                    // we could be zero (we're done), or we could be positive (we've moved ahead
                    // of the new text).  Only if we're negative will we continue looping.
                }
            }

            // At this point, we must be either:
            //   a) done with the cursor
            //   b) (ideally) caught up to the new text position.
            //   c) ahead of the new text position.
            // In case 'b' we can try to reuse a node from teh old tree.
            // Debug.assert(this._oldSourceUnitCursor.isFinished() || this._changeDelta >= 0);
        }

        private intersectsWithChangeRangeSpanInOriginalText(start: number, length: number) {
            return !this.isPastChangeRange() && this._changeRange.span().intersectsWith(start, length);
        }

        private tryGetNodeFromOldSourceUnit(): ISyntaxNode {
            // Debug.assert(this.canReadFromOldSourceUnit());

            // Keep moving the cursor down to the first node that is safe to return.  A node is 
            // safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it does not have any zero width tokens in it.
            //  d) it does not have a regex token in it.
            //  e) we are still in the same strict or non-strict state that the node was originally parsed in.
            while (true) {
                var node = this._oldSourceUnitCursor.currentNode();
                if (node === null) {
                    // Couldn't even read a node, nothing to return.
                    return null;
                }

                if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), fullWidth(node))) {
                    // Didn't intersect with the change range.
                    var isIncrementallyUnusuable = TypeScript.isIncrementallyUnusable(node);
                    if (!isIncrementallyUnusuable) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a node we can reuse.
                        return node;
                    }
                }

                // We couldn't use currentNode. Try to move to its first child (in case that's a 
                // node).  If it is we can try using that.  Otherwise we'll just bail out in the
                // next iteration of the loop.
                this._oldSourceUnitCursor.moveToFirstChild();
            }
        }

        private canReuseTokenFromOldSourceUnit(position: number, token: ISyntaxToken): boolean {
            // A token is safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it is not zero width.
            //  d) it is not a contextual parser token.
            //
            // NOTE: It is safe to get a token regardless of what our strict context was/is.  That's 
            // because the strict context doesn't change what tokens are scanned, only how the 
            // parser reacts to them.
            //
            // NOTE: we don't mark a keyword that was converted to an identifier as 'incrementally 
            // unusable.  This is because we don't want to mark it's containing parent node as 
            // unusable.  i.e. if i have this:  "public Foo(string: Type) { }", then that *entire* node 
            // is reusuable even though "string" was converted to an identifier.  However, we still
            // need to make sure that if that the parser asks for a *token* we don't return it.  
            // Converted identifiers can't ever be created by the scanner, and as such, should not 
            // be returned by this source.
            if (token !== null) {
                if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                    // Didn't intersect with the change range.
                    if (!token.isIncrementallyUnusable() && !isContextualToken(token)) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a token we can reuse.
                        return true;
                    }
                }
            }

            return false;
        }

        private tryGetTokenFromOldSourceUnit(): ISyntaxToken {
            // Debug.assert(this.canReadFromOldSourceUnit());

            // get the current token that the cursor is pointing at.
            var token = this._oldSourceUnitCursor.currentToken();

            return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) 
                ? token : null;
        }

        public peekToken(n: number): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryPeekTokenFromOldSourceUnit(n);
                if (token !== null) {
                    return token;
                }
            }

            // Couldn't peek this far in the old tree.  Get the token from the new text.
            return this._normalParserSource.peekToken(n);
        }

        private tryPeekTokenFromOldSourceUnit(n: number): ISyntaxToken {
            // Debug.assert(this.canReadFromOldSourceUnit());
            
            // clone the existing cursor so we can move it forward and then restore ourselves back
            // to where we started from.

            var cursorClone = cloneSyntaxCursor(this._oldSourceUnitCursor);

            var token = this.tryPeekTokenFromOldSourceUnitWorker(n);

            returnSyntaxCursor(this._oldSourceUnitCursor);
            this._oldSourceUnitCursor = cursorClone;

            return token;
        }

        private tryPeekTokenFromOldSourceUnitWorker(n: number): ISyntaxToken {
            // In order to peek the 'nth' token we need all the tokens up to that point.  That way
            // we know we know position that the nth token is at.  The position is necessary so 
            // that we can test if this token (or any that precede it cross the change range).
            var currentPosition = this.absolutePosition();

            // First, make sure the cursor is pointing at a token.
            this._oldSourceUnitCursor.moveToFirstToken();

            // Now, keep walking forward to successive tokens.
            for (var i = 0; i < n; i++) {
                var interimToken = this._oldSourceUnitCursor.currentToken();

                if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                    return null;
                }

                currentPosition += interimToken.fullWidth();
                this._oldSourceUnitCursor.moveToNextSibling();
            }

            var token = this._oldSourceUnitCursor.currentToken();
            return this.canReuseTokenFromOldSourceUnit(currentPosition, token) 
                ? token : null;
        }

        public consumeNode(node: ISyntaxNode): void {
            // A node could have only come from the old source unit cursor.  Update it and our 
            // current state.
            // Debug.assert(this._changeDelta === 0);
            // Debug.assert(this.currentNode() === node);

            this._oldSourceUnitCursor.moveToNextSibling();

            // Update the underlying source with where it should now be currently pointin.
            var absolutePosition = this.absolutePosition() + fullWidth(node);
            this._normalParserSource.resetToPosition(absolutePosition);

            // Debug.assert(previousToken !== null);
            // Debug.assert(previousToken.width() > 0);

            //if (!this.isPastChangeRange()) {
            //    // If we still have a change range, then this node must have ended before the 
            //    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
            //    Debug.assert(this.absolutePosition() < this._changeRange.span().start());
            //}
        }

        public consumeToken(currentToken: ISyntaxToken): void {
            // This token may have come from the old source unit, or from the new text.  Handle
            // both accordingly.

            if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                // The token came from the old source unit.  So our tree and text must be in sync.
                // Debug.assert(this._changeDelta === 0);

                // Move the cursor past this token.
                this._oldSourceUnitCursor.moveToNextSibling();

                // Debug.assert(!this._normalParserSource.isPinned());
                
                // Update the underlying source with where it should now be currently pointing. We 
                // don't need to do this when the token came from the new text as the source will
                // automatically be placed in the right position.
                var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                this._normalParserSource.resetToPosition(absolutePosition);

                // Debug.assert(previousToken !== null);
                // Debug.assert(previousToken.width() > 0);

                //if (!this.isPastChangeRange()) {
                //    // If we still have a change range, then this token must have ended before the 
                //    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                //    Debug.assert(this.absolutePosition() < this._changeRange.span().start());
                //}
            }
            else {
                // the token came from the new text.  That means the normal source moved forward,
                // while the syntax cursor stayed in the same place.  Thus our delta moves even 
                // further back.
                this._changeDelta -= currentToken.fullWidth();

                // Move our underlying source forward.
                this._normalParserSource.consumeToken(currentToken);

                // Because we read a token from the new text, we may have moved ourselves past the
                // change range.  If we did, then we may also have to update our change delta to
                // compensate for the length change between the old and new text.
                if (!this.isPastChangeRange()) {
                    // var changeEndInNewText = this._changeRange.span().start() + this._changeRange.newLength();
                    if (this.absolutePosition() >= this._changeRangeNewSpan.end()) {
                        this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();

                        // Once we're past the change range, we no longer need it.  Null it out.
                        // From now on we can check if we're past the change range just by seeing
                        // if this is null.
                        this._changeRange = null;
                    }
                }
            }
        }

        private isPastChangeRange(): boolean {
            return this._changeRange === null;
        }
    }

    // A simple walker we use to hit all the tokens of a node and update their positions when they
    // are reused in a different location because of an incremental parse.

    class SetTokenTextAndFullStartWalker extends SyntaxWalker {
        public position: number;
        public text: ISimpleText;

        public visitToken(token: ISyntaxToken): void {
            var position = this.position;
            token.setTextAndFullStart(this.text, position);

            this.position = position + token.fullWidth();
        }
    }

    var setTokenTextAndFullStartWalker = new SetTokenTextAndFullStartWalker();

    var arrayPool: any[][] = [];
    var arrayPoolCount: number = 0;

    function getArray(): any[] {
        if (arrayPoolCount === 0) {
            return [];
        }

        arrayPoolCount--;
        var result = arrayPool[arrayPoolCount];
        arrayPool[arrayPoolCount] = null;

        return result;
    }

    function returnZeroLengthArray(array: any[]) {
        if (array.length === 0) {
            returnArray(array);
        }
    }

    function returnArray(array: any[]) {
        array.length = 0;
        arrayPool[arrayPoolCount] = array;
        arrayPoolCount++;
    }

    interface IParser {
        parseSyntaxTree(fileName: string, source: IParserSource, languageVersion: LanguageVersion, isDeclaration: boolean): SyntaxTree;
    }

    // Contains the actual logic to parse typescript/javascript.  This is the code that generally
    // represents the logic necessary to handle all the language grammar constructs.  When the 
    // language changes, this should generally only be the place necessary to fix up.
    function createParser(): IParser {
        // Name of the file we're parsing.
        var fileName: string;

        // Underlying source where we pull nodes and tokens from.
        var source: IParserSource;

        var languageVersion: LanguageVersion;

        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        var listParsingState: ListParsingState = 0;

        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
        // that some tokens that would be considered identifiers may be considered keywords.  When 
        // rewinding, we need to store and restore this as the mode may have changed.
        //
        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        var isInStrictMode: boolean = false;

        // Current state of the parser.  If we need to rewind we will store and reset these values as
        // appropriate.

        // Diagnostics created when parsing invalid code.  Any diagnosics created when speculative 
        // parsing need to removed when rewinding.  To do this we store the count of diagnostics when 
        // we start speculative parsing.  And if we rewind, we restore this to the same count that we 
        // started at.
        var diagnostics: Diagnostic[] = [];

        var parseNodeData: number = 0;

        function parseSyntaxTree(_fileName: string, _source: IParserSource, _languageVersion: LanguageVersion, isDeclaration: boolean): SyntaxTree {
            // First, set up our state.
            fileName = _fileName;
            source = _source;
            languageVersion = _languageVersion;

            // Now actually parse the tree.
            var result = parseSyntaxTreeWorker(isDeclaration);

            // Now, clear out our state so that our singleton parser doesn't keep things alive.
            diagnostics = [];
            parseNodeData = SyntaxConstants.None;
            fileName = null;
            source.release();
            source = null;
            _source = null;

            return result;
        }


        function parseSyntaxTreeWorker(isDeclaration: boolean): SyntaxTree {
            var sourceUnit = parseSourceUnit();

            var allDiagnostics = source.tokenDiagnostics().concat(diagnostics);
            allDiagnostics.sort((a: Diagnostic, b: Diagnostic) => a.start() - b.start());

            return new SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, fileName, source.text.lineMap(), languageVersion);
        }

        function getRewindPoint(): IParserRewindPoint {
            var rewindPoint = source.getRewindPoint();

            rewindPoint.diagnosticsCount = diagnostics.length;

            // Values we keep around for debug asserting purposes.
            rewindPoint.isInStrictMode = isInStrictMode;
            rewindPoint.listParsingState = listParsingState;

            return rewindPoint;
        }

        function rewind(rewindPoint: IParserRewindPoint): void {
            source.rewind(rewindPoint);

            diagnostics.length = rewindPoint.diagnosticsCount;
        }

        function releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Debug.assert(listParsingState === rewindPoint.listParsingState);
            // Debug.assert(isInStrictMode === rewindPoint.isInStrictMode);

            source.releaseRewindPoint(rewindPoint);
        }

        function currentNode(): ISyntaxNode {
            var node = source.currentNode();

            // We can only reuse a node if it was parsed under the same strict mode that we're 
            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
            // the user added 'using strict' at the top of the file, then we can't use that node
            // again as the presense of strict mode may cause us to parse the tokens in the file
            // differetly.
            //
            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
            // are unaffected by strict mode.  It's just the parser will decide what to do with it
            // differently depending on what mode it is in.
            if (node === null || parsedInStrictMode(node) !== isInStrictMode) {
                return null;
            }

            return node;
        }

        function currentToken(): ISyntaxToken {
            return source.currentToken();
        }

        function currentContextualToken(): ISyntaxToken {
            // We're mutating the source here.  We are potentially overwriting the original token we
            // scanned with a regex token.  So we have to clear our state.
            return source.currentContextualToken();
        }

        function peekToken(n: number): ISyntaxToken {
            return source.peekToken(n);
        }

        function consumeToken(token: ISyntaxToken): void {
            source.consumeToken(token);
        }

        function consumeNode(node: ISyntaxNode): void {
            source.consumeNode(node);
        }

        //this method is called very frequently
        //we should keep it simple so that it can be inlined.
        function eatToken(kind: SyntaxKind): ISyntaxToken {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(SyntaxFacts.isTokenKind(kind()))

            var token = currentToken();
            if (token.kind() === kind) {
                consumeToken(token);
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return createMissingToken(kind, token);
        }

        // Eats the token if it is there.  Otherwise does nothing.  Will not report errors.
        function tryEatToken(kind: SyntaxKind): ISyntaxToken {
            if (currentToken().kind() === kind) {
                return eatToken(kind);
            }

            return null;
        }

        function eatKeyword(kind: SyntaxKind): ISyntaxToken {
            // Debug.assert(SyntaxFacts.isTokenKind(kind))

            var token = currentToken();
            if (token.kind() === kind) {
                consumeToken(token);
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return createMissingToken(kind, token);
        }

        // An identifier is basically any word, unless it is a reserved keyword.  so 'foo' is an 
        // identifier and 'return' is not.  Note: a word may or may not be an identifier depending 
        // on the state of the parser.  For example, 'yield' is an identifier *unless* the parser 
        // is in strict mode.
        function isIdentifier(token: ISyntaxToken): boolean {
            var tokenKind = token.kind();

            if (tokenKind === SyntaxKind.IdentifierName) {
                return true;
            }

            // Keywords are only identifiers if they're FutureReservedStrictWords and we're in 
            // strict mode.  *Or* if it's a typescript 'keyword'. 
            if (tokenKind >= SyntaxKind.FirstFutureReservedStrictKeyword) {
                if (tokenKind <= SyntaxKind.LastFutureReservedStrictKeyword) {
                    // Could be a keyword or identifier.  It's an identifier if we're not in strict
                    // mode.
                    return !isInStrictMode;
                }
                
                // If it's typescript keyword, then it's actually a javascript identifier.
                return tokenKind <= SyntaxKind.LastTypeScriptKeyword;
            }

            // Anything else is not an identifier.
            return false;
        }

        // This method should be called when the grammar calls for an *IdentifierName* and not an
        // *Identifier*.
        function eatIdentifierNameToken(): ISyntaxToken {
            var token = currentToken();

            // If we have an identifier name, then consume and return it.
            if (token.kind() === SyntaxKind.IdentifierName) {
                consumeToken(token);
                return token;
            }

            // If we have a keyword, then it can be used as an identifier name.  However, we need 
            // to convert it to an identifier so that no later parts of the systems see it as a 
            // keyword.
            if (SyntaxFacts.isAnyKeyword(token.kind())) {
                consumeToken(token);
                return token.convertKeywordToIdentifier();
            }

            return createMissingToken(SyntaxKind.IdentifierName, token);
        }

        function eatOptionalIdentifierToken(): ISyntaxToken {
            return isIdentifier(currentToken()) ? eatIdentifierToken() : null;
        }

        // This method should be called when the grammar calls for an *Identifier* and not an
        // *IdentifierName*.
        function eatIdentifierToken(): ISyntaxToken {
            var token = currentToken();
            if (isIdentifier(token)) {
                consumeToken(token);

                if (token.kind() === SyntaxKind.IdentifierName) {
                    return token;
                }

                return token.convertKeywordToIdentifier();
            }

            return createMissingToken(SyntaxKind.IdentifierName, token);
        }

        function previousTokenHasTrailingNewLine(token: ISyntaxToken): boolean {
            var tokenFullStart = token.fullStart();
            if (tokenFullStart === 0) {
                // First token in the document.  Thus it has no 'previous' token, and there is 
                // no preceding newline.
                return false;
            }

            // If our previous token ended with a newline, then *by definition* we must have started
            // at the beginning of a line.  
            var lineNumber = source.text.lineMap().getLineNumberFromPosition(tokenFullStart);
            var lineStart = source.text.lineMap().getLineStartPosition(lineNumber);

            return lineStart == tokenFullStart;
        }

        function canEatAutomaticSemicolon(allowWithoutNewLine: boolean): boolean {
            var token = currentToken();

            // An automatic semicolon is always allowed if we're at the end of the file.
            if (token.kind() === SyntaxKind.EndOfFileToken) {
                return true;
            }

            // Or if the next token is a close brace (regardless of which line it is on).
            if (token.kind() === SyntaxKind.CloseBraceToken) {
                return true;
            }

            if (allowWithoutNewLine) {
                return true;
            }

            // It is also allowed if there is a newline between the last token seen and the next one.
            if (previousTokenHasTrailingNewLine(token)) {
                return true;
            }

            return false;
        }

        function canEatExplicitOrAutomaticSemicolon(allowWithoutNewline: boolean): boolean {
            var token = currentToken();

            if (token.kind() === SyntaxKind.SemicolonToken) {
                return true;
            }

            return canEatAutomaticSemicolon(allowWithoutNewline);
        }

        function eatExplicitOrAutomaticSemicolon(allowWithoutNewline: boolean): ISyntaxToken {
            var token = currentToken();

            // If we see a semicolon, then we can definitely eat it.
            if (token.kind() === SyntaxKind.SemicolonToken) {
                return eatToken(SyntaxKind.SemicolonToken);
            }

            // Check if an automatic semicolon could go here.  If so, then there's no problem and
            // we can proceed without error.  Return 'null' as there's no actual token for this 
            // position. 
            if (canEatAutomaticSemicolon(allowWithoutNewline)) {
                return null;
            }

            // No semicolon could be consumed here at all.  Just call the standard eating function
            // so we get the token and the error for it.
            return eatToken(SyntaxKind.SemicolonToken);
        }

        function isKeyword(kind: SyntaxKind): boolean {
            if (kind >= SyntaxKind.FirstKeyword) {
                if (kind <= SyntaxKind.LastFutureReservedKeyword) {
                    return true;
                }

                if (isInStrictMode) {
                    return kind <= SyntaxKind.LastFutureReservedStrictKeyword;
                }
            }

            return false;
        }

        function createMissingToken(expectedKind: SyntaxKind, actual: ISyntaxToken): ISyntaxToken {
            var diagnostic = getExpectedTokenDiagnostic(expectedKind, actual);
            addDiagnostic(diagnostic);

            // The missing token will be at the full start of the current token.  That way empty tokens
            // will always be between real tokens and not inside an actual token.
            return Syntax.emptyToken(expectedKind);
        }

        function getExpectedTokenDiagnostic(expectedKind: SyntaxKind, actual: ISyntaxToken): Diagnostic {
            var token = currentToken();

            // They wanted something specific, just report that that token was missing.
            if (SyntaxFacts.isAnyKeyword(expectedKind) || SyntaxFacts.isAnyPunctuation(expectedKind)) {
                return new Diagnostic(fileName, source.text.lineMap(), start(token), width(token), DiagnosticCode._0_expected, [SyntaxFacts.getText(expectedKind)]);
            }
            else {
                // They wanted an identifier.

                // If the user supplied a keyword, give them a specialized message.
                if (actual !== null && SyntaxFacts.isAnyKeyword(actual.kind())) {
                    return new Diagnostic(fileName, source.text.lineMap(), start(token), width(token), DiagnosticCode.Identifier_expected_0_is_a_keyword, [SyntaxFacts.getText(actual.kind())]);
                }
                else {
                    // Otherwise just report that an identifier was expected.
                    return new Diagnostic(fileName, source.text.lineMap(), start(token), width(token), DiagnosticCode.Identifier_expected, null);
                }
            }

            // throw Errors.notYetImplemented();
        }

        function getBinaryExpressionPrecedence(expressionKind: SyntaxKind): BinaryExpressionPrecedence {
            switch (expressionKind) {
                case SyntaxKind.LogicalOrExpression:
                    return BinaryExpressionPrecedence.LogicalOrExpressionPrecedence;

                case SyntaxKind.LogicalAndExpression:
                    return BinaryExpressionPrecedence.LogicalAndExpressionPrecedence;

                case SyntaxKind.BitwiseOrExpression:
                    return BinaryExpressionPrecedence.BitwiseOrExpressionPrecedence;

                case SyntaxKind.BitwiseExclusiveOrExpression:
                    return BinaryExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence;

                case SyntaxKind.BitwiseAndExpression:
                    return BinaryExpressionPrecedence.BitwiseAndExpressionPrecedence;

                case SyntaxKind.EqualsWithTypeConversionExpression:
                case SyntaxKind.NotEqualsWithTypeConversionExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                    return BinaryExpressionPrecedence.EqualityExpressionPrecedence;

                case SyntaxKind.LessThanExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.InstanceOfExpression:
                case SyntaxKind.InExpression:
                    return BinaryExpressionPrecedence.RelationalExpressionPrecedence;

                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.SignedRightShiftExpression:
                case SyntaxKind.UnsignedRightShiftExpression:
                    return BinaryExpressionPrecedence.ShiftExpressionPrecdence;

                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                    return BinaryExpressionPrecedence.AdditiveExpressionPrecedence;

                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                    return BinaryExpressionPrecedence.MultiplicativeExpressionPrecedence;
            }

            throw Errors.invalidOperation();
        }
        
        function addSkippedTokenAfterNodeOrToken(nodeOrToken: ISyntaxNodeOrToken, skippedToken: ISyntaxToken): ISyntaxNodeOrToken {
            if (isToken(nodeOrToken)) {
                return addSkippedTokenAfterToken(<ISyntaxToken>nodeOrToken, skippedToken);
            }
            else if (isNode(nodeOrToken)) {
                return addSkippedTokenAfterNode(<ISyntaxNode>nodeOrToken, skippedToken);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        function clearCachedNodeData(element: ISyntaxElement): void {
        }

        function replaceTokenInParent(oldToken: ISyntaxToken, newToken: ISyntaxToken): void {
            // oldToken may be parented by a node or a list.
            replaceTokenInParentWorker(oldToken, newToken);

            var parent = oldToken.parent;
            newToken.parent = parent;

            // Parent must be a list or a node.  All of those have a 'data' element.
            Debug.assert(isNode(parent) || isList(parent) || isSeparatedList(parent));
            var dataElement = <{ data: number }><any>parent;
            if (dataElement.data) {
                dataElement.data &= SyntaxConstants.NodeParsedInStrictModeMask
            }
        }

        function replaceTokenInParentWorker(oldToken: ISyntaxToken, newToken: ISyntaxToken): void {
            var parent = oldToken.parent;

            if (isNode(parent)) {
                var node = <any>parent;
                for (var key in node) {
                    if (node[key] === oldToken) {
                        node[key] = newToken;
                        return;
                    }
                }
            }
            else if (isList(parent)) {
                var list1 = <ISyntaxNodeOrToken[]>parent;
                for (var i = 0, n = list1.length; i < n; i++) {
                    if (list1[i] === oldToken) {
                        list1[i] = newToken;
                        return;
                    }
                }
            }
            else if (isSeparatedList(parent)) {
                var list2 = <ISyntaxNodeOrToken[]>parent;
                for (var i = 0, n = childCount(list2); i < n; i++) {
                    if (childAt(list2, i) === oldToken) {
                        if (i % 2 === 0) {
                            list2[i / 2] = newToken;
                        }
                        else {
                            list2.separators[(i - 1) / 2] = newToken;
                        }
                        return;
                    }
                }
            }

            throw Errors.invalidOperation();
        }

        function addSkippedTokenAfterNode(node: ISyntaxNode, skippedToken: ISyntaxToken): ISyntaxNode {
            var oldToken = lastToken(node);
            var newToken = addSkippedTokenAfterToken(oldToken, skippedToken);

            replaceTokenInParent(oldToken, newToken);
            return node;
        }

        function addSkippedTokensBeforeNode(node: ISyntaxNode, skippedTokens: ISyntaxToken[]): ISyntaxNode {
            if (skippedTokens.length > 0) {
                var oldToken = firstToken(node);
                var newToken = addSkippedTokensBeforeToken(oldToken, skippedTokens);

                replaceTokenInParent(oldToken, newToken);
            }

            return node;
        }

        function addSkippedTokensBeforeToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0 || token.kind() === SyntaxKind.EndOfFileToken);
            // Debug.assert(skippedTokens.length > 0);

            var leadingTrivia: ISyntaxTrivia[] = [];
            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                var skippedToken = skippedTokens[i];
                addSkippedTokenToTriviaArray(leadingTrivia, skippedToken);
            }

            addTriviaTo(token.leadingTrivia(), leadingTrivia);

            var updatedToken = Syntax.withLeadingTrivia(token, Syntax.triviaList(leadingTrivia));

            // We've prepending this token with new leading trivia.  This means the full start of
            // the token is not where the scanner originally thought it was, but is instead at the
            // start of the first skipped token.
            updatedToken.setTextAndFullStart(source.text, skippedTokens[0].fullStart());

            // Don't need this array anymore.  Give it back so we can reuse it.
            returnArray(skippedTokens);

            return updatedToken;
        }

        function addSkippedTokensAfterToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0);
            if (skippedTokens.length === 0) {
                returnArray(skippedTokens);
                return token;
            }

            var trailingTrivia = token.trailingTrivia().toArray();

            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
            }

            // Don't need this array anymore.  Give it back so we can reuse it.
            returnArray(skippedTokens);
            return Syntax.withTrailingTrivia(token, Syntax.triviaList(trailingTrivia));
        }

        function addSkippedTokenAfterToken(token: ISyntaxToken, skippedToken: ISyntaxToken): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0);

            var trailingTrivia = token.trailingTrivia().toArray();
            addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

            return Syntax.withTrailingTrivia(token, Syntax.triviaList(trailingTrivia));
        }

        function addSkippedTokenToTriviaArray(array: ISyntaxTrivia[], skippedToken: ISyntaxToken): void {
            // Debug.assert(skippedToken.text().length > 0);
            
            // first, add the leading trivia of the skipped token to the array
            addTriviaTo(skippedToken.leadingTrivia(), array);

            // now, add the text of the token as skipped text to the trivia array.
            var trimmedToken = Syntax.withTrailingTrivia(Syntax.withLeadingTrivia(skippedToken, Syntax.emptyTriviaList), Syntax.emptyTriviaList);

            // Because we removed the leading trivia from the skipped token, the full start of the
            // trimmed token is the start of the skipped token.
            trimmedToken.setTextAndFullStart(source.text, start(skippedToken));

            array.push(Syntax.skippedTokenTrivia(trimmedToken));

            // Finally, add the trailing trivia of the skipped token to the trivia array.
            addTriviaTo(skippedToken.trailingTrivia(), array);
        }

        function addTriviaTo(list: ISyntaxTriviaList, array: ISyntaxTrivia[]): void {
            for (var i = 0, n = list.count(); i < n; i++) {
                array.push(list.syntaxTriviaAt(i));
            }
        }

        function setStrictMode(_isInStrictMode: boolean) {
            isInStrictMode = _isInStrictMode;
            parseNodeData = _isInStrictMode ? SyntaxConstants.NodeParsedInStrictModeMask : 0;
        }

        function parseSourceUnit(): SourceUnitSyntax {
            // Note: technically we don't need to save and restore this here.  After all, this the top
            // level parsing entrypoint.  So it will always start as false and be reset to false when the
            // loop ends.  However, for sake of symmetry and consistancy we do this.
            var savedIsInStrictMode = isInStrictMode;

            var result = parseSyntaxList<IModuleElementSyntax>(ListParsingState.SourceUnit_ModuleElements, updateStrictModeState);
            var moduleElements = result.list;

            setStrictMode(savedIsInStrictMode);

            var sourceUnit = new SourceUnitSyntax(parseNodeData, moduleElements, currentToken());

            sourceUnit = <SourceUnitSyntax>addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

            if (Debug.shouldAssert(AssertionLevel.Aggressive)) {
                Debug.assert(fullWidth(sourceUnit) === source.text.length());

                if (Debug.shouldAssert(AssertionLevel.VeryAggressive)) {
                    Debug.assert(fullText(sourceUnit) === source.text.substr(0, source.text.length()));
                }
            }

            return sourceUnit;
        }

        function updateStrictModeState(items: any[]): void {
            if (!isInStrictMode) {
                // Check if all the items are directive prologue elements.
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (!SyntaxFacts.isDirectivePrologueElement(item)) {
                        return;
                    }
                }

                setStrictMode(SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
            }
        }

        function isModuleElement(inErrorRecovery: boolean): boolean {
            if (SyntaxUtilities.isModuleElement(currentNode())) {
                return true;
            }

            var _currentToken = currentToken();
            var nextToken = peekToken(1);
            var _modifierCount = modifierCount();
            var tokenAfterModifiers = peekToken(_modifierCount);
            return isImportDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                   isExportAssignment() ||
                   isModuleDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                   isInterfaceDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                   isClassDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                   isEnumDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                   isStatement(inErrorRecovery);
        }
        
        function tryParseModuleElement(inErrorRecovery: boolean): IModuleElementSyntax {
            var node = currentNode();
            if (SyntaxUtilities.isModuleElement(node)) {
                consumeNode(node);
                return <IModuleElementSyntax>node;
            }

            var _currentToken = currentToken();
            var nextToken = peekToken(1);
            var _modifierCount = modifierCount();
            var tokenAfterModifiers = peekToken(_modifierCount);

            if (isImportDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {
                return parseImportDeclaration();
            }
            else if (isExportAssignment()) {
                return parseExportAssignment();
            }
            else if (isModuleDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {
                return parseModuleDeclaration();
            }
            else if (isInterfaceDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {
                return parseInterfaceDeclaration();
            }
            else if (isClassDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {
                return parseClassDeclaration();
            }
            else if (isEnumDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {
                return parseEnumDeclaration();
            }
            else {
                return tryParseStatement(inErrorRecovery);
            }
        }

        function isImportDeclaration(currentToken: ISyntaxToken, nextToken: ISyntaxToken, modifierCount: number, tokenAfterModifiers: ISyntaxToken): boolean {
            // If we have at least one modifier, and we see 'import', then consider this an import
            // declaration.
            if (modifierCount > 0 &&
                tokenAfterModifiers.kind() === SyntaxKind.ImportKeyword) {
                return true;
            }

            // 'import' is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a import construct and not some javascript expression.
            return currentToken.kind() === SyntaxKind.ImportKeyword &&
                isIdentifier(nextToken);
        }

        function parseImportDeclaration(): ImportDeclarationSyntax {
            return new ImportDeclarationSyntax(parseNodeData,
                parseModifiers(),
                eatKeyword(SyntaxKind.ImportKeyword),
                eatIdentifierToken(),
                eatToken(SyntaxKind.EqualsToken),
                parseModuleReference(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function isExportAssignment(): boolean {
            return currentToken().kind() === SyntaxKind.ExportKeyword &&
                peekToken(1).kind() === SyntaxKind.EqualsToken;
        }

        function parseExportAssignment(): ExportAssignmentSyntax {
            return new ExportAssignmentSyntax(parseNodeData,
                eatKeyword(SyntaxKind.ExportKeyword),
                eatToken(SyntaxKind.EqualsToken),
                eatIdentifierToken(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseModuleReference(): IModuleReferenceSyntax {
            if (isExternalModuleReference()) {
                return parseExternalModuleReference();
            }
            else {
                return parseModuleNameModuleReference();
            }
        }

        function isExternalModuleReference(): boolean {
            var token0 = currentToken();
            if (token0.kind() === SyntaxKind.RequireKeyword) {
                return peekToken(1).kind() === SyntaxKind.OpenParenToken;
            }

            return false;
        }

        function parseExternalModuleReference(): ExternalModuleReferenceSyntax {
            return new ExternalModuleReferenceSyntax(parseNodeData,
                eatKeyword(SyntaxKind.RequireKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                eatToken(SyntaxKind.StringLiteral),
                eatToken(SyntaxKind.CloseParenToken));
        }

        function parseModuleNameModuleReference(): ModuleNameModuleReferenceSyntax {
            return new ModuleNameModuleReferenceSyntax(parseNodeData, parseName());
        }

        // NOTE: This will allow all identifier names.  Even the ones that are keywords.
        function parseIdentifierName(): INameSyntax {
            var identifierName = eatIdentifierNameToken();
            return identifierName;
        }

        function tryParseTypeArgumentList(inExpression: boolean): TypeArgumentListSyntax {
            if (currentToken().kind() !== SyntaxKind.LessThanToken) {
                return null;
            }

            var lessThanToken: ISyntaxToken;
            var greaterThanToken: ISyntaxToken;
            var result: { skippedTokens: ISyntaxToken[]; list: ITypeSyntax[]; };
            var typeArguments: ITypeSyntax[];

            if (!inExpression) {
                // if we're not in an expression, this must be a type argument list.  Just parse
                // it out as such.
                lessThanToken = eatToken(SyntaxKind.LessThanToken);
                // Debug.assert(lessThanToken.fullWidth() > 0);

                result = parseSeparatedSyntaxList<ITypeSyntax>(ListParsingState.TypeArgumentList_Types);
                typeArguments = result.list;
                lessThanToken = addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                greaterThanToken = eatToken(SyntaxKind.GreaterThanToken);

                return new TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, greaterThanToken);
            }

            // If we're in an expression, then we only want to consume this as a type argument list
            // if we're sure that it's a type arg list and not an arithmetic expression.

            var rewindPoint = getRewindPoint();

            // We've seen a '<'.  Try to parse it out as a type argument list.
            lessThanToken = eatToken(SyntaxKind.LessThanToken);
            // Debug.assert(lessThanToken.fullWidth() > 0);

            result = parseSeparatedSyntaxList<ITypeSyntax>(ListParsingState.TypeArgumentList_Types);
            typeArguments = result.list;
            lessThanToken = addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

            greaterThanToken = eatToken(SyntaxKind.GreaterThanToken);

            // We're in a context where '<' could be the start of a type argument list, or part
            // of an arithmetic expression.  We'll presume it's the latter unless we see the '>'
            // and a following token that guarantees that it's supposed to be a type argument list.
            if (greaterThanToken.fullWidth() === 0 || !canFollowTypeArgumentListInExpression(currentToken().kind())) {
                rewind(rewindPoint);

                releaseRewindPoint(rewindPoint);
                return null;
            }
            else {
                releaseRewindPoint(rewindPoint);
                return new TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, greaterThanToken);
            }
        }

        function canFollowTypeArgumentListInExpression(kind: SyntaxKind): boolean {
            switch (kind) {
                case SyntaxKind.OpenParenToken:                 // foo<x>(   
                case SyntaxKind.DotToken:                       // foo<x>.
                    // These two cases are the only cases where this token can legally follow a
                    // type argument list.  So we definitely want to treat this as a type arg list.

                case SyntaxKind.CloseParenToken:                // foo<x>)
                case SyntaxKind.CloseBracketToken:              // foo<x>]
                case SyntaxKind.ColonToken:                     // foo<x>:
                case SyntaxKind.SemicolonToken:                 // foo<x>;
                case SyntaxKind.CommaToken:                     // foo<x>,
                case SyntaxKind.QuestionToken:                  // foo<x>?
                case SyntaxKind.EqualsEqualsToken:              // foo<x> ==
                case SyntaxKind.EqualsEqualsEqualsToken:        // foo<x> ===
                case SyntaxKind.ExclamationEqualsToken:         // foo<x> !=
                case SyntaxKind.ExclamationEqualsEqualsToken:   // foo<x> !==
                case SyntaxKind.AmpersandAmpersandToken:        // foo<x> &&
                case SyntaxKind.BarBarToken:                    // foo<x> ||
                case SyntaxKind.CaretToken:                     // foo<x> ^
                case SyntaxKind.AmpersandToken:                 // foo<x> &
                case SyntaxKind.BarToken:                       // foo<x> |
                case SyntaxKind.CloseBraceToken:                // foo<x> }
                case SyntaxKind.EndOfFileToken:                 // foo<x>
                    // these cases can't legally follow a type arg list.  However, they're not legal 
                    // expressions either.  The user is probably in the middle of a generic type. So
                    // treat it as such.
                    return true;

                default:
                    // Anything else treat as an expression.
                    return false;
            }
        }

        function parseName(): INameSyntax {
            return tryParseName() || eatIdentifierToken();
        }

        function eatRightSideOfName(): ISyntaxToken {
            var _currentToken = currentToken();

            // Technically a keyword is valid here as all keywords are identifier names.
            // However, often we'll encounter this in error situations when the keyword
            // is actually starting another valid construct.

            // So, we check for the following specific case:

            //      name.
            //      keyword identifierNameOrKeyword

            // Note: the newlines are important here.  For example, if that above code 
            // were rewritten into:

            //      name.keyword
            //      identifierNameOrKeyword

            // Then we would consider it valid.  That's because ASI would take effect and
            // the code would be implicitly: "name.keyword; identifierNameOrKeyword".  
            // In the first case though, ASI will not take effect because there is not a
            // line terminator after the dot.
            if (SyntaxFacts.isAnyKeyword(_currentToken.kind()) &&
                previousTokenHasTrailingNewLine(_currentToken) &&
                !_currentToken.hasTrailingNewLine() &&
                SyntaxFacts.isIdentifierNameOrAnyKeyword(peekToken(1))) {

                return createMissingToken(SyntaxKind.IdentifierName, _currentToken);
            }
            else {
                return eatIdentifierNameToken();
            }
        }

        function tryParseName(): INameSyntax {
            var token0 = currentToken();
            var shouldContinue = isIdentifier(token0);
            if (!shouldContinue) {
                return null;
            }

            // Call eatIdentifierName to convert the token to an identifier if it is as keyword.
            var current: INameSyntax = eatIdentifierToken();

            while (shouldContinue && currentToken().kind() === SyntaxKind.DotToken) {
                var dotToken = eatToken(SyntaxKind.DotToken);
                var identifierName = eatRightSideOfName();

                current = new QualifiedNameSyntax(parseNodeData, current, dotToken, identifierName);
                shouldContinue = identifierName.fullWidth() > 0;
            }

            return current;
        }

        function isEnumDeclaration(currentToken: ISyntaxToken, nextToken: ISyntaxToken, modifierCount: number, tokenAfterModifiers: ISyntaxToken): boolean {
            // If we have at least one modifier, and we see 'enum', then consider this an enum
            // declaration.
            if (modifierCount > 0 &&
                tokenAfterModifiers.kind() === SyntaxKind.EnumKeyword) {
                return true;
            }

            // 'enum' is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a enum construct and not some javascript expression.
            return currentToken.kind() === SyntaxKind.EnumKeyword &&
                   isIdentifier(nextToken);
        }

        function parseEnumDeclaration(): EnumDeclarationSyntax {
            // Debug.assert(isEnumDeclaration());

            var modifiers = parseModifiers();
            var enumKeyword = eatKeyword(SyntaxKind.EnumKeyword);
            var identifier = eatIdentifierToken();

            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);
            var enumElements = Syntax.emptySeparatedList<EnumElementSyntax>();

            if (openBraceToken.fullWidth() > 0) {
                var listResult = parseSeparatedSyntaxList<EnumElementSyntax>(ListParsingState.EnumDeclaration_EnumElements);
                enumElements = listResult.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, listResult.skippedTokens);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new EnumDeclarationSyntax(parseNodeData, modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken);
        }

        function isEnumElement(inErrorRecovery: boolean): boolean {
            if (currentNode() !== null && currentNode().kind() === SyntaxKind.EnumElement) {
                return true;
            }

            return isPropertyName(currentToken(), inErrorRecovery);
        }

        function tryParseEnumElementEqualsValueClause(): EqualsValueClauseSyntax {
            return isEqualsValueClause(/*inParameter*/ false) ? parseEqualsValueClause(/*allowIn:*/ true) : null;
        }

        function tryParseEnumElement(inErrorRecovery: boolean): EnumElementSyntax {
            // Debug.assert(isEnumElement());
            var node = currentNode();
            if (node !== null && node.kind() === SyntaxKind.EnumElement) {
                consumeNode(node);
                return <EnumElementSyntax>node;
            }

            if (!isPropertyName(currentToken(), inErrorRecovery)) {
                return null;
            }

            return new EnumElementSyntax(parseNodeData, eatPropertyName(), tryParseEnumElementEqualsValueClause());
        }

        function isModifier(token: ISyntaxToken): boolean {
            switch (token.kind()) {
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.StaticKeyword:
                case SyntaxKind.ExportKeyword:
                case SyntaxKind.DeclareKeyword:
                    return true;

                default:
                    return false;
            }
        }

        function modifierCount(): number {
            var modifierCount = 0;
            while (isModifier(peekToken(modifierCount))) {
                modifierCount++;
            }

            return modifierCount;
        }

        function parseModifiers(): ISyntaxToken[] {
            var tokens: ISyntaxToken[] = getArray();

            while (true) {
                var token = currentToken();
                if (isModifier(token)) {
                    consumeToken(token);
                    tokens.push(token);
                    continue;
                }

                break;
            }

            var result = Syntax.list(tokens);

            // If the tokens array is greater than one, then we can't return it.  It will have been 
            // copied directly into the syntax list.
            returnZeroLengthArray(tokens);

            return result;
        }

        function isClassDeclaration(currentToken: ISyntaxToken, nextToken: ISyntaxToken, modifierCount: number, tokenAfterModifiers: ISyntaxToken): boolean {
            // If we have at least one modifier, and we see 'class', then consider this a class
            // declaration.
            if (modifierCount > 0 &&
                tokenAfterModifiers.kind() === SyntaxKind.ClassKeyword) {
                return true;
            }

            // 'class' is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a class construct and not some javascript expression.
            return currentToken.kind() === SyntaxKind.ClassKeyword &&
                   isIdentifier(nextToken);
        }

        function parseHeritageClauses(): HeritageClauseSyntax[] {
            var heritageClauses = Syntax.emptyList<HeritageClauseSyntax>();
            
            if (isHeritageClause()) {
                var result = parseSyntaxList<HeritageClauseSyntax>(ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses);
                heritageClauses = result.list;
                // Debug.assert(result.skippedTokens.length === 0);
            }

            return heritageClauses;
        }

        function tryParseHeritageClauseTypeName(): ITypeSyntax {
            if (!isHeritageClauseTypeName()) {
                return null;
            }

            return tryParseNameOrGenericType();
        }

        function parseClassDeclaration(): ClassDeclarationSyntax {
            // Debug.assert(isClassDeclaration());

            var modifiers = parseModifiers();

            var classKeyword = eatKeyword(SyntaxKind.ClassKeyword);
            var identifier = eatIdentifierToken();
            var typeParameterList = tryParseTypeParameterList(/*requireCompleteTypeParameterList:*/ false);
            var heritageClauses = parseHeritageClauses();
            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);
            var classElements = Syntax.emptyList<IClassElementSyntax>();

            if (openBraceToken.fullWidth() > 0) {
                var listResult = parseSyntaxList<IClassElementSyntax>(ListParsingState.ClassDeclaration_ClassElements);

                classElements = listResult.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, listResult.skippedTokens);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new ClassDeclarationSyntax(parseNodeData, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken);
        }

        function isAccessor(inErrorRecovery: boolean): boolean {
            var index = modifierCount();

            if (peekToken(index).kind() !== SyntaxKind.GetKeyword &&
                peekToken(index).kind() !== SyntaxKind.SetKeyword) {
                return false;
            }

            index++;
            return isPropertyName(peekToken(index), inErrorRecovery);
        }

        function parseAccessor(checkForStrictMode: boolean): ISyntaxNode {
            // Debug.assert(isMemberAccessorDeclaration());

            var modifiers = parseModifiers();

            if (currentToken().kind() === SyntaxKind.GetKeyword) {
                return parseGetMemberAccessorDeclaration(modifiers, checkForStrictMode);
            }
            else if (currentToken().kind() === SyntaxKind.SetKeyword) {
                return parseSetMemberAccessorDeclaration(modifiers, checkForStrictMode);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        function parseGetMemberAccessorDeclaration(modifiers: ISyntaxToken[], checkForStrictMode: boolean): GetAccessorSyntax {
            return new GetAccessorSyntax(parseNodeData,
                modifiers,
                eatKeyword(SyntaxKind.GetKeyword),
                eatPropertyName(),
                parseParameterList(),
                parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false),
                parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, checkForStrictMode));
        }

        function parseSetMemberAccessorDeclaration(modifiers: ISyntaxToken[], checkForStrictMode: boolean): SetAccessorSyntax {
            return new SetAccessorSyntax(parseNodeData,
                modifiers,
                eatKeyword(SyntaxKind.SetKeyword),
                eatPropertyName(),
                parseParameterList(),
                parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, checkForStrictMode));
        }

        function isClassElement(inErrorRecovery: boolean): boolean {
            if (SyntaxUtilities.isClassElement(currentNode())) {
                return true;
            }

            // Note: the order of these calls is important.  Specifically, isMemberVariableDeclaration
            // checks for a subset of the conditions of the previous two calls.
            return isConstructorDeclaration() ||
                   isMemberFunctionDeclaration(inErrorRecovery) ||
                   isAccessor(inErrorRecovery) ||
                   isMemberVariableDeclaration(inErrorRecovery) ||
                   isIndexMemberDeclaration();
        }

        function tryParseClassElement(inErrorRecovery: boolean): IClassElementSyntax {
            // Debug.assert(isClassElement());
            var node = currentNode();
            if (SyntaxUtilities.isClassElement(node)) {
                consumeNode(node);
                return <IClassElementSyntax>node;
            }

            if (isConstructorDeclaration()) {
                return parseConstructorDeclaration();
            }
            else if (isMemberFunctionDeclaration(inErrorRecovery)) {
                return parseMemberFunctionDeclaration();
            }
            else if (isAccessor(inErrorRecovery)) {
                return parseAccessor(/*checkForStrictMode:*/ false);
            }
            else if (isMemberVariableDeclaration(inErrorRecovery)) {
                return parseMemberVariableDeclaration();
            }
            else if (isIndexMemberDeclaration()) {
                return parseIndexMemberDeclaration();
            }
            else {
                return null;
            }
        }

        function isConstructorDeclaration(): boolean {
            // Note: we deviate slightly from the spec here.  If we see 'constructor' then we 
            // assume this is a constructor.  That means, if a user writes "public constructor;"
            // it won't be viewed as a member.  As a workaround, they can simply write:
            //      public 'constructor';

            var index = modifierCount();
            return peekToken(index).kind() === SyntaxKind.ConstructorKeyword;
        }

        function parseConstructorDeclaration(): ConstructorDeclarationSyntax {
            // Debug.assert(isConstructorDeclaration());

            var modifiers = parseModifiers();
            var constructorKeyword = eatKeyword(SyntaxKind.ConstructorKeyword);
            var callSignature = parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            if (isBlock()) {
                block = parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true);
            }
            else {
                semicolonToken = eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return new ConstructorDeclarationSyntax(parseNodeData, modifiers, constructorKeyword, callSignature, block, semicolonToken);
        }

        function isMemberFunctionDeclaration(inErrorRecovery: boolean): boolean {
            var index = 0;

            // Note: typescript is highly ambiguous here.  We may have things like:
            //      public()
            //      public public()
            //      public static()
            //      public static public()
            //
            // etc.
            //
            // This means we can't just blindly consume and move past modifier tokens.  Instead, we 
            // need to see if we're at the function's name, and only skip it if we're not.
            while (true) {
                var token = peekToken(index);
                if (isPropertyName(token, inErrorRecovery) &&
                    isCallSignature(index + 1)) {
                    return true;
                }

                // We weren't at the name of the function.  If we have a modifier token, then 
                // consume it and try again.
                if (isModifier(token)) {
                    index++;
                    continue;
                }

                // Wasn't a member function.
                return false;
            }
        }

        function parseMemberFunctionDeclaration(): MemberFunctionDeclarationSyntax {
            // Debug.assert(isMemberFunctionDeclaration());

            var modifierArray: ISyntaxToken[] = getArray();

            while (true) {
                var _currentToken = currentToken();
                if (isPropertyName(_currentToken, /*inErrorRecovery:*/ false) &&
                    isCallSignature(1)) {
                    break;
                }

                // Debug.assert(ParserImpl.isModifier(currentToken));
                consumeToken(_currentToken);
                modifierArray.push(_currentToken);
            }

            var modifiers = Syntax.list(modifierArray);
            returnZeroLengthArray(modifierArray);

            var propertyName = eatPropertyName();
            var callSignature = parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            // If we got an errant => then we want to parse what's coming up without requiring an
            // open brace.
            var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);

            var block: BlockSyntax = null;
            var semicolon: ISyntaxToken = null;

            if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                block = parseBlock(parseBlockEvenWithNoOpenBrace, /*checkForStrictMode:*/ true);
            }
            else {
                semicolon = eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return new MemberFunctionDeclarationSyntax(parseNodeData, modifiers, propertyName, callSignature, block, semicolon);
        }
        
        function isDefinitelyMemberVariablePropertyName(index: number): boolean {
            // keywords are also property names.  Only accept a keyword as a property 
            // name if is of the form:
            //      public;
            //      public=
            //      public:
            //      public }
            //      public <eof>
            if (SyntaxFacts.isAnyKeyword(peekToken(index).kind())) {
                switch (peekToken(index + 1).kind()) {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.ColonToken:
                    case SyntaxKind.CloseBraceToken:
                    case SyntaxKind.EndOfFileToken:
                       return true;
                    default:
                        return false;
                }
            }
            else {
                // If was a property name and not a keyword, then we're good to go.
                return true;
            }
        }

        function isMemberVariableDeclaration(inErrorRecovery: boolean): boolean {
            var index = 0;

            // Note: typescript is highly ambiguous here.  We may have things like:
            //      public;
            //      public public;
            //      public static;
            //      public static public;
            //
            // etc.
            //
            // This means we can't just blindly consume and move past modifier tokens.  Instead, we 
            // need to see if we're at the function's name, and only skip it if we're not.
            while (true) {
                var token = peekToken(index);
                if (isPropertyName(token, inErrorRecovery) &&
                    isDefinitelyMemberVariablePropertyName(index)) {
                        return true;
                }

                // We weren't at the name of the variable.  If we have a modifier token, then 
                // consume it and try again.
                if (isModifier(peekToken(index))) {
                    index++;
                    continue;
                }

                // Wasn't a member variable.
                return false;
            }
        }

        function parseMemberVariableDeclaration(): MemberVariableDeclarationSyntax {
            // Debug.assert(isMemberVariableDeclaration());

            var modifierArray: ISyntaxToken[] = getArray();

            while (true) {
                var _currentToken = currentToken();
                if (isPropertyName(_currentToken, /*inErrorRecovery:*/ false) &&
                    isDefinitelyMemberVariablePropertyName(0)) {
                    break;
                }

                // Debug.assert(ParserImpl.isModifier(currentToken));
                consumeToken(_currentToken);
                modifierArray.push(_currentToken);
            }

            var modifiers = Syntax.list(modifierArray);
            returnZeroLengthArray(modifierArray);

            return new MemberVariableDeclarationSyntax(parseNodeData, modifiers,
                tryParseVariableDeclarator(/*allowIn:*/ true, /*allowPropertyName:*/ true),

                // Even though we're calling tryParseVariableDeclarator, we must get one (we've already
                // verified that because of of hte call to isMemberVariableDecalrator above.
                // Debug.assert(variableDeclarator !== null);
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function isIndexMemberDeclaration(): boolean {
            var index = modifierCount();
            return isIndexSignature(index);
        }

        function parseIndexMemberDeclaration(): IndexMemberDeclarationSyntax {
            return new IndexMemberDeclarationSyntax(parseNodeData,
                parseModifiers(),
                parseIndexSignature(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewLine:*/ false));
        }

        function tryAddUnexpectedEqualsGreaterThanToken(callSignature: CallSignatureSyntax): boolean {
            var token0 = currentToken();

            var hasEqualsGreaterThanToken = token0.kind() === SyntaxKind.EqualsGreaterThanToken;
            if (hasEqualsGreaterThanToken) {
                // We can only do this if the call signature actually contains a final token that we 
                // could add the => to.
                var _lastToken = lastToken(callSignature);
                if (_lastToken && _lastToken.fullWidth() > 0) {
                    // Previously the language allowed "function f() => expr;" as a shorthand for 
                    // "function f() { return expr; }.
                    // 
                    // Detect if the user is typing this and attempt recovery.
                    var diagnostic = new Diagnostic(fileName, source.text.lineMap(),
                        start(token0), width(token0), DiagnosticCode.Unexpected_token_0_expected, [SyntaxFacts.getText(SyntaxKind.OpenBraceToken)]);
                    addDiagnostic(diagnostic);

                    consumeToken(token0);
                    addSkippedTokenAfterNode(callSignature, token0);

                    return true;
                }
            }


            return false;
        }

        function isFunctionDeclaration(): boolean {
            var index = modifierCount();
            return peekToken(index).kind() === SyntaxKind.FunctionKeyword;
        }

        function parseFunctionDeclaration(): FunctionDeclarationSyntax {
            // Debug.assert(isFunctionDeclaration());

            var modifiers = parseModifiers();
            var functionKeyword = eatKeyword(SyntaxKind.FunctionKeyword);
            var identifier = eatIdentifierToken();
            var callSignature = parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            // If we got an errant => then we want to parse what's coming up without requiring an
            // open brace.
            var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            // Parse a block if we're on a bock, or if we saw a '=>'
            if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                block = parseBlock(parseBlockEvenWithNoOpenBrace, /*checkForStrictMode:*/ true);
            }
            else {
                semicolonToken = eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return new FunctionDeclarationSyntax(parseNodeData, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
        }

        function isModuleDeclaration(currentToken: ISyntaxToken, nextToken: ISyntaxToken, modifierCount: number, tokenAfterModifiers: ISyntaxToken): boolean {
            // If we have at least one modifier, and we see 'module', then consider this a module
            // declaration.
            if (modifierCount > 0 &&
                tokenAfterModifiers.kind() === SyntaxKind.ModuleKeyword) {
                return true;
            }

            // 'module' is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a module construct and not some javascript expression.
            if (currentToken.kind() === SyntaxKind.ModuleKeyword) {
                return isIdentifier(nextToken) || nextToken.kind() === SyntaxKind.StringLiteral;
            }

            return false;
        }

        function parseModuleDeclaration(): ModuleDeclarationSyntax {
            // Debug.assert(isModuleDeclaration());

            var modifiers = parseModifiers();
            var moduleKeyword = eatKeyword(SyntaxKind.ModuleKeyword);

            var moduleName: INameSyntax = null;
            var stringLiteral: ISyntaxToken = null;

            if (currentToken().kind() === SyntaxKind.StringLiteral) {
                stringLiteral = eatToken(SyntaxKind.StringLiteral);
            }
            else {
                moduleName = parseName();
            }

            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);

            var moduleElements = Syntax.emptyList<IModuleElementSyntax>();
            if (openBraceToken.fullWidth() > 0) {
                var listResult = parseSyntaxList<IModuleElementSyntax>(ListParsingState.ModuleDeclaration_ModuleElements);
                moduleElements = listResult.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, listResult.skippedTokens);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new ModuleDeclarationSyntax(parseNodeData, modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
        }

        function isInterfaceDeclaration(currentToken: ISyntaxToken, nextToken: ISyntaxToken, modifierCount: number, tokenAfterModifiers: ISyntaxToken): boolean {
            // If we have at least one modifier, and we see 'interface', then consider this an interface
            // declaration.
            if (modifierCount > 0 &&
                tokenAfterModifiers.kind() === SyntaxKind.InterfaceKeyword) {
                return true;
            }

            // 'interface' is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a interface construct and not some javascript expression.
            return currentToken.kind() === SyntaxKind.InterfaceKeyword &&
                   isIdentifier(nextToken);
        }

        function parseInterfaceDeclaration(): InterfaceDeclarationSyntax {
            return new InterfaceDeclarationSyntax(parseNodeData,
                parseModifiers(),
                eatKeyword(SyntaxKind.InterfaceKeyword),
                eatIdentifierToken(),
                tryParseTypeParameterList(/*requireCompleteTypeParameterList:*/ false),
                parseHeritageClauses(),
                parseObjectType());
        }

        function parseObjectType(): ObjectTypeSyntax {
            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);

            var typeMembers = Syntax.emptySeparatedList<ITypeMemberSyntax>();
            if (openBraceToken.fullWidth() > 0) {
                var listResult = parseSeparatedSyntaxList<ITypeMemberSyntax>(ListParsingState.ObjectType_TypeMembers);
                typeMembers = listResult.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, listResult.skippedTokens);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new ObjectTypeSyntax(parseNodeData, openBraceToken, typeMembers, closeBraceToken);
        }

        function isTypeMember(inErrorRecovery: boolean): boolean {
            if (SyntaxUtilities.isTypeMember(currentNode())) {
                return true;
            }

            return isCallSignature(/*tokenIndex:*/ 0) ||
                   isConstructSignature() ||
                   isIndexSignature(/*tokenIndex:*/ 0) ||
                   isMethodSignature(inErrorRecovery) ||
                   isPropertySignature(inErrorRecovery);
        }

        function tryParseTypeMember(inErrorRecovery: boolean): ITypeMemberSyntax {
            var node = currentNode();
            if (SyntaxUtilities.isTypeMember(node)) {
                consumeNode(node);
                return <ITypeMemberSyntax>node;
            }

            if (isCallSignature(/*tokenIndex:*/ 0)) {
                return parseCallSignature(/*requireCompleteTypeParameterList:*/ false);
            }
            else if (isConstructSignature()) {
                return parseConstructSignature();
            }
            else if (isIndexSignature(/*tokenIndex:*/ 0)) {
                return parseIndexSignature();
            }
            else if (isMethodSignature(inErrorRecovery)) {
                // Note: it is important that isFunctionSignature is called before isPropertySignature.
                // isPropertySignature checks for a subset of isFunctionSignature.
                return parseMethodSignature();
            }
            else if (isPropertySignature(inErrorRecovery)) {
                return parsePropertySignature();
            }
            else {
                return null;
            }
        }

        function parseConstructSignature(): ConstructSignatureSyntax {
            return new ConstructSignatureSyntax(parseNodeData,
                eatKeyword(SyntaxKind.NewKeyword),
                parseCallSignature(/*requireCompleteTypeParameterList:*/ false));
        }

        function parseIndexSignature(): IndexSignatureSyntax {
            return new IndexSignatureSyntax(parseNodeData,
                eatToken(SyntaxKind.OpenBracketToken),
                parseParameter(),
                eatToken(SyntaxKind.CloseBracketToken),
                parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false));
        }

        function parseMethodSignature(): MethodSignatureSyntax {
            return new MethodSignatureSyntax(parseNodeData,
                eatPropertyName(),
                tryEatToken(SyntaxKind.QuestionToken),
                parseCallSignature(/*requireCompleteTypeParameterList:*/ false));
        }

        function parsePropertySignature(): PropertySignatureSyntax {
            return new PropertySignatureSyntax(parseNodeData,
                eatPropertyName(),
                tryEatToken(SyntaxKind.QuestionToken),
                parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false));
        }

        function isCallSignature(tokenIndex: number): boolean {
            var tokenKind = peekToken(tokenIndex).kind();
            return tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken;
        }

        function isConstructSignature(): boolean {
            if (currentToken().kind() !== SyntaxKind.NewKeyword) {
                return false;
            }

            var token1 = peekToken(1);
            return token1.kind() === SyntaxKind.LessThanToken || token1.kind() === SyntaxKind.OpenParenToken;
        }

        function isIndexSignature(tokenIndex: number): boolean {
            return peekToken(tokenIndex).kind() === SyntaxKind.OpenBracketToken;
        }

        function isMethodSignature(inErrorRecovery: boolean): boolean {
            if (isPropertyName(currentToken(), inErrorRecovery)) {
                // id(
                if (isCallSignature(1)) {
                    return true;
                }

                // id?(
                if (peekToken(1).kind() === SyntaxKind.QuestionToken &&
                    isCallSignature(2)) {
                    return true;
                }
            }

            return false;
        }

        function isPropertySignature(inErrorRecovery: boolean): boolean {
            var _currentToken = currentToken();

            // Keywords can start properties.  However, they're often intended to start something
            // else.  If we see a modifier before something that can be a property, then don't
            // try parse it out as a property.  For example, if we have:
            //
            //      public foo
            //
            // Then don't parse 'public' as a property name.  Note: if you have:
            //
            //      public
            //      foo
            //
            // Then we *should* parse it as a property name, as ASI takes effect here.
            if (isModifier(_currentToken) &&
                !_currentToken.hasTrailingNewLine() &&
                isPropertyName(peekToken(1), inErrorRecovery))
            {
                return false;
            }

            // Note: property names also start function signatures.  So it's important that we call this
            // after we calll isFunctionSignature.
            return isPropertyName(_currentToken, inErrorRecovery);
        }

        function isHeritageClause(): boolean {
            var token0 = currentToken();
            return token0.kind() === SyntaxKind.ExtendsKeyword || token0.kind() === SyntaxKind.ImplementsKeyword;
        }

        function isNotHeritageClauseTypeName(): boolean {
            if (currentToken().kind() === SyntaxKind.ImplementsKeyword ||
                currentToken().kind() === SyntaxKind.ExtendsKeyword) {

                return isIdentifier(peekToken(1));
            }

            return false;
        }

        function isHeritageClauseTypeName(): boolean {
            if (isIdentifier(currentToken())) {
                // We want to make sure that the "extends" in "extends foo" or the "implements" in
                // "implements foo" is not considered a type name.
                return !isNotHeritageClauseTypeName();
            }
            
            return false;
        }

        function tryParseHeritageClause(): HeritageClauseSyntax {
            var extendsOrImplementsKeyword = currentToken();
            if (extendsOrImplementsKeyword.kind() !== SyntaxKind.ExtendsKeyword && extendsOrImplementsKeyword.kind() !== SyntaxKind.ImplementsKeyword) {
                return null;
            }

            consumeToken(extendsOrImplementsKeyword);

            var listResult = parseSeparatedSyntaxList<INameSyntax>(ListParsingState.HeritageClause_TypeNameList);
            var typeNames = listResult.list;
            extendsOrImplementsKeyword = addSkippedTokensAfterToken(extendsOrImplementsKeyword, listResult.skippedTokens);

            return new HeritageClauseSyntax(parseNodeData, extendsOrImplementsKeyword, typeNames);
        }

        function isInterfaceEnumClassOrModule(): boolean {
            var _currentToken = currentToken();
            var nextToken = peekToken(1);
            var _modifierCount = modifierCount();
            var tokenAfterModifiers = peekToken(_modifierCount);
            if (isInterfaceDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                isClassDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                isEnumDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers) ||
                isModuleDeclaration(_currentToken, nextToken, _modifierCount, tokenAfterModifiers)) {

                return true;
            }

            return false;
        }

        function isStatement(inErrorRecovery: boolean): boolean {
            if (SyntaxUtilities.isStatement(currentNode())) {
                return true;
            }

            var _currentToken = currentToken();
            var currentTokenKind = _currentToken.kind();
            switch (currentTokenKind) {
                // ERROR RECOVERY
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.StaticKeyword:
                    // None of the above are actually keywords.  And they might show up in a real
                    // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                    // that can't possibly be a statement (and instead will be a class element), 
                    // and we should not parse it out here.
                    var token1 = peekToken(1);
                    if (SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                        // Definitely not a statement.
                        return false;
                    }

                    // Handle this below in 'isExpressionStatement()'
                    break;

                // Common cases that we can immediately assume are statements.
                case SyntaxKind.IfKeyword:
                case SyntaxKind.OpenBraceToken:
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.SwitchKeyword:
                case SyntaxKind.ThrowKeyword:
                case SyntaxKind.BreakKeyword:
                case SyntaxKind.ContinueKeyword:
                case SyntaxKind.ForKeyword:
                case SyntaxKind.WhileKeyword:
                case SyntaxKind.WithKeyword:
                case SyntaxKind.DoKeyword:
                case SyntaxKind.TryKeyword:
                case SyntaxKind.DebuggerKeyword:
                    return true;
            }
            
            // Check for common things that might appear where we expect a statement, but which we 
            // do not want to consume.  This can happen when the user does not terminate their 
            // existing block properly.  We don't want to accidently consume these as expression 
            // below.
            if (isInterfaceEnumClassOrModule()) {
                return false;
            }

            // More complicated cases.
            return isLabeledStatement(_currentToken) ||
                isVariableStatement() ||
                isFunctionDeclaration() ||
                isEmptyStatement(_currentToken, inErrorRecovery) ||
                isExpressionStatement(_currentToken);
        }

        function parseStatement(inErrorRecovery: boolean): IStatementSyntax {
            return tryParseStatement(inErrorRecovery) || parseExpressionStatement();
        }

        function tryParseStatement(inErrorRecovery: boolean): IStatementSyntax {
            var node = currentNode();
            if (SyntaxUtilities.isStatement(node)) {
                consumeNode(node);
                return <IStatementSyntax><ISyntaxNode>node;
            }

            var _currentToken = currentToken();
            var currentTokenKind = _currentToken.kind();

            switch (currentTokenKind) {
                // ERROR RECOVERY
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.StaticKeyword:
                    // None of the above are actually keywords.  And they might show up in a real
                    // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                    // that can't possibly be a statement (and instead will be a class element), 
                    // and we should not parse it out here.
                    if (SyntaxFacts.isIdentifierNameOrAnyKeyword(peekToken(1))) {
                        // Definitely not a statement.
                        return null;
                    }
                    else {
                        break;
                    }

                case SyntaxKind.IfKeyword: return parseIfStatement();
                case SyntaxKind.OpenBraceToken: return parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
                case SyntaxKind.ReturnKeyword: return parseReturnStatement();
                case SyntaxKind.SwitchKeyword: return parseSwitchStatement();
                case SyntaxKind.ThrowKeyword: return parseThrowStatement();
                case SyntaxKind.BreakKeyword: return parseBreakStatement();
                case SyntaxKind.ContinueKeyword: return parseContinueStatement();
                case SyntaxKind.ForKeyword: return parseForOrForInStatement();
                case SyntaxKind.WhileKeyword: return parseWhileStatement();
                case SyntaxKind.WithKeyword: return parseWithStatement();
                case SyntaxKind.DoKeyword: return parseDoStatement();
                case SyntaxKind.TryKeyword: return parseTryStatement();
                case SyntaxKind.DebuggerKeyword: return parseDebuggerStatement();
            }
            
            // Check for common things that might appear where we expect a statement, but which we 
            // do not want to consume.  This can happen when the user does not terminate their 
            // existing block properly.  We don't want to accidently consume these as expression 
            // below.
            if (isInterfaceEnumClassOrModule()) {
                return null;
            }

            if (isVariableStatement()) {
                return parseVariableStatement();
            }
            else if (isLabeledStatement(_currentToken)) {
                return parseLabeledStatement();
            }
            else if (isFunctionDeclaration()) {
                return parseFunctionDeclaration();
            }
            else if (isEmptyStatement(_currentToken, inErrorRecovery)) {
                return parseEmptyStatement();
            }
            else if (isExpressionStatement(_currentToken)) {
                // Fall back to parsing this as expression statement.
                return parseExpressionStatement();
            }
            else {
                return null;
            }
        }

        function parseDebuggerStatement(): DebuggerStatementSyntax {
            return new DebuggerStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.DebuggerKeyword),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseDoStatement(): DoStatementSyntax {
            return new DoStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.DoKeyword),
                parseStatement(/*inErrorRecovery:*/ false),
                eatKeyword(SyntaxKind.WhileKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken),

                // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
                // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
                // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
                //  do;while(0)x will have a semicolon inserted before x.
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ true));
        }

        function isLabeledStatement(currentToken: ISyntaxToken): boolean {
            return isIdentifier(currentToken) && peekToken(1).kind() === SyntaxKind.ColonToken;
        }

        function parseLabeledStatement(): LabeledStatementSyntax {
            return new LabeledStatementSyntax(parseNodeData,
                eatIdentifierToken(),
                eatToken(SyntaxKind.ColonToken),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function parseTryStatement(): TryStatementSyntax {
            // Debug.assert(isTryStatement());

            var tryKeyword = eatKeyword(SyntaxKind.TryKeyword);

            var savedListParsingState = listParsingState;
            listParsingState |= ListParsingState.TryBlock_Statements;
            var block = parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            listParsingState = savedListParsingState;

            var catchClause: CatchClauseSyntax = null;
            if (isCatchClause()) {
                catchClause = parseCatchClause();
            }

            // If we don't have a catch clause, then we must have a finally clause.  Try to parse
            // one out no matter what.
            var finallyClause: FinallyClauseSyntax = null;
            if (catchClause === null || isFinallyClause()) {
                finallyClause = parseFinallyClause();
            }

            return new TryStatementSyntax(parseNodeData, tryKeyword, block, catchClause, finallyClause);
        }

        function isCatchClause(): boolean {
            return currentToken().kind() === SyntaxKind.CatchKeyword;
        }

        function parseCatchClauseBlock(): BlockSyntax {
            var savedListParsingState = listParsingState;
            listParsingState |= ListParsingState.CatchBlock_Statements;
            var block = parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            listParsingState = savedListParsingState;

            return block;
        }

        function parseCatchClause(): CatchClauseSyntax {
            return new CatchClauseSyntax(parseNodeData,
                eatKeyword(SyntaxKind.CatchKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                eatIdentifierToken(),
                parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false),
                eatToken(SyntaxKind.CloseParenToken),
                parseCatchClauseBlock());
        }

        function isFinallyClause(): boolean {
            return currentToken().kind() === SyntaxKind.FinallyKeyword;
        }

        function parseFinallyClause(): FinallyClauseSyntax {
            return new FinallyClauseSyntax(parseNodeData,
                eatKeyword(SyntaxKind.FinallyKeyword),
                parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false));
        }

        function parseWithStatement(): WithStatementSyntax {
            return new WithStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.WithKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function parseWhileStatement(): WhileStatementSyntax {
            return new WhileStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.WhileKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function isEmptyStatement(currentToken: ISyntaxToken, inErrorRecovery: boolean): boolean {
            // If we're in error recovery, then we don't want to treat ';' as an empty statement.
            // The problem is that ';' can show up in far too many contexts, and if we see one 
            // and assume it's a statement, then we may bail out innapropriately from whatever 
            // we're parsing.  For example, if we have a semicolon in the middle of a class, then
            // we really don't want to assume the class is over and we're on a statement in the
            // outer module.  We just want to consume and move on.
            if (inErrorRecovery) {
                return false;
            }

            return currentToken.kind() === SyntaxKind.SemicolonToken;
        }

        function parseEmptyStatement(): EmptyStatementSyntax {
            return new EmptyStatementSyntax(parseNodeData, eatToken(SyntaxKind.SemicolonToken));
        }

        function parseForOrForInStatement(): IStatementSyntax {
            // Debug.assert(isForOrForInStatement());

            var forKeyword = eatKeyword(SyntaxKind.ForKeyword);
            var openParenToken = eatToken(SyntaxKind.OpenParenToken);

            var _currentToken = currentToken();
            if (_currentToken.kind() === SyntaxKind.VarKeyword) {
                // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                return parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
            }
            else if (_currentToken.kind() === SyntaxKind.SemicolonToken) {
                // for ( ; Expressionopt ; Expressionopt ) Statement
                return parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken);
            }
            else {
                // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                // for ( LeftHandSideExpression in Expression ) Statement
                return parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
            }
        }

        function parseForOrForInStatementWithVariableDeclaration(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): IStatementSyntax {
            // Debug.assert(forKeyword.kind === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);
            // Debug.assert(currentToken().kind() === SyntaxKind.VarKeyword);

            // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
            // for ( var VariableDeclarationNoIn in Expression ) Statement

            var variableDeclaration = parseVariableDeclaration(/*allowIn:*/ false);

            if (currentToken().kind() === SyntaxKind.InKeyword) {
                return parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }

            return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
        }

        function parseForInStatementWithVariableDeclarationOrInitializer(
                forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                initializer: IExpressionSyntax): ForInStatementSyntax {
            // for ( var VariableDeclarationNoIn in Expression ) Statement

            return new ForInStatementSyntax(parseNodeData,
                forKeyword, openParenToken, variableDeclaration, initializer,
                eatKeyword(SyntaxKind.InKeyword),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function parseForOrForInStatementWithInitializer(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): IStatementSyntax {
            // Debug.assert(forKeyword.kind() === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);

            // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
            // for ( LeftHandSideExpression in Expression ) Statement

            var initializer = parseExpression(/*allowIn:*/ false);
            if (currentToken().kind() === SyntaxKind.InKeyword) {
                return parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
            else {
                return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
        }

        function parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): ForStatementSyntax {
            // Debug.assert(forKeyword.kind() === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);
            // Debug.assert(currentToken().kind() === SyntaxKind.SemicolonToken);
            // for ( ; Expressionopt ; Expressionopt ) Statement

            return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, /*variableDeclaration:*/ null, /*initializer:*/ null);
        }

        function tryParseForStatementCondition(): IExpressionSyntax {
            var token0 = currentToken();
            if (token0.kind() !== SyntaxKind.SemicolonToken &&
                token0.kind() !== SyntaxKind.CloseParenToken &&
                token0.kind() !== SyntaxKind.EndOfFileToken) {
                return parseExpression(/*allowIn:*/ true);
            }

            return null;
        }

        function tryParseForStatementIncrementor(): IExpressionSyntax {
            var token0 = currentToken();
            if (token0.kind() !== SyntaxKind.CloseParenToken &&
                token0.kind() !== SyntaxKind.EndOfFileToken) {
                return parseExpression(/*allowIn:*/ true);
            }

            return null;
        }

        function parseForStatementWithVariableDeclarationOrInitializer(
                    forKeyword: ISyntaxToken,
                    openParenToken: ISyntaxToken,
                    variableDeclaration: VariableDeclarationSyntax,
                    initializer: IExpressionSyntax): ForStatementSyntax {

            return new ForStatementSyntax(parseNodeData,
                forKeyword, openParenToken, variableDeclaration, initializer,

                // NOTE: From the es5 section on Automatic Semicolon Insertion.
                // a semicolon is never inserted automatically if the semicolon would then ... become 
                // one of the two semicolons in the header of a for statement
                eatToken(SyntaxKind.SemicolonToken),
                tryParseForStatementCondition(),

                // NOTE: See above.  Semicolons in for statements don't participate in automatic 
                // semicolon insertion.
                eatToken(SyntaxKind.SemicolonToken),
                tryParseForStatementIncrementor(),
                eatToken(SyntaxKind.CloseParenToken),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function tryEatBreakOrContinueLabel(): ISyntaxToken {
            // If there is no newline after the break keyword, then we can consume an optional 
            // identifier.
            var identifier: ISyntaxToken = null;
            if (!canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                if (isIdentifier(currentToken())) {
                    return eatIdentifierToken();
                }
            }

            return null;
        }

        function parseBreakStatement(): BreakStatementSyntax {
            return new BreakStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.BreakKeyword),
                tryEatBreakOrContinueLabel(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseContinueStatement(): ContinueStatementSyntax {
            return new ContinueStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.ContinueKeyword),
                tryEatBreakOrContinueLabel(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseSwitchStatement() {
            // Debug.assert(isSwitchStatement());

            var switchKeyword = eatKeyword(SyntaxKind.SwitchKeyword);
            var openParenToken = eatToken(SyntaxKind.OpenParenToken);
            var expression = parseExpression(/*allowIn:*/ true);
            var closeParenToken = eatToken(SyntaxKind.CloseParenToken);

            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);

            var switchClauses = Syntax.emptyList<ISwitchClauseSyntax>();
            if (openBraceToken.fullWidth() > 0) {
                var listResult = parseSyntaxList<ISwitchClauseSyntax>(ListParsingState.SwitchStatement_SwitchClauses);
                switchClauses = listResult.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, listResult.skippedTokens);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new SwitchStatementSyntax(parseNodeData, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
        }

        function isCaseSwitchClause(): boolean {
            return currentToken().kind() === SyntaxKind.CaseKeyword;
        }

        function isDefaultSwitchClause(): boolean {
            return currentToken().kind() === SyntaxKind.DefaultKeyword;
        }

        function isSwitchClause(): boolean {
            if (SyntaxUtilities.isSwitchClause(currentNode())) {
                return true;
            }

            return isCaseSwitchClause() || isDefaultSwitchClause();
        }

        function tryParseSwitchClause(): ISwitchClauseSyntax {
            // Debug.assert(isSwitchClause());
            var node = currentNode();
            if (SyntaxUtilities.isSwitchClause(node)) {
                consumeNode(node);
                return <ISwitchClauseSyntax><ISyntaxNode>node;
            }

            if (isCaseSwitchClause()) {
                return parseCaseSwitchClause();
            }
            else if (isDefaultSwitchClause()) {
                return parseDefaultSwitchClause();
            }
            else {
                return null;
            }
        }

        function parseCaseSwitchClause(): CaseSwitchClauseSyntax {
            // Debug.assert(isCaseSwitchClause());

            var caseKeyword = eatKeyword(SyntaxKind.CaseKeyword);
            var expression = parseExpression(/*allowIn:*/ true);
            var colonToken = eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList<IStatementSyntax>();

            // TODO: allow parsing of the list evne if there's no colon.  However, we have to make 
            // sure we add any skipped tokens to the right previous node or token.
            if (colonToken.fullWidth() > 0) {
                var listResult = parseSyntaxList<IStatementSyntax>(ListParsingState.SwitchClause_Statements);
                statements = listResult.list;
                colonToken = addSkippedTokensAfterToken(colonToken, listResult.skippedTokens);
            }

            return new CaseSwitchClauseSyntax(parseNodeData, caseKeyword, expression, colonToken, statements);
        }

        function parseDefaultSwitchClause(): DefaultSwitchClauseSyntax {
            // Debug.assert(isDefaultSwitchClause());

            var defaultKeyword = eatKeyword(SyntaxKind.DefaultKeyword);
            var colonToken = eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList<IStatementSyntax>();

            // TODO: Allow parsing without a colon here.  However, ensure that we attach any skipped 
            // tokens to the defaultKeyword.
            if (colonToken.fullWidth() > 0) {
                var listResult = parseSyntaxList<IStatementSyntax>(ListParsingState.SwitchClause_Statements);
                statements = listResult.list;
                colonToken = addSkippedTokensAfterToken(colonToken, listResult.skippedTokens);
            }

            return new DefaultSwitchClauseSyntax(parseNodeData, defaultKeyword, colonToken, statements);
        }

        function parseThrowStatementExpression(): IExpressionSyntax {
            if (canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                // Because of automatic semicolon insertion, we need to report error if this 
                // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
                // directly as that might consume an expression on the following line.  
                return createMissingToken(SyntaxKind.IdentifierName, null);
            }
            else {
                return parseExpression(/*allowIn:*/ true);
            }
        }

        function parseThrowStatement(): ThrowStatementSyntax {
            return new ThrowStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.ThrowKeyword),
                parseThrowStatementExpression(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function tryParseReturnStatementExpression(): IExpressionSyntax {
            if (!canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                return parseExpression(/*allowIn:*/ true);
            }

            return null;
        }

        function parseReturnStatement(): ReturnStatementSyntax {
            return new ReturnStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.ReturnKeyword),
                tryParseReturnStatementExpression(),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function isExpressionStatement(currentToken: ISyntaxToken): boolean {
            // As per the gramar, neither { nor 'function' can start an expression statement.
            var kind = currentToken.kind;
            if (kind() === SyntaxKind.OpenBraceToken || kind() === SyntaxKind.FunctionKeyword) {
                return false;
            }

            return isExpression(currentToken);
        }

        function isAssignmentOrOmittedExpression(): boolean {
            var _currentToken = currentToken();
            if (_currentToken.kind() === SyntaxKind.CommaToken) {
                return true;
            }

            return isExpression(_currentToken);
        }

        function tryParseAssignmentOrOmittedExpression(): IExpressionSyntax {
            // Debug.assert(isAssignmentOrOmittedExpression());

            if (currentToken().kind() === SyntaxKind.CommaToken) {
                return new OmittedExpressionSyntax(parseNodeData);
            }

            return tryParseAssignmentExpressionOrHigher(/*force:*/ false, /*allowIn:*/ true);
        }

        function isExpression(currentToken: ISyntaxToken): boolean {
            switch (currentToken.kind()) {
                // Literals
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RegularExpressionLiteral:

                 // For array literals.
                case SyntaxKind.OpenBracketToken:

                // For parenthesized expressions
                case SyntaxKind.OpenParenToken: 

                // For cast expressions.
                case SyntaxKind.LessThanToken:

                // Prefix unary expressions.
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:

                // For object type literal expressions.
                case SyntaxKind.OpenBraceToken: 

                // ERROR TOLERANCE:
                // If we see a => then we know the user was probably trying to type in an arrow 
                // function.  So allow this as the start of an expression, knowing that when we 
                // actually try to parse it we'll report the missing identifier.
                case SyntaxKind.EqualsGreaterThanToken:

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // Note: if we see a / or /= token then we always consider this an expression.  Why?
                    // Well, either that / or /= is actually a regular expression, in which case we're 
                    // definitely an expression.  Or, it's actually a divide.  In which case, we *still*
                    // want to think of ourself as an expression.  "But wait", you say.  '/' doesn't
                    // start an expression.  That's true.  BUt like the above check for =>, for error
                    // tolerance, we will consider ourselves in an expression.  We'll then parse out an
                    // missing identifier and then will consume the / token naturally as a binary 
                    // expression.

                // Simple epxressions.
                case SyntaxKind.SuperKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:

                // For object creation expressions.
                case SyntaxKind.NewKeyword: 

                // Prefix unary expressions
                case SyntaxKind.DeleteKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.TypeOfKeyword:

                // For function expressions.
                case SyntaxKind.FunctionKeyword:
                    return true;
            }

            return isIdentifier(currentToken);
        }

        function parseExpressionStatement(): ExpressionStatementSyntax {
            return new ExpressionStatementSyntax(parseNodeData,
                parseExpression(/*allowIn:*/ true),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseIfStatement(): IfStatementSyntax {
            return new IfStatementSyntax(parseNodeData,
                eatKeyword(SyntaxKind.IfKeyword),
                eatToken(SyntaxKind.OpenParenToken),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken),
                parseStatement(/*inErrorRecovery:*/ false),
                parseOptionalElseClause());
        }

        function parseOptionalElseClause(): ElseClauseSyntax {
            return currentToken().kind() === SyntaxKind.ElseKeyword ? parseElseClause() : null;
        }

        function parseElseClause(): ElseClauseSyntax {
            return new ElseClauseSyntax(parseNodeData,
                eatKeyword(SyntaxKind.ElseKeyword),
                parseStatement(/*inErrorRecovery:*/ false));
        }

        function isVariableStatement(): boolean {
            var index = modifierCount();
            return peekToken(index).kind() === SyntaxKind.VarKeyword;
        }

        function parseVariableStatement(): VariableStatementSyntax {
            return new VariableStatementSyntax(parseNodeData,
                parseModifiers(),
                parseVariableDeclaration(/*allowIn:*/ true),
                eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
        }

        function parseVariableDeclaration(allowIn: boolean): VariableDeclarationSyntax {
            // Debug.assert(currentToken().kind() === SyntaxKind.VarKeyword);

            var varKeyword = eatKeyword(SyntaxKind.VarKeyword);
            // Debug.assert(varKeyword.fullWidth() > 0);

            var listParsingState = allowIn
                ? ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn
                : ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn;

            var resultList = parseSeparatedSyntaxList<VariableDeclaratorSyntax>(listParsingState);
            var variableDeclarators = resultList.list;
            varKeyword = addSkippedTokensAfterToken(varKeyword, resultList.skippedTokens);

            return new VariableDeclarationSyntax(parseNodeData, varKeyword, variableDeclarators);
        }

        function isVariableDeclarator(): boolean {
            if (currentNode() !== null && currentNode().kind() === SyntaxKind.VariableDeclarator) {
                return true;
            }

            return isIdentifier(currentToken());
        }

        function canReuseVariableDeclaratorNode(node: ISyntaxNode) {
            if (node === null || node.kind() !== SyntaxKind.VariableDeclarator) {
                return false;
            }

            // Very subtle incremental parsing bug.  Consider the following code:
            //
            //      var v = new List < A, B
            //
            // This is actually legal code.  It's a list of variable declarators "v = new List<A" 
            // on one side and "B" on the other. If you then change that to:
            //
            //      var v = new List < A, B >()
            // 
            // then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
            // start reparsing at "B" and we completely fail to handle this properly.
            //
            // In order to prevent this, we do not allow a variable declarator to be reused if it
            // has an initializer.
            var variableDeclarator = <VariableDeclaratorSyntax>node;
            return variableDeclarator.equalsValueClause === null;
        }

        function tryParseVariableDeclarator(allowIn: boolean, allowPropertyName: boolean): VariableDeclaratorSyntax {
            // TODO(cyrusn): What if the 'allowIn' context has changed between when we last parsed 
            // and now?  We could end up with an incorrect tree.  For example, say we had in the old 
            // tree "var i = a in b".  Then, in the new tree the declarator portion moved into:
            // "for (var i = a in b".  We would not want to reuse the declarator as the "in b" portion 
            // would need to be consumed by the for declaration instead.  Need to see if it is possible
            // to hit this case.
            var node = currentNode();
            if (canReuseVariableDeclaratorNode(node)) {
                consumeNode(node);
                return <VariableDeclaratorSyntax>node;
            }

            if (allowPropertyName) {
                // Debug.assert(isPropertyName(currentToken(), /*inErrorRecovery:*/ false));
            }

            if (!allowPropertyName && !isIdentifier(currentToken())) {
                return null;
            }

            var propertyName = allowPropertyName ? eatPropertyName() : eatIdentifierToken();
            var equalsValueClause: EqualsValueClauseSyntax = null;
            var typeAnnotation: TypeAnnotationSyntax = null;

            if (propertyName.fullWidth() > 0) {
                typeAnnotation = parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);

                if (isEqualsValueClause(/*inParameter*/ false)) {
                    equalsValueClause = parseEqualsValueClause(allowIn);
                }
            }

            return new VariableDeclaratorSyntax(parseNodeData, propertyName, typeAnnotation, equalsValueClause);
        }

        function isEqualsValueClause(inParameter: boolean): boolean {
            var token0 = currentToken();
            if (token0.kind() === SyntaxKind.EqualsToken) {
                return true;
            }

            // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
            // there is no newline after the last token and if we're on an expression.  If so, parse
            // this as an equals-value clause with a missing equals.
            if (!previousTokenHasTrailingNewLine(token0)) {
                // The 'isExpression' call below returns true for "=>".  That's because it smartly
                // assumes that there is just a missing identifier and the user wanted a lambda.  
                // While this is sensible, we don't want to allow that here as that would mean we're
                // glossing over multiple erorrs and we're probably making things worse.  So don't
                // treat this as an equals value clause and let higher up code handle things.
                if (token0.kind() === SyntaxKind.EqualsGreaterThanToken) {
                    return false;
                }

                // There are two places where we allow equals-value clauses.  The first is in a 
                // variable declarator.  The second is with a parameter.  For variable declarators
                // it's more likely that a { would be a allowed (as an object literal).  While this
                // is also allowed for parameters, the risk is that we consume the { as an object
                // literal when it really will be for the block following the parameter.
                if (token0.kind() === SyntaxKind.OpenBraceToken &&
                    inParameter) {
                    return false;
                }

                return isExpression(token0);
            }

            return false;
        }

        function parseEqualsValueClause(allowIn: boolean): EqualsValueClauseSyntax {
            return new EqualsValueClauseSyntax(parseNodeData,
                eatToken(SyntaxKind.EqualsToken),
                tryParseAssignmentExpressionOrHigher(/*force:*/ true, allowIn));
        }

        function parseExpression(allowIn: boolean): IExpressionSyntax {
            // Expression[in]:
            //      AssignmentExpression[in] 
            //      Expression[in] , AssignmentExpression[in]

            var leftOperand = tryParseAssignmentExpressionOrHigher(/*force:*/ true, allowIn);
            while (true) {
                var token0 = currentToken();
                var token0Kind = token0.kind();

                if (token0Kind !== SyntaxKind.CommaToken) {
                    break;
                }

                consumeToken(token0);

                var rightOperand = tryParseAssignmentExpressionOrHigher(/*force:*/ true, allowIn);
                leftOperand = new BinaryExpressionSyntax(parseNodeData, leftOperand, token0, rightOperand);
            }

            return leftOperand;
        }

        // Called when you need to parse an expression, but you do not want to allow 'CommaExpressions'.
        // i.e. if you have "var a = 1, b = 2" then when we parse '1' we want to parse with higher 
        // precedence than 'comma'.  Otherwise we'll get: "var a = (1, (b = 2))", instead of
        // "var a = (1), b = (2)");
        function tryParseAssignmentExpressionOrHigher(force: boolean, allowIn: boolean): IExpressionSyntax {
            // Augmented by TypeScript:
            //
            //  AssignmentExpression[in]:
            //      1) ConditionalExpression[in]
            //      2) LeftHandSideExpression = AssignmentExpression[in]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
            //      4) ArrowFunctionExpression <-- added by TypeScript
            //
            // Open spec question.  Right now, there is no 'ArrowFunctionExpression[in]' variant.
            // Thus, if the user has:
            //
            //      for (var a = () => b in c) {}
            //
            // Then we will fail to parse (because the 'in' will be consumed as part of the body of
            // the lambda, and not as part of the 'for' statement).  This is likely not an issue
            // whatsoever as there seems to be no good reason why anyone would ever write code like
            // the above.
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing. 
            // (i.e. they're both BinaryExpressions with an assignment operator in it).

            // First, check if we have production '4' (an arrow function).  Note that if we do, we
            // must *not* recurse for productsion 1, 2 or 3. An ArrowFunction is not a 
            // LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done 
            // with AssignmentExpression if we see one.

            var arrowFunction = tryParseAnyArrowFunctionExpression();
            if (arrowFunction !== null) {
                return arrowFunction;
            }

            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
            // start with a LogicalOrExpression, while the assignment productions can only start with
            // LeftHandSideExpressions.
            //
            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a 
            // LeftHandSide or higher, then we can try to parse out the assignment expression part.  
            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any 
            // binary expression here, so we pass in the 'lowest' precedence here so that it matches
            // and consumes anything.
            var leftOperand = tryParseBinaryExpressionOrHigher(force, BinaryExpressionPrecedence.Lowest, allowIn);
            if (leftOperand === null) {
                return null;
            }

            if (SyntaxUtilities.isLeftHandSizeExpression(leftOperand)) {
                // Note: we call currentOperatorToken so that we get an appropriately merged token
                // for cases like > > =  becoming >>=
                var token0 = currentOperatorToken();
                var token0Kind = token0.kind();

                // Check for recursive assignment expressions.
                if (isAssignmentOperatorToken(token0Kind)) {
                    consumeToken(token0);

                    var rightOperand = tryParseAssignmentExpressionOrHigher(/*force:*/ true, allowIn);
                    var binaryExpressionKind = SyntaxFacts.getBinaryExpressionFromOperatorToken(token0Kind);

                    return new BinaryExpressionSyntax(parseNodeData, leftOperand, token0, rightOperand);
                }
            }

            // It wasn't an assignment or a lambda.  This is a conditional expression:
            return parseConditionalExpressionRest(allowIn, leftOperand);
        }

        function isAssignmentOperatorToken(tokenKind: SyntaxKind): boolean {
            switch (tokenKind) {
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.EqualsToken:
                    return true;

                default:
                    return false;
            }
        }

        function tryParseAnyArrowFunctionExpression(): IExpressionSyntax {
            if (isSimpleArrowFunctionExpression()) {
                return parseSimpleArrowFunctionExpression();
            }

            return tryParseParenthesizedArrowFunctionExpression();
        }

        function tryParseUnaryExpressionOrHigher(force: boolean): IUnaryExpressionSyntax {
            var _currentToken = currentToken();
            var currentTokenKind = _currentToken.kind();
            var operatorKind = SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

            if (operatorKind !== SyntaxKind.None) {
                consumeToken(_currentToken);
                return new PrefixUnaryExpressionSyntax(parseNodeData, _currentToken, tryParseUnaryExpressionOrHigher(/*force:*/ true));
            }
            else if (currentTokenKind === SyntaxKind.TypeOfKeyword) {
                return parseTypeOfExpression();
            }
            else if (currentTokenKind === SyntaxKind.VoidKeyword) {
                return parseVoidExpression();
            }
            else if (currentTokenKind === SyntaxKind.DeleteKeyword) {
                return parseDeleteExpression();
            }
            else if (currentTokenKind === SyntaxKind.LessThanToken) {
                return parseCastExpression();
            }
            else {
                return tryParsePostfixExpressionOrHigher(force);
            }
        }

        function tryParseBinaryExpressionOrHigher(force: boolean, precedence: BinaryExpressionPrecedence, allowIn: boolean): IExpressionSyntax {
            // The binary expressions are incredibly left recursive in their definitions. We 
            // clearly can't implement that through recursion.  So, instead, we first bottom out 
            // of all the recursion by jumping to this production and consuming a UnaryExpression 
            // first.
            //
            // MultiplicativeExpression: See 11.5 
            //      UnaryExpression 
            var leftOperand = tryParseUnaryExpressionOrHigher(force);
            if (leftOperand === null) {
                return null;
            }

            // We then pop up the stack consuming the other side of the binary exprssion if it exists.
            return parseBinaryExpressionRest(precedence, allowIn, leftOperand);
        }

        function parseConditionalExpressionRest(allowIn: boolean, leftOperand: IExpressionSyntax): IExpressionSyntax {
            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.

            var token0 = currentToken();
            var token0Kind = token0.kind();

            // Now check for conditional expression.
            if (token0Kind !== SyntaxKind.QuestionToken) {
                return leftOperand;
            }

            return new ConditionalExpressionSyntax(parseNodeData,
                leftOperand,
                eatToken(SyntaxKind.QuestionToken),

                // Note: we explicitly do *not* pass 'allowIn' here.  An 'in' expression is always
                // allowed in the 'true' part of a conditional expression.
                tryParseAssignmentExpressionOrHigher(/*force:*/ true, /*allowIn:*/ true),
                eatToken(SyntaxKind.ColonToken),
                tryParseAssignmentExpressionOrHigher(/*force:*/ true, allowIn));
        }

        function parseBinaryExpressionRest(precedence: BinaryExpressionPrecedence, allowIn: boolean, leftOperand: IExpressionSyntax): IExpressionSyntax {
            while (true) {
                // We either have a binary operator here, or we're finished.  We call 
                // currentOperatorToken versus currentToken here so that we merge token sequences
                // like > and = into >=
                var operatorToken = currentOperatorToken();
                var tokenKind = operatorToken.kind();

                // Only proceed if we see binary expression token.  However we don't parse 
                // assignment expressions or comma expressions here.  Those are taken care of 
                // respectively in parseAssignmentExpression and parseExpression.
                if (!SyntaxFacts.isBinaryExpressionOperatorToken(tokenKind) ||
                    tokenKind === SyntaxKind.CommaToken ||
                    isAssignmentOperatorToken(tokenKind)) {

                    break;
                }

                // also, if it's the 'in' operator, only allow if our caller allows it.
                if (tokenKind === SyntaxKind.InKeyword && !allowIn) {
                    break;
                }

                var binaryExpressionKind = SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                var newPrecedence = getBinaryExpressionPrecedence(binaryExpressionKind);

                // All binary operators must have precedence > 0
                // Debug.assert(newPrecedence > 0);

                // Check the precedence to see if we should "take" this operator
                if (newPrecedence <= precedence) {
                    break;
                }

                // Precedence is okay, so we'll "take" this operator.
                // Now skip the operator token we're on.
                consumeToken(operatorToken);

                var rightOperand = tryParseBinaryExpressionOrHigher(/*force:*/ true, newPrecedence, allowIn);
                leftOperand = new BinaryExpressionSyntax(parseNodeData, leftOperand, operatorToken, rightOperand);
            }

            return leftOperand;
        }

        var mergeTokensStorage: SyntaxKind[] = [];

        function currentOperatorToken(): ISyntaxToken {
            var token0 = currentToken();

            // If we see a > we need to see if we can actually merge this contextually into a 
            // >>  >>>  >=  >>=  >>>=  token.
            if (token0.kind() === SyntaxKind.GreaterThanToken) {
                token0 = currentContextualToken();
                var kind = token0.kind;
                //Debug.assert(kind() === SyntaxKind.GreaterThanToken || kind() === SyntaxKind.GreaterThanGreaterThanToken ||
                //             kind() === SyntaxKind.GreaterThanGreaterThanGreaterThanToken || kind() === SyntaxKind.GreaterThanEqualsToken ||
                //             kind() === SyntaxKind.GreaterThanGreaterThanEqualsToken || kind() === SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken);
            }

            return token0;
        }

        function tryParseMemberExpressionOrHigher(force: boolean, inObjectCreation: boolean): IMemberExpressionSyntax {
            // Note: to make our lives simpler, we merge the NewExpression production into the
            // MemberExpression construct like so:
            //
            //   MemberExpression : See 11.2 
            //      1) PrimaryExpression 
            //      2) FunctionExpression
            //      3) MemberExpression[Expression]
            //      4) MemberExpression.IdentifierName
            //      5) new MemberExpression Arguments?
            //
            // Technically this is ambiguous.  i.e. CallExpression defines:
            //
            //   CallExpression:
            //      MemberExpression Arguments
            // 
            // If you see: "new Foo()"
            //
            // Then that could be treated as a single ObjectCreationExpression, or it could be 
            // treated as the invocation of "new Foo".  We disambiguate that in code (to match
            // the original grammar) by making sure that if we see an ObjectCreationExpression
            // we always consume arguments if they are there. So we treat "new Foo()" as an
            // object creation only, and not at all as an invocation)  Another way to think 
            // about this is that for every "new" that we see, we will consume an argument
            // list if it is there as part of the associated object creation node.  Any
            // *additional* argument lists we see, will become invocation expressions.
            //
            // Also, for simplicity, we merge FunctionExpression into PrimaryExpression.  There
            // are no other places where these expressions are referred to independently in the
            // grammar.
            //
            // Because MemberExpression is left recursive, we need to bottom out of the recursion
            // immediately.  The two possible bottom out states are 'new' or a primary/function
            // expression.  So we parse those out first.
            var expression: IMemberExpressionSyntax = null;
            if (currentToken().kind() === SyntaxKind.NewKeyword) {
                expression = parseObjectCreationExpression();
            }
            else {
                expression = tryParsePrimaryExpression(force);
                if (expression === null) {
                    return null;
                }
            }
        
            return parseMemberExpressionRest(expression, /*inObjectCreation:*/ inObjectCreation); 
        }

        function parseCallExpressionRest(expression: ILeftHandSideExpressionSyntax, inObjectCreation: boolean): ILeftHandSideExpressionSyntax {
            return parseCallOrMemberExpressionRest(expression, /*allowArguments:*/ true, inObjectCreation);
        }

        function parseMemberExpressionRest(expression: IMemberExpressionSyntax, inObjectCreation: boolean): IMemberExpressionSyntax {
            return <IMemberExpressionSyntax>parseCallOrMemberExpressionRest(expression, /*allowArguments:*/ false, inObjectCreation);
        }

        function parseCallOrMemberExpressionRest(
            expression: ILeftHandSideExpressionSyntax, allowArguments: boolean, inObjectCreation: boolean): ILeftHandSideExpressionSyntax {

            while (true) {
                var currentTokenKind = currentToken().kind();

                switch (currentTokenKind) {
                    case SyntaxKind.OpenParenToken:
                        if (!allowArguments) {
                            break;
                        }

                        expression = new InvocationExpressionSyntax(parseNodeData, expression, parseArgumentList(/*typeArgumentList:*/ null));
                        continue;

                    case SyntaxKind.LessThanToken:
                        if (!allowArguments) {
                            break;
                        }

                        // See if this is the start of a generic invocation.  If so, consume it and
                        // keep checking for postfix expressions.  Otherwise, it's just a '<' that's 
                        // part of an arithmetic expression.  Break out so we consume it higher in the
                        // stack.
                        var argumentList = tryParseArgumentList();
                        if (argumentList === null) {
                            break;
                        }

                        expression = new InvocationExpressionSyntax(parseNodeData, expression, argumentList);
                        continue;

                    case SyntaxKind.OpenBracketToken:
                        expression = parseElementAccessExpression(expression, inObjectCreation);
                        continue;

                    case SyntaxKind.DotToken:
                        expression = new MemberAccessExpressionSyntax(parseNodeData, expression, eatToken(SyntaxKind.DotToken), eatIdentifierNameToken());
                        continue;
                }

                return expression;
            }
        }

        function tryParseLeftHandSideExpressionOrHigher(force: boolean): ILeftHandSideExpressionSyntax {
            // Original Ecma:
            // LeftHandSideExpression: See 11.2 
            //      NewExpression
            //      CallExpression 
            //
            // Our simplification:
            //
            // LeftHandSideExpression: See 11.2 
            //      MemberExpression  
            //      CallExpression 
            //
            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
            // MemberExpression to make our lives easier.
            //
            // to best understand the below code, it's important to see how CallExpression expands
            // out into its own productions:
            //
            // CallExpression:
            //      MemberExpression Arguments 
            //      CallExpression Arguments
            //      CallExpression[Expression]
            //      CallExpression.IdentifierName
            //      super   (   ArgumentListopt   )
            //      super.IdentifierName
            //
            // Because of the recursion in these calls, we need to bottom out first.  There are two 
            // bottom out states we can run into.  Either we see 'super' which must start either of
            // the last two CallExpression productions.  Or we have a MemberExpression which either
            // completes the LeftHandSideExpression, or starts the beginning of the first four
            // CallExpression productions.

            var expression: ILeftHandSideExpressionSyntax = null;
            if (currentToken().kind() === SyntaxKind.SuperKeyword) {
                expression = parseSuperExpression();
            }
            else {
                expression = tryParseMemberExpressionOrHigher(force, /*inObjectCreation:*/ false);
                if (expression === null) {
                    return null;
                }
            }

            // Now, we *may* be complete.  However, we might have consumed the start of a 
            // CallExpression.  As such, we need to consume the rest of it here to be complete.
            return parseCallExpressionRest(expression, /*inObjectCreation:*/ false);
        }

        function parseSuperExpression(): ILeftHandSideExpressionSyntax {
            var expression: ILeftHandSideExpressionSyntax = eatKeyword(SyntaxKind.SuperKeyword);

            // If we have seen "super" it must be followed by '(' or '.'.
            // If it wasn't then just try to parse out a '.' and report an error.
            var currentTokenKind = currentToken().kind();
            if (currentTokenKind === SyntaxKind.OpenParenToken || currentTokenKind === SyntaxKind.DotToken) {
                return expression;
            }

            return new MemberAccessExpressionSyntax(parseNodeData, expression, eatToken(SyntaxKind.DotToken), eatIdentifierNameToken());
        }

        function tryParsePostfixExpressionOrHigher(force: boolean): IPostfixExpressionSyntax {
            var expression = tryParseLeftHandSideExpressionOrHigher(force);
            if (expression === null) {
                return null;
            }

            var _currentToken = currentToken();
            var currentTokenKind = _currentToken.kind();

            switch (currentTokenKind) {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                    // Because of automatic semicolon insertion, we should only consume the ++ or -- 
                    // if it is on the same line as the previous token.
                    if (previousTokenHasTrailingNewLine(_currentToken)) {
                        break;
                    }

                    consumeToken(_currentToken);
                    return new PostfixUnaryExpressionSyntax(parseNodeData, expression, _currentToken);
            }

            return expression;
        }

        function tryParseGenericArgumentList(): ArgumentListSyntax {
            // Debug.assert(currentToken().kind() === SyntaxKind.LessThanToken);
            // If we have a '<', then only parse this as a arugment list if the type arguments
            // are complete and we have an open paren.  if we don't, rewind and return nothing.
            var rewindPoint = getRewindPoint();

            var typeArgumentList = tryParseTypeArgumentList(/*inExpression:*/ true);
            var token0 = currentToken();

            var isOpenParen = token0.kind() === SyntaxKind.OpenParenToken;
            var isDot = token0.kind() === SyntaxKind.DotToken;
            var isOpenParenOrDot = isOpenParen || isDot;

            var argumentList: ArgumentListSyntax = null;
            if (typeArgumentList === null || !isOpenParenOrDot) {
                // Wasn't generic.  Rewind to where we started so this can be parsed as an 
                // arithmetic expression.
                rewind(rewindPoint);
                releaseRewindPoint(rewindPoint);
                return null;
            }
            else {
                releaseRewindPoint(rewindPoint);
                // It's not uncommon for a user to type: "Foo<T>."
                //
                // This is not legal in typescript (as an parameter list must follow the type
                // arguments).  We want to give a good error message for this as otherwise
                // we'll bail out here and give a poor error message when we try to parse this
                // as an arithmetic expression.
                if (isDot) {
                    // A parameter list must follow a generic type argument list.
                    var diagnostic = new Diagnostic(fileName, source.text.lineMap(), start(token0), width(token0),
                        DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, null);
                    addDiagnostic(diagnostic);

                    return new ArgumentListSyntax(parseNodeData, typeArgumentList,
                        Syntax.emptyToken(SyntaxKind.OpenParenToken), Syntax.emptySeparatedList<IExpressionSyntax>(), Syntax.emptyToken(SyntaxKind.CloseParenToken));
                }
                else {
                    return parseArgumentList(typeArgumentList);
                }
            }
        }

        function tryParseArgumentList(): ArgumentListSyntax {
            if (currentToken().kind() === SyntaxKind.LessThanToken) {
                return tryParseGenericArgumentList();
            }

            if (currentToken().kind() === SyntaxKind.OpenParenToken) {
                return parseArgumentList(null);
            }

            return null;
        }

        function parseArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax {
            var openParenToken = eatToken(SyntaxKind.OpenParenToken);

            // Don't use the name 'arguments' it prevents V8 from optimizing this method.
            var _arguments = Syntax.emptySeparatedList<IExpressionSyntax>();

            if (openParenToken.fullWidth() > 0) {
                var result = parseSeparatedSyntaxList<IExpressionSyntax>(ListParsingState.ArgumentList_AssignmentExpressions);
                _arguments = result.list;
                openParenToken = addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = eatToken(SyntaxKind.CloseParenToken);

            return new ArgumentListSyntax(parseNodeData, typeArgumentList, openParenToken, _arguments, closeParenToken);
        }

        function tryParseArgumentListExpression(): IExpressionSyntax {
            // Generally while parsing lists, we don't want to 'force' the parser to parse
            // the item.  That way, if the expected item isn't htere, we can bail out and
            // move to a higher stage of list parsing.  However, it's extremely common to 
            // see something like "Foo(, a".  in this case, even though there isn't an expression
            // after the open paren, we still want to force parsing an expression (which will
            // cause a missing identiifer to be created), so that we will then consume the
            // comma and the following list items).
            var force = currentToken().kind() === SyntaxKind.CommaToken;
            return tryParseAssignmentExpressionOrHigher(force, /*allowIn:*/ true);
        }

        function parseElementAccessExpression(expression: ILeftHandSideExpressionSyntax, inObjectCreation: boolean): ElementAccessExpressionSyntax {
            // Debug.assert(currentToken().kind() === SyntaxKind.OpenBracketToken);

            var openBracketToken = eatToken(SyntaxKind.OpenBracketToken);
            var argumentExpression: IExpressionSyntax;

            // It's not uncommon for a user to write: "new Type[]".  Check for that common pattern
            // and report a better error message.
            if (currentToken().kind() === SyntaxKind.CloseBracketToken &&
                inObjectCreation) {

                var start = TypeScript.start(openBracketToken);
                var end = TypeScript.end(currentToken());
                var diagnostic = new Diagnostic(fileName, source.text.lineMap(), start, end - start,
                    DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, null);
                addDiagnostic(diagnostic);

                argumentExpression = Syntax.emptyToken(SyntaxKind.IdentifierName);
            }
            else {
                argumentExpression = parseExpression(/*allowIn:*/ true);
            }

            var closeBracketToken = eatToken(SyntaxKind.CloseBracketToken);

            return new ElementAccessExpressionSyntax(parseNodeData, expression, openBracketToken, argumentExpression, closeBracketToken);
        }

        function tryParsePrimaryExpression(force: boolean): IPrimaryExpressionSyntax {
            var _currentToken = currentToken();

            if (isIdentifier(_currentToken)) {
                return eatIdentifierToken();
            }

            var currentTokenKind = _currentToken.kind();
            switch (currentTokenKind) {
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                case SyntaxKind.StringLiteral:
                    consumeToken(_currentToken);
                    return _currentToken;

                case SyntaxKind.FunctionKeyword:
                    return parseFunctionExpression();

                case SyntaxKind.OpenBracketToken:
                    return parseArrayLiteralExpression();

                case SyntaxKind.OpenBraceToken:
                    return parseObjectLiteralExpression();

                case SyntaxKind.OpenParenToken:
                    return parseParenthesizedExpression();

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // If we see a standalone / or /= and we're expecting a term, then try to reparse
                    // it as a regular expression.  If we succeed, then return that.  Otherwise, fall
                    // back and just return a missing identifier as usual.  We'll then form a binary
                    // expression out of of the / as usual.
                    var result = tryReparseDivideAsRegularExpression();
                    return result || eatIdentifierToken()
            }

            if (!force) {
                return null;
            }

            // Nothing else worked, just try to consume an identifier so we report an error.
            return eatIdentifierToken();
        }

        function tryReparseDivideAsRegularExpression(): IPrimaryExpressionSyntax {
            // If we see a / or /= token, then that may actually be the start of a regex in certain 
            // contexts.

            // var currentToken = this.currentToken();
            // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken.kind()));

            // Ok, from our quick lexical check, this could be a place where a regular expression could
            // go.  Now we have to do a bunch of work.  Ask the source to retrive the token at the 
            // current position again.  But this time allow it to retrieve it as a regular expression.
            var currentToken = currentContextualToken();

            // Note: we *must* have gotten a /, /= or regular expression.  Or else something went *very*
            // wrong with our logic above.
            // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(currentToken.kind()));

            if (currentToken.kind() === SyntaxKind.SlashToken || currentToken.kind() === SyntaxKind.SlashEqualsToken) {
                // Still came back as a / or /=.   This is not a regular expression literal.
                return null;
            }
            else if (currentToken.kind() === SyntaxKind.RegularExpressionLiteral) {
                consumeToken(currentToken);
                return currentToken;
            }
            else {
                // Something *very* wrong happened.  This is an internal parser fault that we need 
                // to figure out and fix.
                throw Errors.invalidOperation();
            }
        }

        function parseTypeOfExpression(): TypeOfExpressionSyntax {
            return new TypeOfExpressionSyntax(parseNodeData,
                eatKeyword(SyntaxKind.TypeOfKeyword),
                tryParseUnaryExpressionOrHigher(/*force:*/ true));
        }

        function parseDeleteExpression(): DeleteExpressionSyntax {
            return new DeleteExpressionSyntax(parseNodeData,
                eatKeyword(SyntaxKind.DeleteKeyword),
                tryParseUnaryExpressionOrHigher(/*force:*/ true));
        }

        function parseVoidExpression(): VoidExpressionSyntax {
            return new VoidExpressionSyntax(parseNodeData,
                eatKeyword(SyntaxKind.VoidKeyword),
                tryParseUnaryExpressionOrHigher(/*force:*/ true));
        }

        function parseFunctionExpression(): FunctionExpressionSyntax {
            return new FunctionExpressionSyntax(parseNodeData,
                eatKeyword(SyntaxKind.FunctionKeyword),
                eatOptionalIdentifierToken(),
                parseCallSignature(/*requireCompleteTypeParameterList:*/ false),
                parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true));
        }

        function parseObjectCreationExpression(): ObjectCreationExpressionSyntax {
            // ObjectCreationExpression
            //      new MemberExpression Arguments?
            //
            // Note: if we see arguments we absolutely take them and attach them tightly to this
            // object creation expression.
            //
            // See comment in tryParseMemberExpressionOrHigher for a more complete explanation of
            // this decision.

            return new ObjectCreationExpressionSyntax(parseNodeData,
                eatKeyword(SyntaxKind.NewKeyword),
                tryParseMemberExpressionOrHigher(/*force:*/ true, /*inObjectCreation:*/ true),
                tryParseArgumentList());
        }

        function parseCastExpression(): CastExpressionSyntax {
            return new CastExpressionSyntax(parseNodeData,
                eatToken(SyntaxKind.LessThanToken),
                parseType(),
                eatToken(SyntaxKind.GreaterThanToken),
                tryParseUnaryExpressionOrHigher(/*force:*/ true));
        }

        function parseParenthesizedExpression(): ParenthesizedExpressionSyntax {
            return new ParenthesizedExpressionSyntax(parseNodeData,
                eatToken(SyntaxKind.OpenParenToken),
                parseExpression(/*allowIn:*/ true),
                eatToken(SyntaxKind.CloseParenToken));
        }

        function tryParseParenthesizedArrowFunctionExpression(): ParenthesizedArrowFunctionExpressionSyntax {
            var tokenKind = currentToken().kind();
            if (tokenKind !== SyntaxKind.OpenParenToken && tokenKind !== SyntaxKind.LessThanToken) {
                return null;
            }

            // Because arrow functions and parenthesized expressions look similar, we have to check far
            // enough ahead to be sure we've actually got an arrow function. For example, both nodes can
            // start with:
            //    (a = b, c = d, ..., e = f).
            //So we effectively need infinite lookahead to decide which node we're in.
            //
            // First, check for things that definitely have enough information to let us know it's an
            // arrow function.

            if (isDefinitelyArrowFunctionExpression()) {
                // We have something like "() =>" or "(a) =>".  Definitely a lambda, so parse it
                // unilaterally as such.
                return tryParseParenthesizedArrowFunctionExpressionWorker(/*requiresArrow:*/ false);
            }

            // Now, look for cases where we're sure it's not an arrow function.  This will help save us
            // a costly parse.
            if (!isPossiblyArrowFunctionExpression()) {
                return null;
            }

            // Then, try to actually parse it as a arrow function, and only return if we see an => 
            var rewindPoint = getRewindPoint();

            var arrowFunction = tryParseParenthesizedArrowFunctionExpressionWorker(/*requiresArrow:*/ true);
            if (arrowFunction === null) {
                rewind(rewindPoint);
            }

            releaseRewindPoint(rewindPoint);
            return arrowFunction;
        }

        function tryParseParenthesizedArrowFunctionExpressionWorker(requireArrow: boolean): ParenthesizedArrowFunctionExpressionSyntax {
            var _currentToken = currentToken();
            // Debug.assert(currentToken.kind() === SyntaxKind.OpenParenToken || currentToken.kind() === SyntaxKind.LessThanToken);

            var callSignature = parseCallSignature(/*requireCompleteTypeParameterList:*/ true);

            if (requireArrow && currentToken().kind() !== SyntaxKind.EqualsGreaterThanToken) {
                return null;
            }

            var equalsGreaterThanToken = eatToken(SyntaxKind.EqualsGreaterThanToken);

            var block = tryParseArrowFunctionBlock();
            var expression: IExpressionSyntax = null;
            if (block === null) {
                expression = tryParseAssignmentExpressionOrHigher(/*force:*/ true, /*allowIn:*/ true);
            }

            return new ParenthesizedArrowFunctionExpressionSyntax(parseNodeData, callSignature, equalsGreaterThanToken, block, expression);
        }

        function tryParseArrowFunctionBlock(): BlockSyntax {
            if (isBlock()) {
                return parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            }
            else {
                // We didn't have a block.  However, we may be in an error situation.  For example,
                // if the user wrote:
                //
                //  a => 
                //      var v = 0;
                //  }
                //
                // (i.e. they're missing the open brace).  See if that's the case so we can try to 
                // recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                if (isStatement(/*inErrorRecovery:*/ false) &&
                    !isExpressionStatement(currentToken()) &&
                    !isFunctionDeclaration()) {
                    // We've seen a statement (and it isn't an expressionStatement like 'foo()'), 
                    // so treat this like a block with a missing open brace.
                    return parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ true, /*checkForStrictMode:*/ false);
                }
                else {
                    return null;
                }
            }
        }

        function isSimpleArrowFunctionExpression(): boolean {
            // ERROR RECOVERY TWEAK:
            // If we see a standalone => try to parse it as an arrow function as that's likely what
            // the user intended to write.
            var token0 = currentToken();
            if (token0.kind() === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return isIdentifier(token0) &&
                   peekToken(1).kind() === SyntaxKind.EqualsGreaterThanToken;
        }

        function parseSimpleArrowFunctionExpression(): SimpleArrowFunctionExpressionSyntax {
            // Debug.assert(isSimpleArrowFunctionExpression());

            var identifier = eatIdentifierToken();
            var equalsGreaterThanToken = eatToken(SyntaxKind.EqualsGreaterThanToken);

            var block = tryParseArrowFunctionBlock();
            var expression: IExpressionSyntax = null;
            if (block === null) {
                expression = tryParseAssignmentExpressionOrHigher(/*force:*/ true, /*allowIn:*/ true);
            }

            return new SimpleArrowFunctionExpressionSyntax(parseNodeData, identifier, equalsGreaterThanToken, block, expression);
        }

        function isBlock(): boolean {
            return currentToken().kind() === SyntaxKind.OpenBraceToken;
        }

        function isDefinitelyArrowFunctionExpression(): boolean {
            var token0 = currentToken();
            if (token0.kind() !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we can't say it's 'definitely' an arrow function.             
                return false;
            }

            var token1 = peekToken(1);
            var token2: ISyntaxToken;

            if (token1.kind() === SyntaxKind.CloseParenToken) {
                // ()
                // Definitely an arrow function.  Could never be a parenthesized expression.  
                // *However*, because of error situations, we could end up with things like "().foo".
                // In this case, we don't want to think of this as the start of an arrow function.
                // To prevent this, we are a little stricter, and we require that we at least see:
                //      "():"  or  "() =>"  or "() {}".  Note: the last one is illegal.  However it
                // most likely is a missing => and not a parenthesized expression.
                token2 = peekToken(2);
                return token2.kind() === SyntaxKind.ColonToken ||
                       token2.kind() === SyntaxKind.EqualsGreaterThanToken ||
                       token2.kind() === SyntaxKind.OpenBraceToken;
            }

            if (token1.kind() === SyntaxKind.DotDotDotToken) {
                // (...
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            token2 = peekToken(2);
            if (token1.kind() === SyntaxKind.PublicKeyword || token1.kind() === SyntaxKind.PrivateKeyword) {
                if (isIdentifier(token2)) {
                    // "(public id" or "(function id".  Definitely an arrow function.  Could never 
                    // be a parenthesized expression.  Note: this will be an *illegal* arrow 
                    // function (as accessibility modifiers are not allowed in it).  However, that
                    // will be reported by the grammar checker walker.
                    return true;
                }
            }

            if (!isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            // (id
            //
            // Lots of options here.  Check for things that make us certain it's an
            // arrow function.
            if (token2.kind() === SyntaxKind.ColonToken) {
                // (id:
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            var token3 = peekToken(3);
            if (token2.kind() === SyntaxKind.QuestionToken) {
                // (id?
                // Could be an arrow function, or a parenthesized conditional expression.

                // Check for the things that could only be arrow functions.
                if (token3.kind() === SyntaxKind.ColonToken ||
                    token3.kind() === SyntaxKind.CloseParenToken ||
                    token3.kind() === SyntaxKind.CommaToken) {
                    // (id?:
                    // (id?)
                    // (id?,
                    // These are the only cases where this could be an arrow function.
                    // And none of them can be parenthesized expression.
                    return true;
                }
            }

            if (token2.kind() === SyntaxKind.CloseParenToken) {
                // (id)
                // Could be an arrow function, or a parenthesized conditional expression.

                if (token3.kind() === SyntaxKind.EqualsGreaterThanToken) {
                    // (id) =>
                    // Definitely an arrow function.  Could not be a parenthesized expression.
                    return true;
                }

                // Note: "(id):" *looks* like it could be an arrow function.  However, it could
                // show up in:  "foo ? (id): 
                // So we can't return true here for that case.
            }

            // TODO: Add more cases if you're sure that there is enough information to know to 
            // parse this as an arrow function.  Note: be very careful here.

            // Anything else wasn't clear enough.  Try to parse the expression as an arrow function and bail out
            // if we fail.
            return false;
        }

        function isPossiblyArrowFunctionExpression(): boolean {
            var token0 = currentToken();
            if (token0.kind() !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we have to say it's possibly an arrow function.
                return true;
            }

            var token1 = peekToken(1);

            if (!isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            var token2 = peekToken(2);
            if (token2.kind() === SyntaxKind.EqualsToken) {
                // (id =
                //
                // This *could* be an arrow function.  i.e. (id = 0) => { }
                // Or it could be a parenthesized expression.  So we'll have to actually
                // try to parse it.
                return true;
            }

            if (token2.kind() === SyntaxKind.CommaToken) {
                // (id,

                // This *could* be an arrow function.  i.e. (id, id2) => { }
                // Or it could be a parenthesized expression (as javascript supports
                // the comma operator).  So we'll have to actually try to parse it.
                return true;
            }

            if (token2.kind() === SyntaxKind.CloseParenToken) {
                // (id)

                var token3 = peekToken(3);
                if (token3.kind() === SyntaxKind.ColonToken) {
                    // (id):
                    //
                    // This could be an arrow function. i.e. (id): number => { }
                    // Or it could be parenthesized exprssion: foo ? (id) :
                    // So we'll have to actually try to parse it.
                    return true;
                }
            }

            // Nothing else could be an arrow function.
            return false;
        }

        function parseObjectLiteralExpression(): ObjectLiteralExpressionSyntax {
            // Debug.assert(currentToken().kind() === SyntaxKind.OpenBraceToken);

            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);
            // Debug.assert(openBraceToken.fullWidth() > 0);

            var result = parseSeparatedSyntaxList<IPropertyAssignmentSyntax>(ListParsingState.ObjectLiteralExpression_PropertyAssignments);
            var propertyAssignments = result.list;
            openBraceToken = addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new ObjectLiteralExpressionSyntax(parseNodeData, openBraceToken, propertyAssignments, closeBraceToken);
        }

        function tryParsePropertyAssignment(inErrorRecovery: boolean): IPropertyAssignmentSyntax {
            // Debug.assert(isPropertyAssignment(/*inErrorRecovery:*/ false));

            if (isAccessor(inErrorRecovery)) {
                return parseAccessor(/*checkForStrictMode:*/ true);
            }
            else if (isFunctionPropertyAssignment(inErrorRecovery)) {
                return parseFunctionPropertyAssignment();
            }
            else if (isSimplePropertyAssignment(inErrorRecovery)) {
                return parseSimplePropertyAssignment();
            }
            else {
                return null;
            }
        }

        function isPropertyAssignment(inErrorRecovery: boolean): boolean {
            return isAccessor(inErrorRecovery) ||
                   isFunctionPropertyAssignment(inErrorRecovery) ||
                   isSimplePropertyAssignment(inErrorRecovery);
        }

        function eatPropertyName(): ISyntaxToken {
            var _currentToken = currentToken();
            if (SyntaxFacts.isIdentifierNameOrAnyKeyword(_currentToken)) {
                return eatIdentifierNameToken();
            }

            // Debug.assert(isPropertyName(currentToken, false));
            consumeToken(_currentToken);
            return _currentToken;
        }

        function isFunctionPropertyAssignment(inErrorRecovery: boolean): boolean {
            return isPropertyName(currentToken(), inErrorRecovery) &&
                   isCallSignature(/*index:*/ 1);
        }

        function parseFunctionPropertyAssignment(): FunctionPropertyAssignmentSyntax {
            return new FunctionPropertyAssignmentSyntax(parseNodeData,
                eatPropertyName(),
                parseCallSignature(/*requireCompleteTypeParameterList:*/ false),
                parseBlock(/*parseBlockEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true));
        }

        function isSimplePropertyAssignment(inErrorRecovery: boolean): boolean {
            return isPropertyName(currentToken(), inErrorRecovery);
        }

        function parseSimplePropertyAssignment(): SimplePropertyAssignmentSyntax {
            return new SimplePropertyAssignmentSyntax(parseNodeData,
                eatPropertyName(),
                eatToken(SyntaxKind.ColonToken),
                tryParseAssignmentExpressionOrHigher(/*force:*/ true, /*allowIn:*/ true));
        }

        function isPropertyName(token: ISyntaxToken, inErrorRecovery: boolean): boolean {
            // NOTE: we do *not* want to check "isIdentifier" here.  Any IdentifierName is 
            // allowed here, even reserved words like keywords.
            if (SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                // Except: if we're in error recovery, then we don't want to consider keywords. 
                // After all, if we have:
                //
                //      { a: 1
                //      return
                //
                // we don't want consider 'return' to be the next property in the object literal.
                if (inErrorRecovery) {
                    return isIdentifier(token);
                }
                else {
                    return true;
                }
            }

            switch (token.kind()) {
                case SyntaxKind.StringLiteral:
                case SyntaxKind.NumericLiteral:
                    return true;

                default:
                    return false;
            }
        }

        function parseArrayLiteralExpression(): ArrayLiteralExpressionSyntax {
            // Debug.assert(currentToken().kind() === SyntaxKind.OpenBracketToken);

            var openBracketToken = eatToken(SyntaxKind.OpenBracketToken);
            // Debug.assert(openBracketToken.fullWidth() > 0);

            var result = parseSeparatedSyntaxList<IExpressionSyntax>(ListParsingState.ArrayLiteralExpression_AssignmentExpressions);
            var expressions = result.list;
            openBracketToken = addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

            var closeBracketToken = eatToken(SyntaxKind.CloseBracketToken);

            return new ArrayLiteralExpressionSyntax(parseNodeData, openBracketToken, expressions, closeBracketToken);
        }

        function parseBlock(parseBlockEvenWithNoOpenBrace: boolean, checkForStrictMode: boolean): BlockSyntax {
            var openBraceToken = eatToken(SyntaxKind.OpenBraceToken);

            var statements = Syntax.emptyList<IStatementSyntax>();

            if (parseBlockEvenWithNoOpenBrace || openBraceToken.fullWidth() > 0) {
                var savedIsInStrictMode = isInStrictMode;
                
                var processItems = checkForStrictMode ? updateStrictModeState : null;
                var result = parseSyntaxList<IStatementSyntax>(ListParsingState.Block_Statements, processItems);
                statements = result.list;
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                setStrictMode(savedIsInStrictMode);
            }

            var closeBraceToken = eatToken(SyntaxKind.CloseBraceToken);

            return new BlockSyntax(parseNodeData, openBraceToken, statements, closeBraceToken);
        }

        function parseCallSignature(requireCompleteTypeParameterList: boolean): CallSignatureSyntax {
            return new CallSignatureSyntax(parseNodeData,
                tryParseTypeParameterList(requireCompleteTypeParameterList),
                parseParameterList(),
                parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false));
        }

        function tryParseTypeParameterList(requireCompleteTypeParameterList: boolean): TypeParameterListSyntax {
            if (currentToken().kind() !== SyntaxKind.LessThanToken) {
                return null;
            }

            var rewindPoint = getRewindPoint();

            var lessThanToken = eatToken(SyntaxKind.LessThanToken);
            // Debug.assert(lessThanToken.fullWidth() > 0);

            var result = parseSeparatedSyntaxList<TypeParameterSyntax>(ListParsingState.TypeParameterList_TypeParameters);
            var typeParameters = result.list;
            lessThanToken = addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

            var greaterThanToken = eatToken(SyntaxKind.GreaterThanToken);

            // return null if we were required to have a '>' token and we did not  have one.
            if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                rewind(rewindPoint);
                releaseRewindPoint(rewindPoint);
                return null;
            }
            else {
                releaseRewindPoint(rewindPoint);
                return new TypeParameterListSyntax(parseNodeData, lessThanToken, typeParameters, greaterThanToken);
            }
        }

        function isTypeParameter(): boolean {
            return isIdentifier(currentToken());
        }

        function parseTypeParameter(): TypeParameterSyntax {
            return tryParseTypeParameter() || new TypeParameterSyntax(parseNodeData, eatIdentifierToken(), /*constraint:*/ null);
        }

        function tryParseTypeParameter(): TypeParameterSyntax {
            // Debug.assert(isTypeParameter());
            if (!isIdentifier(currentToken())) {
                return null;
            }

            return new TypeParameterSyntax(parseNodeData, eatIdentifierToken(), tryParseConstraint());
        }

        function tryParseConstraint(): ConstraintSyntax {
            if (currentToken().kind() !== SyntaxKind.ExtendsKeyword) {
                return null;
            }

            return new ConstraintSyntax(parseNodeData, eatKeyword(SyntaxKind.ExtendsKeyword), parseType());
        }

        function parseParameterList(): ParameterListSyntax {
            var openParenToken = eatToken(SyntaxKind.OpenParenToken);
            var parameters = Syntax.emptySeparatedList<ParameterSyntax>();

            if (openParenToken.fullWidth() > 0) {
                var result = parseSeparatedSyntaxList<ParameterSyntax>(ListParsingState.ParameterList_Parameters);
                parameters = result.list;
                openParenToken = addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = eatToken(SyntaxKind.CloseParenToken);
            return new ParameterListSyntax(parseNodeData, openParenToken, parameters, closeParenToken);
        }

        function parseOptionalTypeAnnotation(allowStringLiteral: boolean): TypeAnnotationSyntax {
            return currentToken().kind() === SyntaxKind.ColonToken ? parseTypeAnnotation(allowStringLiteral) : null;
        }

        function parseTypeAnnotation(allowStringLiteral: boolean): TypeAnnotationSyntax {
            // Debug.assert(isTypeAnnotation());

            var colonToken = eatToken(SyntaxKind.ColonToken);
            var type = allowStringLiteral && currentToken().kind() === SyntaxKind.StringLiteral
                ? eatToken(SyntaxKind.StringLiteral)
                : parseType();

            return new TypeAnnotationSyntax(parseNodeData, colonToken, type);
        }

        function isType(): boolean {
            var _currentToken = currentToken();
            var currentTokenKind = _currentToken.kind();

            switch (currentTokenKind) {
                // TypeQuery
                case SyntaxKind.TypeOfKeyword:

                // Pedefined types:
                case SyntaxKind.AnyKeyword:
                case SyntaxKind.NumberKeyword:
                case SyntaxKind.BooleanKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.VoidKeyword:

                // Object type
                case SyntaxKind.OpenBraceToken:

                // Function type:
                case SyntaxKind.OpenParenToken:
                case SyntaxKind.LessThanToken:

                // Constructor type:
                case SyntaxKind.NewKeyword:
                    return true;
            }

            // Name
            return isIdentifier(_currentToken);
        }

        function parseType(): ITypeSyntax {
            return tryParseType() || eatIdentifierToken();
        }

        function tryParseType(): ITypeSyntax {
            var type = tryParseNonArrayType();
            if (type === null) {
                return null;
            }

            while (currentToken().kind() === SyntaxKind.OpenBracketToken) {
                var openBracketToken = eatToken(SyntaxKind.OpenBracketToken);
                var closeBracketToken = eatToken(SyntaxKind.CloseBracketToken);

                type = new ArrayTypeSyntax(parseNodeData, type, openBracketToken, closeBracketToken);
            }

            return type;
        }

        function parseTypeQuery(): TypeQuerySyntax {
            return new TypeQuerySyntax(parseNodeData, eatToken(SyntaxKind.TypeOfKeyword), parseName());
        }

        function tryParseNonArrayType(): ITypeSyntax {
            var _currentToken = currentToken();
            switch (_currentToken.kind()) {
                // Pedefined types:
                case SyntaxKind.AnyKeyword:
                case SyntaxKind.NumberKeyword:
                case SyntaxKind.BooleanKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.VoidKeyword:
                    // if any of these are followed by '.', then this is actually a module name,
                    // and these keywords will be reinterpreted as an identifier.
                    if (peekToken(1).kind() === SyntaxKind.DotToken) {
                        break;
                    }

                    consumeToken(_currentToken);
                    return _currentToken;

                // Object type
                case SyntaxKind.OpenBraceToken:
                    return parseObjectType();

                // Function type:
                case SyntaxKind.OpenParenToken:
                case SyntaxKind.LessThanToken:
                    return parseFunctionType();

                // Constructor type:
                case SyntaxKind.NewKeyword:
                    return parseConstructorType();

                case SyntaxKind.TypeOfKeyword:
                    return parseTypeQuery();
            }

            return tryParseNameOrGenericType();
        }

        function tryParseNameOrGenericType(): ITypeSyntax {
            var name = tryParseName();
            if (name === null) {
                return null;
            }

            var typeArgumentList = tryParseTypeArgumentList(/*inExpression:*/ false);

            if (typeArgumentList === null) {
                return name;
            }

            return new GenericTypeSyntax(parseNodeData, name, typeArgumentList);
        }

        function parseFunctionType(): FunctionTypeSyntax {
            return new FunctionTypeSyntax(parseNodeData,
                tryParseTypeParameterList(/*requireCompleteTypeParameterList:*/ false),
                parseParameterList(),
                eatToken(SyntaxKind.EqualsGreaterThanToken),
                parseType());
        }

        function parseConstructorType(): ConstructorTypeSyntax {
            return new ConstructorTypeSyntax(parseNodeData,
                eatKeyword(SyntaxKind.NewKeyword),
                tryParseTypeParameterList(/*requireCompleteTypeParameterList:*/ false),
                parseParameterList(),
                eatToken(SyntaxKind.EqualsGreaterThanToken),
                parseType());
        }

        function isParameter(): boolean {
            if (currentNode() !== null && currentNode().kind() === SyntaxKind.Parameter) {
                return true;
            }

            var token = currentToken();
            var tokenKind = token.kind();
            if (tokenKind === SyntaxKind.DotDotDotToken) {
                return true;
            }

            if (isModifier(token) && !isModifierUsedAsParameterIdentifier(token)) {
                return true;
            }

            return isIdentifier(token);
        }

        // Modifiers are perfectly legal names for parameters.  i.e.  you can have: foo(public: number) { }
        // Most of the time we want to treat the modifier as a modifier.  However, if we're certain 
        // it's a parameter identifier, then don't consider it as a modifier.
        function isModifierUsedAsParameterIdentifier(token: ISyntaxToken): boolean {
            if (isIdentifier(token)) {
                // Check for:
                // foo(public)
                // foo(public: ...
                // foo(public= ...
                // foo(public, ...
                // foo(public? ...
                //
                // In all these cases, it's not actually a modifier, but is instead the identifier.
                // In any other case treat it as the modifier.
                var nextTokenKind = peekToken(1).kind();
                switch (nextTokenKind) {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.ColonToken:
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.CommaToken:
                    case SyntaxKind.QuestionToken:
                        return true;
                }
            }

            return false;
        }

        function parseParameter(): ParameterSyntax {
            var result = tryParseParameter();
            if (result !== null) {
                return result;
            }

            return new ParameterSyntax(parseNodeData,
                /*dotDotDotToken:*/ null, /*modifiers:*/ Syntax.emptyList<ISyntaxToken>(), /*identifier:*/ eatIdentifierToken(),
                /*questionToken:*/ null, /*typeAnnotation:*/ null, /*equalsValueClause:*/ null);
        }

        function tryParseParameter(): ParameterSyntax {
            var node = currentNode();
            if (node !== null && node.kind() === SyntaxKind.Parameter) {
                consumeNode(node);
                return <ParameterSyntax>node;
            }

            var dotDotDotToken = tryEatToken(SyntaxKind.DotDotDotToken);

            var modifierArray: ISyntaxToken[] = getArray();

            while (true) {
                var _currentToken = currentToken();
                if (isModifier(_currentToken) && !isModifierUsedAsParameterIdentifier(_currentToken)) {
                    consumeToken(_currentToken);
                    modifierArray.push(_currentToken);
                    continue;
                }

                break;
            }

            var modifiers = Syntax.list(modifierArray);
            returnZeroLengthArray(modifierArray);

            // If we're not forcing, and we don't see anything to indicate this is a parameter, then 
            // bail out.
            if (!isIdentifier(currentToken()) && dotDotDotToken === null && modifiers.length === 0) {
                return null;
            }

            var identifier = eatIdentifierToken();
            var questionToken = tryEatToken(SyntaxKind.QuestionToken);
            var typeAnnotation = parseOptionalTypeAnnotation(/*allowStringLiteral:*/ true);

            var equalsValueClause: EqualsValueClauseSyntax = null;
            if (isEqualsValueClause(/*inParameter*/ true)) {
                equalsValueClause = parseEqualsValueClause(/*allowIn:*/ true);
            }

            return new ParameterSyntax(parseNodeData, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause);
        }

        function parseSyntaxList<T extends ISyntaxNodeOrToken>(
                currentListType: ListParsingState,
                processItems: (items: any[]) => void = null): { skippedTokens: ISyntaxToken[]; list: T[]; } {
            var savedListParsingState = listParsingState;
            listParsingState |= currentListType;

            var result = parseSyntaxListWorker<T>(currentListType, processItems);

            listParsingState = savedListParsingState;

            return result;
        }

        function parseSeparatedSyntaxList<T extends ISyntaxNodeOrToken>(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: T[]; } {
            var savedListParsingState = listParsingState;
            listParsingState |= currentListType;

            var result = parseSeparatedSyntaxListWorker<T>(currentListType);

            listParsingState = savedListParsingState;

            return result;
        }

        // Returns true if we should abort parsing.
        function abortParsingListOrMoveToNextToken<T extends ISyntaxNodeOrToken>(
                currentListType: ListParsingState,
                nodes: T[],
                separators: ISyntaxToken[],
                skippedTokens: ISyntaxToken[]): boolean {
            // Ok.  We're at a token that is not a terminator for the list and wasn't the start of 
            // an item in the list. Definitely report an error for this token.
            reportUnexpectedTokenDiagnostic(currentListType);

            // Now, check if the token is a terminator for one our parent lists, or the start of an
            // item in one of our parent lists.  If so, we won't want to consume the token.  We've 
            // already reported the error, so just return to our caller so that a higher up 
            // production can consume it.
            for (var state = ListParsingState.LastListParsingState;
                 state >= ListParsingState.FirstListParsingState;
                 state >>= 1) {

                if ((listParsingState & state) !== 0) {
                    if (isExpectedListTerminator(state) || isExpectedListItem(state, /*inErrorRecovery:*/ true)) {
                        // Abort parsing this list.
                        return true;
                    }
                }
            }

            // Otherwise, if none of the lists we're in can capture this token, then we need to 
            // unilaterally skip it.  Note: we've already reported an error above.
            var skippedToken = currentToken();

            // Consume this token and move onto the next item in the list.
            consumeToken(skippedToken);

            addSkippedTokenToList(nodes, separators, skippedTokens, skippedToken);

            // Continue parsing this list.  Attach this token to whatever we've seen already.
            return false;
        }
        
        function addSkippedTokenToList<T extends ISyntaxNodeOrToken>(
                nodes: T[],
                separators: ISyntaxToken[],
                skippedTokens: ISyntaxToken[],
                skippedToken: ISyntaxToken): void {
            // Now, add this skipped token to the last item we successfully parsed in the list.  Or
            // add it to the list of skipped tokens if we haven't parsed anything.  Our caller will
            // have to deal with them.

            var length = nodes.length + (separators ? separators.length : 0);

            for (var i = length - 1; i >= 0; i--) {
                var array: ISyntaxNodeOrToken[] = separators && (i % 2 === 1) ? separators : nodes;
                var arrayIndex = separators ? IntegerUtilities.integerDivide(i, 2) : i;

                var item = array[arrayIndex];
                var _lastToken = lastToken(item);
                if (_lastToken && _lastToken.fullWidth() > 0) {
                    array[arrayIndex] = <T>addSkippedTokenAfterNodeOrToken(item, skippedToken);
                    return;
                }
            }

            // Didn't have anything in the list we could add to.  Add to the skipped items array
            // for our caller to handle.
            skippedTokens.push(skippedToken);
        }

        function tryParseExpectedListItem(currentListType: ListParsingState,
                                         inErrorRecovery: boolean,
                                         items: ISyntaxElement[],
                                         processItems: (items: any[]) => void): void {
            var item = tryParseExpectedListItemWorker(currentListType, inErrorRecovery);

            if (item !== null) {
                // Debug.assert(item !== null);

                items.push(item);

                if (processItems !== null) {
                    processItems(items);
                }
            }
        }

        function listIsTerminated(currentListType: ListParsingState): boolean {
            return isExpectedListTerminator(currentListType) ||
                   currentToken().kind() === SyntaxKind.EndOfFileToken;
        }

        function parseSyntaxListWorker<T extends ISyntaxNodeOrToken>(
                currentListType: ListParsingState,
                processItems: (items: any[]) => void ): { skippedTokens: ISyntaxToken[]; list: T[]; } {
            var items: T[] = getArray();
            var skippedTokens: ISyntaxToken[] = getArray();

            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = items.length;
                tryParseExpectedListItem(currentListType, /*inErrorRecovery:*/ false, items, processItems);

                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.

                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (listIsTerminated(currentListType)) {
                        break;
                    }

                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = abortParsingListOrMoveToNextToken(currentListType, items, null, skippedTokens);
                    if (abort) {
                        break;
                    }
                }

                // We either parsed an element.  Or we failed to, but weren't at the end of the list
                // and didn't want to abort. Continue parsing elements.
            }

            var result = Syntax.list<T>(items);

            // Can't return if it has more then 1 element.  In that case, the list will have been
            // copied into the SyntaxList.
            returnZeroLengthArray(items);

            return { skippedTokens: skippedTokens, list: result };
        }

        function parseSeparatedSyntaxListWorker<T extends ISyntaxNodeOrToken>(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: T[]; } {
            var nodes: T[] = getArray();
            var separators: ISyntaxToken[] = getArray();
            var skippedTokens: ISyntaxToken[] = getArray();

            // Debug.assert(nodes.length === 0);
            // Debug.assert(separators.length === 0);
            // Debug.assert(skippedTokens.length === 0);
            // Debug.assert(<any>skippedTokens !== nodes);
            // Debug.assert(skippedTokens !== separators);
            // Debug.assert(<any>nodes !== separators);

            var _separatorKind = separatorKind(currentListType);
            var allowAutomaticSemicolonInsertion = _separatorKind === SyntaxKind.SemicolonToken;

            var inErrorRecovery = false;
            var listWasTerminated = false;
            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = nodes.length;
                // Debug.assert(oldItemsCount % 2 === 0);
                tryParseExpectedListItem(currentListType, inErrorRecovery, nodes, null);
                
                var newItemsCount = nodes.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.
                    // Debug.assert(items === null || items.length % 2 === 0);
                    
                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (listIsTerminated(currentListType)) {
                        listWasTerminated = true;
                        break;
                    }
                    
                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = abortParsingListOrMoveToNextToken(currentListType, nodes, separators, skippedTokens);
                    if (abort) {
                        break;
                    }
                    else {
                        // We just skipped a token.  We're now in error recovery mode.
                        inErrorRecovery = true;
                        continue;
                    }
                }

                // Debug.assert(newItemsCount % 2 === 1);

                // We were able to successfully parse out a list item.  So we're no longer in error
                // recovery.
                inErrorRecovery = false;

                // Now, we have to see if we have a separator or not.  If we do have a separator
                // we've got to consume it and continue trying to parse list items.  Note: we always
                // allow 'comma' as a separator (for error tolerance).  We will later do a post pass
                // to report when a comma was used improperly in a list that needed semicolons.
                var _currentToken = currentToken();
                if (_currentToken.kind() === _separatorKind || _currentToken.kind() === SyntaxKind.CommaToken) {
                    // Consume the last separator and continue parsing list elements.
                    consumeToken(_currentToken);
                    separators.push(_currentToken);
                    continue;
                }

                // We didn't see the expected separator.  There are two reasons this might happen.
                // First, we may actually be at the end of the list.  If we are, then we're done
                // parsing list elements.  
                if (listIsTerminated(currentListType)) {
                    listWasTerminated = true;
                    break;
                }

                // Otherwise, it might be a case where we can parse out an implicit semicolon.

                // Note: it's important that we check this *after* the check above for
                // 'listIsTerminated'.  Consider the following case:
                //
                //      {
                //          a       // <-- just finished parsing 'a'
                //      }
                //
                // Automatic semicolon insertion rules state: "When, as the program is parsed from
                // left to right, a token (called the offending token) is encountered that is not 
                // allowed by any production of the grammar".  So we should only ever insert a 
                // semicolon if we couldn't consume something normally.  in the above case, we can
                // consume the '}' just fine.  So ASI doesn't apply.

                if (allowAutomaticSemicolonInsertion && canEatAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                    var semicolonToken = eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false) || Syntax.emptyToken(SyntaxKind.SemicolonToken);
                    separators.push(semicolonToken);
                    // Debug.assert(items.length % 2 === 0);
                    continue;
                }

                // We weren't at the end of the list.  And thre was no separator we could parse out.
                // Try parse the separator we expected, and continue parsing more list elements.
                // This time mark that we're in error recovery mode though.
                //
                // Note: trying to eat this token will emit the appropriate diagnostic.
                separators.push(eatToken(_separatorKind));

                // Now that we're in 'error recovery' mode we cantweak some parsing rules as 
                // appropriate.  For example, if we have:
                //
                //      var v = { a
                //      return
                //
                // Then we'll be missing the comma.  As such, we want to parse 'return' in a less
                // tolerant manner.  Normally 'return' could be a property in an object literal.
                // However, in error recovery mode, we do *not* want it to be.
                //
                // Continue trying to parse out list elements.
                inErrorRecovery = true;
            }

            var result = Syntax.separatedList<T>(nodes, separators);

            // Can't return if it has more then 0 elements.  In that case, the list will have been
            // copied into the SyntaxList.
            returnZeroLengthArray(nodes);
            returnZeroLengthArray(separators);

            return { skippedTokens: skippedTokens, list: result };
        }

        function separatorKind(currentListType: ListParsingState): SyntaxKind {
            switch (currentListType) {
                case ListParsingState.HeritageClause_TypeNameList:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.EnumDeclaration_EnumElements:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return SyntaxKind.CommaToken;

                case ListParsingState.ObjectType_TypeMembers:
                    return SyntaxKind.SemicolonToken;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        function reportUnexpectedTokenDiagnostic(listType: ListParsingState): void {
            var token = currentToken();

            var diagnostic = new Diagnostic(fileName, source.text.lineMap(),
                start(token), width(token), DiagnosticCode.Unexpected_token_0_expected, [getExpectedListElementType(listType)]);
            addDiagnostic(diagnostic);
        }

        function addDiagnostic(diagnostic: Diagnostic): void {
            // Except: if we already have a diagnostic for this position, don't report another one.
            if (diagnostics.length > 0 &&
                diagnostics[diagnostics.length - 1].start() === diagnostic.start()) {
                return;
            }

            diagnostics.push(diagnostic);
        }

        function isExpectedListTerminator(currentListType: ListParsingState): boolean {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return isExpectedSourceUnit_ModuleElementsTerminator();

                case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    return isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return isExpectedClassDeclaration_ClassElementsTerminator();

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return isExpectedModuleDeclaration_ModuleElementsTerminator();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return isExpectedSwitchStatement_SwitchClausesTerminator();

                case ListParsingState.SwitchClause_Statements:
                    return isExpectedSwitchClause_StatementsTerminator();

                case ListParsingState.Block_Statements:
                    return isExpectedBlock_StatementsTerminator();

                case ListParsingState.TryBlock_Statements:
                    return isExpectedTryBlock_StatementsTerminator();

                case ListParsingState.CatchBlock_Statements:
                    return isExpectedCatchBlock_StatementsTerminator();

                case ListParsingState.EnumDeclaration_EnumElements:
                    return isExpectedEnumDeclaration_EnumElementsTerminator();

                case ListParsingState.ObjectType_TypeMembers:
                    return isExpectedObjectType_TypeMembersTerminator();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return isExpectedArgumentList_AssignmentExpressionsTerminator();

                case ListParsingState.HeritageClause_TypeNameList:
                    return isExpectedHeritageClause_TypeNameListTerminator();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                case ListParsingState.ParameterList_Parameters:
                    return isExpectedParameterList_ParametersTerminator();

                case ListParsingState.TypeArgumentList_Types:
                    return isExpectedTypeArgumentList_TypesTerminator();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return isExpectedTypeParameterList_TypeParametersTerminator();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                default:
                    throw Errors.invalidOperation();
            }
        }

        function isExpectedSourceUnit_ModuleElementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.EndOfFileToken;
        }

        function isExpectedEnumDeclaration_EnumElementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedModuleDeclaration_ModuleElementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedObjectType_TypeMembersTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedLiteralExpression_AssignmentExpressionsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBracketToken;
        }

        function isExpectedTypeArgumentList_TypesTerminator(): boolean {
            var token = currentToken();
            if (token.kind() === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // If we're at a token that can follow the type argument list, then we'll also consider
            // the list terminated.
            if (canFollowTypeArgumentListInExpression(token.kind())) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        function isExpectedTypeParameterList_TypeParametersTerminator(): boolean {
            var token = currentToken();
            if (token.kind() === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // These commonly follow type parameter lists.
            if (token.kind() === SyntaxKind.OpenParenToken ||
                token.kind() === SyntaxKind.OpenBraceToken ||
                token.kind() === SyntaxKind.ExtendsKeyword ||
                token.kind() === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        function isExpectedParameterList_ParametersTerminator(): boolean {
            var token = currentToken();
            if (token.kind() === SyntaxKind.CloseParenToken) {
                return true;
            }

            // We may also see a { in an error case.  i.e.:
            // function (a, b, c  {
            if (token.kind() === SyntaxKind.OpenBraceToken) {
                return true;
            }

            // We may also see a => in an error case.  i.e.:
            // (f: number => { ... }
            if (token.kind() === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return false;
        }

        function isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator(): boolean {
            // This is the case when we're parsing variable declarations in a for/for-in statement.
            if (currentToken().kind() === SyntaxKind.SemicolonToken ||
                currentToken().kind() === SyntaxKind.CloseParenToken) {
                return true;
            }

            if (currentToken().kind() === SyntaxKind.InKeyword) {
                return true;
            }

            return false;
        }

        function isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(): boolean {
            //// This is the case when we're parsing variable declarations in a variable statement.

            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see a => then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (currentToken().kind() === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            // We're done when we can eat a semicolon.
            return canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
        }

        function isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator(): boolean {
            var token0 = currentToken();
            if (token0.kind() === SyntaxKind.OpenBraceToken ||
                token0.kind() === SyntaxKind.CloseBraceToken) {
                return true;
            }

            return false;
        }

        function isExpectedHeritageClause_TypeNameListTerminator(): boolean {
            var token0 = currentToken();
            if (token0.kind() === SyntaxKind.ExtendsKeyword ||
                token0.kind() === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            if (isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                return true;
            }

            return false;
        }

        function isExpectedArgumentList_AssignmentExpressionsTerminator(): boolean {
            var token0 = currentToken();
            return token0.kind() === SyntaxKind.CloseParenToken ||
                   token0.kind() === SyntaxKind.SemicolonToken;
        }

        function isExpectedClassDeclaration_ClassElementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedSwitchStatement_SwitchClausesTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedSwitchClause_StatementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken ||
                   isSwitchClause();
        }

        function isExpectedBlock_StatementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CloseBraceToken;
        }

        function isExpectedTryBlock_StatementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.CatchKeyword ||
                   currentToken().kind() === SyntaxKind.FinallyKeyword;
        }

        function isExpectedCatchBlock_StatementsTerminator(): boolean {
            return currentToken().kind() === SyntaxKind.FinallyKeyword;
        }

        function isExpectedListItem(currentListType: ListParsingState, inErrorRecovery: boolean): any {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return isModuleElement(inErrorRecovery);

                case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    return isHeritageClause();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return isClassElement(inErrorRecovery);

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return isModuleElement(inErrorRecovery);

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return isSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return isStatement(inErrorRecovery);

                case ListParsingState.Block_Statements:
                    return isStatement(inErrorRecovery);

                case ListParsingState.TryBlock_Statements:
                case ListParsingState.CatchBlock_Statements:
                    // These two are special.  They're just augmentations of "Block_Statements" 
                    // used so we can abort out of the try block if we see a 'catch' or 'finally'
                    // keyword.  There are no additional list items that they add, so we just
                    // return 'false' here.
                    return false;

                case ListParsingState.EnumDeclaration_EnumElements:
                    return isEnumElement(inErrorRecovery);
                
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return isVariableDeclarator();

                case ListParsingState.ObjectType_TypeMembers:
                    return isTypeMember(inErrorRecovery);

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return isExpectedArgumentList_AssignmentExpression();

                case ListParsingState.HeritageClause_TypeNameList:
                    return isHeritageClauseTypeName();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return isPropertyAssignment(inErrorRecovery);

                case ListParsingState.ParameterList_Parameters:
                    return isParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return isType();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return isTypeParameter();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return isAssignmentOrOmittedExpression();

                default:
                    throw Errors.invalidOperation();
            }
        }

        function isExpectedArgumentList_AssignmentExpression(): boolean {
            var _currentToken = currentToken();
            if (isExpression(_currentToken)) {
                return true;
            }

            // If we're on a comma then the user has written something like "Foo(a,," or "Foo(,".
            // Instead of skipping the comma, create an empty expression to go before the comma 
            // so that the tree is more well formed and doesn't have skipped tokens.
            if (_currentToken.kind() === SyntaxKind.CommaToken) {
                return true;
            }

            return false;
        }

        function tryParseExpectedListItemWorker(currentListType: ListParsingState, inErrorRecovery: boolean): ISyntaxNodeOrToken {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return tryParseModuleElement(inErrorRecovery);

                case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    return tryParseHeritageClause();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return tryParseClassElement(inErrorRecovery);

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return tryParseModuleElement(inErrorRecovery);

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return tryParseSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return tryParseStatement(inErrorRecovery);

                case ListParsingState.Block_Statements:
                    return tryParseStatement(inErrorRecovery);

                case ListParsingState.EnumDeclaration_EnumElements:
                    return tryParseEnumElement(inErrorRecovery);

                case ListParsingState.ObjectType_TypeMembers:
                    return tryParseTypeMember(inErrorRecovery);

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return tryParseArgumentListExpression();

                case ListParsingState.HeritageClause_TypeNameList:
                    return tryParseHeritageClauseTypeName();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return tryParseVariableDeclarator(/*allowIn:*/ true, /*allowIdentifierName:*/ false);

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return tryParseVariableDeclarator(/*allowIn:*/ false, /*allowIdentifierName:*/ false);

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return tryParsePropertyAssignment(inErrorRecovery);

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return tryParseAssignmentOrOmittedExpression();

                case ListParsingState.ParameterList_Parameters:
                    return tryParseParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return tryParseType();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return tryParseTypeParameter();

                default:
                    throw Errors.invalidOperation();
            }
        }

        function getExpectedListElementType(currentListType: ListParsingState): string {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return getLocalizedText(DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    return '{';

                case ListParsingState.ClassDeclaration_ClassElements:
                    return getLocalizedText(DiagnosticCode.constructor_function_accessor_or_variable, null);

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return getLocalizedText(DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return getLocalizedText(DiagnosticCode.case_or_default_clause, null);

                case ListParsingState.SwitchClause_Statements:
                    return getLocalizedText(DiagnosticCode.statement, null);

                case ListParsingState.Block_Statements:
                    return getLocalizedText(DiagnosticCode.statement, null);

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return getLocalizedText(DiagnosticCode.identifier, null);

                case ListParsingState.EnumDeclaration_EnumElements:
                    return getLocalizedText(DiagnosticCode.identifier, null);

                case ListParsingState.ObjectType_TypeMembers:
                    return getLocalizedText(DiagnosticCode.call_construct_index_property_or_function_signature, null);

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return getLocalizedText(DiagnosticCode.expression, null);

                case ListParsingState.HeritageClause_TypeNameList:
                    return getLocalizedText(DiagnosticCode.type_name, null);

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return getLocalizedText(DiagnosticCode.property_or_accessor, null);

                case ListParsingState.ParameterList_Parameters:
                    return getLocalizedText(DiagnosticCode.parameter, null);

                case ListParsingState.TypeArgumentList_Types:
                    return getLocalizedText(DiagnosticCode.type, null);

                case ListParsingState.TypeParameterList_TypeParameters:
                    return getLocalizedText(DiagnosticCode.type_parameter, null);

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return getLocalizedText(DiagnosticCode.expression, null);

                default:
                    throw Errors.invalidOperation();
            }
        }

        return {
            parseSyntaxTree: parseSyntaxTree
        };
    }

    // We keep the parser around as a singleton.  This is because calling createParser is actually
    // expensive in V8 currently.  We then clear it after a parse so that it doesn't  keep state 
    // alive unintentionally.
    var parser = createParser();

    export function parse(fileName: string,
                          text: ISimpleText,
                          isDeclaration: boolean,
                          languageVersion: LanguageVersion): SyntaxTree {
        var source = new NormalParserSource(fileName, languageVersion, text);
        return parser.parseSyntaxTree(fileName, source, languageVersion, isDeclaration);
    }

    export function incrementalParse(oldSyntaxTree: SyntaxTree,
                                     textChangeRange: TextChangeRange,
                                     newText: ISimpleText): SyntaxTree {
        if (textChangeRange.isUnchanged()) {
            return oldSyntaxTree;
        }

        var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);
        return parser.parseSyntaxTree(oldSyntaxTree.fileName(), source, oldSyntaxTree.languageVersion(), oldSyntaxTree.isDeclaration());
    }
}
///<reference path='references.ts' />

module TypeScript.PrettyPrinter {
    export function prettyPrint(node: ISyntaxNode, indentWhitespace: string = "    "): string {
        var impl = new PrettyPrinterImpl(indentWhitespace);
        visitNodeOrToken(impl, node);
        return impl.result.join("");
    }

    class PrettyPrinterImpl implements ISyntaxVisitor {
        public result: string[] = [];
        private indentations: string[] = [];
        private indentation: number = 0;

        constructor(private indentWhitespace: string) {
        }

        private newLineCountBetweenModuleElements(element1: IModuleElementSyntax, element2: IModuleElementSyntax): number {
            if (element1 === null || element2 === null) {
                return 0;
            }

            if (lastToken(element1).kind() === SyntaxKind.CloseBraceToken) {
                return 2;
            }

            return 1;
        }

        private newLineCountBetweenClassElements(element1: IClassElementSyntax, element2: IClassElementSyntax): number {
            if (element1 === null || element2 === null) {
                return 0;
            }

            return 1;
        }

        private newLineCountBetweenStatements(element1: IClassElementSyntax, element2: IClassElementSyntax): number {
            if (element1 === null || element2 === null) {
                return 0;
            }

            if (lastToken(element1).kind() === SyntaxKind.CloseBraceToken) {
                return 2;
            }

            return 1;
        }

        private newLineCountBetweenSwitchClauses(element1: ISwitchClauseSyntax, element2: ISwitchClauseSyntax): number {
            if (element1 === null || element2 === null) {
                return 0;
            }

            if (childCount(element1.statements) === 0) {
                return 1;
            }

            return 2;
        }

        private ensureSpace(): void {
            if (this.result.length > 0) {
                var last = ArrayUtilities.last(this.result);
                if (last !== " " && last !== "\r\n") {
                    this.appendText(" ");
                }
            }
        }

        private ensureNewLine(): void {
            if (this.result.length > 0) {
                var last = ArrayUtilities.last(this.result);
                if (last !== "\r\n") {
                    this.appendText("\r\n");
                }
            }
        }

        private appendNewLines(count: number): void {
            for (var i = 0; i < count; i++) {
                this.appendText("\r\n");
            }
        }

        private getIndentation(count: number): string {
            for (var i = this.indentations.length; i <= count; i++) {
                var text = i === 0
                    ? ""
                    : this.indentations[i - 1] + this.indentWhitespace;
                this.indentations[i] = text;
            }

            return this.indentations[count];
        }

        private appendIndentationIfAfterNewLine(): void {
            if (this.result.length > 0) {
                if (ArrayUtilities.last(this.result) === "\r\n") {
                    this.result.push(this.getIndentation(this.indentation));
                }
            }
        }

        private appendText(text: string): void {
            this.result.push(text);
        }

        private appendElement(element: ISyntaxElement): void {
            if (isToken(element)) {
                this.appendToken(<ISyntaxToken>element);
            }
            else if (isNode(element)) {
                this.appendNode(<ISyntaxNode>element);
            }
        }

        private appendNode(node: ISyntaxNode): void {
            visitNodeOrToken(this, node);
        }

        private appendToken(token: ISyntaxToken): void {
            if (token !== null && token.fullWidth() > 0) {
                this.appendIndentationIfAfterNewLine();
                this.appendText(token.text());
            }
        }

        public visitToken(token: ISyntaxToken): void {
            this.appendToken(token);
        }

        private appendSpaceList(list: ISyntaxNodeOrToken[]): void {
            for (var i = 0, n = childCount(list); i < n; i++) {
                if (isNode(childAt(list, i))) {
                    this.appendNode(<ISyntaxNode>childAt(list, i));
                }
                else {
                    this.appendToken(<ISyntaxToken>childAt(list, i));
                }

                this.ensureSpace();
            }
        }

        private appendSeparatorSpaceList(list: ISyntaxNodeOrToken[]): void {
            for (var i = 0, n = childCount(list); i < n; i++) {
                if (i % 2 === 0) {
                    if (i > 0) {
                        this.ensureSpace();
                    }

                    visitNodeOrToken(this, childAt(list, i));
                }
                else {
                    this.appendToken(<ISyntaxToken>childAt(list, i));
                }
            }
        }

        private appendSeparatorNewLineList(list: ISyntaxNodeOrToken[]): void {
            for (var i = 0, n = childCount(list); i < n; i++) {
                if (i % 2 === 0) {
                    if (i > 0) {
                        this.ensureNewLine();
                    }

                    visitNodeOrToken(this, childAt(list, i));
                }
                else {
                    this.appendToken(<ISyntaxToken>childAt(list, i));
                }
            }
        }

        private appendModuleElements(list: IModuleElementSyntax[]): void {
            var lastModuleElement: IModuleElementSyntax = null;
            for (var i = 0, n = list.length; i < n; i++) {
                var moduleElement = list[i];
                var newLineCount = this.newLineCountBetweenModuleElements(lastModuleElement, moduleElement);

                this.appendNewLines(newLineCount);
                visitNodeOrToken(this, moduleElement);

                lastModuleElement = moduleElement;
            }
        }

        public visitSourceUnit(node: SourceUnitSyntax): void {
            this.appendModuleElements(node.moduleElements);
        }

        public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): void {
            this.appendToken(node.requireKeyword);
            this.appendToken(node.openParenToken);
            this.appendToken(node.stringLiteral);
            this.appendToken(node.closeParenToken);
        }

        public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): void {
            visitNodeOrToken(this, node.moduleName);
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): void {
            this.appendToken(node.importKeyword);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.ensureSpace();
            this.appendToken(node.equalsToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.moduleReference);
            this.appendToken(node.semicolonToken);
        }

        public visitExportAssignment(node: ExportAssignmentSyntax): void {
            this.appendToken(node.exportKeyword);
            this.ensureSpace();
            this.appendToken(node.equalsToken);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.appendToken(node.semicolonToken);
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.classKeyword);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.appendNode(node.typeParameterList);
            this.ensureSpace();
            this.appendSpaceList(node.heritageClauses);
            this.ensureSpace();
            this.appendToken(node.openBraceToken);
            this.ensureNewLine();

            this.indentation++;

            var lastClassElement: IClassElementSyntax = null;
            for (var i = 0, n = node.classElements.length; i < n; i++) {
                var classElement = node.classElements[i];
                var newLineCount = this.newLineCountBetweenClassElements(lastClassElement, classElement);

                this.appendNewLines(newLineCount);
                visitNodeOrToken(this, classElement);

                lastClassElement = classElement;
            }

            this.indentation--;

            this.ensureNewLine();
            this.appendToken(node.closeBraceToken);
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.interfaceKeyword);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.appendNode(node.typeParameterList);
            this.ensureSpace();
            this.appendSpaceList(node.heritageClauses);
            this.ensureSpace();
            this.appendObjectType(node.body, /*appendNewLines:*/ true);
        }

        private appendObjectType(node: ObjectTypeSyntax, appendNewLines: boolean): void {
            this.appendToken(node.openBraceToken);

            if (appendNewLines) {
                this.ensureNewLine();
                this.indentation++;
            }
            else {
                this.ensureSpace();
            }

            for (var i = 0, n = childCount(node.typeMembers); i < n; i++) {
                visitNodeOrToken(this, childAt(node.typeMembers, i));

                if (appendNewLines) {
                    this.ensureNewLine();
                }
                else {
                    this.ensureSpace();
                }
            }

            this.indentation--;
            this.appendToken(node.closeBraceToken);
        }

        public visitHeritageClause(node: HeritageClauseSyntax): void {
            this.appendToken(node.extendsOrImplementsKeyword);
            this.ensureSpace();
            this.appendSeparatorSpaceList(node.typeNames);
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.moduleKeyword);
            this.ensureSpace();
            this.appendElement(node.name);
            this.ensureSpace();
            this.appendToken(node.stringLiteral);
            this.ensureSpace();

            this.appendToken(node.openBraceToken);
            this.ensureNewLine();

            this.indentation++;
            
            this.appendModuleElements(node.moduleElements);

            this.indentation--;
            this.appendToken(node.closeBraceToken);
        }

        private appendBlockOrSemicolon(block: BlockSyntax, semicolonToken: ISyntaxToken) {
            if (block) {
                this.ensureSpace();
                visitNodeOrToken(this, block);
            }
            else {
                this.appendToken(semicolonToken);
            }
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.functionKeyword);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.appendNode(node.callSignature);
            this.appendBlockOrSemicolon(node.block, node.semicolonToken);
        }

        public visitVariableStatement(node: VariableStatementSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            visitNodeOrToken(this, node.variableDeclaration);
            this.appendToken(node.semicolonToken);
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): void {
            this.appendToken(node.varKeyword);
            this.ensureSpace();
            this.appendSeparatorSpaceList(node.variableDeclarators);
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): void {
            this.appendToken(node.propertyName);
            this.appendNode(node.equalsValueClause);
        }

        public visitEqualsValueClause(node: EqualsValueClauseSyntax): void {
            this.ensureSpace();
            this.appendToken(node.equalsToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.value);
        }

        public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): void {
            this.appendToken(node.operatorToken);
            visitNodeOrToken(this, node.operand);
        }

        public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): void {
            this.appendToken(node.openBracketToken);
            this.appendSeparatorSpaceList(node.expressions);
            this.appendToken(node.closeBracketToken);
        }

        public visitOmittedExpression(node: OmittedExpressionSyntax): void {
            // Nothing to do.
        }

        public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): void {
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.closeParenToken);
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): void {
            this.appendToken(node.identifier);
            this.ensureSpace();
            this.appendToken(node.equalsGreaterThanToken);
            this.ensureSpace();
            this.appendNode(node.block);
            this.appendElement(node.expression);
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): void {
            visitNodeOrToken(this, node.callSignature);
            this.ensureSpace();
            this.appendToken(node.equalsGreaterThanToken);
            this.ensureSpace();
            this.appendNode(node.block);
            this.appendElement(node.expression);
        }

        public visitQualifiedName(node: QualifiedNameSyntax): void {
            visitNodeOrToken(this, node.left);
            this.appendToken(node.dotToken);
            this.appendToken(node.right);
        }

        public visitTypeQuery(node: TypeQuerySyntax): void {
            this.appendToken(node.typeOfKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.name);
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): void {
            this.appendToken(node.lessThanToken);
            this.appendSeparatorSpaceList(node.typeArguments);
            this.appendToken(node.greaterThanToken);
        }

        public visitConstructorType(node: ConstructorTypeSyntax): void {
            this.appendToken(node.newKeyword);
            this.ensureSpace();
            this.appendNode(node.typeParameterList);
            visitNodeOrToken(this, node.parameterList);
            this.ensureSpace();
            this.appendToken(node.equalsGreaterThanToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.type);
        }

        public visitFunctionType(node: FunctionTypeSyntax): void {
            this.appendNode(node.typeParameterList);
            visitNodeOrToken(this, node.parameterList);
            this.ensureSpace();
            this.appendToken(node.equalsGreaterThanToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.type);
        }

        public visitObjectType(node: ObjectTypeSyntax): void {
            this.appendToken(node.openBraceToken);
            this.ensureSpace();
            this.appendSeparatorSpaceList(node.typeMembers);
            this.appendToken(node.closeBraceToken);
        }

        public visitArrayType(node: ArrayTypeSyntax): void {
            visitNodeOrToken(this, node.type);
            this.appendToken(node.openBracketToken);
            this.appendToken(node.closeBracketToken);
        }

        public visitGenericType(node: GenericTypeSyntax): void {
            visitNodeOrToken(this, node.name);
            visitNodeOrToken(this, node.typeArgumentList);
        }

        public visitTypeAnnotation(node: TypeAnnotationSyntax): void {
            this.appendToken(node.colonToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.type);
        }

        private appendStatements(statements: IStatementSyntax[]): void {
            var lastStatement: IStatementSyntax = null;
            for (var i = 0, n = statements.length; i < n; i++) {
                var statement = statements[i];

                var newLineCount = this.newLineCountBetweenStatements(lastStatement, statement);

                this.appendNewLines(newLineCount);
                visitNodeOrToken(this, statement);

                lastStatement = statement;
            }
        }

        public visitBlock(node: BlockSyntax): void {
            this.appendToken(node.openBraceToken);
            this.ensureNewLine();
            this.indentation++;
            
            this.appendStatements(node.statements);

            this.indentation--;
            this.ensureNewLine();
            this.appendToken(node.closeBraceToken);
        }

        public visitParameter(node: ParameterSyntax): void {
            this.appendToken(node.dotDotDotToken);
            this.appendSpaceList(node.modifiers);
            this.appendToken(node.identifier);
            this.appendToken(node.questionToken);
            this.appendNode(node.typeAnnotation);
            this.appendNode(node.equalsValueClause);
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): void {
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.dotToken);
            this.appendToken(node.name);
        }

        public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): void {
            visitNodeOrToken(this, node.operand);
            this.appendToken(node.operatorToken);
        }

        public visitElementAccessExpression(node: ElementAccessExpressionSyntax): void {
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.openBracketToken);
            visitNodeOrToken(this, node.argumentExpression);
            this.appendToken(node.closeBracketToken);
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): void {
            visitNodeOrToken(this, node.expression);
            visitNodeOrToken(this, node.argumentList);
        }

        public visitArgumentList(node: ArgumentListSyntax): void {
            this.appendToken(node.openParenToken);
            this.appendSeparatorSpaceList(node.arguments);
            this.appendToken(node.closeParenToken);
        }

        public visitBinaryExpression(node: BinaryExpressionSyntax): void {
            visitNodeOrToken(this, node.left);

            if (node.kind() !== SyntaxKind.CommaExpression) {
                this.ensureSpace();
            }

            this.appendToken(node.operatorToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.right);
        }

        public visitConditionalExpression(node: ConditionalExpressionSyntax): void {
            visitNodeOrToken(this, node.condition);
            this.ensureSpace();
            this.appendToken(node.questionToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.whenTrue);
            this.ensureSpace();
            this.appendToken(node.colonToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.whenFalse);
        }

        public visitConstructSignature(node: ConstructSignatureSyntax): void {
            this.appendToken(node.newKeyword);
            visitNodeOrToken(this, node.callSignature);
        }

        public visitMethodSignature(node: MethodSignatureSyntax): void {
            this.appendToken(node.propertyName);
            this.appendToken(node.questionToken);
            visitNodeOrToken(this, node.callSignature);
        }

        public visitIndexSignature(node: IndexSignatureSyntax): void {
            this.appendToken(node.openBracketToken);
            this.appendNode(node.parameter);
            this.appendToken(node.closeBracketToken);
            this.appendNode(node.typeAnnotation);
        }

        public visitPropertySignature(node: PropertySignatureSyntax): void {
            this.appendToken(node.propertyName);
            this.appendToken(node.questionToken);
            this.appendNode(node.typeAnnotation);
        }

        public visitParameterList(node: ParameterListSyntax): void {
            this.appendToken(node.openParenToken);
            this.appendSeparatorSpaceList(node.parameters);
            this.appendToken(node.closeParenToken);
        }

        public visitCallSignature(node: CallSignatureSyntax): void {
            this.appendNode(node.typeParameterList);
            visitNodeOrToken(this, node.parameterList);
            this.appendNode(node.typeAnnotation);
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): void {
            this.appendToken(node.lessThanToken);
            this.appendSeparatorSpaceList(node.typeParameters);
            this.appendToken(node.greaterThanToken);
        }

        public visitTypeParameter(node: TypeParameterSyntax): void {
            this.appendToken(node.identifier);
            this.appendNode(node.constraint);
        }

        public visitConstraint(node: ConstraintSyntax): void {
            this.ensureSpace();
            this.appendToken(node.extendsKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.type);
        }

        private appendBlockOrStatement(node: IStatementSyntax): void {
            if (node.kind() === SyntaxKind.Block) {
                this.ensureSpace();
                visitNodeOrToken(this, node);
            }
            else {
                this.ensureNewLine();
                this.indentation++;
                visitNodeOrToken(this, node);
                this.indentation--;
            }
        }

        public visitIfStatement(node: IfStatementSyntax): void {
            this.appendToken(node.ifKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.condition);
            this.appendToken(node.closeParenToken);
            this.appendBlockOrStatement(node.statement);
            this.appendNode(node.elseClause);
        }

        public visitElseClause(node: ElseClauseSyntax): void {
            this.ensureNewLine();
            this.appendToken(node.elseKeyword);

            if (node.statement.kind() === SyntaxKind.IfStatement) {
                this.ensureSpace();
                visitNodeOrToken(this, node.statement);
            }
            else {
                this.appendBlockOrStatement(node.statement);
            }
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): void {
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.semicolonToken);
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): void {
            this.appendToken(node.constructorKeyword);
            visitNodeOrToken(this, node.callSignature);
            this.appendBlockOrSemicolon(node.block, node.semicolonToken);
        }

        public visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            visitNodeOrToken(this, node.indexSignature);
            this.appendToken(node.semicolonToken);
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.propertyName);
            visitNodeOrToken(this, node.callSignature);
            this.appendBlockOrSemicolon(node.block, node.semicolonToken);
        }

        public visitGetAccessor(node: GetAccessorSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.getKeyword);
            this.ensureSpace();
            this.appendToken(node.propertyName);
            visitNodeOrToken(this, node.parameterList);
            this.appendNode(node.typeAnnotation);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
        }

        public visitSetAccessor(node: SetAccessorSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.setKeyword);
            this.ensureSpace();
            this.appendToken(node.propertyName);
            visitNodeOrToken(this, node.parameterList);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            visitNodeOrToken(this, node.variableDeclarator);
            this.appendToken(node.semicolonToken);
        }

        public visitThrowStatement(node: ThrowStatementSyntax): void {
            this.appendToken(node.throwKeyword);

            if (node.expression) {
                this.ensureSpace();
                visitNodeOrToken(this, node.expression);
            }

            this.appendToken(node.semicolonToken);
        }

        public visitReturnStatement(node: ReturnStatementSyntax): void {
            this.appendToken(node.returnKeyword);

            if (node.expression) {
                this.ensureSpace();
                visitNodeOrToken(this, node.expression);
            }

            this.appendToken(node.semicolonToken);
        }

        public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): void {
            this.appendToken(node.newKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
            this.appendNode(node.argumentList);
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): void {
            this.appendToken(node.switchKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.closeParenToken);
            this.ensureSpace();
            this.appendToken(node.openBraceToken);
            this.ensureNewLine();

            var lastSwitchClause: ISwitchClauseSyntax = null;
            for (var i = 0, n = node.switchClauses.length; i < n; i++) {
                var switchClause = node.switchClauses[i];

                var newLineCount = this.newLineCountBetweenSwitchClauses(lastSwitchClause, switchClause);

                this.appendNewLines(newLineCount);
                visitNodeOrToken(this, switchClause);

                lastSwitchClause = switchClause;
            }

            this.ensureNewLine();
            this.appendToken(node.closeBraceToken);
        }

        private appendSwitchClauseStatements(node: ISwitchClauseSyntax): void {
            if (childCount(node.statements) === 1 && childAt(node.statements, 0).kind() === SyntaxKind.Block) {
                this.ensureSpace();
                visitNodeOrToken(this, childAt(node.statements, 0));
            }
            else if (childCount(node.statements) > 0) {
                this.ensureNewLine();

                this.indentation++;
                this.appendStatements(node.statements);
                this.indentation--;
            }
        }

        public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): void {
            this.appendToken(node.caseKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
            this.appendToken(node.colonToken);
            this.appendSwitchClauseStatements(node);
        }

        public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): void {
            this.appendToken(node.defaultKeyword);
            this.appendToken(node.colonToken);
            this.appendSwitchClauseStatements(node);
        }

        public visitBreakStatement(node: BreakStatementSyntax): void {
            this.appendToken(node.breakKeyword);
            if (node.identifier) {
                this.ensureSpace();
                this.appendToken(node.identifier);
            }

            this.appendToken(node.semicolonToken);
        }

        public visitContinueStatement(node: ContinueStatementSyntax): void {
            this.appendToken(node.continueKeyword);
            if (node.identifier) {
                this.ensureSpace();
                this.appendToken(node.identifier);
            }

            this.appendToken(node.semicolonToken);
        }

        public visitForStatement(node: ForStatementSyntax): void {
            this.appendToken(node.forKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            this.appendNode(node.variableDeclaration);
            this.appendElement(node.initializer);
            this.appendToken(node.firstSemicolonToken);

            if (node.condition) {
                this.ensureSpace();
                visitNodeOrToken(this, node.condition);
            }

            this.appendToken(node.secondSemicolonToken);

            if (node.incrementor) {
                this.ensureSpace();
                visitNodeOrToken(this, node.incrementor);
            }

            this.appendToken(node.closeParenToken);
            this.appendBlockOrStatement(node.statement);
        }

        public visitForInStatement(node: ForInStatementSyntax): void {
            this.appendToken(node.forKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            this.appendNode(node.variableDeclaration);
            this.appendElement(node.left);
            this.ensureSpace();
            this.appendToken(node.inKeyword);
            this.ensureSpace();
            this.appendElement(node.expression);
            this.appendToken(node.closeParenToken);
            this.appendBlockOrStatement(node.statement);
        }

        public visitWhileStatement(node: WhileStatementSyntax): void {
            this.appendToken(node.whileKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.condition);
            this.appendToken(node.closeParenToken);
            this.appendBlockOrStatement(node.statement);
        }

        public visitWithStatement(node: WithStatementSyntax): void {
            this.appendToken(node.withKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.condition);
            this.appendToken(node.closeParenToken);
            this.appendBlockOrStatement(node.statement);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): void {
            this.appendSpaceList(node.modifiers);
            this.ensureSpace();
            this.appendToken(node.enumKeyword);
            this.ensureSpace();
            this.appendToken(node.identifier);
            this.ensureSpace();
            this.appendToken(node.openBraceToken);
            this.ensureNewLine();

            this.indentation++;
            this.appendSeparatorNewLineList(node.enumElements);
            this.indentation--;

            this.appendToken(node.closeBraceToken);
        }

        public visitEnumElement(node: EnumElementSyntax): void {
            this.appendToken(node.propertyName);
            this.ensureSpace();
            this.appendNode(node.equalsValueClause);
        }

        public visitCastExpression(node: CastExpressionSyntax): void {
            this.appendToken(node.lessThanToken);
            visitNodeOrToken(this, node.type);
            this.appendToken(node.greaterThanToken);
            visitNodeOrToken(this, node.expression);
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): void {
            this.appendToken(node.openBraceToken);

            if (childCount(node.propertyAssignments) === 1) {
                this.ensureSpace();
                visitNodeOrToken(this, <ISyntaxNodeOrToken>childAt(node.propertyAssignments, 0));
                this.ensureSpace();
            }
            else if (childCount(node.propertyAssignments) > 0) {
                this.indentation++;
                this.ensureNewLine();
                this.appendSeparatorNewLineList(node.propertyAssignments);
                this.ensureNewLine();
                this.indentation--;
            }

            this.appendToken(node.closeBraceToken);
        }

        public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): void {
            this.appendToken(node.propertyName);
            this.appendToken(node.colonToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
        }

        public visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): void {
            this.appendToken(node.propertyName);
            visitNodeOrToken(this, node.callSignature);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
        }

        public visitFunctionExpression(node: FunctionExpressionSyntax): void {
            this.appendToken(node.functionKeyword);
            
            if (node.identifier) {
                this.ensureSpace();
                this.appendToken(node.identifier);
            }

            visitNodeOrToken(this, node.callSignature);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): void {
            this.appendToken(node.semicolonToken);
        }

        public visitTryStatement(node: TryStatementSyntax): void {
            this.appendToken(node.tryKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
            this.appendNode(node.catchClause);
            this.appendNode(node.finallyClause);
        }

        public visitCatchClause(node: CatchClauseSyntax): void {
            this.ensureNewLine();
            this.appendToken(node.catchKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            this.appendToken(node.identifier);
            this.appendToken(node.closeParenToken);
            this.ensureSpace();
            visitNodeOrToken(this, node.block);
        }

        public visitFinallyClause(node: FinallyClauseSyntax): void {
            this.ensureNewLine();
            this.appendToken(node.finallyKeyword);
            this.ensureNewLine();
            visitNodeOrToken(this, node.block);
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): void {
            this.appendToken(node.identifier);
            this.appendToken(node.colonToken);
            this.appendBlockOrStatement(node.statement);
        }

        public visitDoStatement(node: DoStatementSyntax): void {
            this.appendToken(node.doKeyword);
            this.appendBlockOrStatement(node.statement);
            this.ensureNewLine();
            this.appendToken(node.whileKeyword);
            this.ensureSpace();
            this.appendToken(node.openParenToken);
            visitNodeOrToken(this, node.condition);
            this.appendToken(node.closeParenToken);
            this.appendToken(node.semicolonToken);
        }

        public visitTypeOfExpression(node: TypeOfExpressionSyntax): void {
            this.appendToken(node.typeOfKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
        }

        public visitDeleteExpression(node: DeleteExpressionSyntax): void {
            this.appendToken(node.deleteKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
        }

        public visitVoidExpression(node: VoidExpressionSyntax): void {
            this.appendToken(node.voidKeyword);
            this.ensureSpace();
            visitNodeOrToken(this, node.expression);
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): void {
            this.appendToken(node.debuggerKeyword);
            this.appendToken(node.semicolonToken);
        }
    }
}
///<reference path='..\text\references.ts' />

///<reference path='characterInfo.ts' />
///<reference path='constants.ts' />
///<reference path='formattingOptions.ts' />
// ///<reference path='indentation.ts' />
///<reference path='languageVersion.ts' />

// Scanner depends on SyntaxKind and SyntaxFacts
///<reference path='syntaxKind.ts' />
///<reference path='syntaxFacts.ts' />
///<reference path='scanner.ts' />

///<reference path='scannerUtilities.generated.ts' />
///<reference path='slidingWindow.ts' />
///<reference path='syntax.ts' />
///<reference path='syntaxElement.ts' />
///<reference path='syntaxFacts2.ts' />
///<reference path='syntaxList.ts' />
///<reference path='syntaxNode.ts' />
///<reference path='syntaxNodeOrToken.ts' />
///<reference path='syntaxNodes.generated.ts' />

// SyntaxDedenter depends on SyntaxRewriter
// ///<reference path='syntaxDedenter.ts' />
// SyntaxIndenter depends on SyntaxRewriter
// ///<reference path='syntaxIndenter.ts' />

///<reference path='syntaxToken.ts' />
///<reference path='syntaxTrivia.ts' />
///<reference path='syntaxTriviaList.ts' />
///<reference path='syntaxUtilities.ts' />
///<reference path='syntaxVisitor.generated.ts' />
///<reference path='syntaxWalker.generated.ts' />

// SyntaxInformationMap depends on SyntaxWalker
// ///<reference path='syntaxNodeInvariantsChecker.ts' />

// DepthLimitedWalker depends on PositionTrackingWalker
///<reference path='depthLimitedWalker.ts' />

// Parser depends on PositionTrackingWalker
///<reference path='parser.ts' />

// SyntaxTree depends on PositionTrackingWalker
///<reference path='syntaxTree.ts' />

///<reference path='unicode.ts' />
///<reference path='references.ts' />

module TypeScript {
    // To save space in a token we use 60 bits to encode the following.
    //
    //   _packedFullStartAndInfo:
    //                                                 
    // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx    <-- Leading trivia info.
    // 0000 0000 0000 0000 0000 0000 0000 0000 00xx x000    <-- Trailing trivia info.
    // 0000 0000 0000 0000 0000 0000 0000 0000 0x00 0000    <-- Is keyword converted to identifier.
    // 00xx xxxx xxxx xxxx xxxx xxxx xxxx xxxx x000 0000    <-- Full start.
    // ^                                               ^
    // |                                               |
    // Bit 39                                          Bit 0

    enum ScannerConstants {
        LeadingTriviaShift                  = 0,
        TrailingTriviaShift                 = 3,
        IsKeywordConvertedToIdentifierShift = 6,

        // We use 31 bits to store the full start of a token.  However, because the bits go past 
        // the 32 bit mark in the number, we can't use shifts to retrive or store the value.  
        // This is because javascript says that a bitwise operator immediate truncates values to
        // 32bits before they are applied.  However, we can effectively shift just by dividing or
        // multiplying by the right amount. This may result in a fractional number.  but we can 
        // then extract the bits we want at that point with a mask.
        //
        // Here dividing/multiplying by 128 is the same as shifting over 7 bits.
        FullStartAdjust                      = 128,

        IsKeywordConvertedToIdentifierMask  = 0x01, // 00000001
        TriviaBitMask                       = 0x07, // 00000111
        CommentTriviaBitMask                = 0x01, // 00000001
        NewLineTriviaBitMask                = 0x02, // 00000010
        WhitespaceTriviaBitMask             = 0x04, // 00000100
        FullStartBitMask                    = 0x7FFFFFFF
    }

    // Make sure our math works for packing/unpacking large fullStarts.
    Debug.assert(unpackFullStart(packFullStartAndInfo(1 << 30, true, 0, 0)) === (1 << 30));
    Debug.assert(unpackFullStart(packFullStartAndInfo(3 << 29, false, 7, 0)) === (3 << 29));
    Debug.assert(unpackFullStart(packFullStartAndInfo(10 << 27, true, 0, 7)) === (10 << 27));

    function packFullStartAndInfo(fullStart: number, isKeywordConvertedToIdentifier: boolean, leadingTriviaInfo: number, trailingTriviaInfo: number): number {
        var shiftedFullStart = fullStart * ScannerConstants.FullStartAdjust;
        var packedInfo = 
            ((isKeywordConvertedToIdentifier ? 1 : 0) << ScannerConstants.IsKeywordConvertedToIdentifierShift) |
            (leadingTriviaInfo << ScannerConstants.LeadingTriviaShift) |
            (trailingTriviaInfo << ScannerConstants.TrailingTriviaShift);

        // 'shiftedFullInfo' may be larger than 32 bits.  So we need to add here to preserve all
        // teh values, rather than using bitwise |   
        return shiftedFullStart + packedInfo;
    }

    function packFullWidthAndKind(fullWidth: number, kind: number) {
        return (fullWidth << 7) | kind;
    }

    function unpackFullWidth(fullWidth: number) {
        return fullWidth >> 7;
    }

    function unpackFullStart(packedFullStartAndInfo: number): number {
        var shiftedValue = packedFullStartAndInfo / ScannerConstants.FullStartAdjust;
        return shiftedValue & ScannerConstants.FullStartBitMask;
    }

    function unpackIsKeywordConvertedToIdentifier(packedFullStartAndInfo: number): boolean {
        var val = (packedFullStartAndInfo >> ScannerConstants.IsKeywordConvertedToIdentifierShift) & ScannerConstants.IsKeywordConvertedToIdentifierMask;
        return val !== 0;
    }

    function unpackLeadingTriviaInfo(packedFullStartAndInfo: number): number {
        return (packedFullStartAndInfo >> ScannerConstants.LeadingTriviaShift) & ScannerConstants.TriviaBitMask;
    }

    function unpackTrailingTriviaInfo(packedFullStartAndInfo: number): number {
        return (packedFullStartAndInfo >> ScannerConstants.TrailingTriviaShift) & ScannerConstants.TriviaBitMask;
    }

    var isKeywordStartCharacter: boolean[] = ArrayUtilities.createArray<boolean>(CharacterCodes.maxAsciiCharacter, false);
    var isIdentifierStartCharacter: boolean[] = ArrayUtilities.createArray<boolean>(CharacterCodes.maxAsciiCharacter, false);
    var isIdentifierPartCharacter: boolean[] = ArrayUtilities.createArray<boolean>(CharacterCodes.maxAsciiCharacter, false);

    for (var character = 0; character < CharacterCodes.maxAsciiCharacter; character++) {
        if ((character >= CharacterCodes.a && character <= CharacterCodes.z) ||
            (character >= CharacterCodes.A && character <= CharacterCodes.Z) ||
            character === CharacterCodes._ || character === CharacterCodes.$) {

            isIdentifierStartCharacter[character] = true;
            isIdentifierPartCharacter[character] = true;
        }
        else if (character >= CharacterCodes._0 && character <= CharacterCodes._9) {
            isIdentifierPartCharacter[character] = true;
        }
    }

    for (var keywordKind = SyntaxKind.FirstKeyword; keywordKind <= SyntaxKind.LastKeyword; keywordKind++) {
        var keyword = SyntaxFacts.getText(keywordKind);
        isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
    }

    export function isContextualToken(token: ISyntaxToken): boolean {
        // These tokens are contextually created based on parsing decisions.  We can't reuse 
        // them in incremental scenarios as we may be in a context where the parser would not
        // create them.
        switch (token.kind()) {
            // Created by the parser when it sees / or /= in a location where it needs an expression.
            case SyntaxKind.RegularExpressionLiteral:

            // Created by the parser when it sees > in a binary expression operator context.
            case SyntaxKind.GreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return true;

            default:
                return token.isKeywordConvertedToIdentifier();
        }
    }

    var lastTokenInfo = { leadingTriviaWidth: -1, width: -1 };
    var lastTokenInfoTokenID: number = -1;

    var triviaScanner = createScannerInternal(LanguageVersion.EcmaScript5, SimpleText.fromString(""), () => { });


    export class ScannerToken implements ISyntaxToken {
        public parent: ISyntaxElement = null;

        public _isPrimaryExpression: any;
        public _isMemberExpression: any;
        public _isLeftHandSideExpression: any;
        public _isPostfixExpression: any;
        public _isUnaryExpression: any;
        public _isExpression: any;

        constructor(public _text: ISimpleText,
                    private _packedFullStartAndInfo: number,
                    private _packedFullWidthAndKind: number) {
        }

        public setTextAndFullStart(text: ISimpleText, fullStart: number): void {
            this._text = text;

            this._packedFullStartAndInfo = packFullStartAndInfo(fullStart,
                this.isKeywordConvertedToIdentifier(),
                unpackLeadingTriviaInfo(this._packedFullStartAndInfo),
                unpackTrailingTriviaInfo(this._packedFullStartAndInfo));
        }

        public kind(): SyntaxKind {
            return this._packedFullWidthAndKind & 0x7F;
        }

        public isIncrementallyUnusable(): boolean {
            // Almost no scanner tokens make their *containing node* incrementally unusable.  
            // Note: several scanner tokens may themselves be unusable.  i.e. if the parser asks
            // for a full node, then that ndoe can be returned even if it contains parser generated
            // tokens (like regexs and merged operator tokens). However, if the parser asks for a
            // for a token, then those contextual tokens will not be reusable.
            return false;
        }

        public isKeywordConvertedToIdentifier(): boolean {
            return unpackIsKeywordConvertedToIdentifier(this._packedFullStartAndInfo);
        }

        public convertKeywordToIdentifier(): ISyntaxToken {
            var data = packFullStartAndInfo(
                unpackFullStart(this._packedFullStartAndInfo),
                /*isKeywordConvertedToIdentifier:*/ true,
                unpackLeadingTriviaInfo(this._packedFullStartAndInfo),
                unpackTrailingTriviaInfo(this._packedFullStartAndInfo));
            return new ScannerToken(this._text, data, packFullWidthAndKind(this.fullWidth(), SyntaxKind.IdentifierName));
        }

        public fullWidth(): number { return unpackFullWidth(this._packedFullWidthAndKind); }
        public fullStart(): number { return unpackFullStart(this._packedFullStartAndInfo); }

        private fillSizeInfo(): void {
            if (lastTokenInfoTokenID !== syntaxID(this)) {
                triviaScanner.fillTokenInfo(this, this._text, lastTokenInfo);
                lastTokenInfoTokenID = syntaxID(this);
            }
        }

        public fullText(): string {
            return this._text.substr(this.fullStart(), this.fullWidth());
        }

        public text(): string {
            this.fillSizeInfo();
            return this._text.substr(this.fullStart() + lastTokenInfo.leadingTriviaWidth, lastTokenInfo.width);
        }

        public leadingTrivia(): ISyntaxTriviaList {
            if (!this.hasLeadingTrivia()) {
                return Syntax.emptyTriviaList;
            }

            return triviaScanner.scanTrivia(this, /*isTrailing:*/ false);
        }

        public trailingTrivia(): ISyntaxTriviaList {
            if (!this.hasTrailingTrivia()) {
                return Syntax.emptyTriviaList;
            }

            return triviaScanner.scanTrivia(this, /*isTrailing:*/ true);
        }

        public leadingTriviaWidth(): number {
            if (!this.hasLeadingTrivia()) {
                return 0;
            }

            this.fillSizeInfo();
            return lastTokenInfo.leadingTriviaWidth;
        }

        public trailingTriviaWidth(): number {
            if (!this.hasTrailingTrivia()) {
                return 0;
            }

            this.fillSizeInfo();
            return this.fullWidth() - lastTokenInfo.leadingTriviaWidth - lastTokenInfo.width;
        }

        public hasLeadingTrivia(): boolean {
            var info = unpackLeadingTriviaInfo(this._packedFullStartAndInfo);
            return info !== 0;
        }

        public hasLeadingComment(): boolean {
            var info = unpackLeadingTriviaInfo(this._packedFullStartAndInfo);
            return (info & ScannerConstants.CommentTriviaBitMask) !== 0;
        }

        public hasLeadingNewLine(): boolean {
            var info = unpackLeadingTriviaInfo(this._packedFullStartAndInfo);
            return (info & ScannerConstants.NewLineTriviaBitMask) !== 0;
        }

        public hasTrailingTrivia(): boolean {
            var info = unpackTrailingTriviaInfo(this._packedFullStartAndInfo);
            return info !== 0;
        }

        public hasTrailingComment(): boolean {
            var info = unpackTrailingTriviaInfo(this._packedFullStartAndInfo);
            return (info & ScannerConstants.CommentTriviaBitMask) !== 0;
        }

        public hasTrailingNewLine(): boolean {
            var info = unpackTrailingTriviaInfo(this._packedFullStartAndInfo);
            return (info & ScannerConstants.NewLineTriviaBitMask) !== 0;
        }

        public hasSkippedToken(): boolean { return false; }

        public clone(): ISyntaxToken {
            return new ScannerToken(this._text, this._packedFullStartAndInfo, this._packedFullWidthAndKind);
        }
    }

    export interface DiagnosticCallback {
        (position: number, width: number, key: string, arguments: any[]): void;
    }

    interface TokenInfo {
        leadingTriviaWidth: number;
        width: number;
    }

    interface ScannerInternal extends Scanner {
        fillTokenInfo(token: ISyntaxToken, text: ISimpleText, tokenInfo: TokenInfo): void;
        scanTrivia(token: ScannerToken, isTrailing: boolean): ISyntaxTriviaList;
    }

    export interface Scanner {
        setIndex(index: number): void;
        scan(allowContextualToken: boolean): ISyntaxToken;
    }

    export function createScanner(languageVersion: LanguageVersion, text: ISimpleText, reportDiagnostic: DiagnosticCallback): Scanner {
        var scanner = createScannerInternal(languageVersion, text, reportDiagnostic);
        return {
            setIndex: scanner.setIndex,
            scan: scanner.scan,
        };
    }

    function createScannerInternal(languageVersion: LanguageVersion, text: ISimpleText, reportDiagnostic: DiagnosticCallback): ScannerInternal {
        var str: string;
        var index: number;
        var start: number;
        var end: number;

        function setIndex(_index: number) {
            index = _index;
        }

        function reset(_text: ISimpleText, _start: number, _end: number) {
            Debug.assert(_start <= _text.length());
            Debug.assert(_end <= _text.length());

            if (!str || text !== _text) {
                text = _text;
                str = _text.substr(0, _text.length());
            }

            start = _start;
            end = _end;
            index = _start;
        }

        function scan(allowContextualToken: boolean): ISyntaxToken {
            var fullStart = index;

            var leadingTriviaInfo = scanTriviaInfo(/*isTrailing: */ false);
            var kind = scanSyntaxKind(allowContextualToken);
            var trailingTriviaInfo = scanTriviaInfo(/*isTrailing: */true);

            // inline the packing logic for perf.
            var packedFullStartAndTriviaInfo = (fullStart * ScannerConstants.FullStartAdjust) +
                ((leadingTriviaInfo << ScannerConstants.LeadingTriviaShift) |
                 (trailingTriviaInfo << ScannerConstants.TrailingTriviaShift));
            var packedFullWidthAndKind = ((index - fullStart) << 7) | kind;
            return new ScannerToken(text, packedFullStartAndTriviaInfo, packedFullWidthAndKind);
        }

        function scanTrivia(parent: ScannerToken, isTrailing: boolean): ISyntaxTriviaList {
            if (isTrailing) {
                reset(parent._text, TypeScript.end(parent), fullEnd(parent));
            }
            else {
                reset(parent._text, parent.fullStart(), TypeScript.start(parent));
            }
            // Debug.assert(length > 0);

            // Keep this exactly in sync with scanTriviaInfo
            var trivia: ISyntaxTrivia[] = [];

            while (true) {
                if (index < end) {
                    var ch = str.charCodeAt(index);
                    switch (ch) {
                        // Unicode 3.0 space characters
                        case CharacterCodes.space:
                        case CharacterCodes.nonBreakingSpace:
                        case CharacterCodes.enQuad:
                        case CharacterCodes.emQuad:
                        case CharacterCodes.enSpace:
                        case CharacterCodes.emSpace:
                        case CharacterCodes.threePerEmSpace:
                        case CharacterCodes.fourPerEmSpace:
                        case CharacterCodes.sixPerEmSpace:
                        case CharacterCodes.figureSpace:
                        case CharacterCodes.punctuationSpace:
                        case CharacterCodes.thinSpace:
                        case CharacterCodes.hairSpace:
                        case CharacterCodes.zeroWidthSpace:
                        case CharacterCodes.narrowNoBreakSpace:
                        case CharacterCodes.ideographicSpace:

                        case CharacterCodes.tab:
                        case CharacterCodes.verticalTab:
                        case CharacterCodes.formFeed:
                        case CharacterCodes.byteOrderMark:
                            // Normal whitespace.  Consume and continue.
                            trivia.push(scanWhitespaceTrivia());
                            continue;

                        case CharacterCodes.slash:
                            // Potential comment.  Consume if so.  Otherwise, break out and return.
                            var ch2 = str.charCodeAt(index + 1);
                            if (ch2 === CharacterCodes.slash) {
                                trivia.push(scanSingleLineCommentTrivia());
                                continue;
                            }

                            if (ch2 === CharacterCodes.asterisk) {
                                trivia.push(scanMultiLineCommentTrivia());
                                continue;
                            }

                            // Not a comment.  Don't consume.
                            throw Errors.invalidOperation();

                        case CharacterCodes.carriageReturn:
                        case CharacterCodes.lineFeed:
                        case CharacterCodes.paragraphSeparator:
                        case CharacterCodes.lineSeparator:
                            trivia.push(scanLineTerminatorSequenceTrivia(ch));

                            // If we're consuming leading trivia, then we will continue consuming more 
                            // trivia (including newlines) up to the first token we see.  If we're 
                            // consuming trailing trivia, then we break after the first newline we see.
                            if (!isTrailing) {
                                continue;
                            }

                            break;

                        default:
                            throw Errors.invalidOperation();
                    }
                }

                // Debug.assert(trivia.length > 0);
                var triviaList = Syntax.triviaList(trivia);
                triviaList.parent = parent;

                return triviaList;
            }
        }

        function scanTriviaInfo(isTrailing: boolean): number {
            // Keep this exactly in sync with scanTrivia
            var commentInfo = 0;
            var whitespaceInfo = 0;
            var newLineInfo = 0;

            while (true) {
                var ch = str.charCodeAt(index);

                switch (ch) {
                    // Unicode 3.0 space characters
                    case CharacterCodes.space:
                    case CharacterCodes.nonBreakingSpace:
                    case CharacterCodes.enQuad:
                    case CharacterCodes.emQuad:
                    case CharacterCodes.enSpace:
                    case CharacterCodes.emSpace:
                    case CharacterCodes.threePerEmSpace:
                    case CharacterCodes.fourPerEmSpace:
                    case CharacterCodes.sixPerEmSpace:
                    case CharacterCodes.figureSpace:
                    case CharacterCodes.punctuationSpace:
                    case CharacterCodes.thinSpace:
                    case CharacterCodes.hairSpace:
                    case CharacterCodes.zeroWidthSpace:
                    case CharacterCodes.narrowNoBreakSpace:
                    case CharacterCodes.ideographicSpace:

                    case CharacterCodes.tab:
                    case CharacterCodes.verticalTab:
                    case CharacterCodes.formFeed:
                    case CharacterCodes.byteOrderMark:
                        // Normal whitespace.  Consume and continue.
                        whitespaceInfo = ScannerConstants.WhitespaceTriviaBitMask;
                        index++;
                        continue;

                    case CharacterCodes.slash:
                        // Potential comment.  Consume if so.  Otherwise, break out and return.
                        var ch2 = str.charCodeAt(index + 1);
                        if (ch2 === CharacterCodes.slash) {
                            commentInfo = ScannerConstants.CommentTriviaBitMask;
                            skipSingleLineCommentTrivia();
                            continue;
                        }

                        if (ch2 === CharacterCodes.asterisk) {
                            commentInfo = ScannerConstants.CommentTriviaBitMask;
                            skipMultiLineCommentTrivia();
                            continue;
                        }

                        // Not a comment.  Don't consume.
                        break;

                    case CharacterCodes.carriageReturn:
                    case CharacterCodes.lineFeed:
                    case CharacterCodes.paragraphSeparator:
                    case CharacterCodes.lineSeparator:
                        newLineInfo = ScannerConstants.NewLineTriviaBitMask;
                        skipLineTerminatorSequence(ch);

                        // If we're consuming leading trivia, then we will continue consuming more 
                        // trivia (including newlines) up to the first token we see.  If we're 
                        // consuming trailing trivia, then we break after the first newline we see.
                        if (!isTrailing) {
                            continue;
                        }

                        break;
                }

                return commentInfo + newLineInfo + whitespaceInfo;
            }
        }

        function isNewLineCharacter(ch: number): boolean {
            switch (ch) {
                case CharacterCodes.carriageReturn:
                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    return true;
                default:
                    return false;
            }
        }

        function scanWhitespaceTrivia(): ISyntaxTrivia {
            // We're going to be extracting text out of sliding window.  Make sure it can't move past
            // this point.
            var absoluteStartIndex = index;

            while (true) {
                var ch = str.charCodeAt(index);

                switch (ch) {
                    // Unicode 3.0 space characters
                    case CharacterCodes.space:
                    case CharacterCodes.nonBreakingSpace:
                    case CharacterCodes.enQuad:
                    case CharacterCodes.emQuad:
                    case CharacterCodes.enSpace:
                    case CharacterCodes.emSpace:
                    case CharacterCodes.threePerEmSpace:
                    case CharacterCodes.fourPerEmSpace:
                    case CharacterCodes.sixPerEmSpace:
                    case CharacterCodes.figureSpace:
                    case CharacterCodes.punctuationSpace:
                    case CharacterCodes.thinSpace:
                    case CharacterCodes.hairSpace:
                    case CharacterCodes.zeroWidthSpace:
                    case CharacterCodes.narrowNoBreakSpace:
                    case CharacterCodes.ideographicSpace:

                    case CharacterCodes.tab:
                    case CharacterCodes.verticalTab:
                    case CharacterCodes.formFeed:
                    case CharacterCodes.byteOrderMark:
                        // Normal whitespace.  Consume and continue.
                        index++;
                        continue;
                }

                break;
            }

            return createTrivia(SyntaxKind.WhitespaceTrivia, absoluteStartIndex);
        }

        function createTrivia(kind: SyntaxKind, absoluteStartIndex: number): ISyntaxTrivia {
            var fullWidth = index - absoluteStartIndex;
            return Syntax.deferredTrivia(kind, text, absoluteStartIndex, fullWidth);
        }

        function scanSingleLineCommentTrivia(): ISyntaxTrivia {
            var absoluteStartIndex = index;
            skipSingleLineCommentTrivia();

            return createTrivia(SyntaxKind.SingleLineCommentTrivia, absoluteStartIndex);
        }

        function skipSingleLineCommentTrivia(): void {
            index += 2;

            // The '2' is for the "//" we consumed.
            while (true) {
                var ch = str.charCodeAt(index);
                if (isNaN(ch) || isNewLineCharacter(ch)) {
                    return;
                }

                index++;
            }
        }

        function scanMultiLineCommentTrivia(): ISyntaxTrivia {
            var absoluteStartIndex = index;
            skipMultiLineCommentTrivia();

            return createTrivia(SyntaxKind.MultiLineCommentTrivia, absoluteStartIndex);
        }

        function skipMultiLineCommentTrivia(): number {
            // The '2' is for the "/*" we consumed.
            index += 2;

            while (true) {
                if (index >= end) {
                    reportDiagnostic(end, 0, DiagnosticCode.AsteriskSlash_expected, null);
                    return;
                }

                if (str.charCodeAt(index) === CharacterCodes.asterisk &&
                    str.charCodeAt(index + 1) === CharacterCodes.slash) {

                    index += 2;
                    return;
                }

                index++;
            }
        }

        function scanLineTerminatorSequenceTrivia(ch: number): ISyntaxTrivia {
            var absoluteStartIndex = index;
            skipLineTerminatorSequence(ch);

            return createTrivia(SyntaxKind.NewLineTrivia, absoluteStartIndex);
        }

        function skipLineTerminatorSequence(ch: number): void {
            // Consume the first of the line terminator we saw.
            index++;

            // If it happened to be a \r and there's a following \n, then consume both.
            if (ch === CharacterCodes.carriageReturn && str.charCodeAt(index) === CharacterCodes.lineFeed) {
                index++;
            }
        }

        function scanSyntaxKind(allowContextualToken: boolean): SyntaxKind {
            if (index >= end) {
                return SyntaxKind.EndOfFileToken;
            }

            var character = str.charCodeAt(index);

            switch (character) {
                case CharacterCodes.doubleQuote:
                case CharacterCodes.singleQuote:
                    return scanStringLiteral();

                // These are the set of variable width punctuation tokens.
                case CharacterCodes.slash:
                    return scanSlashToken(allowContextualToken);

                case CharacterCodes.dot:
                    return scanDotToken();

                case CharacterCodes.minus:
                    return scanMinusToken();

                case CharacterCodes.exclamation:
                    return scanExclamationToken();

                case CharacterCodes.equals:
                    return scanEqualsToken();

                case CharacterCodes.bar:
                    return scanBarToken();

                case CharacterCodes.asterisk:
                    return scanAsteriskToken();

                case CharacterCodes.plus:
                    return scanPlusToken();

                case CharacterCodes.percent:
                    return scanPercentToken();

                case CharacterCodes.ampersand:
                    return scanAmpersandToken();

                case CharacterCodes.caret:
                    return scanCaretToken();

                case CharacterCodes.lessThan:
                    return scanLessThanToken();

                // These are the set of fixed, single character length punctuation tokens.
                // The token kind does not depend on what follows.
                case CharacterCodes.greaterThan:
                    return scanGreaterThanToken(allowContextualToken);

                case CharacterCodes.comma:
                    return advanceAndSetTokenKind(SyntaxKind.CommaToken);

                case CharacterCodes.colon:
                    return advanceAndSetTokenKind(SyntaxKind.ColonToken);

                case CharacterCodes.semicolon:
                    return advanceAndSetTokenKind(SyntaxKind.SemicolonToken);

                case CharacterCodes.tilde:
                    return advanceAndSetTokenKind(SyntaxKind.TildeToken);

                case CharacterCodes.openParen:
                    return advanceAndSetTokenKind(SyntaxKind.OpenParenToken);

                case CharacterCodes.closeParen:
                    return advanceAndSetTokenKind(SyntaxKind.CloseParenToken);

                case CharacterCodes.openBrace:
                    return advanceAndSetTokenKind(SyntaxKind.OpenBraceToken);

                case CharacterCodes.closeBrace:
                    return advanceAndSetTokenKind(SyntaxKind.CloseBraceToken);

                case CharacterCodes.openBracket:
                    return advanceAndSetTokenKind(SyntaxKind.OpenBracketToken);

                case CharacterCodes.closeBracket:
                    return advanceAndSetTokenKind(SyntaxKind.CloseBracketToken);

                case CharacterCodes.question:
                    return advanceAndSetTokenKind(SyntaxKind.QuestionToken);

                case CharacterCodes._0: case CharacterCodes._1: case CharacterCodes._2: case CharacterCodes._3:
                case CharacterCodes._4: case CharacterCodes._5: case CharacterCodes._6: case CharacterCodes._7:
                case CharacterCodes._8: case CharacterCodes._9:
                    return scanNumericLiteral();
            }

            // We run into so many identifiers (and keywords) when scanning, that we want the code to
            // be as fast as possible.  To that end, we have an extremely fast path for scanning that
            // handles the 99.9% case of no-unicode characters and no unicode escapes.
            if (isIdentifierStartCharacter[character]) {
                var result = tryFastScanIdentifierOrKeyword(character);
                if (result !== SyntaxKind.None) {
                    return result;
                }
            }

            if (isIdentifierStart(peekCharOrUnicodeEscape())) {
                return slowScanIdentifierOrKeyword();
            }

            return scanDefaultCharacter(character);
        }

        function isIdentifierStart(interpretedChar: number): boolean {
            if (isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierStart(interpretedChar, languageVersion);
        }

        function isIdentifierPart(interpretedChar: number): boolean {
            if (isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierPart(interpretedChar, languageVersion);
        }

        function tryFastScanIdentifierOrKeyword(firstCharacter: number): SyntaxKind {
            var startIndex = index;
            var character: number = 0;

            // Note that we go up to the windowCount-1 so that we can read the character at the end
            // of the window and check if it's *not* an identifier part character.
            while (index < end) {
                character = str.charCodeAt(index);
                if (!isIdentifierPartCharacter[character]) {
                    break;
                }

                index++;
            }

            if (index < end && (character === CharacterCodes.backslash || character > CharacterCodes.maxAsciiCharacter)) {
                // We saw a \ (which could start a unicode escape), or we saw a unicode character.
                // This can't be scanned quickly.  Don't update the window position and just bail out
                // to the slow path.
                index = startIndex;
                return SyntaxKind.None;
            }
            else {
                // Saw an ascii character that wasn't a backslash and wasn't an identifier 
                // character.  Or we hit the end of the file  This identifier is done.

                // Also check if it a keyword if it started with a lowercase letter.
                var kind: SyntaxKind;
                var identifierLength = index - startIndex;
                if (isKeywordStartCharacter[firstCharacter]) {
                    kind = ScannerUtilities.identifierKind(str, startIndex, identifierLength);
                }
                else {
                    kind = SyntaxKind.IdentifierName;
                }

                return kind;
            }
        }

        // A slow path for scanning identifiers.  Called when we run into a unicode character or
        // escape sequence while processing the fast path.
        function slowScanIdentifierOrKeyword(): SyntaxKind {
            var startIndex = index;

            do {
                scanCharOrUnicodeEscape();
            }
            while (isIdentifierPart(peekCharOrUnicodeEscape()));

            // From ES6 specification.
            // The ReservedWord definitions are specified as literal sequences of Unicode 
            // characters.However, any Unicode character in a ReservedWord can also be 
            // expressed by a \ UnicodeEscapeSequence that expresses that same Unicode 
            // character's code point.Use of such escape sequences does not change the meaning 
            // of the ReservedWord.
            //
            // i.e. "\u0076ar" is the keyword 'var'.  Check for that here.
            var length = index - startIndex;
            var text = str.substr(startIndex, length);
            var valueText = massageEscapes(text);

            var keywordKind = SyntaxFacts.getTokenKind(valueText);
            if (keywordKind >= SyntaxKind.FirstKeyword && keywordKind <= SyntaxKind.LastKeyword) {
                return keywordKind;
            }

            return SyntaxKind.IdentifierName;
        }

        function scanNumericLiteral(): SyntaxKind {
            if (isHexNumericLiteral()) {
                scanHexNumericLiteral();
            }
            else if (isOctalNumericLiteral()) {
                scanOctalNumericLiteral();
            }
            else {
                scanDecimalNumericLiteral();
            }

            return SyntaxKind.NumericLiteral;
        }

        function isOctalNumericLiteral(): boolean {
            return str.charCodeAt(index) === CharacterCodes._0 &&
                CharacterInfo.isOctalDigit(str.charCodeAt(index + 1));
        }

        function scanOctalNumericLiteral(): void {
            var position = index

            while (CharacterInfo.isOctalDigit(str.charCodeAt(index))) {
                index++;
            }

            if (languageVersion >= LanguageVersion.EcmaScript5) {
                reportDiagnostic(
                    position, index - position, DiagnosticCode.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher, null);
            }
        }

        function scanDecimalDigits(): void {
            while (CharacterInfo.isDecimalDigit(str.charCodeAt(index))) {
                index++;
            }
        }

        function scanDecimalNumericLiteral(): void {
            scanDecimalDigits();

            if (str.charCodeAt(index) === CharacterCodes.dot) {
                index++;
            }

            scanDecimalDigits();

            // If we see an 'e' or 'E' we should only consume it if its of the form:
            // e<number> or E<number> 
            // e+<number>   E+<number>
            // e-<number>   E-<number>
            var ch = str.charCodeAt(index);
            if (ch === CharacterCodes.e || ch === CharacterCodes.E) {
                // Ok, we've got 'e' or 'E'.  Make sure it's followed correctly.
                var nextChar1 = str.charCodeAt(index + 1);

                if (CharacterInfo.isDecimalDigit(nextChar1)) {
                    // e<number> or E<number>
                    // Consume 'e' or 'E' and the number portion.
                    index++;
                    scanDecimalDigits();
                }
                else if (nextChar1 === CharacterCodes.minus || nextChar1 === CharacterCodes.plus) {
                    // e+ or E+ or e- or E-
                    var nextChar2 = str.charCodeAt(index + 2);
                    if (CharacterInfo.isDecimalDigit(nextChar2)) {
                        // e+<number> or E+<number> or e-<number> or E-<number>
                        // Consume first two characters and the number portion.
                        index += 2;
                        scanDecimalDigits();
                    }
                }
            }
        }

        function scanHexNumericLiteral(): void {
            // Move past the 0x.
            index += 2;

            while (CharacterInfo.isHexDigit(str.charCodeAt(index))) {
                index++;
            }
        }

        function isHexNumericLiteral(): boolean {
            if (str.charCodeAt(index) === CharacterCodes._0) {
                var ch = str.charCodeAt(index + 1);

                if (ch === CharacterCodes.x || ch === CharacterCodes.X) {
                    ch = str.charCodeAt(index + 2);

                    return CharacterInfo.isHexDigit(ch);
                }
            }

            return false;
        }

        function advanceAndSetTokenKind(kind: SyntaxKind): SyntaxKind {
            index++;
            return kind;
        }

        function scanLessThanToken(): SyntaxKind {
            index++;
            var ch0 = str.charCodeAt(index);
            if (ch0 === CharacterCodes.equals) {
                index++;
                return SyntaxKind.LessThanEqualsToken;
            }
            else if (ch0 === CharacterCodes.lessThan) {
                index++;
                if (str.charCodeAt(index) === CharacterCodes.equals) {
                    index++;
                    return SyntaxKind.LessThanLessThanEqualsToken;
                }
                else {
                    return SyntaxKind.LessThanLessThanToken;
                }
            }
            else {
                return SyntaxKind.LessThanToken;
            }
        }

        function scanGreaterThanToken(allowContextualToken: boolean): SyntaxKind {
            index++;
            if (allowContextualToken) {
                var ch0 = str.charCodeAt(index);
                if (ch0 === CharacterCodes.greaterThan) {
                    // >>
                    index++;
                    var ch1 = str.charCodeAt(index);
                    if (ch1 === CharacterCodes.greaterThan) {
                        // >>>
                        index++;
                        var ch2 = str.charCodeAt(index);
                        if (ch2 === CharacterCodes.equals) {
                            // >>>=
                            index++;
                            return SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;
                        }
                        else {
                            return SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
                        }
                    }
                    else if (ch1 === CharacterCodes.equals) {
                        // >>=
                        index++;
                        return SyntaxKind.GreaterThanGreaterThanEqualsToken;
                    }
                    else {
                        return SyntaxKind.GreaterThanGreaterThanToken;
                    }
                }
                else if (ch0 === CharacterCodes.equals) {
                    // >=
                    index++;
                    return SyntaxKind.GreaterThanEqualsToken;
                }
            }

            return SyntaxKind.GreaterThanToken;
        }

        function scanBarToken(): SyntaxKind {
            index++;
            var ch = str.charCodeAt(index);
            if (ch === CharacterCodes.equals) {
                index++;
                return SyntaxKind.BarEqualsToken;
            }
            else if (ch === CharacterCodes.bar) {
                index++;
                return SyntaxKind.BarBarToken;
            }
            else {
                return SyntaxKind.BarToken;
            }
        }

        function scanCaretToken(): SyntaxKind {
            index++;
            if (str.charCodeAt(index) === CharacterCodes.equals) {
                index++;
                return SyntaxKind.CaretEqualsToken;
            }
            else {
                return SyntaxKind.CaretToken;
            }
        }

        function scanAmpersandToken(): SyntaxKind {
            index++;
            var character = str.charCodeAt(index);
            if (character === CharacterCodes.equals) {
                index++;
                return SyntaxKind.AmpersandEqualsToken;
            }
            else if (character === CharacterCodes.ampersand) {
                index++;
                return SyntaxKind.AmpersandAmpersandToken;
            }
            else {
                return SyntaxKind.AmpersandToken;
            }
        }

        function scanPercentToken(): SyntaxKind {
            index++;
            if (str.charCodeAt(index) === CharacterCodes.equals) {
                index++;
                return SyntaxKind.PercentEqualsToken;
            }
            else {
                return SyntaxKind.PercentToken;
            }
        }

        function scanMinusToken(): SyntaxKind {
            index++;
            var character = str.charCodeAt(index);

            if (character === CharacterCodes.equals) {
                index++;
                return SyntaxKind.MinusEqualsToken;
            }
            else if (character === CharacterCodes.minus) {
                index++;
                return SyntaxKind.MinusMinusToken;
            }
            else {
                return SyntaxKind.MinusToken;
            }
        }

        function scanPlusToken(): SyntaxKind {
            index++;
            var character = str.charCodeAt(index);
            if (character === CharacterCodes.equals) {
                index++;
                return SyntaxKind.PlusEqualsToken;
            }
            else if (character === CharacterCodes.plus) {
                index++;
                return SyntaxKind.PlusPlusToken;
            }
            else {
                return SyntaxKind.PlusToken;
            }
        }

        function scanAsteriskToken(): SyntaxKind {
            index++;
            if (str.charCodeAt(index) === CharacterCodes.equals) {
                index++;
                return SyntaxKind.AsteriskEqualsToken;
            }
            else {
                return SyntaxKind.AsteriskToken;
            }
        }

        function scanEqualsToken(): SyntaxKind {
            index++;
            var character = str.charCodeAt(index);
            if (character === CharacterCodes.equals) {
                index++;

                if (str.charCodeAt(index) === CharacterCodes.equals) {
                    index++;

                    return SyntaxKind.EqualsEqualsEqualsToken;
                }
                else {
                    return SyntaxKind.EqualsEqualsToken;
                }
            }
            else if (character === CharacterCodes.greaterThan) {
                index++;
                return SyntaxKind.EqualsGreaterThanToken;
            }
            else {
                return SyntaxKind.EqualsToken;
            }
        }

        function isDotPrefixedNumericLiteral(): boolean {
            if (str.charCodeAt(index) === CharacterCodes.dot) {
                var ch = str.charCodeAt(index + 1);
                return CharacterInfo.isDecimalDigit(ch);
            }

            return false;
        }

        function scanDotToken(): SyntaxKind {
            if (isDotPrefixedNumericLiteral()) {
                return scanNumericLiteral();
            }

            index++;
            if (str.charCodeAt(index) === CharacterCodes.dot &&
                str.charCodeAt(index + 1) === CharacterCodes.dot) {

                index += 2;
                return SyntaxKind.DotDotDotToken;
            }
            else {
                return SyntaxKind.DotToken;
            }
        }

        function scanSlashToken(allowContextualToken: boolean): SyntaxKind {
            // NOTE: By default, we do not try scanning a / as a regexp here.  We instead consider it a
            // div or div-assign.  Later on, if the parser runs into a situation where it would like a 
            // term, and it sees one of these then it may restart us asking specifically if we could 
            // scan out a regex.
            if (allowContextualToken) {
                var result = tryScanRegularExpressionToken();
                if (result !== SyntaxKind.None) {
                    return result;
                }
            }

            index++;
            if (str.charCodeAt(index) === CharacterCodes.equals) {
                index++;
                return SyntaxKind.SlashEqualsToken;
            }
            else {
                return SyntaxKind.SlashToken;
            }
        }

        function tryScanRegularExpressionToken(): SyntaxKind {
            var startIndex = index;

            index++;

            var inEscape = false;
            var inCharacterClass = false;
            while (true) {
                var ch = str.charCodeAt(index);

                if (isNaN(ch) || isNewLineCharacter(ch)) {
                    index = startIndex;
                    return SyntaxKind.None;
                }

                index++;
                if (inEscape) {
                    inEscape = false;
                    continue;
                }

                switch (ch) {
                    case CharacterCodes.backslash:
                        // We're now in an escape.  Consume the next character we see (unless it's
                        // a newline or null.
                        inEscape = true;
                        continue;

                    case CharacterCodes.openBracket:
                        // If we see a [ then we're starting an character class.  Note: it's ok if 
                        // we then hit another [ inside a character class.  We'll just set the value
                        // to true again and that's ok.
                        inCharacterClass = true;
                        continue;

                    case CharacterCodes.closeBracket:
                        // If we ever hit a cloe bracket then we're now no longer in a character 
                        // class.  If we weren't in a character class to begin with, then this has 
                        // no effect.
                        inCharacterClass = false;
                        continue;

                    case CharacterCodes.slash:
                        // If we see a slash, and we're in a character class, then ignore it.
                        if (inCharacterClass) {
                            continue;
                        }

                        // We're done with the regex.  Break out of the switch (which will break 
                        // out of hte loop.
                        break;

                    default:
                        // Just consume any other characters.
                        continue;
                }

                break;
            }

            // TODO: The grammar says any identifier part is allowed here.  Do we need to support
            // \u identifiers here?  The existing typescript parser does not.  
            while (isIdentifierPartCharacter[str.charCodeAt(index)]) {
                index++;
            }

            return SyntaxKind.RegularExpressionLiteral;
        }

        function scanExclamationToken(): SyntaxKind {
            index++;
            if (str.charCodeAt(index) === CharacterCodes.equals) {
                index++;

                if (str.charCodeAt(index) === CharacterCodes.equals) {
                    index++;

                    return SyntaxKind.ExclamationEqualsEqualsToken;
                }
                else {
                    return SyntaxKind.ExclamationEqualsToken;
                }
            }
            else {
                return SyntaxKind.ExclamationToken;
            }
        }

        function scanDefaultCharacter(character: number): SyntaxKind {
            var position = index;
            index++;

            var text = String.fromCharCode(character);
            var messageText = getErrorMessageText(text);
            reportDiagnostic(position, 1, DiagnosticCode.Unexpected_character_0, [messageText]);

            return SyntaxKind.ErrorToken;
        }

        // Convert text into a printable form usable for an error message.  This will both quote the 
        // string, and ensure all characters printable (i.e. by using unicode escapes when they're not).
        function getErrorMessageText(text: string): string {
            // For just a simple backslash, we return it as is.  The default behavior of JSON.stringify
            // is not what we want here.
            if (text === "\\") {
                return '"\\"';
            }

            return JSON.stringify(text);
        }

        function skipEscapeSequence(): void {
            var rewindPoint = index;

            // Consume the backslash.
            index++;

            // Get the char after the backslash
            var ch = str.charCodeAt(index);
            if (isNaN(ch)) {
                // if we're at teh end of the file, just return, the string scanning code will 
                // report an appropriate error.
                return;
            }

            index++;
            switch (ch) {
                case CharacterCodes.x:
                case CharacterCodes.u:
                    index = rewindPoint;
                    var value = scanUnicodeOrHexEscape(/*report:*/ true);
                    break;

                case CharacterCodes.carriageReturn:
                    // If it's \r\n then consume both characters.
                    if (str.charCodeAt(index) === CharacterCodes.lineFeed) {
                        index++;
                    }
                    break;

                // We don't have to do anything special about these characters.  I'm including them
                // Just so it's clear that we intentially process them in the exact same way:
                //case CharacterCodes.singleQuote:
                //case CharacterCodes.doubleQuote:
                //case CharacterCodes.backslash:
                //case CharacterCodes._0:
                //case CharacterCodes.b:
                //case CharacterCodes.f:
                //case CharacterCodes.n:
                //case CharacterCodes.r:
                //case CharacterCodes.t:
                //case CharacterCodes.v:
                //case CharacterCodes.lineFeed:
                //case CharacterCodes.paragraphSeparator:
                //case CharacterCodes.lineSeparator:
                default:
                    // Any other character is ok as well.  As per rule:
                    // EscapeSequence :: CharacterEscapeSequence
                    // CharacterEscapeSequence :: NonEscapeCharacter
                    // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
                    break;
            }
        }

        function scanStringLiteral(): SyntaxKind {
            var quoteCharacter = str.charCodeAt(index);

            // Debug.assert(quoteCharacter === CharacterCodes.singleQuote || quoteCharacter === CharacterCodes.doubleQuote);

            index++;

            while (true) {
                var ch = str.charCodeAt(index);
                if (ch === CharacterCodes.backslash) {
                    skipEscapeSequence();
                }
                else if (ch === quoteCharacter) {
                    index++;
                    break;
                }
                else if (isNaN(ch) || isNewLineCharacter(ch)) {
                    reportDiagnostic(MathPrototype.min(index, end), 1, DiagnosticCode.Missing_close_quote_character, null);
                    break;
                }
                else {
                    index++;
                }
            }

            return SyntaxKind.StringLiteral;
        }

        function isUnicodeEscape(character: number): boolean {
            return character === CharacterCodes.backslash &&
                str.charCodeAt(index + 1) === CharacterCodes.u;
        }

        function peekCharOrUnicodeEscape(): number {
            var character = str.charCodeAt(index);
            if (isUnicodeEscape(character)) {
                return peekUnicodeOrHexEscape();
            }
            else {
                return character;
            }
        }

        function peekUnicodeOrHexEscape(): number {
            var startIndex = index;

            // if we're peeking, then we don't want to change the position
            var ch = scanUnicodeOrHexEscape(/*report:*/ false);

            index = startIndex;

            return ch;
        }

        // Returns true if this was a unicode escape.
        function scanCharOrUnicodeEscape(): void {
            if (str.charCodeAt(index) === CharacterCodes.backslash &&
                str.charCodeAt(index + 1) === CharacterCodes.u) {

                scanUnicodeOrHexEscape(/*report:*/ true);
            }
            else {
                index++;
            }
        }

        function scanUnicodeOrHexEscape(report: boolean): number {
            var start = index;
            var character = str.charCodeAt(index);
            // Debug.assert(character === CharacterCodes.backslash);
            index++;

            character = str.charCodeAt(index);
            // Debug.assert(character === CharacterCodes.u || character === CharacterCodes.x);

            var intChar = 0;
            index++;

            var count = character === CharacterCodes.u ? 4 : 2;

            for (var i = 0; i < count; i++) {
                var ch2 = str.charCodeAt(index);
                if (!CharacterInfo.isHexDigit(ch2)) {
                    if (report) {
                        reportDiagnostic(start, index - start, DiagnosticCode.Unrecognized_escape_sequence, null)
                    }

                    break;
                }

                intChar = (intChar << 4) + CharacterInfo.hexValue(ch2);
                index++;
            }

            return intChar;
        }

        function fillTokenInfo(token: ISyntaxToken, text: ISimpleText, tokenInfo: TokenInfo): void {
            var fullStart = token.fullStart();
            var fullEnd = fullStart + token.fullWidth();
            reset(text, fullStart, fullEnd);

            var leadingTriviaInfo = scanTriviaInfo(/*isTrailing: */ false);

            var start = index;
            scanSyntaxKind(isContextualToken(token));
            var end = index;

            tokenInfo.leadingTriviaWidth = start - fullStart;
            tokenInfo.width = end - start;
        }

        reset(text, 0, text.length());

        return {
            setIndex: setIndex,
            scan: scan,
            fillTokenInfo: fillTokenInfo,
            scanTrivia: scanTrivia,
        };
    }

    export function isValidIdentifier(text: ISimpleText, languageVersion: LanguageVersion): boolean {
        var hadError = false;
        var scanner = createScanner(languageVersion, text, () => hadError = true);

        var token = scanner.scan(/*allowContextualToken:*/ false);

        return !hadError && SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && width(token) === text.length();
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class ScannerUtilities {
        public static identifierKind(array: string, startIndex: number, length: number): SyntaxKind {
            switch (length) {
            case 2:
                // do, if, in
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.d:
                    // do
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o) ? SyntaxKind.DoKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.i:
                    // if, in
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.f:
                        // if
                        return SyntaxKind.IfKeyword;
                    case CharacterCodes.n:
                        // in
                        return SyntaxKind.InKeyword;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case 3:
                // for, new, try, var, let, any, get, set
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.f:
                    // for
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.r) ? SyntaxKind.ForKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.n:
                    // new
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.w) ? SyntaxKind.NewKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.t:
                    // try
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.r && array.charCodeAt(startIndex + 2) === CharacterCodes.y) ? SyntaxKind.TryKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.v:
                    // var
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.a && array.charCodeAt(startIndex + 2) === CharacterCodes.r) ? SyntaxKind.VarKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.l:
                    // let
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.t) ? SyntaxKind.LetKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.a:
                    // any
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.n && array.charCodeAt(startIndex + 2) === CharacterCodes.y) ? SyntaxKind.AnyKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.g:
                    // get
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.t) ? SyntaxKind.GetKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.s:
                    // set
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.t) ? SyntaxKind.SetKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 4:
                // case, else, null, this, true, void, with, enum
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.c:
                    // case
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.a && array.charCodeAt(startIndex + 2) === CharacterCodes.s && array.charCodeAt(startIndex + 3) === CharacterCodes.e) ? SyntaxKind.CaseKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.e:
                    // else, enum
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.l:
                        // else
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.s && array.charCodeAt(startIndex + 3) === CharacterCodes.e) ? SyntaxKind.ElseKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.n:
                        // enum
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.u && array.charCodeAt(startIndex + 3) === CharacterCodes.m) ? SyntaxKind.EnumKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.n:
                    // null
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.u && array.charCodeAt(startIndex + 2) === CharacterCodes.l && array.charCodeAt(startIndex + 3) === CharacterCodes.l) ? SyntaxKind.NullKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.t:
                    // this, true
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.h:
                        // this
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.i && array.charCodeAt(startIndex + 3) === CharacterCodes.s) ? SyntaxKind.ThisKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.r:
                        // true
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.u && array.charCodeAt(startIndex + 3) === CharacterCodes.e) ? SyntaxKind.TrueKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.v:
                    // void
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.i && array.charCodeAt(startIndex + 3) === CharacterCodes.d) ? SyntaxKind.VoidKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.w:
                    // with
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.i && array.charCodeAt(startIndex + 2) === CharacterCodes.t && array.charCodeAt(startIndex + 3) === CharacterCodes.h) ? SyntaxKind.WithKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 5:
                // break, catch, false, throw, while, class, const, super, yield
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.b:
                    // break
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.r && array.charCodeAt(startIndex + 2) === CharacterCodes.e && array.charCodeAt(startIndex + 3) === CharacterCodes.a && array.charCodeAt(startIndex + 4) === CharacterCodes.k) ? SyntaxKind.BreakKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.c:
                    // catch, class, const
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.a:
                        // catch
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.t && array.charCodeAt(startIndex + 3) === CharacterCodes.c && array.charCodeAt(startIndex + 4) === CharacterCodes.h) ? SyntaxKind.CatchKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.l:
                        // class
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.a && array.charCodeAt(startIndex + 3) === CharacterCodes.s && array.charCodeAt(startIndex + 4) === CharacterCodes.s) ? SyntaxKind.ClassKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.o:
                        // const
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.n && array.charCodeAt(startIndex + 3) === CharacterCodes.s && array.charCodeAt(startIndex + 4) === CharacterCodes.t) ? SyntaxKind.ConstKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.f:
                    // false
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.a && array.charCodeAt(startIndex + 2) === CharacterCodes.l && array.charCodeAt(startIndex + 3) === CharacterCodes.s && array.charCodeAt(startIndex + 4) === CharacterCodes.e) ? SyntaxKind.FalseKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.t:
                    // throw
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.h && array.charCodeAt(startIndex + 2) === CharacterCodes.r && array.charCodeAt(startIndex + 3) === CharacterCodes.o && array.charCodeAt(startIndex + 4) === CharacterCodes.w) ? SyntaxKind.ThrowKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.w:
                    // while
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.h && array.charCodeAt(startIndex + 2) === CharacterCodes.i && array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.e) ? SyntaxKind.WhileKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.s:
                    // super
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.u && array.charCodeAt(startIndex + 2) === CharacterCodes.p && array.charCodeAt(startIndex + 3) === CharacterCodes.e && array.charCodeAt(startIndex + 4) === CharacterCodes.r) ? SyntaxKind.SuperKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.y:
                    // yield
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.i && array.charCodeAt(startIndex + 2) === CharacterCodes.e && array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.d) ? SyntaxKind.YieldKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 6:
                // delete, return, switch, typeof, export, import, public, static, module, number, string
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.d:
                    // delete
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.l && array.charCodeAt(startIndex + 3) === CharacterCodes.e && array.charCodeAt(startIndex + 4) === CharacterCodes.t && array.charCodeAt(startIndex + 5) === CharacterCodes.e) ? SyntaxKind.DeleteKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // return
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.t && array.charCodeAt(startIndex + 3) === CharacterCodes.u && array.charCodeAt(startIndex + 4) === CharacterCodes.r && array.charCodeAt(startIndex + 5) === CharacterCodes.n) ? SyntaxKind.ReturnKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.s:
                    // switch, static, string
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.w:
                        // switch
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.i && array.charCodeAt(startIndex + 3) === CharacterCodes.t && array.charCodeAt(startIndex + 4) === CharacterCodes.c && array.charCodeAt(startIndex + 5) === CharacterCodes.h) ? SyntaxKind.SwitchKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.t:
                        // static, string
                        switch(array.charCodeAt(startIndex + 2)) {
                        case CharacterCodes.a:
                            // static
                            return (array.charCodeAt(startIndex + 3) === CharacterCodes.t && array.charCodeAt(startIndex + 4) === CharacterCodes.i && array.charCodeAt(startIndex + 5) === CharacterCodes.c) ? SyntaxKind.StaticKeyword : SyntaxKind.IdentifierName;
                        case CharacterCodes.r:
                            // string
                            return (array.charCodeAt(startIndex + 3) === CharacterCodes.i && array.charCodeAt(startIndex + 4) === CharacterCodes.n && array.charCodeAt(startIndex + 5) === CharacterCodes.g) ? SyntaxKind.StringKeyword : SyntaxKind.IdentifierName;
                        default:
                            return SyntaxKind.IdentifierName;
                        }

                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.t:
                    // typeof
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.y && array.charCodeAt(startIndex + 2) === CharacterCodes.p && array.charCodeAt(startIndex + 3) === CharacterCodes.e && array.charCodeAt(startIndex + 4) === CharacterCodes.o && array.charCodeAt(startIndex + 5) === CharacterCodes.f) ? SyntaxKind.TypeOfKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.e:
                    // export
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.x && array.charCodeAt(startIndex + 2) === CharacterCodes.p && array.charCodeAt(startIndex + 3) === CharacterCodes.o && array.charCodeAt(startIndex + 4) === CharacterCodes.r && array.charCodeAt(startIndex + 5) === CharacterCodes.t) ? SyntaxKind.ExportKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.i:
                    // import
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.m && array.charCodeAt(startIndex + 2) === CharacterCodes.p && array.charCodeAt(startIndex + 3) === CharacterCodes.o && array.charCodeAt(startIndex + 4) === CharacterCodes.r && array.charCodeAt(startIndex + 5) === CharacterCodes.t) ? SyntaxKind.ImportKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.p:
                    // public
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.u && array.charCodeAt(startIndex + 2) === CharacterCodes.b && array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.i && array.charCodeAt(startIndex + 5) === CharacterCodes.c) ? SyntaxKind.PublicKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.m:
                    // module
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.d && array.charCodeAt(startIndex + 3) === CharacterCodes.u && array.charCodeAt(startIndex + 4) === CharacterCodes.l && array.charCodeAt(startIndex + 5) === CharacterCodes.e) ? SyntaxKind.ModuleKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.n:
                    // number
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.u && array.charCodeAt(startIndex + 2) === CharacterCodes.m && array.charCodeAt(startIndex + 3) === CharacterCodes.b && array.charCodeAt(startIndex + 4) === CharacterCodes.e && array.charCodeAt(startIndex + 5) === CharacterCodes.r) ? SyntaxKind.NumberKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 7:
                // default, finally, extends, package, private, boolean, declare, require
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.d:
                    // default, declare
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.e:
                        // default, declare
                        switch(array.charCodeAt(startIndex + 2)) {
                        case CharacterCodes.f:
                            // default
                            return (array.charCodeAt(startIndex + 3) === CharacterCodes.a && array.charCodeAt(startIndex + 4) === CharacterCodes.u && array.charCodeAt(startIndex + 5) === CharacterCodes.l && array.charCodeAt(startIndex + 6) === CharacterCodes.t) ? SyntaxKind.DefaultKeyword : SyntaxKind.IdentifierName;
                        case CharacterCodes.c:
                            // declare
                            return (array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.a && array.charCodeAt(startIndex + 5) === CharacterCodes.r && array.charCodeAt(startIndex + 6) === CharacterCodes.e) ? SyntaxKind.DeclareKeyword : SyntaxKind.IdentifierName;
                        default:
                            return SyntaxKind.IdentifierName;
                        }

                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.f:
                    // finally
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.i && array.charCodeAt(startIndex + 2) === CharacterCodes.n && array.charCodeAt(startIndex + 3) === CharacterCodes.a && array.charCodeAt(startIndex + 4) === CharacterCodes.l && array.charCodeAt(startIndex + 5) === CharacterCodes.l && array.charCodeAt(startIndex + 6) === CharacterCodes.y) ? SyntaxKind.FinallyKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.e:
                    // extends
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.x && array.charCodeAt(startIndex + 2) === CharacterCodes.t && array.charCodeAt(startIndex + 3) === CharacterCodes.e && array.charCodeAt(startIndex + 4) === CharacterCodes.n && array.charCodeAt(startIndex + 5) === CharacterCodes.d && array.charCodeAt(startIndex + 6) === CharacterCodes.s) ? SyntaxKind.ExtendsKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.p:
                    // package, private
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.a:
                        // package
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.c && array.charCodeAt(startIndex + 3) === CharacterCodes.k && array.charCodeAt(startIndex + 4) === CharacterCodes.a && array.charCodeAt(startIndex + 5) === CharacterCodes.g && array.charCodeAt(startIndex + 6) === CharacterCodes.e) ? SyntaxKind.PackageKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.r:
                        // private
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.i && array.charCodeAt(startIndex + 3) === CharacterCodes.v && array.charCodeAt(startIndex + 4) === CharacterCodes.a && array.charCodeAt(startIndex + 5) === CharacterCodes.t && array.charCodeAt(startIndex + 6) === CharacterCodes.e) ? SyntaxKind.PrivateKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                case CharacterCodes.b:
                    // boolean
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.o && array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.e && array.charCodeAt(startIndex + 5) === CharacterCodes.a && array.charCodeAt(startIndex + 6) === CharacterCodes.n) ? SyntaxKind.BooleanKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // require
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.q && array.charCodeAt(startIndex + 3) === CharacterCodes.u && array.charCodeAt(startIndex + 4) === CharacterCodes.i && array.charCodeAt(startIndex + 5) === CharacterCodes.r && array.charCodeAt(startIndex + 6) === CharacterCodes.e) ? SyntaxKind.RequireKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 8:
                // continue, debugger, function
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.c:
                    // continue
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.n && array.charCodeAt(startIndex + 3) === CharacterCodes.t && array.charCodeAt(startIndex + 4) === CharacterCodes.i && array.charCodeAt(startIndex + 5) === CharacterCodes.n && array.charCodeAt(startIndex + 6) === CharacterCodes.u && array.charCodeAt(startIndex + 7) === CharacterCodes.e) ? SyntaxKind.ContinueKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.d:
                    // debugger
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.e && array.charCodeAt(startIndex + 2) === CharacterCodes.b && array.charCodeAt(startIndex + 3) === CharacterCodes.u && array.charCodeAt(startIndex + 4) === CharacterCodes.g && array.charCodeAt(startIndex + 5) === CharacterCodes.g && array.charCodeAt(startIndex + 6) === CharacterCodes.e && array.charCodeAt(startIndex + 7) === CharacterCodes.r) ? SyntaxKind.DebuggerKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.f:
                    // function
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.u && array.charCodeAt(startIndex + 2) === CharacterCodes.n && array.charCodeAt(startIndex + 3) === CharacterCodes.c && array.charCodeAt(startIndex + 4) === CharacterCodes.t && array.charCodeAt(startIndex + 5) === CharacterCodes.i && array.charCodeAt(startIndex + 6) === CharacterCodes.o && array.charCodeAt(startIndex + 7) === CharacterCodes.n) ? SyntaxKind.FunctionKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 9:
                // interface, protected
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.i:
                    // interface
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.n && array.charCodeAt(startIndex + 2) === CharacterCodes.t && array.charCodeAt(startIndex + 3) === CharacterCodes.e && array.charCodeAt(startIndex + 4) === CharacterCodes.r && array.charCodeAt(startIndex + 5) === CharacterCodes.f && array.charCodeAt(startIndex + 6) === CharacterCodes.a && array.charCodeAt(startIndex + 7) === CharacterCodes.c && array.charCodeAt(startIndex + 8) === CharacterCodes.e) ? SyntaxKind.InterfaceKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.p:
                    // protected
                    return (array.charCodeAt(startIndex + 1) === CharacterCodes.r && array.charCodeAt(startIndex + 2) === CharacterCodes.o && array.charCodeAt(startIndex + 3) === CharacterCodes.t && array.charCodeAt(startIndex + 4) === CharacterCodes.e && array.charCodeAt(startIndex + 5) === CharacterCodes.c && array.charCodeAt(startIndex + 6) === CharacterCodes.t && array.charCodeAt(startIndex + 7) === CharacterCodes.e && array.charCodeAt(startIndex + 8) === CharacterCodes.d) ? SyntaxKind.ProtectedKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case 10:
                // instanceof, implements
                switch(array.charCodeAt(startIndex)) {
                case CharacterCodes.i:
                    // instanceof, implements
                    switch(array.charCodeAt(startIndex + 1)) {
                    case CharacterCodes.n:
                        // instanceof
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.s && array.charCodeAt(startIndex + 3) === CharacterCodes.t && array.charCodeAt(startIndex + 4) === CharacterCodes.a && array.charCodeAt(startIndex + 5) === CharacterCodes.n && array.charCodeAt(startIndex + 6) === CharacterCodes.c && array.charCodeAt(startIndex + 7) === CharacterCodes.e && array.charCodeAt(startIndex + 8) === CharacterCodes.o && array.charCodeAt(startIndex + 9) === CharacterCodes.f) ? SyntaxKind.InstanceOfKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.m:
                        // implements
                        return (array.charCodeAt(startIndex + 2) === CharacterCodes.p && array.charCodeAt(startIndex + 3) === CharacterCodes.l && array.charCodeAt(startIndex + 4) === CharacterCodes.e && array.charCodeAt(startIndex + 5) === CharacterCodes.m && array.charCodeAt(startIndex + 6) === CharacterCodes.e && array.charCodeAt(startIndex + 7) === CharacterCodes.n && array.charCodeAt(startIndex + 8) === CharacterCodes.t && array.charCodeAt(startIndex + 9) === CharacterCodes.s) ? SyntaxKind.ImplementsKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case 11:
                // constructor
                return (array.charCodeAt(startIndex) === CharacterCodes.c && array.charCodeAt(startIndex + 1) === CharacterCodes.o && array.charCodeAt(startIndex + 2) === CharacterCodes.n && array.charCodeAt(startIndex + 3) === CharacterCodes.s && array.charCodeAt(startIndex + 4) === CharacterCodes.t && array.charCodeAt(startIndex + 5) === CharacterCodes.r && array.charCodeAt(startIndex + 6) === CharacterCodes.u && array.charCodeAt(startIndex + 7) === CharacterCodes.c && array.charCodeAt(startIndex + 8) === CharacterCodes.t && array.charCodeAt(startIndex + 9) === CharacterCodes.o && array.charCodeAt(startIndex + 10) === CharacterCodes.r) ? SyntaxKind.ConstructorKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISlidingWindowSource {
        // Asks the source to copy items starting at sourceIndex into the window at 'destinationIndex'
        // with up to 'spaceAvailable' items.  The actual number of items fetched should be given as 
        // the return value.
        fetchNextItem(argument: any): any;
    }

    export class SlidingWindow {

        // The number of valid items in window.
        public windowCount: number = 0;

        // The *absolute* index in the *full* array of items the *window* array starts at.  i.e.
        // if there were 100 items, and window contains tokens [70, 80), then this value would be
        // 70.
        public windowAbsoluteStartIndex: number = 0;

        // The index in the window array that we're at. i.e. if there 100 items and 
        // window contains tokens [70, 80), and we're on item 75, then this value would be '5'.
        // Note: it is not absolute.  It is relative to the start of the window.
        public currentRelativeItemIndex: number = 0;

        // The number of pinned points there are.  As long as there is at least one  pinned point, we 
        // will not advance the start of the window array past the item marked by that pin point.
        private _pinCount: number = 0;

        // If there are any outstanding rewind points, this is index in the full array of items
        // that the first rewind point points to.  If this is not -1, then we will not shift the
        // start of the items array past this point.
        private firstPinnedAbsoluteIndex: number = -1;

        constructor(// Underlying source that we retrieve items from.
                    private source: ISlidingWindowSource,
                    // A window of items that has been read in from the underlying source.
                    public window: any[],
                    // The default value to return when there are no more items left in the window.
                    private defaultValue: any,
                    // The length of the source we're reading from if we know it up front.  -1 if we do not.
                    private sourceLength = -1) {
        }

        // The last legal index of the window (exclusive).
        private windowAbsoluteEndIndex(): number {
            return this.windowAbsoluteStartIndex + this.windowCount;
        }

        private addMoreItemsToWindow(argument: any): boolean {
            var sourceLength = this.sourceLength;
            if (sourceLength >= 0 && this.absoluteIndex() >= sourceLength) {
                return false;
            }

            // First, make room for the new items if we're out of room.
            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var item = this.source.fetchNextItem(argument);

            this.window[this.windowCount] = item;

            // Assert disabled because it is actually expensive enugh to affect perf.

            this.windowCount++;
            return true;
        }

        private tryShiftOrGrowWindow(): void {
            // We want to shift if our current item is past the halfway point of the current item window.
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            // However, we can only shift if we have no outstanding rewind points.  Or, if we have an 
            // outstanding rewind point, that it points to some point after the start of the window.
            var isAllowedToShift =
                this.firstPinnedAbsoluteIndex === -1 ||
                this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                // Figure out where we're going to start shifting from. If we have no oustanding rewind 
                // points, then we'll start shifting over all the items starting from the current 
                // token we're point out.  Otherwise, we'll shift starting from the first item that 
                // the rewind point is pointing at.
                // 
                // We'll call that point 'N' from now on. 
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1
                    ? this.currentRelativeItemIndex
                    : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                // We have to shift the number of elements between the start index and the number of 
                // items in the window.
                var shiftCount = this.windowCount - shiftStartIndex;

                // Debug.assert(shiftStartIndex > 0);
                if (shiftCount > 0) {
                    ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                // The window has now moved over to the right by N.
                this.windowAbsoluteStartIndex += shiftStartIndex;

                // The number of valid items in the window has now decreased by N.
                this.windowCount -= shiftStartIndex;

                // The current item now starts further to the left in the window.
                this.currentRelativeItemIndex -= shiftStartIndex;
            }
            else {
                // Grow the exisitng array.
                // this.window[this.window.length * 2 - 1] = this.defaultValue;
                ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        }

        public absoluteIndex(): number {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        }

        public isAtEndOfSource(): boolean {
            return this.absoluteIndex() >= this.sourceLength;
        }

        public getAndPinAbsoluteIndex(): number {
            // Find the absolute index of this pin point.  i.e. it's the index as if we had an 
            // array containing *all* tokens.  
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                // If this is the first pinned point, then store off this index.  We will ensure that
                // we never shift the window past this point.
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        }

        public releaseAndUnpinAbsoluteIndex(absoluteIndex: number) {
            this._pinCount--;
            if (this._pinCount === 0) {
                // If we just released the last outstanding pin, then we no longer need to 'fix' the 
                // token window so it can't move forward.  Set the index to -1 so that we can shift 
                // things over the next time we read past the end of the array.
                this.firstPinnedAbsoluteIndex = -1;
            }
        }

        public rewindToPinnedIndex(absoluteIndex: number): void {
            // The rewind point shows which absolute item we want to rewind to.  Get the relative 
            // index in the actual array that we want to point to.
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            // Make sure we haven't screwed anything up.
            // Debug.assert(relativeIndex >= 0 && relativeIndex < this.windowCount);

            // Set ourselves back to that point.
            this.currentRelativeItemIndex = relativeIndex;
        }

        public currentItem(argument: any): any {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        }

        public peekItemN(n: number): any {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(n >= 0);
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(/*argument:*/ null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        }

        public moveToNextItem(): void {
            this.currentRelativeItemIndex++;
        }

        public disgardAllItemsFromCurrentIndexOnwards(): void {
            // By setting the window count to the current relative offset, we are effectively making
            // any items we added to the window from the current offset onwards unusable.  When we
            // try to get the next item, we'll be forced to refetch them from the underlying source.
            this.windowCount = this.currentRelativeItemIndex;
        }

        public setAbsoluteIndex(absoluteIndex: number): void {
            if (this.absoluteIndex() === absoluteIndex) {
                // Nothing to do if we're setting hte absolute index to where we current are.
                return;
            }

            if (this._pinCount > 0) {
                // If we have any active pins, then the caller better be setting the index somewhere
                // inside our active window.
                // Debug.assert(absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex());
            }

            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                // The caller is setting the index to some place inside our current window.  This is 
                // easy to handle (and should be the common case).
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            }
            else {
                // The caller is setting the index to a place not in the window.  Just throw away 
                // everything we've got.

                // First, set the window start to that index.
                this.windowAbsoluteStartIndex = absoluteIndex;

                // Now, set the count to 0.  So we'll be forced to fetch more items.
                this.windowCount = 0;

                // And set us back to the start of the window.
                this.currentRelativeItemIndex = 0;
            }
        }

        public pinCount(): number {
            return this._pinCount;
        }
    }
}
///<reference path='references.ts' />

module TypeScript.Syntax {
    export var _nextSyntaxID: number = 1;

    export function getStandaloneExpression(positionedToken: ISyntaxToken): ISyntaxNodeOrToken {
        var token = positionedToken;
        if (positionedToken !== null && positionedToken.kind() === SyntaxKind.IdentifierName) {
            var parentPositionedNode = containingNode(positionedToken);
            var parentNode = containingNode(parentPositionedNode);

            if (parentNode.kind() === SyntaxKind.QualifiedName && (<QualifiedNameSyntax>parentNode).right === token) {
                return parentPositionedNode;
            }
            else if (parentNode.kind() === SyntaxKind.MemberAccessExpression && (<MemberAccessExpressionSyntax>parentNode).name === token) {
                return parentPositionedNode;
            }
        }

        return positionedToken;
    }

    export function isInModuleOrTypeContext(positionedToken: ISyntaxToken): boolean {
        if (positionedToken !== null) {
            var positionedNodeOrToken = getStandaloneExpression(positionedToken);
            var parent = containingNode(positionedNodeOrToken);

            if (parent !== null) {
                switch (parent.kind()) {
                    case SyntaxKind.ModuleNameModuleReference:
                        return true;
                    case SyntaxKind.QualifiedName:
                        // left of QN is namespace or type.  Note: when you have "a.b.c()", then
                        // "a.b" is not a qualified name, it is a member access expression.
                        // Qualified names are only parsed when the parser knows it's a type only
                        // context.
                        return true;
                    default:
                        return isInTypeOnlyContext(positionedToken);
                }
            }
        }

        return false;
    }

    export function isInTypeOnlyContext(positionedToken: ISyntaxToken): boolean {
        var positionedNodeOrToken = getStandaloneExpression(positionedToken);
        var positionedParent = containingNode(positionedNodeOrToken);

        var parent = containingNode(positionedParent);
        var nodeOrToken = positionedNodeOrToken;

        if (parent !== null) {
            switch (parent.kind()) {
                case SyntaxKind.ArrayType:
                    return (<ArrayTypeSyntax>parent).type === nodeOrToken;
                case SyntaxKind.CastExpression:
                    return (<CastExpressionSyntax>parent).type === nodeOrToken;
                case SyntaxKind.TypeAnnotation:
                case SyntaxKind.ExtendsHeritageClause:
                case SyntaxKind.ImplementsHeritageClause:
                case SyntaxKind.TypeArgumentList:
                    return true;
                // TODO: add more cases if necessary.  This list may not be complete.
            }
        }

        return false;
    }

    export function childOffset(parent: ISyntaxElement, child: ISyntaxElement) {
        var offset = 0;
        for (var i = 0, n = childCount(parent); i < n; i++) {
            var current = childAt(parent, i);
            if (current === child) {
                return offset;
            }

            if (current !== null) {
                offset += fullWidth(current);
            }
        }

        throw Errors.invalidOperation();
    }

    export function childOffsetAt(parent: ISyntaxElement, index: number) {
        var offset = 0;
        for (var i = 0; i < index; i++) {
            var current = childAt(parent, i);
            if (current !== null) {
                offset += fullWidth(current);
            }
        }

        return offset;
    }

    export function childIndex(parent: ISyntaxElement, child: ISyntaxElement) {
        for (var i = 0, n = childCount(parent); i < n; i++) {
            var current = childAt(parent, i);
            if (current === child) {
                return i;
            }
        }

        throw Errors.invalidOperation();
    }

    export function identifierName(text: string, info: ITokenInfo = null): ISyntaxToken {
        return identifier(text);
    }

    export function trueExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.TrueKeyword);
    }

    export function falseExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.FalseKeyword);
    }

    export function numericLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.NumericLiteral, { text: text });
    }

    export function stringLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.StringLiteral, { text: text });
    }

    export function isSuperInvocationExpression(node: IExpressionSyntax): boolean {
        return node.kind() === SyntaxKind.InvocationExpression &&
            (<InvocationExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperInvocationExpressionStatement(node: ISyntaxNode): boolean {
        return node.kind() === SyntaxKind.ExpressionStatement &&
            isSuperInvocationExpression((<ExpressionStatementSyntax>node).expression);
    }

    export function isSuperMemberAccessExpression(node: IExpressionSyntax): boolean {
        return node.kind() === SyntaxKind.MemberAccessExpression &&
            (<MemberAccessExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperMemberAccessInvocationExpression(node: ISyntaxNode): boolean {
        return node.kind() === SyntaxKind.InvocationExpression &&
            isSuperMemberAccessExpression((<InvocationExpressionSyntax>node).expression);
    }

    //export function assignmentExpression(left: IExpressionSyntax, token: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
    //    return new BinaryExpressionSyntax(SyntaxKind.AssignmentExpression, left, token, right);
    //}

    export function nodeHasSkippedOrMissingTokens(node: ISyntaxNode): boolean {
        for (var i = 0; i < childCount(node); i++) {
            var child = childAt(node, i);
            if (isToken(child)) {
                var token = <ISyntaxToken>child;
                // If a token is skipped, return true. Or if it is a missing token. The only empty token that is not missing is EOF
                if (token.hasSkippedToken() || (width(token) === 0 && token.kind() !== SyntaxKind.EndOfFileToken)) {
                    return true;
                }
            }
        }

        return false;
    }

    export function isUnterminatedStringLiteral(token: ISyntaxToken): boolean {
        if (token && token.kind() === SyntaxKind.StringLiteral) {
            var text = token.text();
            return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
        }

        return false;
    }

    export function isUnterminatedMultilineCommentTrivia(trivia: ISyntaxTrivia): boolean {
        if (trivia && trivia.kind() === SyntaxKind.MultiLineCommentTrivia) {
            var text = trivia.fullText();
            return text.length < 4 || text.substring(text.length - 2) !== "*/";
        }
        return false;
    }

    export function isEntirelyInsideCommentTrivia(trivia: ISyntaxTrivia, fullStart: number, position: number): boolean {
        if (trivia && trivia.isComment() && position > fullStart) {
            var end = fullStart + trivia.fullWidth();
            if (position < end) {
                return true;
            }
            else if (position === end) {
                return trivia.kind() === SyntaxKind.SingleLineCommentTrivia || isUnterminatedMultilineCommentTrivia(trivia);
            }
        }

        return false;
    }

    export function isEntirelyInsideComment(sourceUnit: SourceUnitSyntax, position: number): boolean {
        var positionedToken = findToken(sourceUnit, position);
        var fullStart = positionedToken.fullStart();
        var triviaList: ISyntaxTriviaList = null;
        var lastTriviaBeforeToken: ISyntaxTrivia = null;

        if (positionedToken.kind() === SyntaxKind.EndOfFileToken) {
            // Check if the trivia is leading on the EndOfFile token
            if (positionedToken.hasLeadingTrivia()) {
                triviaList = positionedToken.leadingTrivia();
            }
            // Or trailing on the previous token
            else {
                positionedToken = previousToken(positionedToken);
                if (positionedToken) {
                    if (positionedToken && positionedToken.hasTrailingTrivia()) {
                        triviaList = positionedToken.trailingTrivia();
                        fullStart = end(positionedToken);
                    }
                }
            }
        }
        else {
            if (position <= (fullStart + positionedToken.leadingTriviaWidth())) {
                triviaList = positionedToken.leadingTrivia();
            }
            else if (position >= (fullStart + width(positionedToken))) {
                triviaList = positionedToken.trailingTrivia();
                fullStart = end(positionedToken);
            }
        }

        if (triviaList) {
            // Try to find the trivia matching the position
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (position <= fullStart) {
                    // Moved passed the trivia we need
                    break;
                }
                else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                    // Found the comment trivia we were looking for
                    lastTriviaBeforeToken = trivia;
                    break;
                }

                fullStart += trivia.fullWidth();
            }
        }

        return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
    }

    export function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit: SourceUnitSyntax, position: number): boolean {
        var positionedToken = findToken(sourceUnit, position);

        if (positionedToken) {
            if (positionedToken.kind() === SyntaxKind.EndOfFileToken) {
                // EndOfFile token, enusre it did not follow an unterminated string literal
                positionedToken = previousToken(positionedToken);
                return positionedToken && positionedToken.trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken);
            }
            else if (position > start(positionedToken)) {
                // Ensure position falls enterily within the literal if it is terminated, or the line if it is not
                return (position < end(positionedToken) && (positionedToken.kind() === TypeScript.SyntaxKind.StringLiteral || positionedToken.kind() === TypeScript.SyntaxKind.RegularExpressionLiteral)) ||
                    (position <= end(positionedToken) && isUnterminatedStringLiteral(positionedToken));
            }
        }

        return false;
    }

    function findSkippedTokenOnLeftInTriviaList(positionedToken: ISyntaxToken, position: number, lookInLeadingTriviaList: boolean): ISyntaxToken {
        var triviaList: TypeScript.ISyntaxTriviaList = null;
        var fullEnd: number;

        if (lookInLeadingTriviaList) {
            triviaList = positionedToken.leadingTrivia();
            fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
        }
        else {
            triviaList = positionedToken.trailingTrivia();
            fullEnd = TypeScript.fullEnd(positionedToken);
        }

        if (triviaList && triviaList.hasSkippedToken()) {
            for (var i = triviaList.count() - 1; i >= 0; i--) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var triviaWidth = trivia.fullWidth();

                if (trivia.isSkippedToken() && position >= fullEnd) {
                    return trivia.skippedToken();
                }

                fullEnd -= triviaWidth;
            }
        }

        return null;
    }

    export function findSkippedTokenOnLeft(positionedToken: ISyntaxToken, position: number): ISyntaxToken {
        var positionInLeadingTriviaList = (position < start(positionedToken));
        return findSkippedTokenOnLeftInTriviaList(positionedToken, position, /*lookInLeadingTriviaList*/ positionInLeadingTriviaList);
    }

    export function getAncestorOfKind(positionedToken: ISyntaxElement, kind: SyntaxKind): ISyntaxElement {
        while (positionedToken && positionedToken.parent) {
            if (positionedToken.parent.kind() === kind) {
                return positionedToken.parent;
            }

            positionedToken = positionedToken.parent;
        }

        return null;
    }

    export function hasAncestorOfKind(positionedToken: ISyntaxElement, kind: SyntaxKind): boolean {
        return getAncestorOfKind(positionedToken, kind) !== null;
    }

    export function isIntegerLiteral(expression: IExpressionSyntax): boolean {
        if (expression) {
            switch (expression.kind()) {
                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                    // Note: if there is a + or - sign, we can only allow a normal integer following
                    // (and not a hex integer).  i.e. -0xA is a legal expression, but it is not a 
                    // *literal*.
                    expression = (<PrefixUnaryExpressionSyntax>expression).operand;
                    return isToken(expression) && IntegerUtilities.isInteger((<ISyntaxToken>expression).text());

                case SyntaxKind.NumericLiteral:
                    // If it doesn't have a + or -, then either an integer literal or a hex literal
                    // is acceptable.
                    var text = (<ISyntaxToken> expression).text();
                    return IntegerUtilities.isInteger(text) || IntegerUtilities.isHexInteger(text);
            }
        }

        return false;
    }

    export function containingNode(element: ISyntaxElement): ISyntaxNode {
        var current = element.parent;

        while (current !== null && !isNode(current)) {
            current = current.parent;
        }

        return <ISyntaxNode>current;
    }

    export function findTokenOnLeft(element: ISyntaxElement, position: number, includeSkippedTokens: boolean = false): ISyntaxToken {
        var positionedToken = findToken(element, position, /*includeSkippedTokens*/ false);
        var _start = start(positionedToken);

        // Position better fall within this token.
        // Debug.assert(position >= positionedToken.fullStart());
        // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);

        if (includeSkippedTokens) {
            positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
        }

        // if position is after the start of the token, then this token is the token on the left.
        if (position > _start) {
            return positionedToken;
        }

        // we're in the trivia before the start of the token.  Need to return the previous token.
        if (positionedToken.fullStart() === 0) {
            // Already on the first token.  Nothing before us.
            return null;
        }

        return previousToken(positionedToken, includeSkippedTokens);
    }

    export function findCompleteTokenOnLeft(element: ISyntaxElement, position: number, includeSkippedTokens: boolean = false): ISyntaxToken {
        var positionedToken = findToken(element, position, /*includeSkippedTokens*/ false);

        // Position better fall within this token.
        // Debug.assert(position >= positionedToken.fullStart());
        // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);

        if (includeSkippedTokens) {
            positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
        }

        // if position is after the end of the token, then this token is the token on the left.
        if (width(positionedToken) > 0 && position >= end(positionedToken)) {
            return positionedToken;
        }

        return previousToken(positionedToken, includeSkippedTokens);
    }

    export function firstTokenInLineContainingPosition(syntaxTree: SyntaxTree, position: number): ISyntaxToken {
        var current = findToken(syntaxTree.sourceUnit(), position);
        while (true) {
            if (isFirstTokenInLine(current)) {
                break;
            }

            current = previousToken(current);
        }

        return current;
    }

    function isFirstTokenInLine(token: ISyntaxToken): boolean {
        var _previousToken = previousToken(token);
        return _previousToken === null || _previousToken.hasTrailingNewLine();
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class SyntaxDedenter extends SyntaxRewriter {
        private lastTriviaWasNewLine: boolean;

        constructor(dedentFirstToken: boolean,
                    private dedentationAmount: number,
                    private minimumIndent: number,
                    private options: FormattingOptions) {
            super();
            this.lastTriviaWasNewLine = dedentFirstToken;
        }

        private abort(): void {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        }

        private isAborted(): boolean {
            return this.dedentationAmount === 0;
        }

        public visitToken(token: ISyntaxToken): ISyntaxToken {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                // have to add our indentation to every line that this token hits.
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }

            if (this.isAborted()) {
                // If we've decided to stop dedenting.  Then just return immediately.
                return token;
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        }

        private dedentTriviaList(triviaList: ISyntaxTriviaList): ISyntaxTriviaList {
            var result: ISyntaxTrivia[] = [];
            var dedentNextWhitespace = true;

            // Keep walking through all our trivia (as long as we haven't decided to stop dedenting).
            // Adjust the indentation on any whitespace trivia at the start of a line, or any multi-line
            // trivia that span multiple lines.
            for (var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;

                if (dedentThisTrivia) {
                    if (trivia.kind() === SyntaxKind.WhitespaceTrivia) {
                        // We pass in if there was a following newline after this whitespace.  If there 
                        // is, then it's fine if we dedent this newline all the way to 0.  Otherwise,
                        // if the whitespace is followed by something, then we need to determine how 
                        // much of the whitespace we can remove.  If we can't remove all that we want,
                        // we'll need to adjust the dedentAmount.  And, if we can't remove at all, then
                        // we need to stop dedenting entirely.
                        var hasFollowingNewLine = (i < triviaList.count() - 1) &&
                                                  triviaList.syntaxTriviaAt(i + 1).kind() === SyntaxKind.NewLineTrivia;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    }
                    else if (trivia.kind() !== SyntaxKind.NewLineTrivia) {
                        // We wanted to dedent, but the trivia we're on isn't whitespace and wasn't a 
                        // newline.  That means that we have something like a comment at the beginning
                        // of the line that we can't dedent.  And, if we can't dedent it, then we 
                        // shouldn't dedent this token or any more tokens.
                        this.abort();
                        break;
                    }
                }

                if (trivia.kind() === SyntaxKind.MultiLineCommentTrivia) {
                    // This trivia may span multiple lines.  If it does, we need to dedent each 
                    // successive line of it until it terminates.
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }

                // All other trivia we just append to the list.
                result.push(trivia);
                if (trivia.kind() === SyntaxKind.NewLineTrivia) {
                    // We hit a newline processing the trivia.  We need to add the indentation to the 
                    // next line as well.
                    dedentNextWhitespace = true;
                }
            }

            if (dedentNextWhitespace) {
                // We hit a new line as the last trivia (or there was no trivia).  We want to dedent 
                // the next trivia, but we can't (because the token starts at the start of the line).
                // If we can't dedent this, then we shouldn't dedent anymore.
                this.abort();
            }

            if (this.isAborted()) {
                return triviaList;
            }

            return Syntax.triviaList(result);
        }

        private dedentSegment(segment: string, hasFollowingNewLineTrivia: boolean): string {
            // Find the position of the first non whitespace character in the segment.
            var firstNonWhitespacePosition = Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    // It was entirely whitespace trivia, with a newline after it.  Just trim this down 
                    // to an empty string.
                    return "";
                }
            }
            else if (CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                // It was entirely whitespace, with a newline after it.  Just trim this down to 
                // the newline
                return segment.substring(firstNonWhitespacePosition);
            }

            // It was whitespace without a newline following it.  We need to try to dedent this a bit.

            // Convert that position to a column.  
            var firstNonWhitespaceColumn = Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            // Find the new column we want the nonwhitespace text to start at. Ideally it would be 
            // whatever column it was minus the dedentation amount.  However, we won't go below a 
            // specified minimum indent (hence, max(initial - dedentAmount, minIndent).  *But* if 
            // the initial column was less than that minimum indent, then we'll keep it at that column.
            // (hence min(initial, desired)).
            var newFirstNonWhitespaceColumn =
                MathPrototype.min(firstNonWhitespaceColumn,
                MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));

            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                // We aren't able to detent this token.  Abort what we're doing
                this.abort();
                return segment;
            }

            // Update the dedentation amount for all subsequent tokens we run into.
            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            Debug.assert(this.dedentationAmount >= 0);

            // Compute an indentation string for that.
            var indentationString = Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            // Join the new indentation and the original string without its indentation.
            return indentationString + segment.substring(firstNonWhitespacePosition);
        }

        private dedentWhitespace(trivia: ISyntaxTrivia, hasFollowingNewLineTrivia: boolean): ISyntaxTrivia {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return Syntax.whitespace(newIndentation);
        }

        private dedentMultiLineComment(trivia: ISyntaxTrivia): ISyntaxTrivia {
            var segments = Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                // If there was only one segment, then this wasn't multiline.
                return trivia;
            }

            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, /*hasFollowingNewLineTrivia*/ false);
            }

            var result = segments.join("");

            // Create a new trivia token out of the indented lines.
            return Syntax.multiLineComment(result);
        }

        public static dedentNode<T extends ISyntaxNode>(node: T, dedentFirstToken: boolean, dedentAmount: number, minimumIndent: number, options: FormattingOptions): T {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);

            if (dedenter.isAborted()) {
                // We failed to dedent a token in this node.  Return the original node as is.
                return node;
            }

            return result;
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    // True if there is only a single instance of this element (and thus can be reused in many 
    // places in a syntax tree).  Examples of this include our empty lists.  Because empty 
    // lists can be found all over the tree, we want to save on memory by using this single
    // instance instead of creating new objects for each case.  Note: because of this, shared
    // nodes don't have positions or parents.
    export function isShared(element: ISyntaxElement): boolean {
        var kind = element.kind();
        return (kind === SyntaxKind.List || kind === SyntaxKind.SeparatedList) && (<ISyntaxNodeOrToken[]>element).length === 0;
    }

    export function childCount(element: ISyntaxElement): number {
        var kind = element.kind();
        if (kind === SyntaxKind.List) {
            return (<ISyntaxNodeOrToken[]>element).length;
        }
        else if (kind === SyntaxKind.SeparatedList) {
            return (<ISyntaxNodeOrToken[]>element).length + (<ISyntaxNodeOrToken[]>element).separators.length;
        }
        else if (kind >= SyntaxKind.FirstToken && kind <= SyntaxKind.LastToken) {
            return 0;
        }
        else {
            return nodeMetadata[kind].length;
        }
    }

    export function childAt(element: ISyntaxElement, index: number): ISyntaxElement {
        var kind = element.kind();
        if (kind === SyntaxKind.List) {
            return (<ISyntaxNodeOrToken[]>element)[index];
        }
        else if (kind === SyntaxKind.SeparatedList) {
            return (index % 2 === 0) ? (<ISyntaxNodeOrToken[]>element)[index / 2] : (<ISyntaxNodeOrToken[]>element).separators[(index - 1) / 2];
        }
        else {
            // Debug.assert(isNode(element));
            return (<any>element)[nodeMetadata[element.kind()][index]];
        }
    }

    export function syntaxTree(element: ISyntaxElement): SyntaxTree {
        if (element) {
            Debug.assert(!isShared(element));

            while (element) {
                if (element.kind() === SyntaxKind.SourceUnit) {
                    return (<SourceUnitSyntax>element).syntaxTree;
                }

                element = element.parent;
            }
        }

        return null;
    }

    export function parsedInStrictMode(node: ISyntaxNode): boolean {
        var info = node.data;
        if (info === undefined) {
            return false;
        }

        return (info & SyntaxConstants.NodeParsedInStrictModeMask) !== 0;
    }

    export function previousToken(token: ISyntaxToken, includeSkippedTokens: boolean = false): ISyntaxToken {
        if (includeSkippedTokens) {
            var triviaList = token.leadingTrivia();
            if (triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = TypeScript.start(token);
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return trivia.skippedToken();
                    }

                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }
        }

        var start = token.fullStart();
        if (start === 0) {
            return null;
        }

        return findToken(syntaxTree(token).sourceUnit(), start - 1, includeSkippedTokens);
    }

    /**
     * Finds a token according to the following rules:
     * 1) If position matches the End of the node/s FullSpan and the node is SourceUnitSyntax,
     *    then the EOF token is returned.
     *
     *  2) If node.FullSpan.Contains(position) then the token that contains given position is
     *     returned.
     *
     *  3) Otherwise an ArgumentOutOfRangeException is thrown
     *
     * Note: findToken will always return a non-missing token with width greater than or equal to
     * 1 (except for EOF).  Empty tokens synthesized by the parser are never returned.
     */
    export function findToken(element: ISyntaxElement, position: number, includeSkippedTokens: boolean = false): ISyntaxToken {
        var endOfFileToken = tryGetEndOfFileAt(element, position);
        if (endOfFileToken !== null) {
            return endOfFileToken;
        }

        if (position < 0 || position >= fullWidth(element)) {
            throw Errors.argumentOutOfRange("position");
        }

        var positionedToken = findTokenWorker(element, position);

        if (includeSkippedTokens) {
            return findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
        }

        // Could not find a better match
        return positionedToken;
    }

    export function findSkippedTokenInPositionedToken(positionedToken: ISyntaxToken, position: number): ISyntaxToken {
        var positionInLeadingTriviaList = (position < start(positionedToken));
        return findSkippedTokenInTriviaList(positionedToken, position, /*lookInLeadingTriviaList*/ positionInLeadingTriviaList);
    }

    export function findSkippedTokenInLeadingTriviaList(positionedToken: ISyntaxToken, position: number): ISyntaxToken {
        return findSkippedTokenInTriviaList(positionedToken, position, /*lookInLeadingTriviaList*/ true);
    }

    export function findSkippedTokenInTrailingTriviaList(positionedToken: ISyntaxToken, position: number): ISyntaxToken {
        return findSkippedTokenInTriviaList(positionedToken, position, /*lookInLeadingTriviaList*/ false);
    }

    function findSkippedTokenInTriviaList(positionedToken: ISyntaxToken, position: number, lookInLeadingTriviaList: boolean): ISyntaxToken {
        var triviaList: TypeScript.ISyntaxTriviaList = null;
        var fullStart: number;

        if (lookInLeadingTriviaList) {
            triviaList = positionedToken.leadingTrivia();
            fullStart = positionedToken.fullStart();
        }
        else {
            triviaList = positionedToken.trailingTrivia();
            fullStart = end(positionedToken);
        }

        if (triviaList && triviaList.hasSkippedToken()) {
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var triviaWidth = trivia.fullWidth();

                if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                    return trivia.skippedToken();
                }

                fullStart += triviaWidth;
            }
        }

        return null;
    }

    function findTokenWorker(element: ISyntaxElement, position: number): ISyntaxToken {
        // Debug.assert(position >= 0 && position < this.fullWidth());
        if (isToken(element)) {
            Debug.assert(fullWidth(element) > 0);
            return <ISyntaxToken>element;
        }

        if (isShared(element)) {
            // This should never have been called on this element.  It has a 0 width, so the client 
            // should have skipped over this.
            throw Errors.invalidOperation();
        }

        // Consider: we could use a binary search here to find the child more quickly.
        for (var i = 0, n = childCount(element); i < n; i++) {
            var child = childAt(element, i);

            if (child !== null && fullWidth(child) > 0) {
                var childFullStart = fullStart(child);

                if (position >= childFullStart) {
                    var childFullEnd = childFullStart + fullWidth(child);

                    if (position < childFullEnd) {
                        return findTokenWorker(child, position);
                    }
                }
            }
        }

        throw Errors.invalidOperation();
    }

    function tryGetEndOfFileAt(element: ISyntaxElement, position: number): ISyntaxToken {
        if (element.kind() === SyntaxKind.SourceUnit && position === fullWidth(element)) {
            var sourceUnit = <SourceUnitSyntax>element;
            return sourceUnit.endOfFileToken;
        }

        return null;
    }

    export function nextToken(token: ISyntaxToken, includeSkippedTokens: boolean = false): ISyntaxToken {
        if (token.kind() === SyntaxKind.EndOfFileToken) {
            return null;
        }

        var triviaList = token.trailingTrivia();
        if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (trivia.isSkippedToken()) {
                    return trivia.skippedToken();
                }
            }
        }

        return findToken(syntaxTree(token).sourceUnit(), fullEnd(token), includeSkippedTokens);
    }

    export function isNode(element: ISyntaxElement): boolean {
        if (element !== null) {
            var kind = element.kind();
            return kind >= SyntaxKind.FirstNode && kind <= SyntaxKind.LastNode;
        }

        return false;
    }

    function isTokenKind(kind: SyntaxKind) {
        return kind >= SyntaxKind.FirstToken && kind <= SyntaxKind.LastToken
    }

    export function isToken(element: ISyntaxElement): boolean {
        if (element !== null) {
            return isTokenKind(element.kind());
        }

        return false;
    }

    export function isList(element: ISyntaxElement): boolean {
        return element !== null && element.kind() === SyntaxKind.List;
    }

    export function isSeparatedList(element: ISyntaxElement): boolean {
        return element !== null && element.kind() === SyntaxKind.SeparatedList;
    }

    export function syntaxID(element: ISyntaxElement): number {
        if (isShared(element)) {
            throw Errors.invalidOperation("Should not use shared syntax element as a key.");
        }

        var obj = <any>element;
        if (obj._syntaxID === undefined) {
            obj._syntaxID = TypeScript.Syntax._nextSyntaxID++;
        }

        return obj._syntaxID;
    }

    function collectTextElements(element: ISyntaxElement, elements: string[]): void {
        if (element) {
            if (isToken(element)) {
                elements.push((<ISyntaxToken>element).fullText());
            }
            else {
                for (var i = 0, n = childCount(element); i < n; i++) {
                    collectTextElements(childAt(element, i), elements);
                }
            }
        }
    }

    export function fullText(element: ISyntaxElement): string {
        if (isToken(element)) {
            return (<ISyntaxToken>element).fullText();
        }

        var elements: string[] = [];
        collectTextElements(element, elements);

        return elements.join("");
    }

    export function leadingTriviaWidth(element: ISyntaxElement): number {
        var token = firstToken(element);
        return token ? token.leadingTriviaWidth() : 0;
    }

    export function trailingTriviaWidth(element: ISyntaxElement): number {
        var token = lastToken(element);
        return token ? token.trailingTriviaWidth() : 0;
    }

    export function firstToken(element: ISyntaxElement): ISyntaxToken {
        if (element) {
            var kind = element.kind();

            if (isTokenKind(kind)) {
                return fullWidth(element) > 0 || element.kind() === SyntaxKind.EndOfFileToken ? <ISyntaxToken>element : null;
            }

            if (kind === SyntaxKind.List) {
                var array = <ISyntaxNodeOrToken[]>element;
                for (var i = 0, n = array.length; i < n; i++) {
                    var token = firstToken(array[i]);
                    if (token) {
                        return token;
                    }
                }
            }
            else if (kind === SyntaxKind.SeparatedList) {
                var array = <ISyntaxNodeOrToken[]>element;
                var separators = array.separators;
                for (var i = 0, n = array.length + separators.length; i < n; i++) {
                    var token = firstToken(i % 2 === 0 ? array[i / 2] : separators[(i - 1) / 2]);
                    if (token) {
                        return token;
                    }
                }
            }
            else {
                var metadata = nodeMetadata[kind];
                for (var i = 0, n = metadata.length; i < n; i++) {
                    var child = (<any>element)[metadata[i]];
                    var token = firstToken(child);
                    if (token) {
                        return token;
                    }
                }

                if (element.kind() === SyntaxKind.SourceUnit) {
                    return (<SourceUnitSyntax>element).endOfFileToken;
                }
            }
        }

        return null;
    }

    export function lastToken(element: ISyntaxElement): ISyntaxToken {
        if (isToken(element)) {
            return fullWidth(element) > 0 || element.kind() === SyntaxKind.EndOfFileToken ? <ISyntaxToken>element : null;
        }

        if (element.kind() === SyntaxKind.SourceUnit) {
            return (<SourceUnitSyntax>element).endOfFileToken;
        }

        for (var i = childCount(element) - 1; i >= 0; i--) {
            var child = childAt(element, i);
            if (child !== null) {
                var token = lastToken(child);
                if (token) {
                    return token;
                }
            }
        }

        return null;
    }

    export function fullStart(element: ISyntaxElement): number {
        Debug.assert(!isShared(element));
        var token = isToken(element) ? <ISyntaxToken>element : firstToken(element);
        return token ? token.fullStart() : -1;
    }

    export function fullWidth(element: ISyntaxElement): number {
        if (isToken(element)) {
            return (<ISyntaxToken>element).fullWidth();
        }

        if (isShared(element)) {
            return 0;
        }

        var info = data(element);
        return info >>> SyntaxConstants.NodeFullWidthShift;
    }

    export function isIncrementallyUnusable(element: ISyntaxElement): boolean {
        if (isToken(element)) {
            return (<ISyntaxToken>element).isIncrementallyUnusable();
        }

        if (isShared(element)) {
            // All shared lists are reusable.
            return false;
        }

        return (data(element) & SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
    }

    function data(element: ISyntaxElement): number {
        Debug.assert(isNode(element) || isList(element) || isSeparatedList(element));

        // Lists and nodes all have a 'data' element.
        var dataElement = <{ data: number }><any>element;

        var info = dataElement.data;
        if (info === undefined) {
            info = 0;
        }

        if ((info & SyntaxConstants.NodeDataComputed) === 0) {
            info |= computeData(element);
            dataElement.data = info;
        }

        return info;
    }

    function computeData(element: ISyntaxElement): number {
        var slotCount = childCount(element);

        var fullWidth = 0;

        // If we have no children (like an OmmittedExpressionSyntax), we're automatically not reusable.
        var isIncrementallyUnusable = slotCount === 0;

        for (var i = 0, n = slotCount; i < n; i++) {
            var child = childAt(element, i);

            if (child !== null) {
                fullWidth += TypeScript.fullWidth(child);

                isIncrementallyUnusable = isIncrementallyUnusable || TypeScript.isIncrementallyUnusable(child);
            }
        }

        return (fullWidth << SyntaxConstants.NodeFullWidthShift)
            | (isIncrementallyUnusable ? SyntaxConstants.NodeIncrementallyUnusableMask : 0)
            | SyntaxConstants.NodeDataComputed;
    }

    export function start(element: ISyntaxElement): number {
        var token = isToken(element) ? <ISyntaxToken>element : firstToken(element);
        return token ? token.fullStart() + token.leadingTriviaWidth() : -1;
    }

    export function end(element: ISyntaxElement): number {
        var token = isToken(element) ? <ISyntaxToken>element : lastToken(element);
        return token ? fullEnd(token) - token.trailingTriviaWidth() : -1;
    }

    export function width(element: ISyntaxElement): number {
        return fullWidth(element) - leadingTriviaWidth(element) - trailingTriviaWidth(element);
    }

    export function fullEnd(element: ISyntaxElement): number {
        return fullStart(element) + fullWidth(element);
    }

    export interface ISyntaxElement {
        kind(): SyntaxKind;
        parent?: ISyntaxElement;
    }

    export interface ISyntaxNode extends ISyntaxNodeOrToken {
        data: number;
    }

    export interface IModuleReferenceSyntax extends ISyntaxNode {
        _isModuleReference: any;
    }

    export interface IModuleElementSyntax extends ISyntaxNode {
    }

    export interface IStatementSyntax extends IModuleElementSyntax {
        _isStatement: any;
    }

    export interface ITypeMemberSyntax extends ISyntaxNode {
    }

    export interface IClassElementSyntax extends ISyntaxNode {
    }

    export interface IMemberDeclarationSyntax extends IClassElementSyntax {
    }

    export interface IPropertyAssignmentSyntax extends IClassElementSyntax {
    }

    export interface ISwitchClauseSyntax extends ISyntaxNode {
        _isSwitchClause: any;
        statements: IStatementSyntax[];
    }

    export interface IExpressionSyntax extends ISyntaxNodeOrToken {
        _isExpression: any;
    }

    export interface IUnaryExpressionSyntax extends IExpressionSyntax {
        _isUnaryExpression: any;
    }

    export interface IPostfixExpressionSyntax extends IUnaryExpressionSyntax {
        _isPostfixExpression: any;
    }

    export interface ILeftHandSideExpressionSyntax extends IPostfixExpressionSyntax {
        _isLeftHandSideExpression: any;
    }

    export interface IMemberExpressionSyntax extends ILeftHandSideExpressionSyntax {
        _isMemberExpression: any;
    }

    export interface ICallExpressionSyntax extends ILeftHandSideExpressionSyntax {
        _isCallExpression: any;
    }

    export interface IPrimaryExpressionSyntax extends IMemberExpressionSyntax {
        _isPrimaryExpression: any;
    }

    export interface ITypeSyntax extends ISyntaxNodeOrToken {
    }

    export interface INameSyntax extends ITypeSyntax {
    }
}
///<reference path='syntaxKind.ts' />

module TypeScript.SyntaxFacts {
    var textToKeywordKind: any = {
        "any": SyntaxKind.AnyKeyword,
        "boolean": SyntaxKind.BooleanKeyword,
        "break": SyntaxKind.BreakKeyword,
        "case": SyntaxKind.CaseKeyword,
        "catch": SyntaxKind.CatchKeyword,
        "class": SyntaxKind.ClassKeyword,
        "continue": SyntaxKind.ContinueKeyword,
        "const": SyntaxKind.ConstKeyword,
        "constructor": SyntaxKind.ConstructorKeyword,
        "debugger": SyntaxKind.DebuggerKeyword,
        "declare": SyntaxKind.DeclareKeyword,
        "default": SyntaxKind.DefaultKeyword,
        "delete": SyntaxKind.DeleteKeyword,
        "do": SyntaxKind.DoKeyword,
        "else": SyntaxKind.ElseKeyword,
        "enum": SyntaxKind.EnumKeyword,
        "export": SyntaxKind.ExportKeyword,
        "extends": SyntaxKind.ExtendsKeyword,
        "false": SyntaxKind.FalseKeyword,
        "finally": SyntaxKind.FinallyKeyword,
        "for": SyntaxKind.ForKeyword,
        "function": SyntaxKind.FunctionKeyword,
        "get": SyntaxKind.GetKeyword,
        "if": SyntaxKind.IfKeyword,
        "implements": SyntaxKind.ImplementsKeyword,
        "import": SyntaxKind.ImportKeyword,
        "in": SyntaxKind.InKeyword,
        "instanceof": SyntaxKind.InstanceOfKeyword,
        "interface": SyntaxKind.InterfaceKeyword,
        "let": SyntaxKind.LetKeyword,
        "module": SyntaxKind.ModuleKeyword,
        "new": SyntaxKind.NewKeyword,
        "null": SyntaxKind.NullKeyword,
        "number":SyntaxKind.NumberKeyword,
        "package": SyntaxKind.PackageKeyword,
        "private": SyntaxKind.PrivateKeyword,
        "protected": SyntaxKind.ProtectedKeyword,
        "public": SyntaxKind.PublicKeyword,
        "require": SyntaxKind.RequireKeyword,
        "return": SyntaxKind.ReturnKeyword,
        "set": SyntaxKind.SetKeyword,
        "static": SyntaxKind.StaticKeyword,
        "string": SyntaxKind.StringKeyword,
        "super": SyntaxKind.SuperKeyword,
        "switch": SyntaxKind.SwitchKeyword,
        "this": SyntaxKind.ThisKeyword,
        "throw": SyntaxKind.ThrowKeyword,
        "true": SyntaxKind.TrueKeyword,
        "try": SyntaxKind.TryKeyword,
        "typeof": SyntaxKind.TypeOfKeyword,
        "var": SyntaxKind.VarKeyword,
        "void": SyntaxKind.VoidKeyword,
        "while": SyntaxKind.WhileKeyword,
        "with": SyntaxKind.WithKeyword,
        "yield": SyntaxKind.YieldKeyword,

        "{": SyntaxKind.OpenBraceToken,
        "}": SyntaxKind.CloseBraceToken,
        "(": SyntaxKind.OpenParenToken,
        ")": SyntaxKind.CloseParenToken,
        "[": SyntaxKind.OpenBracketToken,
        "]": SyntaxKind.CloseBracketToken,
        ".": SyntaxKind.DotToken,
        "...": SyntaxKind.DotDotDotToken,
        ";": SyntaxKind.SemicolonToken,
        ",": SyntaxKind.CommaToken,
        "<": SyntaxKind.LessThanToken,
        ">": SyntaxKind.GreaterThanToken,
        "<=": SyntaxKind.LessThanEqualsToken,
        ">=": SyntaxKind.GreaterThanEqualsToken,
        "==": SyntaxKind.EqualsEqualsToken,
        "=>": SyntaxKind.EqualsGreaterThanToken,
        "!=": SyntaxKind.ExclamationEqualsToken,
        "===": SyntaxKind.EqualsEqualsEqualsToken,
        "!==": SyntaxKind.ExclamationEqualsEqualsToken,
        "+": SyntaxKind.PlusToken,
        "-": SyntaxKind.MinusToken,
        "*": SyntaxKind.AsteriskToken,
        "%": SyntaxKind.PercentToken,
        "++": SyntaxKind.PlusPlusToken,
        "--": SyntaxKind.MinusMinusToken,
        "<<": SyntaxKind.LessThanLessThanToken,
        ">>": SyntaxKind.GreaterThanGreaterThanToken,
        ">>>": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
        "&": SyntaxKind.AmpersandToken,
        "|": SyntaxKind.BarToken,
        "^": SyntaxKind.CaretToken,
        "!": SyntaxKind.ExclamationToken,
        "~": SyntaxKind.TildeToken,
        "&&": SyntaxKind.AmpersandAmpersandToken,
        "||": SyntaxKind.BarBarToken,
        "?": SyntaxKind.QuestionToken,
        ":": SyntaxKind.ColonToken,
        "=": SyntaxKind.EqualsToken,
        "+=": SyntaxKind.PlusEqualsToken,
        "-=": SyntaxKind.MinusEqualsToken,
        "*=": SyntaxKind.AsteriskEqualsToken,
        "%=": SyntaxKind.PercentEqualsToken,
        "<<=": SyntaxKind.LessThanLessThanEqualsToken,
        ">>=": SyntaxKind.GreaterThanGreaterThanEqualsToken,
        ">>>=": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        "&=": SyntaxKind.AmpersandEqualsToken,
        "|=": SyntaxKind.BarEqualsToken,
        "^=": SyntaxKind.CaretEqualsToken,
        "/": SyntaxKind.SlashToken,
        "/=": SyntaxKind.SlashEqualsToken,
    };

    var kindToText = new Array<string>();

    for (var name in textToKeywordKind) {
        if (textToKeywordKind.hasOwnProperty(name)) {
            // Debug.assert(kindToText[textToKeywordKind[name]] === undefined);
            kindToText[textToKeywordKind[name]] = name;
        }
    }

    // Manually work around a bug in the CScript 5.8 runtime where 'constructor' is not
    // listed when SyntaxFacts.textToKeywordKind is enumerated because it is the name of
    // the constructor function.
    kindToText[SyntaxKind.ConstructorKeyword] = "constructor";

    export function getTokenKind(text: string): SyntaxKind {
        if (textToKeywordKind.hasOwnProperty(text)) {
            return textToKeywordKind[text];
        }

        return SyntaxKind.None;
    }

    export function getText(kind: SyntaxKind): string {
        var result = kindToText[kind];
        return result !== undefined ? result : null;
    }

    export function isTokenKind(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstToken && kind <= SyntaxKind.LastToken;
    }

    export function isAnyKeyword(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstKeyword && kind <= SyntaxKind.LastKeyword;
    }

    export function isStandardKeyword(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstStandardKeyword && kind <= SyntaxKind.LastStandardKeyword;
    }

    export function isFutureReservedKeyword(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstFutureReservedKeyword && kind <= SyntaxKind.LastFutureReservedKeyword;
    }

    export function isFutureReservedStrictKeyword(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstFutureReservedStrictKeyword && kind <= SyntaxKind.LastFutureReservedStrictKeyword;
    }

    export function isAnyPunctuation(kind: SyntaxKind): boolean {
        return kind >= SyntaxKind.FirstPunctuation && kind <= SyntaxKind.LastPunctuation;
    }

    export function isPrefixUnaryExpressionOperatorToken(tokenKind: SyntaxKind): boolean {
        return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function isBinaryExpressionOperatorToken(tokenKind: SyntaxKind): boolean {
        return getBinaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function getPrefixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusToken:
                return SyntaxKind.PlusExpression;
            case SyntaxKind.MinusToken:
                return SyntaxKind.NegateExpression;
            case SyntaxKind.TildeToken:
                return SyntaxKind.BitwiseNotExpression;
            case SyntaxKind.ExclamationToken:
                return SyntaxKind.LogicalNotExpression;
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PreIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PreDecrementExpression;
            //case SyntaxKind.DeleteKeyword:
            //    return SyntaxKind.DeleteExpression;
            //case SyntaxKind.TypeOfKeyword:
            //    return SyntaxKind.TypeOfExpression;
            //case SyntaxKind.VoidKeyword:
            //    return SyntaxKind.VoidExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getPostfixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PostIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PostDecrementExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getBinaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.AsteriskToken:
                return SyntaxKind.MultiplyExpression;

            case SyntaxKind.SlashToken:
                return SyntaxKind.DivideExpression;

            case SyntaxKind.PercentToken:
                return SyntaxKind.ModuloExpression;

            case SyntaxKind.PlusToken:
                return SyntaxKind.AddExpression;

            case SyntaxKind.MinusToken:
                return SyntaxKind.SubtractExpression;

            case SyntaxKind.LessThanLessThanToken:
                return SyntaxKind.LeftShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanToken:
                return SyntaxKind.SignedRightShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                return SyntaxKind.UnsignedRightShiftExpression;

            case SyntaxKind.LessThanToken:
                return SyntaxKind.LessThanExpression;

            case SyntaxKind.GreaterThanToken:
                return SyntaxKind.GreaterThanExpression;

            case SyntaxKind.LessThanEqualsToken:
                return SyntaxKind.LessThanOrEqualExpression;

            case SyntaxKind.GreaterThanEqualsToken:
                return SyntaxKind.GreaterThanOrEqualExpression;

            case SyntaxKind.InstanceOfKeyword:
                return SyntaxKind.InstanceOfExpression;

            case SyntaxKind.InKeyword:
                return SyntaxKind.InExpression;

            case SyntaxKind.EqualsEqualsToken:
                return SyntaxKind.EqualsWithTypeConversionExpression;

            case SyntaxKind.ExclamationEqualsToken:
                return SyntaxKind.NotEqualsWithTypeConversionExpression;

            case SyntaxKind.EqualsEqualsEqualsToken:
                return SyntaxKind.EqualsExpression;

            case SyntaxKind.ExclamationEqualsEqualsToken:
                return SyntaxKind.NotEqualsExpression;

            case SyntaxKind.AmpersandToken:
                return SyntaxKind.BitwiseAndExpression;

            case SyntaxKind.CaretToken:
                return SyntaxKind.BitwiseExclusiveOrExpression;

            case SyntaxKind.BarToken:
                return SyntaxKind.BitwiseOrExpression;

            case SyntaxKind.AmpersandAmpersandToken:
                return SyntaxKind.LogicalAndExpression;

            case SyntaxKind.BarBarToken:
                return SyntaxKind.LogicalOrExpression;

            case SyntaxKind.BarEqualsToken:
                return SyntaxKind.OrAssignmentExpression;

            case SyntaxKind.AmpersandEqualsToken:
                return SyntaxKind.AndAssignmentExpression;

            case SyntaxKind.CaretEqualsToken:
                return SyntaxKind.ExclusiveOrAssignmentExpression;

            case SyntaxKind.LessThanLessThanEqualsToken:
                return SyntaxKind.LeftShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                return SyntaxKind.SignedRightShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return SyntaxKind.UnsignedRightShiftAssignmentExpression;

            case SyntaxKind.PlusEqualsToken:
                return SyntaxKind.AddAssignmentExpression;

            case SyntaxKind.MinusEqualsToken:
                return SyntaxKind.SubtractAssignmentExpression;

            case SyntaxKind.AsteriskEqualsToken:
                return SyntaxKind.MultiplyAssignmentExpression;

            case SyntaxKind.SlashEqualsToken:
                return SyntaxKind.DivideAssignmentExpression;

            case SyntaxKind.PercentEqualsToken:
                return SyntaxKind.ModuloAssignmentExpression;

            case SyntaxKind.EqualsToken:
                return SyntaxKind.AssignmentExpression;

            case SyntaxKind.CommaToken:
                return SyntaxKind.CommaExpression;

            default:
                return SyntaxKind.None;
        }
    }

    export function getOperatorTokenFromBinaryExpression(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.MultiplyExpression:
                return SyntaxKind.AsteriskToken;

            case SyntaxKind.DivideExpression:
                return SyntaxKind.SlashToken;

            case SyntaxKind.ModuloExpression:
                return SyntaxKind.PercentToken;

            case SyntaxKind.AddExpression:
                return SyntaxKind.PlusToken;

            case SyntaxKind.SubtractExpression:
                return SyntaxKind.MinusToken;

            case SyntaxKind.LeftShiftExpression:
                return SyntaxKind.LessThanLessThanToken;

            case SyntaxKind.SignedRightShiftExpression:
                return SyntaxKind.GreaterThanGreaterThanToken;

            case SyntaxKind.UnsignedRightShiftExpression:
                return SyntaxKind.GreaterThanGreaterThanGreaterThanToken;

            case SyntaxKind.LessThanExpression:
                return SyntaxKind.LessThanToken;

            case SyntaxKind.GreaterThanExpression:
                return SyntaxKind.GreaterThanToken;

            case SyntaxKind.LessThanOrEqualExpression:
                return SyntaxKind.LessThanEqualsToken;

            case SyntaxKind.GreaterThanOrEqualExpression:
                return SyntaxKind.GreaterThanEqualsToken;

            case SyntaxKind.InstanceOfExpression:
                return SyntaxKind.InstanceOfKeyword;

            case SyntaxKind.InExpression:
                return SyntaxKind.InKeyword;

            case SyntaxKind.EqualsWithTypeConversionExpression:
                return SyntaxKind.EqualsEqualsToken;

            case SyntaxKind.NotEqualsWithTypeConversionExpression:
                return SyntaxKind.ExclamationEqualsToken;

            case SyntaxKind.EqualsExpression:
                return SyntaxKind.EqualsEqualsEqualsToken;

            case SyntaxKind.NotEqualsExpression:
                return SyntaxKind.ExclamationEqualsEqualsToken;

            case SyntaxKind.BitwiseAndExpression:
                return SyntaxKind.AmpersandToken;

            case SyntaxKind.BitwiseExclusiveOrExpression:
                return SyntaxKind.CaretToken;

            case SyntaxKind.BitwiseOrExpression:
                return SyntaxKind.BarToken;

            case SyntaxKind.LogicalAndExpression:
                return SyntaxKind.AmpersandAmpersandToken;

            case SyntaxKind.LogicalOrExpression:
                return SyntaxKind.BarBarToken;

            case SyntaxKind.OrAssignmentExpression:
                return SyntaxKind.BarEqualsToken;

            case SyntaxKind.AndAssignmentExpression:
                return SyntaxKind.AmpersandEqualsToken;

            case SyntaxKind.ExclusiveOrAssignmentExpression:
                return SyntaxKind.CaretEqualsToken;

            case SyntaxKind.LeftShiftAssignmentExpression:
                return SyntaxKind.LessThanLessThanEqualsToken;

            case SyntaxKind.SignedRightShiftAssignmentExpression:
                return SyntaxKind.GreaterThanGreaterThanEqualsToken;

            case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                return SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken;

            case SyntaxKind.AddAssignmentExpression:
                return SyntaxKind.PlusEqualsToken;

            case SyntaxKind.SubtractAssignmentExpression:
                return SyntaxKind.MinusEqualsToken;

            case SyntaxKind.MultiplyAssignmentExpression:
                return SyntaxKind.AsteriskEqualsToken;

            case SyntaxKind.DivideAssignmentExpression:
                return SyntaxKind.SlashEqualsToken;

            case SyntaxKind.ModuloAssignmentExpression:
                return SyntaxKind.PercentEqualsToken;

            case SyntaxKind.AssignmentExpression:
                return SyntaxKind.EqualsToken;

            case SyntaxKind.CommaExpression:
                return SyntaxKind.CommaToken;

            default:
                return SyntaxKind.None;
        }
    }
}
///<reference path='references.ts' />

module TypeScript.SyntaxFacts {
    export function isDirectivePrologueElement(node: ISyntaxNodeOrToken): boolean {
        if (node.kind() === SyntaxKind.ExpressionStatement) {
            var expressionStatement = <ExpressionStatementSyntax>node;
            var expression = expressionStatement.expression;

            if (expression.kind() === SyntaxKind.StringLiteral) {
                return true;
            }
        }

        return false;
    }

    export function isUseStrictDirective(node: ISyntaxNodeOrToken): boolean {
        var expressionStatement = <ExpressionStatementSyntax>node;
        var stringLiteral = <ISyntaxToken>expressionStatement.expression;

        var text = stringLiteral.text();
        return text === '"use strict"' || text === "'use strict'";
    }

    export function isIdentifierNameOrAnyKeyword(token: ISyntaxToken): boolean {
        var tokenKind = token.kind();
        return tokenKind === SyntaxKind.IdentifierName || SyntaxFacts.isAnyKeyword(tokenKind);
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class SyntaxIndenter extends SyntaxRewriter {
        private lastTriviaWasNewLine: boolean;
        private indentationTrivia: ISyntaxTrivia;

        constructor(indentFirstToken: boolean,
                    private indentationAmount: number,
                    private options: FormattingOptions) {
            super();
            this.lastTriviaWasNewLine = indentFirstToken;
            this.indentationTrivia = Indentation.indentationTrivia(this.indentationAmount, this.options);
        }

        public visitToken(token: ISyntaxToken): ISyntaxToken {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                // have to add our indentation to every line that this token hits.
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        }

        public indentTriviaList(triviaList: ISyntaxTriviaList): ISyntaxTriviaList {
            var result: ISyntaxTrivia[] = [];

            // First, update any existing trivia with the indent amount.  For example, combine the
            // indent with any whitespace trivia, or prepend any comments with the trivia.
            var indentNextTrivia = true;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;

                switch (trivia.kind()) {
                    case SyntaxKind.MultiLineCommentTrivia:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;

                    case SyntaxKind.SingleLineCommentTrivia:
                    case SyntaxKind.SkippedTokenTrivia:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;

                    case SyntaxKind.WhitespaceTrivia:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;

                    case SyntaxKind.NewLineTrivia:
                        // We hit a newline processing the trivia.  We need to add the indentation to the 
                        // next line as well.  Note: don't bother indenting the newline itself.  This will 
                        // just insert ugly whitespace that most users probably will not want.
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;

                    default:
                        throw Errors.invalidOperation();
                }
            }

            // Then, if the last trivia was a newline (or there was no trivia at all), then just add the
            // indentation in right before the token.
            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }

            return Syntax.triviaList(result);
        }

        private indentSegment(segment: string): string {
            // Find the position of the first non whitespace character in the segment.
            var firstNonWhitespacePosition = Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition < segment.length &&
                CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {

                // If this segment was just a newline, then don't bother indenting it.  That will just
                // leave the user with an ugly indent in their output that they probably do not want.
                return segment;
            }

            // Convert that position to a column.  
            var firstNonWhitespaceColumn = Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            // Find the new column we want the nonwhitespace text to start at.
            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;

            // Compute an indentation string for that.
            var indentationString = Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            // Join the new indentation and the original string without its indentation.
            return indentationString + segment.substring(firstNonWhitespacePosition);
        }

        private indentWhitespace(trivia: ISyntaxTrivia, indentThisTrivia: boolean, result: ISyntaxTrivia[]): void {
            if (!indentThisTrivia) {
                // Line didn't start with this trivia.  So no need to touch it.  Just add to the result
                // and continue on.
                result.push(trivia);
                return;
            }

            // Line started with this trivia.  We want to figure out what the final column this 
            // whitespace goes to will be.  To do that we add the column it is at now to the column we
            // want to indent to.  We then compute the final tabs+whitespace string for that.
            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(Syntax.whitespace(newIndentation));
        }

        private indentSingleLineOrSkippedText(trivia: ISyntaxTrivia, indentThisTrivia: boolean, result: ISyntaxTrivia[]): void {
            if (indentThisTrivia) {
                // The line started with a comment or skipped text.  Add an indentation based 
                // on the desired settings, and then add the trivia itself.
                result.push(this.indentationTrivia);
            }

            result.push(trivia);
        }

        private indentMultiLineComment(trivia: ISyntaxTrivia, indentThisTrivia: boolean, result: ISyntaxTrivia[]): void {
            if (indentThisTrivia) {
                // The line started with a multiline comment.  Add an indentation based 
                // on the desired settings, and then add the trivia itself.
                result.push(this.indentationTrivia);
            }

            // If the multiline comment spans multiple lines, we need to add the right indent amount to
            // each successive line segment as well.
            var segments = Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);

            for (var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }

            var newText = segments.join("");
            result.push(Syntax.multiLineComment(newText));
        }

        public static indentNode(node: ISyntaxNode, indentFirstToken: boolean, indentAmount: number, options: FormattingOptions): SyntaxNode {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        }

        public static indentNodes(nodes: SyntaxNode[], indentFirstToken: boolean, indentAmount: number, options: FormattingOptions): SyntaxNode[] {
            // Note: it is necessary for correctness that we reuse the same SyntaxIndenter here.  
            // That's because when working on nodes 1-N, we need to know if the previous node ended
            // with a newline.  The indenter will track that for us.

            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result: SyntaxNode[] = ArrayUtilities.select<any, any>(nodes, n => n.accept(indenter));

            return result;
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export enum NodeFlags {
        Export   = 0x00000001,  // Declarations
        Ambient  = 0x00000002,  // Declarations
        Optional = 0x00000004,  // Parameter/Property/Method
        Rest     = 0x00000008,  // Parameter
        Public   = 0x00000010,  // Property/Method
        Private  = 0x00000020,  // Property/Method
        Static   = 0x00000040,  // Property/Method
    }

    interface SyntaxElement {
        kind: SyntaxKind;
    }

    interface SyntaxNode extends SyntaxElement {
        flags: NodeFlags;
    }

    function nodeStart(node: Node): number {
    }

    function nodeWidth(node: Node): number {
    }

    interface SyntaxToken extends Name, PrimaryExpression {
    }

    // The raw text of the token, as written in the original source.
    function tokenText(token: SyntaxToken): string {
    }

    // The token's javascript value.  i.e. 0.0 in the text would have the javascript number value: 0.
    function tokenValue(token: SyntaxToken): any {
    }

    // The token's value in string form.  i.e. \u0041 in the source text would result in a string with the text: A.
    function tokenValueText(token: SyntaxToken): string {
    }

    interface SyntaxList<T> extends SyntaxElement {
        length: number;
        item(index: number): T;
    }

    interface SourceUnit extends Node {
        moduleElements: SyntaxList<ModuleElement>;
    }

    interface QualifiedName extends Name {
        left: Name;
        right: SyntaxToken;
    }

    interface ObjectType extends Type {
        typeMembers: SyntaxList<TypeMember>;
    }

    interface FunctionType extends Type {
        typeParameterList?: TypeParameterList;
        parameterList: ParameterList;
        type: Type;
    }

    interface ArrayType extends Type {
        type: Type;
    }

    interface ConstructorType extends Type {
        typeParameterList?: TypeParameterList;
        parameterList: ParameterList;
        type: Type;
    }

    interface GenericType extends Type {
        name: Name;
        typeArgumentList: TypeArgumentList;
    }

    interface TypeQuery extends Type {
        name: Name;
    }

    interface InterfaceDeclaration extends ModuleElement {
        identifier: SyntaxToken;
        typeParameterList?: TypeParameterList;
        heritageClauses: SyntaxList<HeritageClause>;
        body: ObjectType;
    }

    interface FunctionDeclaration extends Statement {
        identifier: SyntaxToken;
        callSignature: CallSignature;
        block?: Block;
    }

    interface ModuleDeclaration extends ModuleElement {
        name?: Name;
        stringLiteral?: SyntaxToken;
        moduleElements: SyntaxList<ModuleElement>;
    }

    interface ClassDeclaration extends ModuleElement {
        identifier: SyntaxToken;
        typeParameterList?: TypeParameterList;
        heritageClauses: SyntaxList<HeritageClause>;
        classElements: SyntaxList<ClassElement>;
    }

    interface EnumDeclaration extends ModuleElement {
        identifier: SyntaxToken;
        enumElements: SyntaxList<EnumElement>;
    }

    interface ImportDeclaration extends ModuleElement {
        identifier: SyntaxToken;
        moduleReference: ModuleReference;
    }

    interface ExportAssignment extends ModuleElement {
        identifier: SyntaxToken;
    }

    interface MemberFunctionDeclaration extends MemberDeclaration {
        propertyName: SyntaxToken;
        callSignature: CallSignature;
        block?: Block;
    }

    interface MemberVariableDeclaration extends MemberDeclaration {
        variableDeclarator: VariableDeclarator;
    }

    interface ConstructorDeclaration extends ClassElement {
        callSignature: CallSignature;
        block?: Block;
    }

    interface IndexMemberDeclaration extends ClassElement {
        indexSignature: IndexSignature;
    }

    interface GetAccessor extends MemberDeclaration, PropertyAssignment {
        propertyName: SyntaxToken;
        parameterList: ParameterList;
        typeAnnotation?: TypeAnnotation;
        block: Block;
    }

    interface SetAccessor extends MemberDeclaration, PropertyAssignment {
        propertyName: SyntaxToken;
        parameterList: ParameterList;
        block: Block;
    }

    interface PropertySignature extends TypeMember {
        propertyName: SyntaxToken;
        typeAnnotation?: TypeAnnotation;
    }

    interface CallSignature extends TypeMember {
        typeParameterList?: TypeParameterList;
        parameterList: ParameterList;
        typeAnnotation?: TypeAnnotation;
    }

    interface ConstructSignature extends TypeMember {
        callSignature: CallSignature;
    }

    interface IndexSignature extends TypeMember {
        parameter: Parameter;
        typeAnnotation?: TypeAnnotation;
    }

    interface MethodSignature extends TypeMember {
        propertyName: SyntaxToken;
        callSignature: CallSignature;
    }

    interface Block extends Statement {
        statements: SyntaxList<Statement>;
    }

    interface IfStatement extends Statement {
        condition: Expression;
        statement: Statement;
        elseClause?: ElseClause;
    }

    interface VariableStatement extends Statement {
        variableDeclaration: VariableDeclaration;
    }

    interface ExpressionStatement extends Statement {
        expression: Expression;
    }

    interface ReturnStatement extends Statement {
        expression?: Expression;
    }

    interface SwitchStatement extends Statement {
        expression: Expression;
        switchClauses: SyntaxList<SwitchClause>;
    }

    interface BreakStatement extends Statement {
        identifier?: SyntaxToken;
    }

    interface ContinueStatement extends Statement {
        identifier?: SyntaxToken;
    }

    interface ForStatement extends Statement {
        variableDeclaration?: VariableDeclaration;
        initializer?: Expression;
        condition?: Expression;
        incrementor?: Expression;
        statement: Statement;
    }

    interface ForInStatement extends Statement {
        variableDeclaration?: VariableDeclaration;
        left?: Expression;
        expression: Expression;
        statement: Statement;
    }

    interface ThrowStatement extends Statement {
        expression: Expression;
    }

    interface WhileStatement extends Statement {
        condition: Expression;
        statement: Statement;
    }

    interface TryStatement extends Statement {
        block: Block;
        catchClause?: CatchClause;
        finallyClause?: FinallyClause;
    }

    interface LabeledStatement extends Statement {
        identifier: SyntaxToken;
        statement: Statement;
    }

    interface DoStatement extends Statement {
        statement: Statement;
        condition: Expression;
    }

    interface WithStatement extends Statement {
        condition: Expression;
        statement: Statement;
    }

    interface PrefixUnaryExpression extends UnaryExpression {
        operand: UnaryExpression;
    }

    interface DeleteExpression extends UnaryExpression {
        expression: UnaryExpression;
    }

    interface TypeOfExpression extends UnaryExpression {
        expression: UnaryExpression;
    }

    interface VoidExpression extends UnaryExpression {
        expression: UnaryExpression;
    }

    interface ConditionalExpression extends Expression {
        condition: Expression;
        whenTrue: Expression;
        whenFalse: Expression;
    }

    interface BinaryExpression extends Expression {
        left: Expression;
        right: Expression;
    }

    interface PostfixUnaryExpression extends PostfixExpression {
        operand: LeftHandSideExpression;
    }

    interface MemberAccessExpression extends MemberExpression, CallExpression {
        expression: LeftHandSideExpression;
        name: SyntaxToken;
    }

    interface InvocationExpression extends CallExpression {
        expression: LeftHandSideExpression;
        argumentList: ArgumentList;
    }

    interface ArrayLiteralExpression extends PrimaryExpression {
        expressions: SyntaxList<Expression>;
    }

    interface ObjectLiteralExpression extends PrimaryExpression {
        propertyAssignments: SyntaxList<PropertyAssignment>;
    }

    interface ObjectCreationExpression extends MemberExpression {
        expression: MemberExpression;
        argumentList?: ArgumentList;
    }

    interface ParenthesizedExpression extends PrimaryExpression {
        expression: Expression;
    }

    interface ParenthesizedArrowFunctionExpression extends UnaryExpression {
        callSignature: CallSignature;
        block?: Block;
        expression?: Expression;
    }

    interface SimpleArrowFunctionExpression extends UnaryExpression {
        identifier: SyntaxToken;
        block?: Block;
        expression?: Expression;
    }

    interface CastExpression extends UnaryExpression {
        type: Type;
        expression: UnaryExpression;
    }

    interface ElementAccessExpression extends MemberExpression, CallExpression {
        expression: LeftHandSideExpression;
        argumentExpression: Expression;
    }

    interface FunctionExpression extends PrimaryExpression {
        identifier?: SyntaxToken;
        callSignature: CallSignature;
        block: Block;
    }

    interface VariableDeclaration extends Node {
        variableDeclarators: SyntaxList<VariableDeclarator>;
    }

    interface VariableDeclarator extends Node {
        propertyName: SyntaxToken;
        typeAnnotation?: TypeAnnotation;
        equalsValueClause?: EqualsValueClause;
    }

    interface ArgumentList extends Node {
        typeArgumentList?: TypeArgumentList;
        arguments: SyntaxList<Expression>;
    }

    interface ParameterList extends Node {
        parameters: SyntaxList<Parameter>;
    }

    interface TypeArgumentList extends Node {
        typeArguments: SyntaxList<Type>;
    }

    interface TypeParameterList extends Node {
        typeParameters: SyntaxList<TypeParameter>;
    }

    interface HeritageClause extends Node {
        typeNames: SyntaxList<Name>;
    }

    interface EqualsValueClause extends Node {
        value: Expression;
    }

    interface CaseSwitchClause extends SwitchClause {
        expression: Expression;
        statements: SyntaxList<Statement>;
    }

    interface DefaultSwitchClause extends SwitchClause {
        statements: SyntaxList<Statement>;
    }

    interface ElseClause extends Node {
        statement: Statement;
    }

    interface CatchClause extends Node {
        identifier: SyntaxToken;
        typeAnnotation?: TypeAnnotation;
        block: Block;
    }

    interface FinallyClause extends Node {
        block: Block;
    }

    interface TypeParameter extends Node {
        identifier: SyntaxToken;
        constraint?: Constraint;
    }

    interface Constraint extends Node {
        type: Type;
    }

    interface SimplePropertyAssignment extends PropertyAssignment {
        propertyName: SyntaxToken;
        expression: Expression;
    }

    interface FunctionPropertyAssignment extends PropertyAssignment {
        propertyName: SyntaxToken;
        callSignature: CallSignature;
        block: Block;
    }

    interface Parameter extends Node {
        identifier: SyntaxToken;
        typeAnnotation?: TypeAnnotation;
        equalsValueClause?: EqualsValueClause;
    }

    interface EnumElement extends Node {
        propertyName: SyntaxToken;
        equalsValueClause?: EqualsValueClause;
    }

    interface TypeAnnotation extends Node {
        type: Type;
    }

    interface ExternalModuleReference extends ModuleReference {
        stringLiteral: SyntaxToken;
    }

    interface ModuleNameModuleReference extends ModuleReference {
        moduleName: Name;
    }

    interface MemberDeclaration extends ClassElement {
    }

    interface Statement extends ModuleElement {
    }

    interface Name extends Type {
    }

    interface UnaryExpression extends Expression {
    }

    interface PostfixExpression extends UnaryExpression {
    }

    interface LeftHandSideExpression extends PostfixExpression {
    }

    interface MemberExpression extends LeftHandSideExpression {
    }

    interface CallExpression extends LeftHandSideExpression {
    }

    interface PrimaryExpression extends MemberExpression {
    }

    interface ModuleElement extends SyntaxElement {
    }

    interface ModuleReference extends Node {
    }

    interface ClassElement extends Node {
    }

    interface TypeMember extends Node {
    }

    interface PropertyAssignment extends Node {
    }

    interface SwitchClause extends Node {
    }

    interface Expression extends SyntaxElement {
    }

    interface Type extends SyntaxElement {
    }
}
// If you change anything in this enum, make sure you run SyntaxGenerator again!

module TypeScript {
    export enum SyntaxKind {
        // Variable width tokens, trivia and lists.
        None,
        List,
        SeparatedList,
        TriviaList,

        // Trivia
        WhitespaceTrivia,
        NewLineTrivia,
        MultiLineCommentTrivia,
        SingleLineCommentTrivia,
        SkippedTokenTrivia,

        // Note: all variable width tokens must come before all fixed width tokens.

        ErrorToken,
        EndOfFileToken,

        // Tokens
        IdentifierName,

        // LiteralTokens
        RegularExpressionLiteral,
        NumericLiteral,
        StringLiteral,

        // All fixed width tokens follow.

        // Keywords
        BreakKeyword,
        CaseKeyword,
        CatchKeyword,
        ContinueKeyword,
        DebuggerKeyword,
        DefaultKeyword,
        DeleteKeyword,
        DoKeyword,
        ElseKeyword,
        FalseKeyword,
        FinallyKeyword,
        ForKeyword,
        FunctionKeyword,
        IfKeyword,
        InKeyword,
        InstanceOfKeyword,
        NewKeyword,
        NullKeyword,
        ReturnKeyword,
        SwitchKeyword,
        ThisKeyword,
        ThrowKeyword,
        TrueKeyword,
        TryKeyword,
        TypeOfKeyword,
        VarKeyword,
        VoidKeyword,
        WhileKeyword,
        WithKeyword,

        // FutureReservedWords.
        ClassKeyword,
        ConstKeyword,
        EnumKeyword,
        ExportKeyword,
        ExtendsKeyword,
        ImportKeyword,
        SuperKeyword,

        // FutureReservedStrictWords.
        ImplementsKeyword,
        InterfaceKeyword,
        LetKeyword,
        PackageKeyword,
        PrivateKeyword,
        ProtectedKeyword,
        PublicKeyword,
        StaticKeyword,
        YieldKeyword,

        // TypeScript keywords.
        AnyKeyword,
        BooleanKeyword,
        ConstructorKeyword,
        DeclareKeyword,
        GetKeyword,
        ModuleKeyword,
        RequireKeyword,
        NumberKeyword,
        SetKeyword,
        StringKeyword,

        // Punctuators
        OpenBraceToken,
        CloseBraceToken,
        OpenParenToken,
        CloseParenToken,
        OpenBracketToken,
        CloseBracketToken,
        DotToken,
        DotDotDotToken,
        SemicolonToken,
        CommaToken,
        LessThanToken,
        GreaterThanToken,
        LessThanEqualsToken,
        GreaterThanEqualsToken,
        EqualsEqualsToken,
        EqualsGreaterThanToken,
        ExclamationEqualsToken,
        EqualsEqualsEqualsToken,
        ExclamationEqualsEqualsToken,
        PlusToken,
        MinusToken,
        AsteriskToken,
        PercentToken,
        PlusPlusToken,
        MinusMinusToken,
        LessThanLessThanToken,
        GreaterThanGreaterThanToken,
        GreaterThanGreaterThanGreaterThanToken,
        AmpersandToken,
        BarToken,
        CaretToken,
        ExclamationToken,
        TildeToken,
        AmpersandAmpersandToken,
        BarBarToken,
        QuestionToken,
        ColonToken,
        EqualsToken,
        PlusEqualsToken,
        MinusEqualsToken,
        AsteriskEqualsToken,
        PercentEqualsToken,
        LessThanLessThanEqualsToken,
        GreaterThanGreaterThanEqualsToken,
        GreaterThanGreaterThanGreaterThanEqualsToken,
        AmpersandEqualsToken,
        BarEqualsToken,
        CaretEqualsToken,
        SlashToken,
        SlashEqualsToken,

        // SyntaxNodes
        SourceUnit,

        // Names
        QualifiedName,

        // Types
        ObjectType,
        FunctionType,
        ArrayType,
        ConstructorType,
        GenericType,
        TypeQuery,

        // Module elements.
        InterfaceDeclaration,
        FunctionDeclaration,
        ModuleDeclaration,
        ClassDeclaration,
        EnumDeclaration,
        ImportDeclaration,
        ExportAssignment,

        // ClassElements
        MemberFunctionDeclaration,
        MemberVariableDeclaration,
        ConstructorDeclaration,
        IndexMemberDeclaration,

        // ClassElement and PropertyAssignment
        GetAccessor,
        SetAccessor,

        // Type members.
        PropertySignature,
        CallSignature,
        ConstructSignature,
        IndexSignature,
        MethodSignature,

        // Statements
        Block,
        IfStatement,
        VariableStatement,
        ExpressionStatement,
        ReturnStatement,
        SwitchStatement,
        BreakStatement,
        ContinueStatement,
        ForStatement,
        ForInStatement,
        EmptyStatement,
        ThrowStatement,
        WhileStatement,
        TryStatement,
        LabeledStatement,
        DoStatement,
        DebuggerStatement,
        WithStatement,

        // Expressions
        PlusExpression,
        NegateExpression,
        BitwiseNotExpression,
        LogicalNotExpression,
        PreIncrementExpression,
        PreDecrementExpression,
        DeleteExpression,
        TypeOfExpression,
        VoidExpression,
        CommaExpression,
        AssignmentExpression,
        AddAssignmentExpression,
        SubtractAssignmentExpression,
        MultiplyAssignmentExpression,
        DivideAssignmentExpression,
        ModuloAssignmentExpression,
        AndAssignmentExpression,
        ExclusiveOrAssignmentExpression,
        OrAssignmentExpression,
        LeftShiftAssignmentExpression,
        SignedRightShiftAssignmentExpression,
        UnsignedRightShiftAssignmentExpression,
        ConditionalExpression,
        LogicalOrExpression,
        LogicalAndExpression,
        BitwiseOrExpression,
        BitwiseExclusiveOrExpression,
        BitwiseAndExpression,
        EqualsWithTypeConversionExpression,
        NotEqualsWithTypeConversionExpression,
        EqualsExpression,
        NotEqualsExpression,
        LessThanExpression,
        GreaterThanExpression,
        LessThanOrEqualExpression,
        GreaterThanOrEqualExpression,
        InstanceOfExpression,
        InExpression,
        LeftShiftExpression,
        SignedRightShiftExpression,
        UnsignedRightShiftExpression,
        MultiplyExpression,
        DivideExpression,
        ModuloExpression,
        AddExpression,
        SubtractExpression,
        PostIncrementExpression,
        PostDecrementExpression,
        MemberAccessExpression,
        InvocationExpression,
        ArrayLiteralExpression,
        ObjectLiteralExpression,
        ObjectCreationExpression,
        ParenthesizedExpression,
        ParenthesizedArrowFunctionExpression,
        SimpleArrowFunctionExpression,
        CastExpression,
        ElementAccessExpression,
        FunctionExpression,
        OmittedExpression,

        // Variable declarations
        VariableDeclaration,
        VariableDeclarator,

        // Lists
        ArgumentList,
        ParameterList,
        TypeArgumentList,
        TypeParameterList,

        // Clauses
        ExtendsHeritageClause,
        ImplementsHeritageClause,
        EqualsValueClause,
        CaseSwitchClause,
        DefaultSwitchClause,
        ElseClause,
        CatchClause,
        FinallyClause,

        // Generics
        TypeParameter,
        Constraint,

        // Property Assignment
        SimplePropertyAssignment,
        // GetAccessorPropertyAssignment,
        // SetAccessorPropertyAssignment,
        FunctionPropertyAssignment,

        // Misc.
        Parameter,
        EnumElement,
        TypeAnnotation,
        ExternalModuleReference,
        ModuleNameModuleReference,

        FirstStandardKeyword = BreakKeyword,
        LastStandardKeyword = WithKeyword,

        FirstFutureReservedKeyword = ClassKeyword,
        LastFutureReservedKeyword = SuperKeyword,

        FirstFutureReservedStrictKeyword = ImplementsKeyword,
        LastFutureReservedStrictKeyword = YieldKeyword,

        FirstTypeScriptKeyword = AnyKeyword,
        LastTypeScriptKeyword = StringKeyword,

        FirstKeyword = FirstStandardKeyword,
        LastKeyword = LastTypeScriptKeyword,

        FirstToken = ErrorToken,
        LastToken = SlashEqualsToken,

        FirstPunctuation = OpenBraceToken,
        LastPunctuation = SlashEqualsToken,

        FirstFixedWidth = FirstKeyword,
        LastFixedWidth = LastPunctuation,

        FirstTrivia = WhitespaceTrivia,
        LastTrivia = SkippedTokenTrivia,

        FirstNode = SourceUnit,
        LastNode = ModuleNameModuleReference,
    }
}
///<reference path='references.ts' />

interface Array<T> {
    data: number;
    separators?: TypeScript.ISyntaxToken[];

    kind(): TypeScript.SyntaxKind;
    parent: TypeScript.ISyntaxElement;

    separatorCount(): number;
    separatorAt(index: number): TypeScript.ISyntaxToken;
}

module TypeScript.Syntax {
    var _emptyList: ISyntaxNodeOrToken[] = [];

    var _emptySeparatedList: ISyntaxNodeOrToken[] = [];
    var _emptySeparators: ISyntaxToken[] = [];

    _emptySeparatedList.separators = _emptySeparators;

    function assertEmptyLists() {
        // Debug.assert(_emptyList.length === 0);
        // var separators = _emptySeparatedList.separators;
        // Debug.assert(!separators || separators.length === 0);
    }

    Array.prototype.kind = function () {
        return this.separators === undefined ? SyntaxKind.List : SyntaxKind.SeparatedList;
    }

    Array.prototype.separatorCount = function (): number {
        assertEmptyLists();
        // Debug.assert(this.kind === SyntaxKind.SeparatedList);
        return this.separators.length;
    }

    Array.prototype.separatorAt = function (index: number): ISyntaxToken {
        assertEmptyLists();
        // Debug.assert(this.kind === SyntaxKind.SeparatedList);
        // Debug.assert(index >= 0 && index < this.separators.length);
        return this.separators[index];
    }

    export function emptyList<T extends ISyntaxNodeOrToken>(): T[] {
        return <T[]><any>_emptyList;
    }

    export function emptySeparatedList<T extends ISyntaxNodeOrToken>(): T[] {
        return <T[]><any>_emptySeparatedList;
    }

    export function list<T extends ISyntaxNodeOrToken>(nodes: T[]): T[] {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptyList<T>();
        }

        for (var i = 0, n = nodes.length; i < n; i++) {
            nodes[i].parent = nodes;
        }

        return nodes;
    }

    export function separatedList<T extends ISyntaxNodeOrToken>(nodes: T[], separators: ISyntaxToken[]): T[] {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptySeparatedList<T>();
        }

        // Debug.assert(separators.length === nodes.length || separators.length == (nodes.length - 1));

        for (var i = 0, n = nodes.length; i < n; i++) {
            nodes[i].parent = nodes;
        }

        for (var i = 0, n = separators.length; i < n; i++) {
            separators[i].parent = nodes;
        }


        nodes.separators = separators.length === 0 ? _emptySeparators : separators;

        return nodes;
    }

    export function nonSeparatorIndexOf<T extends ISyntaxNodeOrToken>(list: T[], ast: ISyntaxNodeOrToken): number {
        for (var i = 0, n = list.length; i < n; i++) {
            if (list[i] === ast) {
                return i;
            }
        }

        return -1;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class SyntaxNode implements ISyntaxNodeOrToken {
        public parent: ISyntaxElement;
        private __kind: SyntaxKind;

        constructor(public data: number) {
        }

        public kind(): SyntaxKind {
            return this.__kind;
        }
    }
}
///<reference path='references.ts' />

// A debug class that we use to make sure a syntax node is valid.  Currently, this simply verifies
// that the same token does not appear in the tree multiple times.  This is important for 
// subsystems that want to map between tokens and positions.  If a token shows up multiple times in
// the node, then it will not have a unique position, previous token, etc. etc. and that can screw
// many algorithms.  For this reason, when generating trees, it is important that nodes that are 
// reused are cloned before insertion.
module TypeScript {
    export class SyntaxNodeInvariantsChecker extends SyntaxWalker {
        private tokenTable = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

        public static checkInvariants(node: ISyntaxNode): void {
            visitNodeOrToken(new SyntaxNodeInvariantsChecker(), node);
        }

        public visitNode(node: ISyntaxNode): void {
            Debug.assert(node.kind === SyntaxKind.SourceUnit || node.parent);
            super.visitNode(node);
        }

        public visitList(list: ISyntaxNodeOrToken[]): void {
            Debug.assert(isShared(list) || list.parent);
            super.visitList(list);
        }

        public visitSeparatedList(list: ISyntaxNodeOrToken[]): void {
            Debug.assert(isShared(list) || list.parent);
            super.visitSeparatedList(list);
        }

        public visitToken(token: ISyntaxToken): void {
            // We're calling 'add', so the table will throw if we try to put the same token in multiple
            // times. 
            Debug.assert(token.parent);
            this.tokenTable.add(token, token);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISyntaxNodeOrToken extends ISyntaxElement {
    }
}
///<reference path='references.ts' />

module TypeScript {
    export var nodeMetadata: string[][] = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],["moduleElements","endOfFileToken"],["left","dotToken","right"],["openBraceToken","typeMembers","closeBraceToken"],["typeParameterList","parameterList","equalsGreaterThanToken","type"],["type","openBracketToken","closeBracketToken"],["newKeyword","typeParameterList","parameterList","equalsGreaterThanToken","type"],["name","typeArgumentList"],["typeOfKeyword","name"],["modifiers","interfaceKeyword","identifier","typeParameterList","heritageClauses","body"],["modifiers","functionKeyword","identifier","callSignature","block","semicolonToken"],["modifiers","moduleKeyword","name","stringLiteral","openBraceToken","moduleElements","closeBraceToken"],["modifiers","classKeyword","identifier","typeParameterList","heritageClauses","openBraceToken","classElements","closeBraceToken"],["modifiers","enumKeyword","identifier","openBraceToken","enumElements","closeBraceToken"],["modifiers","importKeyword","identifier","equalsToken","moduleReference","semicolonToken"],["exportKeyword","equalsToken","identifier","semicolonToken"],["modifiers","propertyName","callSignature","block","semicolonToken"],["modifiers","variableDeclarator","semicolonToken"],["modifiers","constructorKeyword","callSignature","block","semicolonToken"],["modifiers","indexSignature","semicolonToken"],["modifiers","getKeyword","propertyName","parameterList","typeAnnotation","block"],["modifiers","setKeyword","propertyName","parameterList","block"],["propertyName","questionToken","typeAnnotation"],["typeParameterList","parameterList","typeAnnotation"],["newKeyword","callSignature"],["openBracketToken","parameter","closeBracketToken","typeAnnotation"],["propertyName","questionToken","callSignature"],["openBraceToken","statements","closeBraceToken"],["ifKeyword","openParenToken","condition","closeParenToken","statement","elseClause"],["modifiers","variableDeclaration","semicolonToken"],["expression","semicolonToken"],["returnKeyword","expression","semicolonToken"],["switchKeyword","openParenToken","expression","closeParenToken","openBraceToken","switchClauses","closeBraceToken"],["breakKeyword","identifier","semicolonToken"],["continueKeyword","identifier","semicolonToken"],["forKeyword","openParenToken","variableDeclaration","initializer","firstSemicolonToken","condition","secondSemicolonToken","incrementor","closeParenToken","statement"],["forKeyword","openParenToken","variableDeclaration","left","inKeyword","expression","closeParenToken","statement"],["semicolonToken"],["throwKeyword","expression","semicolonToken"],["whileKeyword","openParenToken","condition","closeParenToken","statement"],["tryKeyword","block","catchClause","finallyClause"],["identifier","colonToken","statement"],["doKeyword","statement","whileKeyword","openParenToken","condition","closeParenToken","semicolonToken"],["debuggerKeyword","semicolonToken"],["withKeyword","openParenToken","condition","closeParenToken","statement"],["operatorToken","operand"],["operatorToken","operand"],["operatorToken","operand"],["operatorToken","operand"],["operatorToken","operand"],["operatorToken","operand"],["deleteKeyword","expression"],["typeOfKeyword","expression"],["voidKeyword","expression"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["condition","questionToken","whenTrue","colonToken","whenFalse"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["left","operatorToken","right"],["operand","operatorToken"],["operand","operatorToken"],["expression","dotToken","name"],["expression","argumentList"],["openBracketToken","expressions","closeBracketToken"],["openBraceToken","propertyAssignments","closeBraceToken"],["newKeyword","expression","argumentList"],["openParenToken","expression","closeParenToken"],["callSignature","equalsGreaterThanToken","block","expression"],["identifier","equalsGreaterThanToken","block","expression"],["lessThanToken","type","greaterThanToken","expression"],["expression","openBracketToken","argumentExpression","closeBracketToken"],["functionKeyword","identifier","callSignature","block"],[],["varKeyword","variableDeclarators"],["propertyName","typeAnnotation","equalsValueClause"],["typeArgumentList","openParenToken","arguments","closeParenToken"],["openParenToken","parameters","closeParenToken"],["lessThanToken","typeArguments","greaterThanToken"],["lessThanToken","typeParameters","greaterThanToken"],["extendsOrImplementsKeyword","typeNames"],["extendsOrImplementsKeyword","typeNames"],["equalsToken","value"],["caseKeyword","expression","colonToken","statements"],["defaultKeyword","colonToken","statements"],["elseKeyword","statement"],["catchKeyword","openParenToken","identifier","typeAnnotation","closeParenToken","block"],["finallyKeyword","block"],["identifier","constraint"],["extendsKeyword","type"],["propertyName","colonToken","expression"],["propertyName","callSignature","block"],["dotDotDotToken","modifiers","identifier","questionToken","typeAnnotation","equalsValueClause"],["propertyName","equalsValueClause"],["colonToken","type"],["requireKeyword","openParenToken","stringLiteral","closeParenToken"],["moduleName"],];
    export class SourceUnitSyntax extends SyntaxNode {
        public syntaxTree: SyntaxTree = null;
        public moduleElements: IModuleElementSyntax[];
        public endOfFileToken: ISyntaxToken;
        constructor(data: number, moduleElements: IModuleElementSyntax[], endOfFileToken: ISyntaxToken) {
            super(data);
            this.parent = null,
            this.moduleElements = moduleElements,
            this.endOfFileToken = endOfFileToken,
            !isShared(moduleElements) && (moduleElements.parent = this),
            endOfFileToken.parent = this;
        }
    }
    export class QualifiedNameSyntax extends SyntaxNode implements INameSyntax {
        public left: INameSyntax;
        public dotToken: ISyntaxToken;
        public right: ISyntaxToken;
        public _isName: any; public _isType: any;
        constructor(data: number, left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken) {
            super(data);
            this.left = left,
            this.dotToken = dotToken,
            this.right = right,
            left.parent = this,
            dotToken.parent = this,
            right.parent = this;
        }
    }
    export class ObjectTypeSyntax extends SyntaxNode implements ITypeSyntax {
        public openBraceToken: ISyntaxToken;
        public typeMembers: ITypeMemberSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isType: any;
        constructor(data: number, openBraceToken: ISyntaxToken, typeMembers: ITypeMemberSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.openBraceToken = openBraceToken,
            this.typeMembers = typeMembers,
            this.closeBraceToken = closeBraceToken,
            openBraceToken.parent = this,
            !isShared(typeMembers) && (typeMembers.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class FunctionTypeSyntax extends SyntaxNode implements ITypeSyntax {
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public equalsGreaterThanToken: ISyntaxToken;
        public type: ITypeSyntax;
        public _isType: any;
        constructor(data: number, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax) {
            super(data);
            this.typeParameterList = typeParameterList,
            this.parameterList = parameterList,
            this.equalsGreaterThanToken = equalsGreaterThanToken,
            this.type = type,
            typeParameterList && (typeParameterList.parent = this),
            parameterList.parent = this,
            equalsGreaterThanToken.parent = this,
            type.parent = this;
        }
    }
    export class ArrayTypeSyntax extends SyntaxNode implements ITypeSyntax {
        public type: ITypeSyntax;
        public openBracketToken: ISyntaxToken;
        public closeBracketToken: ISyntaxToken;
        public _isType: any;
        constructor(data: number, type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken) {
            super(data);
            this.type = type,
            this.openBracketToken = openBracketToken,
            this.closeBracketToken = closeBracketToken,
            type.parent = this,
            openBracketToken.parent = this,
            closeBracketToken.parent = this;
        }
    }
    export class ConstructorTypeSyntax extends SyntaxNode implements ITypeSyntax {
        public newKeyword: ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public equalsGreaterThanToken: ISyntaxToken;
        public type: ITypeSyntax;
        public _isType: any;
        constructor(data: number, newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax) {
            super(data);
            this.newKeyword = newKeyword,
            this.typeParameterList = typeParameterList,
            this.parameterList = parameterList,
            this.equalsGreaterThanToken = equalsGreaterThanToken,
            this.type = type,
            newKeyword.parent = this,
            typeParameterList && (typeParameterList.parent = this),
            parameterList.parent = this,
            equalsGreaterThanToken.parent = this,
            type.parent = this;
        }
    }
    export class GenericTypeSyntax extends SyntaxNode implements ITypeSyntax {
        public name: INameSyntax;
        public typeArgumentList: TypeArgumentListSyntax;
        public _isType: any;
        constructor(data: number, name: INameSyntax, typeArgumentList: TypeArgumentListSyntax) {
            super(data);
            this.name = name,
            this.typeArgumentList = typeArgumentList,
            name.parent = this,
            typeArgumentList.parent = this;
        }
    }
    export class TypeQuerySyntax extends SyntaxNode implements ITypeSyntax {
        public typeOfKeyword: ISyntaxToken;
        public name: INameSyntax;
        public _isType: any;
        constructor(data: number, typeOfKeyword: ISyntaxToken, name: INameSyntax) {
            super(data);
            this.typeOfKeyword = typeOfKeyword,
            this.name = name,
            typeOfKeyword.parent = this,
            name.parent = this;
        }
    }
    export class InterfaceDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {
        public modifiers: ISyntaxToken[];
        public interfaceKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public heritageClauses: HeritageClauseSyntax[];
        public body: ObjectTypeSyntax;
        public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: HeritageClauseSyntax[], body: ObjectTypeSyntax) {
            super(data);
            this.modifiers = modifiers,
            this.interfaceKeyword = interfaceKeyword,
            this.identifier = identifier,
            this.typeParameterList = typeParameterList,
            this.heritageClauses = heritageClauses,
            this.body = body,
            !isShared(modifiers) && (modifiers.parent = this),
            interfaceKeyword.parent = this,
            identifier.parent = this,
            typeParameterList && (typeParameterList.parent = this),
            !isShared(heritageClauses) && (heritageClauses.parent = this),
            body.parent = this;
        }
    }
    export class FunctionDeclarationSyntax extends SyntaxNode implements IStatementSyntax {
        public modifiers: ISyntaxToken[];
        public functionKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.functionKeyword = functionKeyword,
            this.identifier = identifier,
            this.callSignature = callSignature,
            this.block = block,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            functionKeyword.parent = this,
            identifier.parent = this,
            callSignature.parent = this,
            block && (block.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ModuleDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {
        public modifiers: ISyntaxToken[];
        public moduleKeyword: ISyntaxToken;
        public name: INameSyntax;
        public stringLiteral: ISyntaxToken;
        public openBraceToken: ISyntaxToken;
        public moduleElements: IModuleElementSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: IModuleElementSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.moduleKeyword = moduleKeyword,
            this.name = name,
            this.stringLiteral = stringLiteral,
            this.openBraceToken = openBraceToken,
            this.moduleElements = moduleElements,
            this.closeBraceToken = closeBraceToken,
            !isShared(modifiers) && (modifiers.parent = this),
            moduleKeyword.parent = this,
            name && (name.parent = this),
            stringLiteral && (stringLiteral.parent = this),
            openBraceToken.parent = this,
            !isShared(moduleElements) && (moduleElements.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class ClassDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {
        public modifiers: ISyntaxToken[];
        public classKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public heritageClauses: HeritageClauseSyntax[];
        public openBraceToken: ISyntaxToken;
        public classElements: IClassElementSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: HeritageClauseSyntax[], openBraceToken: ISyntaxToken, classElements: IClassElementSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.classKeyword = classKeyword,
            this.identifier = identifier,
            this.typeParameterList = typeParameterList,
            this.heritageClauses = heritageClauses,
            this.openBraceToken = openBraceToken,
            this.classElements = classElements,
            this.closeBraceToken = closeBraceToken,
            !isShared(modifiers) && (modifiers.parent = this),
            classKeyword.parent = this,
            identifier.parent = this,
            typeParameterList && (typeParameterList.parent = this),
            !isShared(heritageClauses) && (heritageClauses.parent = this),
            openBraceToken.parent = this,
            !isShared(classElements) && (classElements.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class EnumDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {
        public modifiers: ISyntaxToken[];
        public enumKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public openBraceToken: ISyntaxToken;
        public enumElements: EnumElementSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: EnumElementSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.enumKeyword = enumKeyword,
            this.identifier = identifier,
            this.openBraceToken = openBraceToken,
            this.enumElements = enumElements,
            this.closeBraceToken = closeBraceToken,
            !isShared(modifiers) && (modifiers.parent = this),
            enumKeyword.parent = this,
            identifier.parent = this,
            openBraceToken.parent = this,
            !isShared(enumElements) && (enumElements.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class ImportDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {
        public modifiers: ISyntaxToken[];
        public importKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public equalsToken: ISyntaxToken;
        public moduleReference: IModuleReferenceSyntax;
        public semicolonToken: ISyntaxToken;
        public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.importKeyword = importKeyword,
            this.identifier = identifier,
            this.equalsToken = equalsToken,
            this.moduleReference = moduleReference,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            importKeyword.parent = this,
            identifier.parent = this,
            equalsToken.parent = this,
            moduleReference.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ExportAssignmentSyntax extends SyntaxNode implements IModuleElementSyntax {
        public exportKeyword: ISyntaxToken;
        public equalsToken: ISyntaxToken;
        public identifier: ISyntaxToken;
        public semicolonToken: ISyntaxToken;
        public _isModuleElement: any;
        constructor(data: number, exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken) {
            super(data);
            this.exportKeyword = exportKeyword,
            this.equalsToken = equalsToken,
            this.identifier = identifier,
            this.semicolonToken = semicolonToken,
            exportKeyword.parent = this,
            equalsToken.parent = this,
            identifier.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class MemberFunctionDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {
        public modifiers: ISyntaxToken[];
        public propertyName: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public semicolonToken: ISyntaxToken;
        public _isMemberDeclaration: any; public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.propertyName = propertyName,
            this.callSignature = callSignature,
            this.block = block,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            propertyName.parent = this,
            callSignature.parent = this,
            block && (block.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class MemberVariableDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {
        public modifiers: ISyntaxToken[];
        public variableDeclarator: VariableDeclaratorSyntax;
        public semicolonToken: ISyntaxToken;
        public _isMemberDeclaration: any; public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.variableDeclarator = variableDeclarator,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            variableDeclarator.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ConstructorDeclarationSyntax extends SyntaxNode implements IClassElementSyntax {
        public modifiers: ISyntaxToken[];
        public constructorKeyword: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public semicolonToken: ISyntaxToken;
        public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.constructorKeyword = constructorKeyword,
            this.callSignature = callSignature,
            this.block = block,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            constructorKeyword.parent = this,
            callSignature.parent = this,
            block && (block.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class IndexMemberDeclarationSyntax extends SyntaxNode implements IClassElementSyntax {
        public modifiers: ISyntaxToken[];
        public indexSignature: IndexSignatureSyntax;
        public semicolonToken: ISyntaxToken;
        public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.indexSignature = indexSignature,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            indexSignature.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class GetAccessorSyntax extends SyntaxNode implements IMemberDeclarationSyntax, IPropertyAssignmentSyntax {
        public modifiers: ISyntaxToken[];
        public getKeyword: ISyntaxToken;
        public propertyName: ISyntaxToken;
        public parameterList: ParameterListSyntax;
        public typeAnnotation: TypeAnnotationSyntax;
        public block: BlockSyntax;
        public _isMemberDeclaration: any; public _isPropertyAssignment: any; public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax) {
            super(data);
            this.modifiers = modifiers,
            this.getKeyword = getKeyword,
            this.propertyName = propertyName,
            this.parameterList = parameterList,
            this.typeAnnotation = typeAnnotation,
            this.block = block,
            !isShared(modifiers) && (modifiers.parent = this),
            getKeyword.parent = this,
            propertyName.parent = this,
            parameterList.parent = this,
            typeAnnotation && (typeAnnotation.parent = this),
            block.parent = this;
        }
    }
    export class SetAccessorSyntax extends SyntaxNode implements IMemberDeclarationSyntax, IPropertyAssignmentSyntax {
        public modifiers: ISyntaxToken[];
        public setKeyword: ISyntaxToken;
        public propertyName: ISyntaxToken;
        public parameterList: ParameterListSyntax;
        public block: BlockSyntax;
        public _isMemberDeclaration: any; public _isPropertyAssignment: any; public _isClassElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax) {
            super(data);
            this.modifiers = modifiers,
            this.setKeyword = setKeyword,
            this.propertyName = propertyName,
            this.parameterList = parameterList,
            this.block = block,
            !isShared(modifiers) && (modifiers.parent = this),
            setKeyword.parent = this,
            propertyName.parent = this,
            parameterList.parent = this,
            block.parent = this;
        }
    }
    export class PropertySignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {
        public propertyName: ISyntaxToken;
        public questionToken: ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public _isTypeMember: any;
        constructor(data: number, propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.questionToken = questionToken,
            this.typeAnnotation = typeAnnotation,
            propertyName.parent = this,
            questionToken && (questionToken.parent = this),
            typeAnnotation && (typeAnnotation.parent = this);
        }
    }
    export class CallSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public typeAnnotation: TypeAnnotationSyntax;
        public _isTypeMember: any;
        constructor(data: number, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax) {
            super(data);
            this.typeParameterList = typeParameterList,
            this.parameterList = parameterList,
            this.typeAnnotation = typeAnnotation,
            typeParameterList && (typeParameterList.parent = this),
            parameterList.parent = this,
            typeAnnotation && (typeAnnotation.parent = this);
        }
    }
    export class ConstructSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {
        public newKeyword: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public _isTypeMember: any;
        constructor(data: number, newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax) {
            super(data);
            this.newKeyword = newKeyword,
            this.callSignature = callSignature,
            newKeyword.parent = this,
            callSignature.parent = this;
        }
    }
    export class IndexSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {
        public openBracketToken: ISyntaxToken;
        public parameter: ParameterSyntax;
        public closeBracketToken: ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public _isTypeMember: any;
        constructor(data: number, openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax) {
            super(data);
            this.openBracketToken = openBracketToken,
            this.parameter = parameter,
            this.closeBracketToken = closeBracketToken,
            this.typeAnnotation = typeAnnotation,
            openBracketToken.parent = this,
            parameter.parent = this,
            closeBracketToken.parent = this,
            typeAnnotation && (typeAnnotation.parent = this);
        }
    }
    export class MethodSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {
        public propertyName: ISyntaxToken;
        public questionToken: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public _isTypeMember: any;
        constructor(data: number, propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.questionToken = questionToken,
            this.callSignature = callSignature,
            propertyName.parent = this,
            questionToken && (questionToken.parent = this),
            callSignature.parent = this;
        }
    }
    export class BlockSyntax extends SyntaxNode implements IStatementSyntax {
        public openBraceToken: ISyntaxToken;
        public statements: IStatementSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, openBraceToken: ISyntaxToken, statements: IStatementSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.openBraceToken = openBraceToken,
            this.statements = statements,
            this.closeBraceToken = closeBraceToken,
            openBraceToken.parent = this,
            !isShared(statements) && (statements.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class IfStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public ifKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public condition: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public elseClause: ElseClauseSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax) {
            super(data);
            this.ifKeyword = ifKeyword,
            this.openParenToken = openParenToken,
            this.condition = condition,
            this.closeParenToken = closeParenToken,
            this.statement = statement,
            this.elseClause = elseClause,
            ifKeyword.parent = this,
            openParenToken.parent = this,
            condition.parent = this,
            closeParenToken.parent = this,
            statement.parent = this,
            elseClause && (elseClause.parent = this);
        }
    }
    export class VariableStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public modifiers: ISyntaxToken[];
        public variableDeclaration: VariableDeclarationSyntax;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, modifiers: ISyntaxToken[], variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.modifiers = modifiers,
            this.variableDeclaration = variableDeclaration,
            this.semicolonToken = semicolonToken,
            !isShared(modifiers) && (modifiers.parent = this),
            variableDeclaration.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ExpressionStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public expression: IExpressionSyntax;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, expression: IExpressionSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.expression = expression,
            this.semicolonToken = semicolonToken,
            expression.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ReturnStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public returnKeyword: ISyntaxToken;
        public expression: IExpressionSyntax;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.returnKeyword = returnKeyword,
            this.expression = expression,
            this.semicolonToken = semicolonToken,
            returnKeyword.parent = this,
            expression && (expression.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class SwitchStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public switchKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public expression: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public openBraceToken: ISyntaxToken;
        public switchClauses: ISwitchClauseSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISwitchClauseSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.switchKeyword = switchKeyword,
            this.openParenToken = openParenToken,
            this.expression = expression,
            this.closeParenToken = closeParenToken,
            this.openBraceToken = openBraceToken,
            this.switchClauses = switchClauses,
            this.closeBraceToken = closeBraceToken,
            switchKeyword.parent = this,
            openParenToken.parent = this,
            expression.parent = this,
            closeParenToken.parent = this,
            openBraceToken.parent = this,
            !isShared(switchClauses) && (switchClauses.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class BreakStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public breakKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken) {
            super(data);
            this.breakKeyword = breakKeyword,
            this.identifier = identifier,
            this.semicolonToken = semicolonToken,
            breakKeyword.parent = this,
            identifier && (identifier.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ContinueStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public continueKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken) {
            super(data);
            this.continueKeyword = continueKeyword,
            this.identifier = identifier,
            this.semicolonToken = semicolonToken,
            continueKeyword.parent = this,
            identifier && (identifier.parent = this),
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class ForStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public forKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public variableDeclaration: VariableDeclarationSyntax;
        public initializer: IExpressionSyntax;
        public firstSemicolonToken: ISyntaxToken;
        public condition: IExpressionSyntax;
        public secondSemicolonToken: ISyntaxToken;
        public incrementor: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.forKeyword = forKeyword,
            this.openParenToken = openParenToken,
            this.variableDeclaration = variableDeclaration,
            this.initializer = initializer,
            this.firstSemicolonToken = firstSemicolonToken,
            this.condition = condition,
            this.secondSemicolonToken = secondSemicolonToken,
            this.incrementor = incrementor,
            this.closeParenToken = closeParenToken,
            this.statement = statement,
            forKeyword.parent = this,
            openParenToken.parent = this,
            variableDeclaration && (variableDeclaration.parent = this),
            initializer && (initializer.parent = this),
            firstSemicolonToken.parent = this,
            condition && (condition.parent = this),
            secondSemicolonToken.parent = this,
            incrementor && (incrementor.parent = this),
            closeParenToken.parent = this,
            statement.parent = this;
        }
    }
    export class ForInStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public forKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public variableDeclaration: VariableDeclarationSyntax;
        public left: IExpressionSyntax;
        public inKeyword: ISyntaxToken;
        public expression: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.forKeyword = forKeyword,
            this.openParenToken = openParenToken,
            this.variableDeclaration = variableDeclaration,
            this.left = left,
            this.inKeyword = inKeyword,
            this.expression = expression,
            this.closeParenToken = closeParenToken,
            this.statement = statement,
            forKeyword.parent = this,
            openParenToken.parent = this,
            variableDeclaration && (variableDeclaration.parent = this),
            left && (left.parent = this),
            inKeyword.parent = this,
            expression.parent = this,
            closeParenToken.parent = this,
            statement.parent = this;
        }
    }
    export class EmptyStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, semicolonToken: ISyntaxToken) {
            super(data);
            this.semicolonToken = semicolonToken,
            semicolonToken.parent = this;
        }
    }
    export class ThrowStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public throwKeyword: ISyntaxToken;
        public expression: IExpressionSyntax;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken) {
            super(data);
            this.throwKeyword = throwKeyword,
            this.expression = expression,
            this.semicolonToken = semicolonToken,
            throwKeyword.parent = this,
            expression.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class WhileStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public whileKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public condition: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.whileKeyword = whileKeyword,
            this.openParenToken = openParenToken,
            this.condition = condition,
            this.closeParenToken = closeParenToken,
            this.statement = statement,
            whileKeyword.parent = this,
            openParenToken.parent = this,
            condition.parent = this,
            closeParenToken.parent = this,
            statement.parent = this;
        }
    }
    export class TryStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public tryKeyword: ISyntaxToken;
        public block: BlockSyntax;
        public catchClause: CatchClauseSyntax;
        public finallyClause: FinallyClauseSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax) {
            super(data);
            this.tryKeyword = tryKeyword,
            this.block = block,
            this.catchClause = catchClause,
            this.finallyClause = finallyClause,
            tryKeyword.parent = this,
            block.parent = this,
            catchClause && (catchClause.parent = this),
            finallyClause && (finallyClause.parent = this);
        }
    }
    export class LabeledStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public identifier: ISyntaxToken;
        public colonToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.identifier = identifier,
            this.colonToken = colonToken,
            this.statement = statement,
            identifier.parent = this,
            colonToken.parent = this,
            statement.parent = this;
        }
    }
    export class DoStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public doKeyword: ISyntaxToken;
        public statement: IStatementSyntax;
        public whileKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public condition: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken) {
            super(data);
            this.doKeyword = doKeyword,
            this.statement = statement,
            this.whileKeyword = whileKeyword,
            this.openParenToken = openParenToken,
            this.condition = condition,
            this.closeParenToken = closeParenToken,
            this.semicolonToken = semicolonToken,
            doKeyword.parent = this,
            statement.parent = this,
            whileKeyword.parent = this,
            openParenToken.parent = this,
            condition.parent = this,
            closeParenToken.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class DebuggerStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public debuggerKeyword: ISyntaxToken;
        public semicolonToken: ISyntaxToken;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken) {
            super(data);
            this.debuggerKeyword = debuggerKeyword,
            this.semicolonToken = semicolonToken,
            debuggerKeyword.parent = this,
            semicolonToken && (semicolonToken.parent = this);
        }
    }
    export class WithStatementSyntax extends SyntaxNode implements IStatementSyntax {
        public withKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public condition: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public statement: IStatementSyntax;
        public _isStatement: any; public _isModuleElement: any;
        constructor(data: number, withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.withKeyword = withKeyword,
            this.openParenToken = openParenToken,
            this.condition = condition,
            this.closeParenToken = closeParenToken,
            this.statement = statement,
            withKeyword.parent = this,
            openParenToken.parent = this,
            condition.parent = this,
            closeParenToken.parent = this,
            statement.parent = this;
        }
    }
    export class PrefixUnaryExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public operatorToken: ISyntaxToken;
        public operand: IUnaryExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax) {
            super(data);
            this.operatorToken = operatorToken,
            this.operand = operand,
            operatorToken.parent = this,
            operand.parent = this;
        }
        public kind(): SyntaxKind { return SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(this.operatorToken.kind()); }
    }
    export class DeleteExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public deleteKeyword: ISyntaxToken;
        public expression: IUnaryExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax) {
            super(data);
            this.deleteKeyword = deleteKeyword,
            this.expression = expression,
            deleteKeyword.parent = this,
            expression.parent = this;
        }
    }
    export class TypeOfExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public typeOfKeyword: ISyntaxToken;
        public expression: IUnaryExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax) {
            super(data);
            this.typeOfKeyword = typeOfKeyword,
            this.expression = expression,
            typeOfKeyword.parent = this,
            expression.parent = this;
        }
    }
    export class VoidExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public voidKeyword: ISyntaxToken;
        public expression: IUnaryExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax) {
            super(data);
            this.voidKeyword = voidKeyword,
            this.expression = expression,
            voidKeyword.parent = this,
            expression.parent = this;
        }
    }
    export class ConditionalExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
        public condition: IExpressionSyntax;
        public questionToken: ISyntaxToken;
        public whenTrue: IExpressionSyntax;
        public colonToken: ISyntaxToken;
        public whenFalse: IExpressionSyntax;
        public _isExpression: any;
        constructor(data: number, condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax) {
            super(data);
            this.condition = condition,
            this.questionToken = questionToken,
            this.whenTrue = whenTrue,
            this.colonToken = colonToken,
            this.whenFalse = whenFalse,
            condition.parent = this,
            questionToken.parent = this,
            whenTrue.parent = this,
            colonToken.parent = this,
            whenFalse.parent = this;
        }
    }
    export class BinaryExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
        public left: IExpressionSyntax;
        public operatorToken: ISyntaxToken;
        public right: IExpressionSyntax;
        public _isExpression: any;
        constructor(data: number, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax) {
            super(data);
            this.left = left,
            this.operatorToken = operatorToken,
            this.right = right,
            left.parent = this,
            operatorToken.parent = this,
            right.parent = this;
        }
        public kind(): SyntaxKind { return SyntaxFacts.getBinaryExpressionFromOperatorToken(this.operatorToken.kind()); }
    }
    export class PostfixUnaryExpressionSyntax extends SyntaxNode implements IPostfixExpressionSyntax {
        public operand: ILeftHandSideExpressionSyntax;
        public operatorToken: ISyntaxToken;
        public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, operand: ILeftHandSideExpressionSyntax, operatorToken: ISyntaxToken) {
            super(data);
            this.operand = operand,
            this.operatorToken = operatorToken,
            operand.parent = this,
            operatorToken.parent = this;
        }
        public kind(): SyntaxKind { return SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(this.operatorToken.kind()); }
    }
    export class MemberAccessExpressionSyntax extends SyntaxNode implements IMemberExpressionSyntax, ICallExpressionSyntax {
        public expression: ILeftHandSideExpressionSyntax;
        public dotToken: ISyntaxToken;
        public name: ISyntaxToken;
        public _isMemberExpression: any; public _isCallExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, expression: ILeftHandSideExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken) {
            super(data);
            this.expression = expression,
            this.dotToken = dotToken,
            this.name = name,
            expression.parent = this,
            dotToken.parent = this,
            name.parent = this;
        }
    }
    export class InvocationExpressionSyntax extends SyntaxNode implements ICallExpressionSyntax {
        public expression: ILeftHandSideExpressionSyntax;
        public argumentList: ArgumentListSyntax;
        public _isCallExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, expression: ILeftHandSideExpressionSyntax, argumentList: ArgumentListSyntax) {
            super(data);
            this.expression = expression,
            this.argumentList = argumentList,
            expression.parent = this,
            argumentList.parent = this;
        }
    }
    export class ArrayLiteralExpressionSyntax extends SyntaxNode implements IPrimaryExpressionSyntax {
        public openBracketToken: ISyntaxToken;
        public expressions: IExpressionSyntax[];
        public closeBracketToken: ISyntaxToken;
        public _isPrimaryExpression: any; public _isMemberExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, openBracketToken: ISyntaxToken, expressions: IExpressionSyntax[], closeBracketToken: ISyntaxToken) {
            super(data);
            this.openBracketToken = openBracketToken,
            this.expressions = expressions,
            this.closeBracketToken = closeBracketToken,
            openBracketToken.parent = this,
            !isShared(expressions) && (expressions.parent = this),
            closeBracketToken.parent = this;
        }
    }
    export class ObjectLiteralExpressionSyntax extends SyntaxNode implements IPrimaryExpressionSyntax {
        public openBraceToken: ISyntaxToken;
        public propertyAssignments: IPropertyAssignmentSyntax[];
        public closeBraceToken: ISyntaxToken;
        public _isPrimaryExpression: any; public _isMemberExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, openBraceToken: ISyntaxToken, propertyAssignments: IPropertyAssignmentSyntax[], closeBraceToken: ISyntaxToken) {
            super(data);
            this.openBraceToken = openBraceToken,
            this.propertyAssignments = propertyAssignments,
            this.closeBraceToken = closeBraceToken,
            openBraceToken.parent = this,
            !isShared(propertyAssignments) && (propertyAssignments.parent = this),
            closeBraceToken.parent = this;
        }
    }
    export class ObjectCreationExpressionSyntax extends SyntaxNode implements IMemberExpressionSyntax {
        public newKeyword: ISyntaxToken;
        public expression: IMemberExpressionSyntax;
        public argumentList: ArgumentListSyntax;
        public _isMemberExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax) {
            super(data);
            this.newKeyword = newKeyword,
            this.expression = expression,
            this.argumentList = argumentList,
            newKeyword.parent = this,
            expression.parent = this,
            argumentList && (argumentList.parent = this);
        }
    }
    export class ParenthesizedExpressionSyntax extends SyntaxNode implements IPrimaryExpressionSyntax {
        public openParenToken: ISyntaxToken;
        public expression: IExpressionSyntax;
        public closeParenToken: ISyntaxToken;
        public _isPrimaryExpression: any; public _isMemberExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken) {
            super(data);
            this.openParenToken = openParenToken,
            this.expression = expression,
            this.closeParenToken = closeParenToken,
            openParenToken.parent = this,
            expression.parent = this,
            closeParenToken.parent = this;
        }
    }
    export class ParenthesizedArrowFunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public callSignature: CallSignatureSyntax;
        public equalsGreaterThanToken: ISyntaxToken;
        public block: BlockSyntax;
        public expression: IExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax) {
            super(data);
            this.callSignature = callSignature,
            this.equalsGreaterThanToken = equalsGreaterThanToken,
            this.block = block,
            this.expression = expression,
            callSignature.parent = this,
            equalsGreaterThanToken.parent = this,
            block && (block.parent = this),
            expression && (expression.parent = this);
        }
    }
    export class SimpleArrowFunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public identifier: ISyntaxToken;
        public equalsGreaterThanToken: ISyntaxToken;
        public block: BlockSyntax;
        public expression: IExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax) {
            super(data);
            this.identifier = identifier,
            this.equalsGreaterThanToken = equalsGreaterThanToken,
            this.block = block,
            this.expression = expression,
            identifier.parent = this,
            equalsGreaterThanToken.parent = this,
            block && (block.parent = this),
            expression && (expression.parent = this);
        }
    }
    export class CastExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
        public lessThanToken: ISyntaxToken;
        public type: ITypeSyntax;
        public greaterThanToken: ISyntaxToken;
        public expression: IUnaryExpressionSyntax;
        public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax) {
            super(data);
            this.lessThanToken = lessThanToken,
            this.type = type,
            this.greaterThanToken = greaterThanToken,
            this.expression = expression,
            lessThanToken.parent = this,
            type.parent = this,
            greaterThanToken.parent = this,
            expression.parent = this;
        }
    }
    export class ElementAccessExpressionSyntax extends SyntaxNode implements IMemberExpressionSyntax, ICallExpressionSyntax {
        public expression: ILeftHandSideExpressionSyntax;
        public openBracketToken: ISyntaxToken;
        public argumentExpression: IExpressionSyntax;
        public closeBracketToken: ISyntaxToken;
        public _isMemberExpression: any; public _isCallExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, expression: ILeftHandSideExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken) {
            super(data);
            this.expression = expression,
            this.openBracketToken = openBracketToken,
            this.argumentExpression = argumentExpression,
            this.closeBracketToken = closeBracketToken,
            expression.parent = this,
            openBracketToken.parent = this,
            argumentExpression.parent = this,
            closeBracketToken.parent = this;
        }
    }
    export class FunctionExpressionSyntax extends SyntaxNode implements IPrimaryExpressionSyntax {
        public functionKeyword: ISyntaxToken;
        public identifier: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public _isPrimaryExpression: any; public _isMemberExpression: any; public _isLeftHandSideExpression: any; public _isPostfixExpression: any; public _isUnaryExpression: any; public _isExpression: any;
        constructor(data: number, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax) {
            super(data);
            this.functionKeyword = functionKeyword,
            this.identifier = identifier,
            this.callSignature = callSignature,
            this.block = block,
            functionKeyword.parent = this,
            identifier && (identifier.parent = this),
            callSignature.parent = this,
            block.parent = this;
        }
    }
    export class OmittedExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
        public _isExpression: any;
        constructor(data: number) {
            super(data);
        }
    }
    export class VariableDeclarationSyntax extends SyntaxNode {
        public varKeyword: ISyntaxToken;
        public variableDeclarators: VariableDeclaratorSyntax[];
        constructor(data: number, varKeyword: ISyntaxToken, variableDeclarators: VariableDeclaratorSyntax[]) {
            super(data);
            this.varKeyword = varKeyword,
            this.variableDeclarators = variableDeclarators,
            varKeyword.parent = this,
            !isShared(variableDeclarators) && (variableDeclarators.parent = this);
        }
    }
    export class VariableDeclaratorSyntax extends SyntaxNode {
        public propertyName: ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(data: number, propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.typeAnnotation = typeAnnotation,
            this.equalsValueClause = equalsValueClause,
            propertyName.parent = this,
            typeAnnotation && (typeAnnotation.parent = this),
            equalsValueClause && (equalsValueClause.parent = this);
        }
    }
    export class ArgumentListSyntax extends SyntaxNode {
        public typeArgumentList: TypeArgumentListSyntax;
        public openParenToken: ISyntaxToken;
        public arguments: IExpressionSyntax[];
        public closeParenToken: ISyntaxToken;
        constructor(data: number, typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: IExpressionSyntax[], closeParenToken: ISyntaxToken) {
            super(data);
            this.typeArgumentList = typeArgumentList,
            this.openParenToken = openParenToken,
            this.arguments = _arguments,
            this.closeParenToken = closeParenToken,
            typeArgumentList && (typeArgumentList.parent = this),
            openParenToken.parent = this,
            !isShared(_arguments) && (_arguments.parent = this),
            closeParenToken.parent = this;
        }
    }
    export class ParameterListSyntax extends SyntaxNode {
        public openParenToken: ISyntaxToken;
        public parameters: ParameterSyntax[];
        public closeParenToken: ISyntaxToken;
        constructor(data: number, openParenToken: ISyntaxToken, parameters: ParameterSyntax[], closeParenToken: ISyntaxToken) {
            super(data);
            this.openParenToken = openParenToken,
            this.parameters = parameters,
            this.closeParenToken = closeParenToken,
            openParenToken.parent = this,
            !isShared(parameters) && (parameters.parent = this),
            closeParenToken.parent = this;
        }
    }
    export class TypeArgumentListSyntax extends SyntaxNode {
        public lessThanToken: ISyntaxToken;
        public typeArguments: ITypeSyntax[];
        public greaterThanToken: ISyntaxToken;
        constructor(data: number, lessThanToken: ISyntaxToken, typeArguments: ITypeSyntax[], greaterThanToken: ISyntaxToken) {
            super(data);
            this.lessThanToken = lessThanToken,
            this.typeArguments = typeArguments,
            this.greaterThanToken = greaterThanToken,
            lessThanToken.parent = this,
            !isShared(typeArguments) && (typeArguments.parent = this),
            greaterThanToken.parent = this;
        }
    }
    export class TypeParameterListSyntax extends SyntaxNode {
        public lessThanToken: ISyntaxToken;
        public typeParameters: TypeParameterSyntax[];
        public greaterThanToken: ISyntaxToken;
        constructor(data: number, lessThanToken: ISyntaxToken, typeParameters: TypeParameterSyntax[], greaterThanToken: ISyntaxToken) {
            super(data);
            this.lessThanToken = lessThanToken,
            this.typeParameters = typeParameters,
            this.greaterThanToken = greaterThanToken,
            lessThanToken.parent = this,
            !isShared(typeParameters) && (typeParameters.parent = this),
            greaterThanToken.parent = this;
        }
    }
    export class HeritageClauseSyntax extends SyntaxNode {
        public extendsOrImplementsKeyword: ISyntaxToken;
        public typeNames: INameSyntax[];
        constructor(data: number, extendsOrImplementsKeyword: ISyntaxToken, typeNames: INameSyntax[]) {
            super(data);
            this.extendsOrImplementsKeyword = extendsOrImplementsKeyword,
            this.typeNames = typeNames,
            extendsOrImplementsKeyword.parent = this,
            !isShared(typeNames) && (typeNames.parent = this);
        }
        public kind(): SyntaxKind { return this.extendsOrImplementsKeyword.kind() === SyntaxKind.ExtendsKeyword ? SyntaxKind.ExtendsHeritageClause : SyntaxKind.ImplementsHeritageClause; }
    }
    export class EqualsValueClauseSyntax extends SyntaxNode {
        public equalsToken: ISyntaxToken;
        public value: IExpressionSyntax;
        constructor(data: number, equalsToken: ISyntaxToken, value: IExpressionSyntax) {
            super(data);
            this.equalsToken = equalsToken,
            this.value = value,
            equalsToken.parent = this,
            value.parent = this;
        }
    }
    export class CaseSwitchClauseSyntax extends SyntaxNode implements ISwitchClauseSyntax {
        public caseKeyword: ISyntaxToken;
        public expression: IExpressionSyntax;
        public colonToken: ISyntaxToken;
        public statements: IStatementSyntax[];
        public _isSwitchClause: any;
        constructor(data: number, caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: IStatementSyntax[]) {
            super(data);
            this.caseKeyword = caseKeyword,
            this.expression = expression,
            this.colonToken = colonToken,
            this.statements = statements,
            caseKeyword.parent = this,
            expression.parent = this,
            colonToken.parent = this,
            !isShared(statements) && (statements.parent = this);
        }
    }
    export class DefaultSwitchClauseSyntax extends SyntaxNode implements ISwitchClauseSyntax {
        public defaultKeyword: ISyntaxToken;
        public colonToken: ISyntaxToken;
        public statements: IStatementSyntax[];
        public _isSwitchClause: any;
        constructor(data: number, defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: IStatementSyntax[]) {
            super(data);
            this.defaultKeyword = defaultKeyword,
            this.colonToken = colonToken,
            this.statements = statements,
            defaultKeyword.parent = this,
            colonToken.parent = this,
            !isShared(statements) && (statements.parent = this);
        }
    }
    export class ElseClauseSyntax extends SyntaxNode {
        public elseKeyword: ISyntaxToken;
        public statement: IStatementSyntax;
        constructor(data: number, elseKeyword: ISyntaxToken, statement: IStatementSyntax) {
            super(data);
            this.elseKeyword = elseKeyword,
            this.statement = statement,
            elseKeyword.parent = this,
            statement.parent = this;
        }
    }
    export class CatchClauseSyntax extends SyntaxNode {
        public catchKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public identifier: ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public closeParenToken: ISyntaxToken;
        public block: BlockSyntax;
        constructor(data: number, catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax) {
            super(data);
            this.catchKeyword = catchKeyword,
            this.openParenToken = openParenToken,
            this.identifier = identifier,
            this.typeAnnotation = typeAnnotation,
            this.closeParenToken = closeParenToken,
            this.block = block,
            catchKeyword.parent = this,
            openParenToken.parent = this,
            identifier.parent = this,
            typeAnnotation && (typeAnnotation.parent = this),
            closeParenToken.parent = this,
            block.parent = this;
        }
    }
    export class FinallyClauseSyntax extends SyntaxNode {
        public finallyKeyword: ISyntaxToken;
        public block: BlockSyntax;
        constructor(data: number, finallyKeyword: ISyntaxToken, block: BlockSyntax) {
            super(data);
            this.finallyKeyword = finallyKeyword,
            this.block = block,
            finallyKeyword.parent = this,
            block.parent = this;
        }
    }
    export class TypeParameterSyntax extends SyntaxNode {
        public identifier: ISyntaxToken;
        public constraint: ConstraintSyntax;
        constructor(data: number, identifier: ISyntaxToken, constraint: ConstraintSyntax) {
            super(data);
            this.identifier = identifier,
            this.constraint = constraint,
            identifier.parent = this,
            constraint && (constraint.parent = this);
        }
    }
    export class ConstraintSyntax extends SyntaxNode {
        public extendsKeyword: ISyntaxToken;
        public type: ITypeSyntax;
        constructor(data: number, extendsKeyword: ISyntaxToken, type: ITypeSyntax) {
            super(data);
            this.extendsKeyword = extendsKeyword,
            this.type = type,
            extendsKeyword.parent = this,
            type.parent = this;
        }
    }
    export class SimplePropertyAssignmentSyntax extends SyntaxNode implements IPropertyAssignmentSyntax {
        public propertyName: ISyntaxToken;
        public colonToken: ISyntaxToken;
        public expression: IExpressionSyntax;
        public _isPropertyAssignment: any;
        constructor(data: number, propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.colonToken = colonToken,
            this.expression = expression,
            propertyName.parent = this,
            colonToken.parent = this,
            expression.parent = this;
        }
    }
    export class FunctionPropertyAssignmentSyntax extends SyntaxNode implements IPropertyAssignmentSyntax {
        public propertyName: ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public _isPropertyAssignment: any;
        constructor(data: number, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.callSignature = callSignature,
            this.block = block,
            propertyName.parent = this,
            callSignature.parent = this,
            block.parent = this;
        }
    }
    export class ParameterSyntax extends SyntaxNode {
        public dotDotDotToken: ISyntaxToken;
        public modifiers: ISyntaxToken[];
        public identifier: ISyntaxToken;
        public questionToken: ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(data: number, dotDotDotToken: ISyntaxToken, modifiers: ISyntaxToken[], identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax) {
            super(data);
            this.dotDotDotToken = dotDotDotToken,
            this.modifiers = modifiers,
            this.identifier = identifier,
            this.questionToken = questionToken,
            this.typeAnnotation = typeAnnotation,
            this.equalsValueClause = equalsValueClause,
            dotDotDotToken && (dotDotDotToken.parent = this),
            !isShared(modifiers) && (modifiers.parent = this),
            identifier.parent = this,
            questionToken && (questionToken.parent = this),
            typeAnnotation && (typeAnnotation.parent = this),
            equalsValueClause && (equalsValueClause.parent = this);
        }
    }
    export class EnumElementSyntax extends SyntaxNode {
        public propertyName: ISyntaxToken;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(data: number, propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax) {
            super(data);
            this.propertyName = propertyName,
            this.equalsValueClause = equalsValueClause,
            propertyName.parent = this,
            equalsValueClause && (equalsValueClause.parent = this);
        }
    }
    export class TypeAnnotationSyntax extends SyntaxNode {
        public colonToken: ISyntaxToken;
        public type: ITypeSyntax;
        constructor(data: number, colonToken: ISyntaxToken, type: ITypeSyntax) {
            super(data);
            this.colonToken = colonToken,
            this.type = type,
            colonToken.parent = this,
            type.parent = this;
        }
    }
    export class ExternalModuleReferenceSyntax extends SyntaxNode implements IModuleReferenceSyntax {
        public requireKeyword: ISyntaxToken;
        public openParenToken: ISyntaxToken;
        public stringLiteral: ISyntaxToken;
        public closeParenToken: ISyntaxToken;
        public _isModuleReference: any;
        constructor(data: number, requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken) {
            super(data);
            this.requireKeyword = requireKeyword,
            this.openParenToken = openParenToken,
            this.stringLiteral = stringLiteral,
            this.closeParenToken = closeParenToken,
            requireKeyword.parent = this,
            openParenToken.parent = this,
            stringLiteral.parent = this,
            closeParenToken.parent = this;
        }
    }
    export class ModuleNameModuleReferenceSyntax extends SyntaxNode implements IModuleReferenceSyntax {
        public moduleName: INameSyntax;
        public _isModuleReference: any;
        constructor(data: number, moduleName: INameSyntax) {
            super(data);
            this.moduleName = moduleName,
            moduleName.parent = this;
        }
    }

    (<any>SourceUnitSyntax).prototype.__kind = SyntaxKind.SourceUnit, (<any>QualifiedNameSyntax).prototype.__kind = SyntaxKind.QualifiedName, (<any>ObjectTypeSyntax).prototype.__kind = SyntaxKind.ObjectType, (<any>FunctionTypeSyntax).prototype.__kind = SyntaxKind.FunctionType, (<any>ArrayTypeSyntax).prototype.__kind = SyntaxKind.ArrayType, (<any>ConstructorTypeSyntax).prototype.__kind = SyntaxKind.ConstructorType, (<any>GenericTypeSyntax).prototype.__kind = SyntaxKind.GenericType, (<any>TypeQuerySyntax).prototype.__kind = SyntaxKind.TypeQuery, (<any>InterfaceDeclarationSyntax).prototype.__kind = SyntaxKind.InterfaceDeclaration, (<any>FunctionDeclarationSyntax).prototype.__kind = SyntaxKind.FunctionDeclaration, (<any>ModuleDeclarationSyntax).prototype.__kind = SyntaxKind.ModuleDeclaration, (<any>ClassDeclarationSyntax).prototype.__kind = SyntaxKind.ClassDeclaration, (<any>EnumDeclarationSyntax).prototype.__kind = SyntaxKind.EnumDeclaration, (<any>ImportDeclarationSyntax).prototype.__kind = SyntaxKind.ImportDeclaration, (<any>ExportAssignmentSyntax).prototype.__kind = SyntaxKind.ExportAssignment, (<any>MemberFunctionDeclarationSyntax).prototype.__kind = SyntaxKind.MemberFunctionDeclaration, (<any>MemberVariableDeclarationSyntax).prototype.__kind = SyntaxKind.MemberVariableDeclaration, (<any>ConstructorDeclarationSyntax).prototype.__kind = SyntaxKind.ConstructorDeclaration, (<any>IndexMemberDeclarationSyntax).prototype.__kind = SyntaxKind.IndexMemberDeclaration, (<any>GetAccessorSyntax).prototype.__kind = SyntaxKind.GetAccessor, (<any>SetAccessorSyntax).prototype.__kind = SyntaxKind.SetAccessor, (<any>PropertySignatureSyntax).prototype.__kind = SyntaxKind.PropertySignature, (<any>CallSignatureSyntax).prototype.__kind = SyntaxKind.CallSignature, (<any>ConstructSignatureSyntax).prototype.__kind = SyntaxKind.ConstructSignature, (<any>IndexSignatureSyntax).prototype.__kind = SyntaxKind.IndexSignature, (<any>MethodSignatureSyntax).prototype.__kind = SyntaxKind.MethodSignature, (<any>BlockSyntax).prototype.__kind = SyntaxKind.Block, (<any>IfStatementSyntax).prototype.__kind = SyntaxKind.IfStatement, (<any>VariableStatementSyntax).prototype.__kind = SyntaxKind.VariableStatement, (<any>ExpressionStatementSyntax).prototype.__kind = SyntaxKind.ExpressionStatement, (<any>ReturnStatementSyntax).prototype.__kind = SyntaxKind.ReturnStatement, (<any>SwitchStatementSyntax).prototype.__kind = SyntaxKind.SwitchStatement, (<any>BreakStatementSyntax).prototype.__kind = SyntaxKind.BreakStatement, (<any>ContinueStatementSyntax).prototype.__kind = SyntaxKind.ContinueStatement, (<any>ForStatementSyntax).prototype.__kind = SyntaxKind.ForStatement, (<any>ForInStatementSyntax).prototype.__kind = SyntaxKind.ForInStatement, (<any>EmptyStatementSyntax).prototype.__kind = SyntaxKind.EmptyStatement, (<any>ThrowStatementSyntax).prototype.__kind = SyntaxKind.ThrowStatement, (<any>WhileStatementSyntax).prototype.__kind = SyntaxKind.WhileStatement, (<any>TryStatementSyntax).prototype.__kind = SyntaxKind.TryStatement, (<any>LabeledStatementSyntax).prototype.__kind = SyntaxKind.LabeledStatement, (<any>DoStatementSyntax).prototype.__kind = SyntaxKind.DoStatement, (<any>DebuggerStatementSyntax).prototype.__kind = SyntaxKind.DebuggerStatement, (<any>WithStatementSyntax).prototype.__kind = SyntaxKind.WithStatement, (<any>DeleteExpressionSyntax).prototype.__kind = SyntaxKind.DeleteExpression, (<any>TypeOfExpressionSyntax).prototype.__kind = SyntaxKind.TypeOfExpression, (<any>VoidExpressionSyntax).prototype.__kind = SyntaxKind.VoidExpression, (<any>ConditionalExpressionSyntax).prototype.__kind = SyntaxKind.ConditionalExpression, (<any>MemberAccessExpressionSyntax).prototype.__kind = SyntaxKind.MemberAccessExpression, (<any>InvocationExpressionSyntax).prototype.__kind = SyntaxKind.InvocationExpression, (<any>ArrayLiteralExpressionSyntax).prototype.__kind = SyntaxKind.ArrayLiteralExpression, (<any>ObjectLiteralExpressionSyntax).prototype.__kind = SyntaxKind.ObjectLiteralExpression, (<any>ObjectCreationExpressionSyntax).prototype.__kind = SyntaxKind.ObjectCreationExpression, (<any>ParenthesizedExpressionSyntax).prototype.__kind = SyntaxKind.ParenthesizedExpression, (<any>ParenthesizedArrowFunctionExpressionSyntax).prototype.__kind = SyntaxKind.ParenthesizedArrowFunctionExpression, (<any>SimpleArrowFunctionExpressionSyntax).prototype.__kind = SyntaxKind.SimpleArrowFunctionExpression, (<any>CastExpressionSyntax).prototype.__kind = SyntaxKind.CastExpression, (<any>ElementAccessExpressionSyntax).prototype.__kind = SyntaxKind.ElementAccessExpression, (<any>FunctionExpressionSyntax).prototype.__kind = SyntaxKind.FunctionExpression, (<any>OmittedExpressionSyntax).prototype.__kind = SyntaxKind.OmittedExpression, (<any>VariableDeclarationSyntax).prototype.__kind = SyntaxKind.VariableDeclaration, (<any>VariableDeclaratorSyntax).prototype.__kind = SyntaxKind.VariableDeclarator, (<any>ArgumentListSyntax).prototype.__kind = SyntaxKind.ArgumentList, (<any>ParameterListSyntax).prototype.__kind = SyntaxKind.ParameterList, (<any>TypeArgumentListSyntax).prototype.__kind = SyntaxKind.TypeArgumentList, (<any>TypeParameterListSyntax).prototype.__kind = SyntaxKind.TypeParameterList, (<any>EqualsValueClauseSyntax).prototype.__kind = SyntaxKind.EqualsValueClause, (<any>CaseSwitchClauseSyntax).prototype.__kind = SyntaxKind.CaseSwitchClause, (<any>DefaultSwitchClauseSyntax).prototype.__kind = SyntaxKind.DefaultSwitchClause, (<any>ElseClauseSyntax).prototype.__kind = SyntaxKind.ElseClause, (<any>CatchClauseSyntax).prototype.__kind = SyntaxKind.CatchClause, (<any>FinallyClauseSyntax).prototype.__kind = SyntaxKind.FinallyClause, (<any>TypeParameterSyntax).prototype.__kind = SyntaxKind.TypeParameter, (<any>ConstraintSyntax).prototype.__kind = SyntaxKind.Constraint, (<any>SimplePropertyAssignmentSyntax).prototype.__kind = SyntaxKind.SimplePropertyAssignment, (<any>FunctionPropertyAssignmentSyntax).prototype.__kind = SyntaxKind.FunctionPropertyAssignment, (<any>ParameterSyntax).prototype.__kind = SyntaxKind.Parameter, (<any>EnumElementSyntax).prototype.__kind = SyntaxKind.EnumElement, (<any>TypeAnnotationSyntax).prototype.__kind = SyntaxKind.TypeAnnotation, (<any>ExternalModuleReferenceSyntax).prototype.__kind = SyntaxKind.ExternalModuleReference, (<any>ModuleNameModuleReferenceSyntax).prototype.__kind = SyntaxKind.ModuleNameModuleReference;
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISyntaxToken extends ISyntaxNodeOrToken, INameSyntax, IPrimaryExpressionSyntax {
        // Adjusts the full start and text of this token.  Should only be called by the parser.
        setTextAndFullStart(text: ISimpleText, fullStart: number): void;

        // The absolute start of this element, including the leading trivia.
        fullStart(): number;

        // With of this element, including leading and trailing trivia.
        fullWidth(): number;

        // Text for this token, not including leading or trailing trivia.
        text(): string;
        fullText(): string;

        hasLeadingTrivia(): boolean;
        hasLeadingComment(): boolean;
        hasLeadingNewLine(): boolean;

        hasTrailingTrivia(): boolean;
        hasTrailingComment(): boolean;
        hasTrailingNewLine(): boolean;

        hasSkippedToken(): boolean;

        leadingTrivia(): ISyntaxTriviaList;
        trailingTrivia(): ISyntaxTriviaList;

        leadingTriviaWidth(): number;
        trailingTriviaWidth(): number;

        // True if this was a keyword that the parser converted to an identifier.  i.e. if you have
        //      x.public
        //
        // then 'public' will be converted to an identifier.  These tokens should are parser 
        // generated and, as such, should not be returned when the incremental parser source
        // hands out tokens.  Note: If it is included in a node then *that* node may still
        // be reusuable.  i.e. if i have:  private Foo() { x.public = 1; }
        //
        // Then that entire method node is reusable even if the 'public' identifier is not.
        isKeywordConvertedToIdentifier(): boolean;
        convertKeywordToIdentifier(): ISyntaxToken;

        // True if this element cannot be reused in incremental parsing.  There are several situations
        // in which an element can not be reused.  They are:
        //
        // 1) The element contained skipped text.
        // 2) The element contained zero width tokens.
        // 3) The element contains tokens generated by the parser (like >> or a keyword -> identifier
        //    conversion).
        // 4) The element contains a regex token somewhere under it.  A regex token is either a 
        //    regex itself (i.e. /foo/), or is a token which could start a regex (i.e. "/" or "/=").  This
        //    data is used by the incremental parser to decide if a node can be reused.  Due to the 
        //    lookahead nature of regex tokens, a node containing a regex token cannot be reused.  Normally,
        //    changes to text only affect the tokens directly intersected.  However, because regex tokens 
        //    have such unbounded lookahead (technically bounded at the end of a line, but htat's minor), 
        //    we need to recheck them to see if they've changed due to the edit.  For example, if you had:
        //    
        //         while (true) /3; return;
        //    
        //    And you changed it to:
        //    
        //         while (true) /3; return/;
        //    
        //    Then even though only the 'return' and ';' colons were touched, we'd want to rescan the '/'
        //    token which we would then realize was a regex.
        isIncrementallyUnusable(): boolean;

        clone(): ISyntaxToken;
    }

    export interface ITokenInfo {
        leadingTrivia?: ISyntaxTrivia[];
        text?: string;
        trailingTrivia?: ISyntaxTrivia[];
    }
}

module TypeScript {
    export function tokenValue(token: ISyntaxToken): any {
        if (token.fullWidth() === 0) {
            return null;
        }

        var kind = token.kind();
        var text = token.text();

        if (kind === SyntaxKind.IdentifierName) {
            return massageEscapes(text);
        }

        switch (kind) {
            case SyntaxKind.TrueKeyword:
                return true;
            case SyntaxKind.FalseKeyword:
                return false;
            case SyntaxKind.NullKeyword:
                return null;
        }

        if (SyntaxFacts.isAnyKeyword(kind) || SyntaxFacts.isAnyPunctuation(kind)) {
            return SyntaxFacts.getText(kind);
        }

        if (kind === SyntaxKind.NumericLiteral) {
            return IntegerUtilities.isHexInteger(text) ? parseInt(text, /*radix:*/ 16) : parseFloat(text);
        }
        else if (kind === SyntaxKind.StringLiteral) {
            if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                // Properly terminated.  Remove the quotes, and massage any escape characters we see.
                return massageEscapes(text.substr(1, text.length - 2));
            }
            else {
                // Not property terminated.  Remove the first quote and massage any escape characters we see.
                return massageEscapes(text.substr(1));

            }
        }
        else if (kind === SyntaxKind.RegularExpressionLiteral) {
            return regularExpressionValue(text);
        }
        else if (kind === SyntaxKind.EndOfFileToken || kind === SyntaxKind.ErrorToken) {
            return null;
        }
        else {
            throw Errors.invalidOperation();
        }
    }

    export function tokenValueText(token: ISyntaxToken): string {
        var value = tokenValue(token);
        return value === null ? "" : massageDisallowedIdentifiers(value.toString());
    }

    export function massageEscapes(text: string): string {
        return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
    }

    function regularExpressionValue(text: string): RegExp {
        try {
            var lastSlash = text.lastIndexOf("/");
            var body = text.substring(1, lastSlash);
            var flags = text.substring(lastSlash + 1);
            return new RegExp(body, flags);
        }
        catch (e) {
            return null;
        }
    }

    function massageDisallowedIdentifiers(text: string): string {
        // A bit of an unfortunate hack we need to run on some downlevel browsers. 
        // The problem is that we use a token's valueText as a key in many of our collections.  
        // Unfortunately, if that key turns out to be __proto__, then that breaks in some browsers
        // due to that being a reserved way to get to the object's prototyped.  To workaround this
        // we ensure that the valueText of any token is not __proto__ but is instead #__proto__.
        if (text === "__proto__") {
            return "#__proto__";
        }

        return text;
    }

    var characterArray: number[] = [];

    function convertEscapes(text: string): string {
        characterArray.length = 0;
        var result = "";

        for (var i = 0, n = text.length; i < n; i++) {
            var ch = text.charCodeAt(i);

            if (ch === CharacterCodes.backslash) {
                i++;
                if (i < n) {
                    ch = text.charCodeAt(i);
                    switch (ch) {
                        case CharacterCodes._0:
                            characterArray.push(CharacterCodes.nullCharacter);
                            continue;

                        case CharacterCodes.b:
                            characterArray.push(CharacterCodes.backspace);
                            continue;

                        case CharacterCodes.f:
                            characterArray.push(CharacterCodes.formFeed);
                            continue;

                        case CharacterCodes.n:
                            characterArray.push(CharacterCodes.lineFeed);
                            continue;

                        case CharacterCodes.r:
                            characterArray.push(CharacterCodes.carriageReturn);
                            continue;

                        case CharacterCodes.t:
                            characterArray.push(CharacterCodes.tab);
                            continue;

                        case CharacterCodes.v:
                            characterArray.push(CharacterCodes.verticalTab);
                            continue;

                        case CharacterCodes.x:
                            characterArray.push(hexValue(text, /*start:*/ i + 1, /*length:*/ 2));
                            i += 2;
                            continue;

                        case CharacterCodes.u:
                            characterArray.push(hexValue(text, /*start:*/ i + 1, /*length:*/ 4));
                            i += 4;
                            continue;

                        case CharacterCodes.carriageReturn:
                            var nextIndex = i + 1;
                            if (nextIndex < text.length && text.charCodeAt(nextIndex) === CharacterCodes.lineFeed) {
                                // Skip the entire \r\n sequence.
                                i++;
                            }
                            continue;

                        case CharacterCodes.lineFeed:
                        case CharacterCodes.paragraphSeparator:
                        case CharacterCodes.lineSeparator:
                            // From ES5: LineContinuation is the empty character sequence.
                            continue;

                        default:
                        // Any other character is ok as well.  As per rule:
                        // EscapeSequence :: CharacterEscapeSequence
                        // CharacterEscapeSequence :: NonEscapeCharacter
                        // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
                        //
                        // Intentional fall through
                    }
                }
            }

            characterArray.push(ch);

            if (i && !(i % 1024)) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
                characterArray.length = 0;
            }
        }

        if (characterArray.length) {
            result = result.concat(String.fromCharCode.apply(null, characterArray));
        }

        return result;
    }

    function hexValue(text: string, start: number, length: number): number {
        var intChar = 0;
        for (var i = 0; i < length; i++) {
            var ch2 = text.charCodeAt(start + i);
            if (!CharacterInfo.isHexDigit(ch2)) {
                break;
            }

            intChar = (intChar << 4) + CharacterInfo.hexValue(ch2);
        }

        return intChar;
    }
}

module TypeScript.Syntax {
    export function realizeToken(token: ISyntaxToken): ISyntaxToken {
        return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(), token.text(), token.trailingTrivia());
    }

    export function withLeadingTrivia(token: ISyntaxToken, leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
        return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), leadingTrivia, token.text(), token.trailingTrivia());
    }

    export function withTrailingTrivia(token: ISyntaxToken, trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
        return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(), token.text(), trailingTrivia);
    }


    export function emptyToken(kind: SyntaxKind): ISyntaxToken {
        return new EmptyToken(kind);
    }

    class EmptyToken implements ISyntaxToken {
        public parent: ISyntaxElement = null;
        public data: number;

        public _isPrimaryExpression: any;
        public _isMemberExpression: any;
        public _isLeftHandSideExpression: any;
        public _isPostfixExpression: any;
        public _isUnaryExpression: any;
        public _isExpression: any;

        constructor(private _kind: SyntaxKind) {
        }

        public setTextAndFullStart(text: ISimpleText, fullStart: number): void {
            // An empty token is always at the -1 position.
            // An empty token has no need to point at an underlying text.
        }

        public kind(): SyntaxKind {
            return this._kind;
        }

        public clone(): ISyntaxToken {
            return new EmptyToken(this.kind());
        }

        private findTokenInternal(parent: ISyntaxElement, position: number, fullStart: number): ISyntaxToken {
            return this;
        }

        // Empty tokens are never incrementally reusable.
        public isIncrementallyUnusable() { return true; }

        public isKeywordConvertedToIdentifier() {
            return false;
        }

        public convertKeywordToIdentifier(): ISyntaxToken {
            // We shouldn't ever be called.
            throw Errors.invalidOperation();
        }

        public fullWidth() { return 0; }

        private position(): number {
            // It's hard for us to tell the position of an empty token at the eact time we create 
            // it.  For example, we may have:
            //
            //      a / finally
            //
            // There will be a missing token detected after the forward slash, so it would be 
            // tempting to set its position as the full-end of hte slash token. However, 
            // immediately after that, the 'finally' token will be skipped and will be attached
            // as skipped text to the forward slash.  This means the 'full-end' of the forward
            // slash will change, and thus the empty token will now appear to be embedded inside
            // another token.  This violates are rule that all tokens must only touch at the end,
            // and makes enforcing invariants much harder.
            //
            // To address this we create the empty token with no known position, and then we 
            // determine what it's position should be based on where it lies in the tree.  
            // Specifically, we find the previous non-zero-width syntax element, and we consider
            // the full-start of this token to be at the full-end of that element.

            var previousElement = this.previousNonZeroWidthElement();
            return previousElement === null ? 0 : fullStart(previousElement) + fullWidth(previousElement);
        }

        private previousNonZeroWidthElement(): ISyntaxElement {
            var current: ISyntaxElement = this;
            while (true) {
                var parent = current.parent;
                if (parent === null) {
                    Debug.assert(current.kind() === SyntaxKind.SourceUnit, "We had a node without a parent that was not the root node!");

                    // We walked all the way to the top, and never found a previous element.  This 
                    // can happen with code like:
                    //
                    //      / b;
                    //
                    // We will have an empty identifier token as the first token in the tree.  In
                    // this case, return null so that the position of the empty token will be 
                    // considered to be 0.
                    return null;
                }

                // Ok.  We have a parent.  First, find out which slot we're at in the parent.
                for (var i = 0, n = childCount(parent); i < n; i++) {
                    if (childAt(parent, i) === current) {
                        break;
                    }
                }

                Debug.assert(i !== n, "Could not find current element in parent's child list!");

                // Walk backward from this element, looking for a non-zero-width sibling.
                for (var j = i - 1; j >= 0; j--) {
                    var sibling = childAt(parent, j);
                    if (sibling && fullWidth(sibling) > 0) {
                        return sibling;
                    }
                }

                // We couldn't find a non-zero-width sibling.  We were either the first element, or
                // all preceding elements are empty.  So, move up to our parent so we we can find
                // its preceding sibling.
                current = current.parent;
            }
        }

        public fullStart(): number {
            return this.position();
        }

        public text() { return ""; }
        public fullText(): string { return ""; }

        public hasLeadingTrivia() { return false; }
        public hasLeadingComment() { return false; }
        public hasLeadingNewLine() { return false; }
        public leadingTriviaWidth() { return 0; }
        public hasTrailingTrivia() { return false; }
        public hasTrailingComment() { return false; }
        public hasTrailingNewLine() { return false; }
        public hasSkippedToken() { return false; }

        public trailingTriviaWidth() { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
    }

    class RealizedToken implements ISyntaxToken {
        public parent: ISyntaxElement = null;
        public data: number;
        private _fullStart: number;
        private _kind: SyntaxKind;
        private _isKeywordConvertedToIdentifier: boolean;
        private _leadingTrivia: ISyntaxTriviaList;
        private _text: string;
        private _trailingTrivia: ISyntaxTriviaList;

        public _isPrimaryExpression: any;
        public _isMemberExpression: any;
        public _isLeftHandSideExpression: any;
        public _isPostfixExpression: any;
        public _isUnaryExpression: any;
        public _isExpression: any;

        constructor(fullStart: number,
                    kind: SyntaxKind,
                    isKeywordConvertedToIdentifier: boolean,
                    leadingTrivia: ISyntaxTriviaList,
                    text: string,
                    trailingTrivia: ISyntaxTriviaList) {
            this._fullStart = fullStart;
            this._kind = kind;
            this._isKeywordConvertedToIdentifier = isKeywordConvertedToIdentifier;
            this._text = text;

            this._leadingTrivia = leadingTrivia.clone();
            this._trailingTrivia = trailingTrivia.clone();

            if (!this._leadingTrivia.isShared()) {
                this._leadingTrivia.parent = this;
            }

            if (!this._trailingTrivia.isShared()) {
                this._trailingTrivia.parent = this;
            }
        }

        public setTextAndFullStart(text: ISimpleText, fullStart: number): void {
            // realized token has no need to hold onto the text.
            this._fullStart = fullStart;
        }

        public kind(): SyntaxKind {
            return this._kind;
        }

        public clone(): ISyntaxToken {
            return new RealizedToken(this._fullStart, this.kind(), this._isKeywordConvertedToIdentifier, this._leadingTrivia, this._text, this._trailingTrivia);
        }

        // Realized tokens are created from the parser.  They are *never* incrementally reusable.
        public isIncrementallyUnusable() { return true; }

        public isKeywordConvertedToIdentifier() { 
            return this._isKeywordConvertedToIdentifier; 
        }

        public convertKeywordToIdentifier(): ISyntaxToken {
            return new RealizedToken(this._fullStart, SyntaxKind.IdentifierName, /*isKeywordConvertedToIdentifier:*/ true, this._leadingTrivia, this._text, this._trailingTrivia);
        }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxElement {
            throw Errors.argumentOutOfRange("index");
        }

        public fullStart(): number { return this._fullStart; }
        public fullWidth(): number { return this._leadingTrivia.fullWidth() + this._text.length + this._trailingTrivia.fullWidth(); }

        public text(): string { return this._text; }
        public fullText(): string { return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText(); }

        public hasLeadingTrivia(): boolean { return this._leadingTrivia.count() > 0; }
        public hasLeadingComment(): boolean { return this._leadingTrivia.hasComment(); }
        public hasLeadingNewLine(): boolean { return this._leadingTrivia.hasNewLine(); }
        public leadingTriviaWidth(): number { return this._leadingTrivia.fullWidth(); }

        public hasTrailingTrivia(): boolean { return this._trailingTrivia.count() > 0; }
        public hasTrailingComment(): boolean { return this._trailingTrivia.hasComment(); }
        public hasTrailingNewLine(): boolean { return this._trailingTrivia.hasNewLine(); }
        public trailingTriviaWidth(): number { return this._trailingTrivia.fullWidth(); }

        public hasSkippedToken(): boolean { return this._leadingTrivia.hasSkippedToken() || this._trailingTrivia.hasSkippedToken(); }

        public leadingTrivia(): ISyntaxTriviaList { return this._leadingTrivia; }
        public trailingTrivia(): ISyntaxTriviaList { return this._trailingTrivia; }

        private findTokenInternal(parent: ISyntaxElement, position: number, fullStart: number): ISyntaxToken {
            return this;
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(this._fullStart, this.kind(), this._isKeywordConvertedToIdentifier, leadingTrivia, this._text, this._trailingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(this._fullStart, this.kind(), this._isKeywordConvertedToIdentifier, this._leadingTrivia, this._text, trailingTrivia);
        }
    }

    export function token(kind: SyntaxKind, info: ITokenInfo = null, fullStart = -1): ISyntaxToken {
        var text = (info !== null && info.text !== undefined) ? info.text : SyntaxFacts.getText(kind);

        return new RealizedToken(
            fullStart, kind, false, Syntax.triviaList(info === null ? null : info.leadingTrivia), text, Syntax.triviaList(info === null ? null : info.trailingTrivia));
    }
    
    export function identifier(text: string, info: ITokenInfo = null): ISyntaxToken {
        info = info || {};
        info.text = text;
        return token(SyntaxKind.IdentifierName, info);
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class SyntaxTree {
        private _sourceUnit: SourceUnitSyntax;
        private _isDeclaration: boolean;
        private _parserDiagnostics: Diagnostic[];
        private _allDiagnostics: Diagnostic[] = null;
        private _fileName: string;
        private _lineMap: LineMap;
        private _languageVersion: LanguageVersion;

        constructor(sourceUnit: SourceUnitSyntax,
                    isDeclaration: boolean,
                    diagnostics: Diagnostic[],
                    fileName: string,
                    lineMap: LineMap,
                    languageVersion: LanguageVersion) {
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._languageVersion = languageVersion;

            sourceUnit.syntaxTree = this;
        }

        public sourceUnit(): SourceUnitSyntax {
            return this._sourceUnit;
        }

        public isDeclaration(): boolean {
            return this._isDeclaration;
        }

        private computeDiagnostics(): Diagnostic[] {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }

            // No parser reported diagnostics.  Check for any additional grammar diagnostics.
            var diagnostics: Diagnostic[] = [];
            visitNodeOrToken(new GrammarCheckerWalker(this, diagnostics), this.sourceUnit());

            return diagnostics;
        }

        public diagnostics(): Diagnostic[] {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }

            return this._allDiagnostics;
        }

        public fileName(): string {
            return this._fileName;
        }

        public lineMap(): LineMap {
            return this._lineMap;
        }

        public languageVersion(): LanguageVersion {
            return this._languageVersion;
        }
    }

    class GrammarCheckerWalker extends SyntaxWalker {
        private inAmbientDeclaration: boolean = false;
        private inBlock: boolean = false;
        private inObjectLiteralExpression: boolean = false;
        private currentConstructor: ConstructorDeclarationSyntax = null;

        constructor(private syntaxTree: SyntaxTree,
                    private diagnostics: Diagnostic[]) {
            super();
        }

        private pushDiagnostic(element: ISyntaxElement, diagnosticKey: string, args: any[] = null): void {
            this.diagnostics.push(new Diagnostic(
                this.syntaxTree.fileName(), this.syntaxTree.lineMap(), start(element), width(element), diagnosticKey, args));
        }

        public visitCatchClause(node: CatchClauseSyntax): void {
            if (node.typeAnnotation) {
                this.pushDiagnostic(node.typeAnnotation,
                    DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
            }

            super.visitCatchClause(node);
        }

        private checkParameterListOrder(node: ParameterListSyntax): boolean {
            var seenOptionalParameter = false;
            var parameterCount = node.parameters.length;

            for (var i = 0; i < parameterCount; i++) {
                var parameter = node.parameters[i];

                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        this.pushDiagnostic(
                            parameter,
                            DiagnosticCode.Rest_parameter_must_be_last_in_list);
                        return true;
                    }

                    if (parameter.questionToken) {
                        this.pushDiagnostic(
                            parameter,
                            DiagnosticCode.Rest_parameter_cannot_be_optional);
                        return true;
                    }

                    if (parameter.equalsValueClause) {
                        this.pushDiagnostic(
                            parameter,
                            DiagnosticCode.Rest_parameter_cannot_have_an_initializer);
                        return true;
                    }
                }
                else if (parameter.questionToken || parameter.equalsValueClause) {
                    seenOptionalParameter = true;

                    if (parameter.questionToken && parameter.equalsValueClause) {
                        this.pushDiagnostic(
                            parameter,
                            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                        return true;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        this.pushDiagnostic(
                            parameter,
                            DiagnosticCode.Required_parameter_cannot_follow_optional_parameter);
                        return true;
                    }
                }
            }

            return false;
        }

        private checkParameterListAcessibilityModifiers(node: ParameterListSyntax): boolean {
            for (var i = 0, n = node.parameters.length; i < n; i++) {
                var parameter = node.parameters[i];

                if (this.checkParameterAccessibilityModifiers(node, parameter)) {
                    return true;
                }
            }

            return false;
        }

        private checkParameterAccessibilityModifiers(parameterList: ParameterListSyntax, parameter: ParameterSyntax): boolean {
            if (parameter.modifiers.length > 0) {
                var modifiers = parameter.modifiers;

                for (var i = 0, n = modifiers.length; i < n; i++) {
                    var modifier = modifiers[i];

                    if (this.checkParameterAccessibilityModifier(parameterList, modifier, i)) {
                        return true;
                    }
                }
            }

            return false;
        }

        private checkParameterAccessibilityModifier(parameterList: ParameterListSyntax, modifier: ISyntaxToken, modifierIndex: number): boolean {
            if (modifier.kind() !== SyntaxKind.PublicKeyword && modifier.kind() !== SyntaxKind.PrivateKeyword) {
                this.pushDiagnostic(modifier,
                    DiagnosticCode._0_modifier_cannot_appear_on_a_parameter, [modifier.text()]);
                return true;
            }
            else {
                if (modifierIndex > 0) {
                    this.pushDiagnostic(modifier, DiagnosticCode.Accessibility_modifier_already_seen);
                    return true;
                }

                if (!this.inAmbientDeclaration && this.currentConstructor && !this.currentConstructor.block && this.currentConstructor.callSignature.parameterList === parameterList) {
                    this.pushDiagnostic(modifier,
                        DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_a_constructor_overload);
                    return true;
                }
                else if (this.inAmbientDeclaration || this.currentConstructor === null || this.currentConstructor.callSignature.parameterList !== parameterList) {
                    this.pushDiagnostic(modifier,
                        DiagnosticCode.Parameter_property_declarations_can_only_be_used_in_a_non_ambient_constructor_declaration);
                    return true;
                }
            }

            return false;
        }

        private checkForTrailingSeparator(parent: ISyntaxElement, list: ISyntaxNodeOrToken[]): boolean {
            // If we have at least one child, and we have an even number of children, then that 
            // means we have an illegal trailing separator.
            if (childCount(list) === 0 || childCount(list) % 2 === 1) {
                return false;
            }

            var child = childAt(list, childCount(list) - 1);
            this.pushDiagnostic(child, DiagnosticCode.Trailing_separator_not_allowed);

            return true;
        }

        private checkForAtLeastOneElement(parent: ISyntaxElement, list: ISyntaxNodeOrToken[], expected: string): boolean {
            if (childCount(list) > 0) {
                return false;
            }

            var listFullStart = fullStart(parent) + Syntax.childOffset(parent, list);
            var tokenAtStart = findToken(this.syntaxTree.sourceUnit(), listFullStart);

            this.pushDiagnostic(tokenAtStart, DiagnosticCode.Unexpected_token_0_expected, [expected]);

            return true;
        }

        public visitParameterList(node: ParameterListSyntax): void {
            if (this.checkParameterListAcessibilityModifiers(node) ||
                this.checkParameterListOrder(node) ||
                this.checkForTrailingSeparator(node, node.parameters)) {

                return;
            }

            super.visitParameterList(node);
        }

        public visitHeritageClause(node: HeritageClauseSyntax): void {
            if (this.checkForTrailingSeparator(node, node.typeNames) ||
                this.checkForAtLeastOneElement(node, node.typeNames, getLocalizedText(DiagnosticCode.type_name, null))) {
                return;
            }

            super.visitHeritageClause(node);
        }

        public visitArgumentList(node: ArgumentListSyntax): void {
            if (this.checkForTrailingSeparator(node, node.arguments)) {
                return;
            }

            super.visitArgumentList(node);
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): void {
            if (this.checkForAtLeastOneElement(node, node.variableDeclarators, getLocalizedText(DiagnosticCode.identifier, null))) {
                return;
            }

            // If we have at least one child, and we have an even number of children, then that 
            // means we have an illegal trailing separator.
            var declarators = node.variableDeclarators;
            if (childCount(declarators) % 2 === 0) {
                var lastComma = declarators.separatorAt(declarators.separatorCount() - 1);
                Debug.assert(isToken(lastComma));

                var _nextToken = nextToken(lastComma, /*includeSkippedTokens:*/ true);
                this.pushDiagnostic(_nextToken, DiagnosticCode.Identifier_expected);
                return;
            }

            super.visitVariableDeclaration(node);
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): void {
            if (this.checkForTrailingSeparator(node, node.typeArguments) ||
                this.checkForAtLeastOneElement(node, node.typeArguments, getLocalizedText(DiagnosticCode.identifier, null))) {
                return;
            }

            super.visitTypeArgumentList(node);
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): void {
            if (this.checkForTrailingSeparator(node, node.typeParameters) ||
                this.checkForAtLeastOneElement(node, node.typeParameters, getLocalizedText(DiagnosticCode.identifier, null))) {
                return;
            }

            super.visitTypeParameterList(node);
        }

        private checkIndexSignatureParameter(node: IndexSignatureSyntax): boolean {
            var parameter = node.parameter;

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            }
            else if (parameter.modifiers.length > 0) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            }
            else if (parameter.questionToken) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            }
            else if (parameter.equalsValueClause) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            }
            else if (!parameter.typeAnnotation) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            }
            else if (parameter.typeAnnotation.type.kind() !== SyntaxKind.StringKeyword &&
                     parameter.typeAnnotation.type.kind() !== SyntaxKind.NumberKeyword) {
                this.pushDiagnostic(
                    parameter,
                    DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }

            return false;
        }

        public visitIndexSignature(node: IndexSignatureSyntax): void {
            if (this.checkIndexSignatureParameter(node)) {
                return;
            }

            if (!node.typeAnnotation) {
                this.pushDiagnostic(node, DiagnosticCode.Index_signature_must_have_a_type_annotation);
                return;
            }

            super.visitIndexSignature(node);
        }

        private checkClassDeclarationHeritageClauses(node: ClassDeclarationSyntax): boolean {
            var seenExtendsClause = false;
            var seenImplementsClause = false;

            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses[i];

                if (heritageClause.extendsOrImplementsKeyword.kind() === SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause,
                            DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause,
                            DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }

                    if (heritageClause.typeNames.length > 1) {
                        this.pushDiagnostic(heritageClause,
                            DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }

                    seenExtendsClause = true;
                }
                else {
                    Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === SyntaxKind.ImplementsKeyword);
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause,
                            DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }

                    seenImplementsClause = true;
                }
            }

            return false;
        }

        private checkForDisallowedDeclareModifier(modifiers: ISyntaxToken[]): boolean {
            if (this.inAmbientDeclaration) {
                // If we're already in an ambient declaration, then 'declare' is not allowed.
                var declareToken = SyntaxUtilities.getToken(modifiers, SyntaxKind.DeclareKeyword);

                if (declareToken) {
                    this.pushDiagnostic(declareToken,
                        DiagnosticCode.declare_modifier_not_allowed_for_code_already_in_an_ambient_context);
                    return true;
                }
            }

            return false;
        }

        private checkForRequiredDeclareModifier(moduleElement: IModuleElementSyntax,
                                                typeKeyword: ISyntaxElement,
                                                modifiers: ISyntaxToken[]): boolean {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                // We're at the top level in a declaration file, a 'declare' modifiers is required
                // on most module elements.
                if (!SyntaxUtilities.containsToken(modifiers, SyntaxKind.DeclareKeyword)) {
                    this.pushDiagnostic(firstToken(typeKeyword),
                        DiagnosticCode.declare_modifier_required_for_top_level_element);
                    return true;
                }
            }
        }

        private checkFunctionOverloads(node: ISyntaxElement, moduleElements: IModuleElementSyntax[]): boolean {
            if (!this.inAmbientDeclaration && !this.syntaxTree.isDeclaration()) {
                var inFunctionOverloadChain = false;
                var functionOverloadChainName: string = null;

                for (var i = 0, n = moduleElements.length; i < n; i++) {
                    var moduleElement = moduleElements[i];
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== SyntaxKind.FunctionDeclaration) {
                            this.pushDiagnostic(firstToken(moduleElement),
                                DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        var functionDeclaration = <FunctionDeclarationSyntax>moduleElement;
                        if (tokenValueText(functionDeclaration.identifier) !== functionOverloadChainName) {
                            this.pushDiagnostic(functionDeclaration.identifier,
                                DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                    }

                    if (moduleElement.kind() === SyntaxKind.FunctionDeclaration) {
                        functionDeclaration = <FunctionDeclarationSyntax>moduleElement;
                        if (!SyntaxUtilities.containsToken(functionDeclaration.modifiers, SyntaxKind.DeclareKeyword)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = tokenValueText(functionDeclaration.identifier);

                            if (inFunctionOverloadChain) {
                                if (lastElement) {
                                    this.pushDiagnostic(firstToken(moduleElement), DiagnosticCode.Function_implementation_expected);
                                    return true;
                                }
                                else {
                                    // We're a function without a body, and there's another element 
                                    // after us.  If it's another overload that doesn't have a body,
                                    // then report an error that we're missing an implementation here.

                                    var nextElement = childAt(moduleElements, i + 1);
                                    if (nextElement.kind() === SyntaxKind.FunctionDeclaration) {
                                        var nextFunction = <FunctionDeclarationSyntax>nextElement;

                                        if (tokenValueText(nextFunction.identifier) !== functionOverloadChainName &&
                                            nextFunction.block === null) {

                                            this.pushDiagnostic(functionDeclaration.identifier, DiagnosticCode.Function_implementation_expected);
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }
                }
            }

            return false;
        }

        private checkClassOverloads(node: ClassDeclarationSyntax): boolean {
            if (!this.inAmbientDeclaration && !SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword)) {
                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;

                var functionOverloadChainName: string = null;
                var isInStaticOverloadChain: boolean = null;
                var memberFunctionDeclaration: MemberFunctionDeclarationSyntax = null;

                for (var i = 0, n = node.classElements.length; i < n; i++) {
                    var classElement = node.classElements[i];
                    var lastElement = i === (n - 1);
                    var isStaticOverload: boolean = null;

                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== SyntaxKind.MemberFunctionDeclaration) {
                            this.pushDiagnostic(firstToken(classElement), DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        memberFunctionDeclaration = <MemberFunctionDeclarationSyntax>classElement;
                        if (tokenValueText(memberFunctionDeclaration.propertyName) !== functionOverloadChainName) {
                            this.pushDiagnostic(memberFunctionDeclaration.propertyName,
                                DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }

                        isStaticOverload = SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, SyntaxKind.StaticKeyword);
                        if (isStaticOverload !== isInStaticOverloadChain) {
                            var diagnostic = isInStaticOverloadChain ? DiagnosticCode.Function_overload_must_be_static : DiagnosticCode.Function_overload_must_not_be_static;
                            this.pushDiagnostic(memberFunctionDeclaration.propertyName, diagnostic, null);
                            return true;
                        }
                    }
                    else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== SyntaxKind.ConstructorDeclaration) {
                            this.pushDiagnostic(firstToken(classElement), DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }

                    if (classElement.kind() === SyntaxKind.MemberFunctionDeclaration) {
                        memberFunctionDeclaration = <MemberFunctionDeclarationSyntax>classElement;

                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = tokenValueText(memberFunctionDeclaration.propertyName);
                        isInStaticOverloadChain = SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, SyntaxKind.StaticKeyword);

                        if (inFunctionOverloadChain) {
                            if (lastElement) {
                                this.pushDiagnostic(firstToken(classElement), DiagnosticCode.Function_implementation_expected);
                                return true;
                            }
                            else {
                                // We're a function without a body, and there's another element 
                                // after us.  If it's another overload that doesn't have a body,
                                // then report an error that we're missing an implementation here.

                                var nextElement = childAt(node.classElements, i + 1);
                            if (nextElement.kind() === SyntaxKind.MemberFunctionDeclaration) {
                                    var nextMemberFunction = <MemberFunctionDeclarationSyntax>nextElement;

                                    if (tokenValueText(nextMemberFunction.propertyName) !== functionOverloadChainName &&
                                        nextMemberFunction.block === null) {

                                        this.pushDiagnostic(memberFunctionDeclaration.propertyName, DiagnosticCode.Function_implementation_expected);
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    else if (classElement.kind() === SyntaxKind.ConstructorDeclaration) {
                        var constructorDeclaration = <ConstructorDeclarationSyntax>classElement;

                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic(firstToken(classElement), DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private checkForReservedName(parent: ISyntaxElement, name: ISyntaxToken, diagnosticKey: string): boolean {
            switch (tokenValueText(name)) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "void":
                    this.pushDiagnostic(name, diagnosticKey, [tokenValueText(name)]);
                    return true;
            }

            return false;
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): void {
            if (this.checkForReservedName(node, node.identifier, DiagnosticCode.Class_name_cannot_be_0) ||
                this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkClassDeclarationHeritageClauses(node) ||
                this.checkClassOverloads(node)) {

                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword);
            super.visitClassDeclaration(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        private checkInterfaceDeclarationHeritageClauses(node: InterfaceDeclarationSyntax): boolean {
            var seenExtendsClause = false;

            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses[i];

                if (heritageClause.extendsOrImplementsKeyword.kind() === SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause,
                            DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    seenExtendsClause = true;
                }
                else {
                    Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === SyntaxKind.ImplementsKeyword);
                    this.pushDiagnostic(heritageClause,
                        DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }
            }

            return false;
        }

        private checkInterfaceModifiers(modifiers: ISyntaxToken[]): boolean {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (modifier.kind() === SyntaxKind.DeclareKeyword) {
                    this.pushDiagnostic(modifier,
                        DiagnosticCode.declare_modifier_cannot_appear_on_an_interface_declaration);
                    return true;
                }
            }

            return false;
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void {
            if (this.checkForReservedName(node, node.identifier, DiagnosticCode.Interface_name_cannot_be_0) ||
                this.checkInterfaceModifiers(node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkInterfaceDeclarationHeritageClauses(node)) {

                return;
            }

            super.visitInterfaceDeclaration(node);
        }

        private checkClassElementModifiers(list: ISyntaxToken[]): boolean {
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;

            for (var i = 0, n = list.length; i < n; i++) {
                var modifier = list[i];
                if (modifier.kind() === SyntaxKind.PublicKeyword ||
                    modifier.kind() === SyntaxKind.PrivateKeyword) {

                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic(modifier,
                            DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }

                    if (seenStaticModifier) {
                        var previousToken = list[i - 1];
                        this.pushDiagnostic(modifier,
                            DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }

                    seenAccessibilityModifier = true;
                }
                else if (modifier.kind() === SyntaxKind.StaticKeyword) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic(modifier,
                            DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }

                    seenStaticModifier = true;
                }
                else {
                    this.pushDiagnostic(modifier,
                        DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }
            }

            return false;
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): void {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }

            super.visitMemberVariableDeclaration(node);
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): void {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }

            super.visitMemberFunctionDeclaration(node);
        }

        private checkGetAccessorParameter(node: ISyntaxNode, getKeyword: ISyntaxToken, parameterList: ParameterListSyntax): boolean {
            if (parameterList.parameters.length !== 0) {
                this.pushDiagnostic(getKeyword,
                    DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }

            return false;
        }

        public visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): void {
            if (this.checkIndexMemberModifiers(node)) {
                return;
            }

            super.visitIndexMemberDeclaration(node);
        }

        private checkIndexMemberModifiers(node: IndexMemberDeclarationSyntax): boolean {
            if (node.modifiers.length > 0) {
                this.pushDiagnostic(childAt(node.modifiers, 0), DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }

            return false;
        }

        private checkEcmaScriptVersionIsAtLeast(parent: ISyntaxElement, node: ISyntaxElement, languageVersion: LanguageVersion, diagnosticKey: string): boolean {
            if (this.syntaxTree.languageVersion() < languageVersion) {
                this.pushDiagnostic(node, diagnosticKey);
                return true;
            }

            return false;
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): void {
            var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
            this.inObjectLiteralExpression = true;
            super.visitObjectLiteralExpression(node);
            this.inObjectLiteralExpression = savedInObjectLiteralExpression;
        }

        public visitGetAccessor(node: GetAccessorSyntax): void {
            if (this.checkForAccessorDeclarationInAmbientContext(node) ||
                this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, LanguageVersion.EcmaScript5, DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkClassElementModifiers(node.modifiers) ||
                this.checkGetAccessorParameter(node, node.getKeyword, node.parameterList)) {
                return;
            }

            super.visitGetAccessor(node);
        }

        private checkForAccessorDeclarationInAmbientContext(accessor: ISyntaxNode): boolean {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic(accessor, DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts, null);
                return true;
            }

            return false;
        }

        private checkSetAccessorParameter(node: ISyntaxNode, setKeyword: ISyntaxToken, parameterList: ParameterListSyntax): boolean {
            if (childCount(parameterList.parameters) !== 1) {
                this.pushDiagnostic(setKeyword,
                    DiagnosticCode.set_accessor_must_have_one_and_only_one_parameter);
                return true;
            }

            var parameter = <ParameterSyntax>childAt(parameterList.parameters, 0);

            if (parameter.questionToken) {
                this.pushDiagnostic(parameter,
                    DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }

            if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter,
                    DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter,
                    DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }

            return false;
        }

        public visitSetAccessor(node: SetAccessorSyntax): void {
            if (this.checkForAccessorDeclarationInAmbientContext(node) ||
                this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, LanguageVersion.EcmaScript5, DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkClassElementModifiers(node.modifiers) ||
                this.checkSetAccessorParameter(node, node.setKeyword, node.parameterList)) {
                return;
            }

            super.visitSetAccessor(node);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): void {
            if (this.checkForReservedName(node, node.identifier, DiagnosticCode.Enum_name_cannot_be_0) ||
                this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers),
                this.checkEnumElements(node)) {

                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword);
            super.visitEnumDeclaration(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        private checkEnumElements(node: EnumDeclarationSyntax): boolean {
            var previousValueWasComputed = false;
            for (var i = 0, n = childCount(node.enumElements); i < n; i++) {
                var child = childAt(node.enumElements, i);

                if (i % 2 === 0) {
                    var enumElement = <EnumElementSyntax>child;

                    if (!enumElement.equalsValueClause && previousValueWasComputed) {
                        this.pushDiagnostic(enumElement, DiagnosticCode.Enum_member_must_have_initializer, null);
                        return true;
                    }

                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        previousValueWasComputed = !Syntax.isIntegerLiteral(value);
                    }
                }
            }

            return false;
        }

        public visitEnumElement(node: EnumElementSyntax): void {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic(node.equalsValueClause.equalsToken,
                        DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    return;
                }
            }

            super.visitEnumElement(node);
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): void {
            if (node.expression.kind() === SyntaxKind.SuperKeyword &&
                node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic(node,
                    DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }

            super.visitInvocationExpression(node);
        }

        private checkModuleElementModifiers(modifiers: ISyntaxToken[]): boolean {
            var seenExportModifier = false;
            var seenDeclareModifier = false;

            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (modifier.kind() === SyntaxKind.PublicKeyword ||
                    modifier.kind() === SyntaxKind.PrivateKeyword ||
                    modifier.kind() === SyntaxKind.StaticKeyword) {
                    this.pushDiagnostic(modifier,
                        DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }

                if (modifier.kind() === SyntaxKind.DeclareKeyword) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier,
                            DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }

                    seenDeclareModifier = true;
                }
                else if (modifier.kind() === SyntaxKind.ExportKeyword) {
                    if (seenExportModifier) {
                        this.pushDiagnostic(modifier,
                            DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }

                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier,
                            DiagnosticCode._0_modifier_must_precede_1_modifier,
                            [SyntaxFacts.getText(SyntaxKind.ExportKeyword), SyntaxFacts.getText(SyntaxKind.DeclareKeyword)]);
                        return;
                    }

                    seenExportModifier = true;
                }
            }

            return false;
        }

        private checkForDisallowedImportDeclaration(node: ModuleDeclarationSyntax): boolean {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var child = node.moduleElements[i];
                if (child.kind() === SyntaxKind.ImportDeclaration) {
                    var importDeclaration = <ImportDeclarationSyntax>child;
                    if (importDeclaration.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                        if (node.stringLiteral === null) {
                            this.pushDiagnostic(importDeclaration,
                                DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module, null);
                        }
                    }
                }
            }

            return false;
        }

        private checkForDisallowedDeclareModifierOnImportDeclaration(modifiers: ISyntaxToken[]): boolean {
            var declareToken = SyntaxUtilities.getToken(modifiers, SyntaxKind.DeclareKeyword);

            if (declareToken) {
                this.pushDiagnostic(declareToken,
                    DiagnosticCode.declare_modifier_not_allowed_on_import_declaration);
                return true;
            }
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): any {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }

            super.visitImportDeclaration(node);
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): void {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers) ||
                this.checkForDisallowedImportDeclaration(node) ||
                this.checkForDisallowedExports(node, node.moduleElements) ||
                this.checkForMultipleExportAssignments(node, node.moduleElements)) {

                return;
            }

            if (!SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword) && this.checkFunctionOverloads(node, node.moduleElements)) {
                return;
            }

            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword)) {
                    this.pushDiagnostic(node.stringLiteral,
                        DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    return;
                }
            }

            if (!node.stringLiteral &&
                this.checkForDisallowedExportAssignment(node)) {

                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword);
            super.visitModuleDeclaration(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        private checkForDisallowedExports(node: ISyntaxElement, moduleElements: IModuleElementSyntax[]): boolean {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var child = moduleElements[i];

                if (SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }

            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.length; i < n; i++) {
                    var child = moduleElements[i];

                    if (child.kind() === SyntaxKind.ExportAssignment) {
                        this.pushDiagnostic(child, DiagnosticCode.Export_assignment_not_allowed_in_module_with_exported_element);
                        return true;
                    }
                }
            }

            return false;
        }

        private checkForMultipleExportAssignments(node: ISyntaxElement, moduleElements: IModuleElementSyntax[]): boolean {
            var seenExportAssignment = false;
            var errorFound = false;
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var child = moduleElements[i];
                if (child.kind() === SyntaxKind.ExportAssignment) {
                    if (seenExportAssignment) {
                        this.pushDiagnostic(child, DiagnosticCode.Module_cannot_have_multiple_export_assignments);
                        errorFound = true;
                    }
                    seenExportAssignment = true;
                }
            }

            return errorFound;
        }

        private checkForDisallowedExportAssignment(node: ModuleDeclarationSyntax): boolean {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var child = node.moduleElements[i];

                if (child.kind() === SyntaxKind.ExportAssignment) {
                    this.pushDiagnostic(child, DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);

                    return true;
                }
            }

            return false;
        }

        public visitBlock(node: BlockSyntax): void {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic(firstToken(node), DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts);
                return;
            }

            if (this.checkFunctionOverloads(node, node.statements)) {
                return;
            }

            var savedInBlock = this.inBlock;
            this.inBlock = true;
            super.visitBlock(node);
            this.inBlock = savedInBlock;
        }

        private checkForStatementInAmbientContxt(node: IStatementSyntax): boolean {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic(firstToken(node), DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        }

        public visitBreakStatement(node: BreakStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitBreakStatement(node);
        }

        public visitContinueStatement(node: ContinueStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitContinueStatement(node);
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitDebuggerStatement(node);
        }

        public visitDoStatement(node: DoStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitDoStatement(node);
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitEmptyStatement(node);
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitExpressionStatement(node);
        }

        public visitForInStatement(node: ForInStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node) ||
                this.checkForInStatementVariableDeclaration(node)) {

                return;
            }

            super.visitForInStatement(node);
        }

        private checkForInStatementVariableDeclaration(node: ForInStatementSyntax): boolean {
            // The parser accepts a Variable Declaration in a ForInStatement, but the grammar only
            // allows a very restricted form.  Specifically, there must be only a single Variable
            // Declarator in the Declaration.
            if (node.variableDeclaration && node.variableDeclaration.variableDeclarators.length > 1) {
                this.pushDiagnostic(node.variableDeclaration, DiagnosticCode.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                return true;
            }

            return false;
        }

        public visitForStatement(node: ForStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitForStatement(node);
        }

        public visitIfStatement(node: IfStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitIfStatement(node);
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitLabeledStatement(node);
        }

        public visitReturnStatement(node: ReturnStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitReturnStatement(node);
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitSwitchStatement(node);
        }

        public visitThrowStatement(node: ThrowStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitThrowStatement(node);
        }

        public visitTryStatement(node: TryStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitTryStatement(node);
        }

        public visitWhileStatement(node: WhileStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitWhileStatement(node);
        }

        public visitWithStatement(node: WithStatementSyntax): void {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }

            super.visitWithStatement(node);
        }

        private checkForDisallowedModifiers(parent: ISyntaxElement, modifiers: ISyntaxToken[]): boolean {
            if (this.inBlock || this.inObjectLiteralExpression) {
                if (modifiers.length > 0) {
                    this.pushDiagnostic(childAt(modifiers, 0), DiagnosticCode.Modifiers_cannot_appear_here);
                    return true;
                }
            }

            return false;
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): void {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {

                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword);
            super.visitFunctionDeclaration(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        public visitVariableStatement(node: VariableStatementSyntax): void {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) ||
                this.checkForDisallowedModifiers(node, node.modifiers) ||
                this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) ||
                this.checkModuleElementModifiers(node.modifiers)) {

                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || SyntaxUtilities.containsToken(node.modifiers, SyntaxKind.DeclareKeyword);
            super.visitVariableStatement(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        private checkListSeparators<T extends ISyntaxNodeOrToken>(parent: ISyntaxElement, list: T[], kind: SyntaxKind): boolean {
            for (var i = 0, n = childCount(list); i < n; i++) {
                var child = childAt(list, i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic(child, DiagnosticCode._0_expected, [SyntaxFacts.getText(kind)]);
                }
            }

            return false;
        }

        public visitObjectType(node: ObjectTypeSyntax): void {
            if (this.checkListSeparators(node, node.typeMembers, SyntaxKind.SemicolonToken)) {
                return;
            }

            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            super.visitObjectType(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        public visitArrayType(node: ArrayTypeSyntax): void {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            super.visitArrayType(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        public visitFunctionType(node: FunctionTypeSyntax): void {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            super.visitFunctionType(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        public visitConstructorType(node: ConstructorTypeSyntax): void {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            super.visitConstructorType(node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): void {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic(node.equalsValueClause.equalsToken,
                    DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                return;
            }

            super.visitVariableDeclarator(node);
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): void {
            if (this.checkClassElementModifiers(node.modifiers) ||
                this.checkConstructorModifiers(node.modifiers) ||
                this.checkConstructorTypeParameterList(node) ||
                this.checkConstructorTypeAnnotation(node)) {

                return;
            }

            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            super.visitConstructorDeclaration(node);
            this.currentConstructor = savedCurrentConstructor;
        }

        private checkConstructorModifiers(modifiers: ISyntaxToken[]): boolean {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var child = modifiers[i];
                if (child.kind() !== SyntaxKind.PublicKeyword) {
                    this.pushDiagnostic(child, DiagnosticCode._0_modifier_cannot_appear_on_a_constructor_declaration, [SyntaxFacts.getText(child.kind())]);
                    return true;
                }
            }

            return false;
        }

        private checkConstructorTypeParameterList(node: ConstructorDeclarationSyntax): boolean {
            if (node.callSignature.typeParameterList) {
                this.pushDiagnostic(node.callSignature.typeParameterList, DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration);
                return true;
            }

            return false;
        }

        private checkConstructorTypeAnnotation(node: ConstructorDeclarationSyntax): boolean {
            if (node.callSignature.typeAnnotation) {
                this.pushDiagnostic(node.callSignature.typeAnnotation, DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration);
                return true;
            }

            return false;
        }

        public visitSourceUnit(node: SourceUnitSyntax): void {
            if (this.checkFunctionOverloads(node, node.moduleElements) ||
                this.checkForDisallowedExports(node, node.moduleElements) ||
                this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                
                return;
            }

            super.visitSourceUnit(node);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISyntaxTrivia {
        parent: ISyntaxTriviaList;
        kind(): SyntaxKind;

        isWhitespace(): boolean;
        isComment(): boolean;
        isNewLine(): boolean;
        isSkippedToken(): boolean;

        fullStart(): number;
        fullWidth(): number;

        // Text for this trivia.
        fullText(): string;

        // If this is a skipped token trivia, then this was the token that was skipped.
        skippedToken(): ISyntaxToken;

        clone(): ISyntaxTrivia;
    }
}

module TypeScript.Syntax {
    class AbstractTrivia implements ISyntaxTrivia {
        public parent: ISyntaxTriviaList = null;

        constructor(private _kind: SyntaxKind) {
        }

        public kind(): SyntaxKind {
            return this._kind;
        }

        public clone(): ISyntaxTrivia {
            throw Errors.abstract();
        }

        public fullStart(): number {
            throw Errors.abstract();
        }

        public fullWidth(): number {
            throw Errors.abstract();
        }

        public fullText(): string {
            throw Errors.abstract();
        }

        public skippedToken(): ISyntaxToken {
            throw Errors.abstract();
        }

        public isWhitespace(): boolean {
            return this.kind() === SyntaxKind.WhitespaceTrivia;
        }

        public isComment(): boolean {
            return this.kind() === SyntaxKind.SingleLineCommentTrivia || this.kind() === SyntaxKind.MultiLineCommentTrivia;
        }

        public isNewLine(): boolean {
            return this.kind() === SyntaxKind.NewLineTrivia;
        }

        public isSkippedToken(): boolean {
            return this.kind() === SyntaxKind.SkippedTokenTrivia;
        }
    }

    class NormalTrivia extends AbstractTrivia {
        constructor(kind: SyntaxKind, private _text: string, private _fullStart: number) {
            super(kind);
        }

        public clone(): ISyntaxTrivia {
            return new NormalTrivia(this.kind(), this._text, this._fullStart);
        }

        public fullStart(): number {
            return this._fullStart;
        }

        public fullWidth(): number {
            return this.fullText().length;
        }

        public fullText(): string {
            return this._text;
        }

        public skippedToken(): ISyntaxToken {
            throw Errors.invalidOperation();
        }
    }

    class SkippedTokenTrivia extends AbstractTrivia {
        constructor(private _skippedToken: ISyntaxToken) {
            super(SyntaxKind.SkippedTokenTrivia);

            _skippedToken.parent = <ISyntaxElement><any>this;
        }

        public clone(): ISyntaxTrivia {
            return new SkippedTokenTrivia(this._skippedToken.clone());
        }

        public fullStart(): number {
            return this._skippedToken.fullStart();
        }

        public fullWidth(): number {
            return this.fullText().length;
        }

        public fullText(): string {
            return this.skippedToken().fullText();
        }

        public skippedToken(): ISyntaxToken {
            return this._skippedToken;
        }
    }

    class DeferredTrivia extends AbstractTrivia {
        constructor(kind: SyntaxKind, private _text: ISimpleText, private _fullStart: number, private _fullWidth: number) {
            super(kind);
        }

        public clone(): ISyntaxTrivia {
            return new DeferredTrivia(this.kind(), this._text, this._fullStart, this._fullWidth);
        }

        public fullStart(): number {
            return this._fullStart;
        }

        public fullWidth(): number {
            return this._fullWidth;
        }

        public fullText(): string {
            return this._text.substr(this._fullStart, this._fullWidth);
        }

        public skippedToken(): ISyntaxToken {
            throw Errors.invalidOperation();
        }
    }

    export function deferredTrivia(kind: SyntaxKind, text: ISimpleText, fullStart: number, fullWidth: number): ISyntaxTrivia {
        return new DeferredTrivia(kind, text, fullStart, fullWidth);
    }

    export function trivia(kind: SyntaxKind, text: string, fullStart: number): ISyntaxTrivia {
        // Debug.assert(kind === SyntaxKind.MultiLineCommentTrivia || kind === SyntaxKind.NewLineTrivia || kind === SyntaxKind.SingleLineCommentTrivia || kind === SyntaxKind.WhitespaceTrivia || kind === SyntaxKind.SkippedTextTrivia);
        // Debug.assert(text.length > 0);
        return new NormalTrivia(kind, text, fullStart);
    }

    export function skippedTokenTrivia(token: ISyntaxToken): ISyntaxTrivia {
        Debug.assert(!token.hasLeadingTrivia());
        Debug.assert(!token.hasTrailingTrivia());
        Debug.assert(token.fullWidth() > 0);
        return new SkippedTokenTrivia(token);
    }

    export function spaces(count: number): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, StringUtilities.repeat(" ", count), -1);
    }

    export function whitespace(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, text, -1);
    }

    export function multiLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.MultiLineCommentTrivia, text, -1);
    }

    export function singleLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.SingleLineCommentTrivia, text, -1);
    }

    export var spaceTrivia: ISyntaxTrivia = spaces(1);
    export var lineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\n", -1);
    export var carriageReturnTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r", -1);
    export var carriageReturnLineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r\n", -1);

    // Breaks a multiline trivia up into individual line components.  If the trivia doesn't span
    // any lines, then the result will be a single string with the entire text of the trivia. 
    // Otherwise, there will be one entry in the array for each line spanned by the trivia.  Each
    // entry will contain the line separator at the end of the string.
    export function splitMultiLineCommentTriviaIntoMultipleLines(trivia: ISyntaxTrivia): string[] {
        // Debug.assert(trivia.kind === SyntaxKind.MultiLineCommentTrivia);
        var result: string[] = [];

        var triviaText = trivia.fullText();
        var currentIndex = 0;

        for (var i = 0; i < triviaText.length; i++) {
            var ch = triviaText.charCodeAt(i);

            // When we run into a newline for the first time, create the string builder and copy
            // all the values up to this newline into it.
            var isCarriageReturnLineFeed = false;
            switch (ch) {
                case CharacterCodes.carriageReturn:
                    if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === CharacterCodes.lineFeed) {
                        // Consume the \r
                        i++;
                    }

                // Fall through.

                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    // Eat from the last starting position through to the end of the newline.
                    result.push(triviaText.substring(currentIndex, i + 1));

                    // Set the current index to *after* the newline.
                    currentIndex = i + 1;
                    continue;
            }
        }

        result.push(triviaText.substring(currentIndex));
        return result;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISyntaxTriviaList {
        parent: ISyntaxToken;

        isShared(): boolean;

        count(): number;
        syntaxTriviaAt(index: number): ISyntaxTrivia;

        // With of this trivia list.
        fullWidth(): number;

        // Text for this trivia list.
        fullText(): string;

        hasComment(): boolean;
        hasNewLine(): boolean;
        hasSkippedToken(): boolean;

        last(): ISyntaxTrivia;
        toArray(): ISyntaxTrivia[];

        clone(): ISyntaxTriviaList;
    }
}

module TypeScript.Syntax {
    class EmptyTriviaList implements ISyntaxTriviaList {
        public parent: ISyntaxToken = null;

        public kind() {
            return SyntaxKind.TriviaList;
        }

        public isShared(): boolean {
            return true;
        }

        public count(): number {
            return 0;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            throw Errors.argumentOutOfRange("index");
        }

        public last(): ISyntaxTrivia {
            throw Errors.argumentOutOfRange("index");
        }

        public fullWidth(): number {
            return 0;
        }

        public fullText(): string {
            return "";
        }

        public hasComment(): boolean {
            return false;
        }

        public hasNewLine(): boolean {
            return false;
        }

        public hasSkippedToken(): boolean {
            return false;
        }

        public toArray(): ISyntaxTrivia[] {
            return [];
        }

        public clone() {
            return this;
        }
    };

    export var emptyTriviaList: ISyntaxTriviaList = new EmptyTriviaList();

    function isComment(trivia: ISyntaxTrivia): boolean {
        return trivia.kind() === SyntaxKind.MultiLineCommentTrivia || trivia.kind() === SyntaxKind.SingleLineCommentTrivia;
    }

    class SingletonSyntaxTriviaList implements ISyntaxTriviaList {
        public parent: ISyntaxToken = null;
        private item: ISyntaxTrivia;

        constructor(item: ISyntaxTrivia) {
            this.item = item.clone();
            this.item.parent = this;
        }

        public kind() {
            return SyntaxKind.TriviaList;
        }

        public isShared(): boolean {
            return false;
        }

        public count(): number {
            return 1;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public last(): ISyntaxTrivia {
            return this.item;
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public hasComment(): boolean {
            return isComment(this.item);
        }

        public hasNewLine(): boolean {
            return this.item.kind() === SyntaxKind.NewLineTrivia;
        }

        public hasSkippedToken(): boolean {
            return this.item.kind() === SyntaxKind.SkippedTokenTrivia;
        }

        public toArray(): ISyntaxTrivia[] {
            return [this.item];
        }

        public clone(): ISyntaxTriviaList {
            return new SingletonSyntaxTriviaList(this.item.clone());
        }
    }

    class NormalSyntaxTriviaList implements ISyntaxTriviaList {
        public parent: ISyntaxToken = null;
        private trivia: ISyntaxTrivia[];

        constructor(trivia: ISyntaxTrivia[]) {
            this.trivia = trivia.map(t => {
                var cloned = t.clone();
                cloned.parent = this;
                return cloned;
            });
        }

        public kind() {
            return SyntaxKind.TriviaList;
        }

        public isShared(): boolean {
            return false;
        }

        public count() {
            return this.trivia.length;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index < 0 || index >= this.trivia.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.trivia[index];
        }
        
        public last(): ISyntaxTrivia {
            return this.trivia[this.trivia.length - 1];
        }

        public fullWidth(): number {
            return ArrayUtilities.sum(this.trivia, t => t.fullWidth());
        }

        public fullText(): string {
            var result: string[] = [];

            for (var i = 0, n = this.trivia.length; i < n; i++) {
                result.push(this.trivia[i].fullText());
            }

            return result.join("");
        }

        public hasComment(): boolean {
            for (var i = 0; i < this.trivia.length; i++) {
                if (isComment(this.trivia[i])) {
                    return true;
                }
            }

            return false;
        }

        public hasNewLine(): boolean {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.NewLineTrivia) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedToken(): boolean {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.SkippedTokenTrivia) {
                    return true;
                }
            }

            return false;
        }

        public toArray(): ISyntaxTrivia[] {
            return this.trivia.slice(0);
        }

        public clone(): ISyntaxTriviaList {
            return new NormalSyntaxTriviaList(this.trivia.map(t => t.clone()));
        }
    }

    export function triviaList(trivia: ISyntaxTrivia[]): ISyntaxTriviaList {
        if (trivia === undefined || trivia === null || trivia.length === 0) {
            return Syntax.emptyTriviaList;
        }

        if (trivia.length === 1) {
            return new SingletonSyntaxTriviaList(trivia[0]);
        }

        return new NormalSyntaxTriviaList(trivia);
    }

    export var spaceTriviaList: ISyntaxTriviaList = triviaList([Syntax.spaceTrivia]);
}
///<reference path='references.ts' />

module TypeScript {
    //export function visitSyntaxElement(visitor: ISyntaxVisitor, element: ISyntaxElement): any {
    //    if (element === null) { return null; }
    //    switch (element.kind) {

    //    }
    //}

    export class SyntaxUtilities {
        public static isLeftHandSizeExpression(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.MemberAccessExpression:
                    case SyntaxKind.ElementAccessExpression:
                    case SyntaxKind.ObjectCreationExpression:
                    case SyntaxKind.InvocationExpression:
                    case SyntaxKind.ArrayLiteralExpression:
                    case SyntaxKind.ParenthesizedExpression:
                    case SyntaxKind.ObjectLiteralExpression:
                    case SyntaxKind.FunctionExpression:
                    case SyntaxKind.IdentifierName:
                    case SyntaxKind.RegularExpressionLiteral:
                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.FalseKeyword:
                    case SyntaxKind.NullKeyword:
                    case SyntaxKind.ThisKeyword:
                    case SyntaxKind.TrueKeyword:
                    case SyntaxKind.SuperKeyword:
                        return true;
                }
            }

            return false;
        }

        public static isExpression(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.IdentifierName:
                    case SyntaxKind.RegularExpressionLiteral:
                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.FalseKeyword:
                    case SyntaxKind.NullKeyword:
                    case SyntaxKind.ThisKeyword:
                    case SyntaxKind.TrueKeyword:
                    case SyntaxKind.SuperKeyword:

                    case SyntaxKind.PlusExpression:
                    case SyntaxKind.NegateExpression:
                    case SyntaxKind.BitwiseNotExpression:
                    case SyntaxKind.LogicalNotExpression:
                    case SyntaxKind.PreIncrementExpression:
                    case SyntaxKind.PreDecrementExpression:
                    case SyntaxKind.DeleteExpression:
                    case SyntaxKind.TypeOfExpression:
                    case SyntaxKind.VoidExpression:
                    case SyntaxKind.CommaExpression:
                    case SyntaxKind.AssignmentExpression:
                    case SyntaxKind.AddAssignmentExpression:
                    case SyntaxKind.SubtractAssignmentExpression:
                    case SyntaxKind.MultiplyAssignmentExpression:
                    case SyntaxKind.DivideAssignmentExpression:
                    case SyntaxKind.ModuloAssignmentExpression:
                    case SyntaxKind.AndAssignmentExpression:
                    case SyntaxKind.ExclusiveOrAssignmentExpression:
                    case SyntaxKind.OrAssignmentExpression:
                    case SyntaxKind.LeftShiftAssignmentExpression:
                    case SyntaxKind.SignedRightShiftAssignmentExpression:
                    case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    case SyntaxKind.ConditionalExpression:
                    case SyntaxKind.LogicalOrExpression:
                    case SyntaxKind.LogicalAndExpression:
                    case SyntaxKind.BitwiseOrExpression:
                    case SyntaxKind.BitwiseExclusiveOrExpression:
                    case SyntaxKind.BitwiseAndExpression:
                    case SyntaxKind.EqualsWithTypeConversionExpression:
                    case SyntaxKind.NotEqualsWithTypeConversionExpression:
                    case SyntaxKind.EqualsExpression:
                    case SyntaxKind.NotEqualsExpression:
                    case SyntaxKind.LessThanExpression:
                    case SyntaxKind.GreaterThanExpression:
                    case SyntaxKind.LessThanOrEqualExpression:
                    case SyntaxKind.GreaterThanOrEqualExpression:
                    case SyntaxKind.InstanceOfExpression:
                    case SyntaxKind.InExpression:
                    case SyntaxKind.LeftShiftExpression:
                    case SyntaxKind.SignedRightShiftExpression:
                    case SyntaxKind.UnsignedRightShiftExpression:
                    case SyntaxKind.MultiplyExpression:
                    case SyntaxKind.DivideExpression:
                    case SyntaxKind.ModuloExpression:
                    case SyntaxKind.AddExpression:
                    case SyntaxKind.SubtractExpression:
                    case SyntaxKind.PostIncrementExpression:
                    case SyntaxKind.PostDecrementExpression:
                    case SyntaxKind.MemberAccessExpression:
                    case SyntaxKind.InvocationExpression:
                    case SyntaxKind.ArrayLiteralExpression:
                    case SyntaxKind.ObjectLiteralExpression:
                    case SyntaxKind.ObjectCreationExpression:
                    case SyntaxKind.ParenthesizedExpression:
                    case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    case SyntaxKind.SimpleArrowFunctionExpression:
                    case SyntaxKind.CastExpression:
                    case SyntaxKind.ElementAccessExpression:
                    case SyntaxKind.FunctionExpression:
                    case SyntaxKind.OmittedExpression:
                        return true;
                }
            }

            return false;
        }

        public static isSwitchClause(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.CaseSwitchClause:
                    case SyntaxKind.DefaultSwitchClause:
                        return true;
                }
            }

            return false;
        }

        public static isTypeMember(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.ConstructSignature:
                    case SyntaxKind.MethodSignature:
                    case SyntaxKind.IndexSignature:
                    case SyntaxKind.PropertySignature:
                    case SyntaxKind.CallSignature:
                        return true;
                }
            }

            return false;
        }

        public static isClassElement(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.ConstructorDeclaration:
                    case SyntaxKind.IndexMemberDeclaration:
                    case SyntaxKind.MemberFunctionDeclaration:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                    case SyntaxKind.MemberFunctionDeclaration:
                    case SyntaxKind.MemberVariableDeclaration:
                        return true;
                }
            }

            return false;
        }

        public static isModuleElement(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.ImportDeclaration:
                    case SyntaxKind.ExportAssignment:
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.ModuleDeclaration:
                    case SyntaxKind.EnumDeclaration:

                    // Keep in sync with isStatement:
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.VariableStatement:
                    case SyntaxKind.Block:
                    case SyntaxKind.IfStatement:
                    case SyntaxKind.ExpressionStatement:
                    case SyntaxKind.ThrowStatement:
                    case SyntaxKind.ReturnStatement:
                    case SyntaxKind.SwitchStatement:
                    case SyntaxKind.BreakStatement:
                    case SyntaxKind.ContinueStatement:
                    case SyntaxKind.ForInStatement:
                    case SyntaxKind.ForStatement:
                    case SyntaxKind.WhileStatement:
                    case SyntaxKind.WithStatement:
                    case SyntaxKind.EmptyStatement:
                    case SyntaxKind.TryStatement:
                    case SyntaxKind.LabeledStatement:
                    case SyntaxKind.DoStatement:
                    case SyntaxKind.DebuggerStatement:
                        return true;
                }
            }

            return false;
        }

        public static isStatement(element: ISyntaxElement) {
            if (element) {
                switch (element.kind()) {
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.VariableStatement:
                    case SyntaxKind.Block:
                    case SyntaxKind.IfStatement:
                    case SyntaxKind.ExpressionStatement:
                    case SyntaxKind.ThrowStatement:
                    case SyntaxKind.ReturnStatement:
                    case SyntaxKind.SwitchStatement:
                    case SyntaxKind.BreakStatement:
                    case SyntaxKind.ContinueStatement:
                    case SyntaxKind.ForInStatement:
                    case SyntaxKind.ForStatement:
                    case SyntaxKind.WhileStatement:
                    case SyntaxKind.WithStatement:
                    case SyntaxKind.EmptyStatement:
                    case SyntaxKind.TryStatement:
                    case SyntaxKind.LabeledStatement:
                    case SyntaxKind.DoStatement:
                    case SyntaxKind.DebuggerStatement:
                        return true;
                }
            }

            return false;
        }

        public static isAngleBracket(positionedElement: ISyntaxElement): boolean {
            var element = positionedElement;
            var parent = positionedElement.parent;
            if (parent !== null && (element.kind() === SyntaxKind.LessThanToken || element.kind() === SyntaxKind.GreaterThanToken)) {
                switch (parent.kind()) {
                    case SyntaxKind.TypeArgumentList:
                    case SyntaxKind.TypeParameterList:
                    case SyntaxKind.CastExpression:
                        return true;
                }
            }

            return false;
        }

        public static getToken(list: ISyntaxToken[], kind: SyntaxKind): ISyntaxToken {
            for (var i = 0, n = list.length; i < n; i++) {
                var token = list[i];
                if (token.kind() === kind) {
                    return token;
                }
            }

            return null;
        }

        public static containsToken(list: ISyntaxToken[], kind: SyntaxKind): boolean {
            return SyntaxUtilities.getToken(list, kind) !== null;
        }

        public static hasExportKeyword(moduleElement: IModuleElementSyntax): boolean {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        }

        public static getExportKeyword(moduleElement: IModuleElementSyntax): ISyntaxToken {
            switch (moduleElement.kind()) {
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.ImportDeclaration:
                    return SyntaxUtilities.getToken((<any>moduleElement).modifiers, SyntaxKind.ExportKeyword);
                default: 
                    return null;
            }
        }

        public static isAmbientDeclarationSyntax(positionNode: ISyntaxNode): boolean {
            if (!positionNode) {
                return false;
            }

            var node = positionNode;
            switch (node.kind()) {
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.EnumDeclaration:
                    if (SyntaxUtilities.containsToken(<ISyntaxToken[]>(<any>node).modifiers, SyntaxKind.DeclareKeyword)) {
                        return true;
                    }
                    // Fall through to check if syntax container is ambient

                case SyntaxKind.ImportDeclaration:
                case SyntaxKind.ConstructorDeclaration:
                case SyntaxKind.MemberFunctionDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.MemberVariableDeclaration:
                    if (SyntaxUtilities.isClassElement(node) || SyntaxUtilities.isModuleElement(node)) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(Syntax.containingNode(positionNode));
                    }

                case SyntaxKind.EnumElement:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(Syntax.containingNode(Syntax.containingNode(positionNode)));

                default: 
                    return SyntaxUtilities.isAmbientDeclarationSyntax(Syntax.containingNode(positionNode));
            }
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export function visitNodeOrToken(visitor: ISyntaxVisitor, element: ISyntaxNodeOrToken): any {
        if (element === null) { return null; }
        if (isToken(element)) { return visitor.visitToken(<ISyntaxToken>element); }
        switch (element.kind()) {
            case SyntaxKind.SourceUnit:
                return visitor.visitSourceUnit(<SourceUnitSyntax>element);
            case SyntaxKind.QualifiedName:
                return visitor.visitQualifiedName(<QualifiedNameSyntax>element);
            case SyntaxKind.ObjectType:
                return visitor.visitObjectType(<ObjectTypeSyntax>element);
            case SyntaxKind.FunctionType:
                return visitor.visitFunctionType(<FunctionTypeSyntax>element);
            case SyntaxKind.ArrayType:
                return visitor.visitArrayType(<ArrayTypeSyntax>element);
            case SyntaxKind.ConstructorType:
                return visitor.visitConstructorType(<ConstructorTypeSyntax>element);
            case SyntaxKind.GenericType:
                return visitor.visitGenericType(<GenericTypeSyntax>element);
            case SyntaxKind.TypeQuery:
                return visitor.visitTypeQuery(<TypeQuerySyntax>element);
            case SyntaxKind.InterfaceDeclaration:
                return visitor.visitInterfaceDeclaration(<InterfaceDeclarationSyntax>element);
            case SyntaxKind.FunctionDeclaration:
                return visitor.visitFunctionDeclaration(<FunctionDeclarationSyntax>element);
            case SyntaxKind.ModuleDeclaration:
                return visitor.visitModuleDeclaration(<ModuleDeclarationSyntax>element);
            case SyntaxKind.ClassDeclaration:
                return visitor.visitClassDeclaration(<ClassDeclarationSyntax>element);
            case SyntaxKind.EnumDeclaration:
                return visitor.visitEnumDeclaration(<EnumDeclarationSyntax>element);
            case SyntaxKind.ImportDeclaration:
                return visitor.visitImportDeclaration(<ImportDeclarationSyntax>element);
            case SyntaxKind.ExportAssignment:
                return visitor.visitExportAssignment(<ExportAssignmentSyntax>element);
            case SyntaxKind.MemberFunctionDeclaration:
                return visitor.visitMemberFunctionDeclaration(<MemberFunctionDeclarationSyntax>element);
            case SyntaxKind.MemberVariableDeclaration:
                return visitor.visitMemberVariableDeclaration(<MemberVariableDeclarationSyntax>element);
            case SyntaxKind.ConstructorDeclaration:
                return visitor.visitConstructorDeclaration(<ConstructorDeclarationSyntax>element);
            case SyntaxKind.IndexMemberDeclaration:
                return visitor.visitIndexMemberDeclaration(<IndexMemberDeclarationSyntax>element);
            case SyntaxKind.GetAccessor:
                return visitor.visitGetAccessor(<GetAccessorSyntax>element);
            case SyntaxKind.SetAccessor:
                return visitor.visitSetAccessor(<SetAccessorSyntax>element);
            case SyntaxKind.PropertySignature:
                return visitor.visitPropertySignature(<PropertySignatureSyntax>element);
            case SyntaxKind.CallSignature:
                return visitor.visitCallSignature(<CallSignatureSyntax>element);
            case SyntaxKind.ConstructSignature:
                return visitor.visitConstructSignature(<ConstructSignatureSyntax>element);
            case SyntaxKind.IndexSignature:
                return visitor.visitIndexSignature(<IndexSignatureSyntax>element);
            case SyntaxKind.MethodSignature:
                return visitor.visitMethodSignature(<MethodSignatureSyntax>element);
            case SyntaxKind.Block:
                return visitor.visitBlock(<BlockSyntax>element);
            case SyntaxKind.IfStatement:
                return visitor.visitIfStatement(<IfStatementSyntax>element);
            case SyntaxKind.VariableStatement:
                return visitor.visitVariableStatement(<VariableStatementSyntax>element);
            case SyntaxKind.ExpressionStatement:
                return visitor.visitExpressionStatement(<ExpressionStatementSyntax>element);
            case SyntaxKind.ReturnStatement:
                return visitor.visitReturnStatement(<ReturnStatementSyntax>element);
            case SyntaxKind.SwitchStatement:
                return visitor.visitSwitchStatement(<SwitchStatementSyntax>element);
            case SyntaxKind.BreakStatement:
                return visitor.visitBreakStatement(<BreakStatementSyntax>element);
            case SyntaxKind.ContinueStatement:
                return visitor.visitContinueStatement(<ContinueStatementSyntax>element);
            case SyntaxKind.ForStatement:
                return visitor.visitForStatement(<ForStatementSyntax>element);
            case SyntaxKind.ForInStatement:
                return visitor.visitForInStatement(<ForInStatementSyntax>element);
            case SyntaxKind.EmptyStatement:
                return visitor.visitEmptyStatement(<EmptyStatementSyntax>element);
            case SyntaxKind.ThrowStatement:
                return visitor.visitThrowStatement(<ThrowStatementSyntax>element);
            case SyntaxKind.WhileStatement:
                return visitor.visitWhileStatement(<WhileStatementSyntax>element);
            case SyntaxKind.TryStatement:
                return visitor.visitTryStatement(<TryStatementSyntax>element);
            case SyntaxKind.LabeledStatement:
                return visitor.visitLabeledStatement(<LabeledStatementSyntax>element);
            case SyntaxKind.DoStatement:
                return visitor.visitDoStatement(<DoStatementSyntax>element);
            case SyntaxKind.DebuggerStatement:
                return visitor.visitDebuggerStatement(<DebuggerStatementSyntax>element);
            case SyntaxKind.WithStatement:
                return visitor.visitWithStatement(<WithStatementSyntax>element);
            case SyntaxKind.PreIncrementExpression: case SyntaxKind.PreDecrementExpression: case SyntaxKind.PlusExpression: case SyntaxKind.NegateExpression: case SyntaxKind.BitwiseNotExpression: case SyntaxKind.LogicalNotExpression:
                return visitor.visitPrefixUnaryExpression(<PrefixUnaryExpressionSyntax>element);
            case SyntaxKind.DeleteExpression:
                return visitor.visitDeleteExpression(<DeleteExpressionSyntax>element);
            case SyntaxKind.TypeOfExpression:
                return visitor.visitTypeOfExpression(<TypeOfExpressionSyntax>element);
            case SyntaxKind.VoidExpression:
                return visitor.visitVoidExpression(<VoidExpressionSyntax>element);
            case SyntaxKind.ConditionalExpression:
                return visitor.visitConditionalExpression(<ConditionalExpressionSyntax>element);
            case SyntaxKind.MultiplyExpression: case SyntaxKind.DivideExpression: case SyntaxKind.ModuloExpression: case SyntaxKind.AddExpression: case SyntaxKind.SubtractExpression: case SyntaxKind.LeftShiftExpression: case SyntaxKind.SignedRightShiftExpression: case SyntaxKind.UnsignedRightShiftExpression: case SyntaxKind.LessThanExpression: case SyntaxKind.GreaterThanExpression: case SyntaxKind.LessThanOrEqualExpression: case SyntaxKind.GreaterThanOrEqualExpression: case SyntaxKind.InstanceOfExpression: case SyntaxKind.InExpression: case SyntaxKind.EqualsWithTypeConversionExpression: case SyntaxKind.NotEqualsWithTypeConversionExpression: case SyntaxKind.EqualsExpression: case SyntaxKind.NotEqualsExpression: case SyntaxKind.BitwiseAndExpression: case SyntaxKind.BitwiseExclusiveOrExpression: case SyntaxKind.BitwiseOrExpression: case SyntaxKind.LogicalAndExpression: case SyntaxKind.LogicalOrExpression: case SyntaxKind.OrAssignmentExpression: case SyntaxKind.AndAssignmentExpression: case SyntaxKind.ExclusiveOrAssignmentExpression: case SyntaxKind.LeftShiftAssignmentExpression: case SyntaxKind.SignedRightShiftAssignmentExpression: case SyntaxKind.UnsignedRightShiftAssignmentExpression: case SyntaxKind.AddAssignmentExpression: case SyntaxKind.SubtractAssignmentExpression: case SyntaxKind.MultiplyAssignmentExpression: case SyntaxKind.DivideAssignmentExpression: case SyntaxKind.ModuloAssignmentExpression: case SyntaxKind.AssignmentExpression: case SyntaxKind.CommaExpression:
                return visitor.visitBinaryExpression(<BinaryExpressionSyntax>element);
            case SyntaxKind.PostIncrementExpression: case SyntaxKind.PostDecrementExpression:
                return visitor.visitPostfixUnaryExpression(<PostfixUnaryExpressionSyntax>element);
            case SyntaxKind.MemberAccessExpression:
                return visitor.visitMemberAccessExpression(<MemberAccessExpressionSyntax>element);
            case SyntaxKind.InvocationExpression:
                return visitor.visitInvocationExpression(<InvocationExpressionSyntax>element);
            case SyntaxKind.ArrayLiteralExpression:
                return visitor.visitArrayLiteralExpression(<ArrayLiteralExpressionSyntax>element);
            case SyntaxKind.ObjectLiteralExpression:
                return visitor.visitObjectLiteralExpression(<ObjectLiteralExpressionSyntax>element);
            case SyntaxKind.ObjectCreationExpression:
                return visitor.visitObjectCreationExpression(<ObjectCreationExpressionSyntax>element);
            case SyntaxKind.ParenthesizedExpression:
                return visitor.visitParenthesizedExpression(<ParenthesizedExpressionSyntax>element);
            case SyntaxKind.ParenthesizedArrowFunctionExpression:
                return visitor.visitParenthesizedArrowFunctionExpression(<ParenthesizedArrowFunctionExpressionSyntax>element);
            case SyntaxKind.SimpleArrowFunctionExpression:
                return visitor.visitSimpleArrowFunctionExpression(<SimpleArrowFunctionExpressionSyntax>element);
            case SyntaxKind.CastExpression:
                return visitor.visitCastExpression(<CastExpressionSyntax>element);
            case SyntaxKind.ElementAccessExpression:
                return visitor.visitElementAccessExpression(<ElementAccessExpressionSyntax>element);
            case SyntaxKind.FunctionExpression:
                return visitor.visitFunctionExpression(<FunctionExpressionSyntax>element);
            case SyntaxKind.OmittedExpression:
                return visitor.visitOmittedExpression(<OmittedExpressionSyntax>element);
            case SyntaxKind.VariableDeclaration:
                return visitor.visitVariableDeclaration(<VariableDeclarationSyntax>element);
            case SyntaxKind.VariableDeclarator:
                return visitor.visitVariableDeclarator(<VariableDeclaratorSyntax>element);
            case SyntaxKind.ArgumentList:
                return visitor.visitArgumentList(<ArgumentListSyntax>element);
            case SyntaxKind.ParameterList:
                return visitor.visitParameterList(<ParameterListSyntax>element);
            case SyntaxKind.TypeArgumentList:
                return visitor.visitTypeArgumentList(<TypeArgumentListSyntax>element);
            case SyntaxKind.TypeParameterList:
                return visitor.visitTypeParameterList(<TypeParameterListSyntax>element);
            case SyntaxKind.ExtendsHeritageClause: case SyntaxKind.ImplementsHeritageClause:
                return visitor.visitHeritageClause(<HeritageClauseSyntax>element);
            case SyntaxKind.EqualsValueClause:
                return visitor.visitEqualsValueClause(<EqualsValueClauseSyntax>element);
            case SyntaxKind.CaseSwitchClause:
                return visitor.visitCaseSwitchClause(<CaseSwitchClauseSyntax>element);
            case SyntaxKind.DefaultSwitchClause:
                return visitor.visitDefaultSwitchClause(<DefaultSwitchClauseSyntax>element);
            case SyntaxKind.ElseClause:
                return visitor.visitElseClause(<ElseClauseSyntax>element);
            case SyntaxKind.CatchClause:
                return visitor.visitCatchClause(<CatchClauseSyntax>element);
            case SyntaxKind.FinallyClause:
                return visitor.visitFinallyClause(<FinallyClauseSyntax>element);
            case SyntaxKind.TypeParameter:
                return visitor.visitTypeParameter(<TypeParameterSyntax>element);
            case SyntaxKind.Constraint:
                return visitor.visitConstraint(<ConstraintSyntax>element);
            case SyntaxKind.SimplePropertyAssignment:
                return visitor.visitSimplePropertyAssignment(<SimplePropertyAssignmentSyntax>element);
            case SyntaxKind.FunctionPropertyAssignment:
                return visitor.visitFunctionPropertyAssignment(<FunctionPropertyAssignmentSyntax>element);
            case SyntaxKind.Parameter:
                return visitor.visitParameter(<ParameterSyntax>element);
            case SyntaxKind.EnumElement:
                return visitor.visitEnumElement(<EnumElementSyntax>element);
            case SyntaxKind.TypeAnnotation:
                return visitor.visitTypeAnnotation(<TypeAnnotationSyntax>element);
            case SyntaxKind.ExternalModuleReference:
                return visitor.visitExternalModuleReference(<ExternalModuleReferenceSyntax>element);
            case SyntaxKind.ModuleNameModuleReference:
                return visitor.visitModuleNameModuleReference(<ModuleNameModuleReferenceSyntax>element);
        }

        throw Errors.invalidOperation();
    }

    export interface ISyntaxVisitor {
        visitToken(token: ISyntaxToken): any;
        visitSourceUnit(node: SourceUnitSyntax): any;
        visitQualifiedName(node: QualifiedNameSyntax): any;
        visitObjectType(node: ObjectTypeSyntax): any;
        visitFunctionType(node: FunctionTypeSyntax): any;
        visitArrayType(node: ArrayTypeSyntax): any;
        visitConstructorType(node: ConstructorTypeSyntax): any;
        visitGenericType(node: GenericTypeSyntax): any;
        visitTypeQuery(node: TypeQuerySyntax): any;
        visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any;
        visitFunctionDeclaration(node: FunctionDeclarationSyntax): any;
        visitModuleDeclaration(node: ModuleDeclarationSyntax): any;
        visitClassDeclaration(node: ClassDeclarationSyntax): any;
        visitEnumDeclaration(node: EnumDeclarationSyntax): any;
        visitImportDeclaration(node: ImportDeclarationSyntax): any;
        visitExportAssignment(node: ExportAssignmentSyntax): any;
        visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any;
        visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any;
        visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any;
        visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): any;
        visitGetAccessor(node: GetAccessorSyntax): any;
        visitSetAccessor(node: SetAccessorSyntax): any;
        visitPropertySignature(node: PropertySignatureSyntax): any;
        visitCallSignature(node: CallSignatureSyntax): any;
        visitConstructSignature(node: ConstructSignatureSyntax): any;
        visitIndexSignature(node: IndexSignatureSyntax): any;
        visitMethodSignature(node: MethodSignatureSyntax): any;
        visitBlock(node: BlockSyntax): any;
        visitIfStatement(node: IfStatementSyntax): any;
        visitVariableStatement(node: VariableStatementSyntax): any;
        visitExpressionStatement(node: ExpressionStatementSyntax): any;
        visitReturnStatement(node: ReturnStatementSyntax): any;
        visitSwitchStatement(node: SwitchStatementSyntax): any;
        visitBreakStatement(node: BreakStatementSyntax): any;
        visitContinueStatement(node: ContinueStatementSyntax): any;
        visitForStatement(node: ForStatementSyntax): any;
        visitForInStatement(node: ForInStatementSyntax): any;
        visitEmptyStatement(node: EmptyStatementSyntax): any;
        visitThrowStatement(node: ThrowStatementSyntax): any;
        visitWhileStatement(node: WhileStatementSyntax): any;
        visitTryStatement(node: TryStatementSyntax): any;
        visitLabeledStatement(node: LabeledStatementSyntax): any;
        visitDoStatement(node: DoStatementSyntax): any;
        visitDebuggerStatement(node: DebuggerStatementSyntax): any;
        visitWithStatement(node: WithStatementSyntax): any;
        visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any;
        visitDeleteExpression(node: DeleteExpressionSyntax): any;
        visitTypeOfExpression(node: TypeOfExpressionSyntax): any;
        visitVoidExpression(node: VoidExpressionSyntax): any;
        visitConditionalExpression(node: ConditionalExpressionSyntax): any;
        visitBinaryExpression(node: BinaryExpressionSyntax): any;
        visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any;
        visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any;
        visitInvocationExpression(node: InvocationExpressionSyntax): any;
        visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any;
        visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any;
        visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any;
        visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any;
        visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any;
        visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any;
        visitCastExpression(node: CastExpressionSyntax): any;
        visitElementAccessExpression(node: ElementAccessExpressionSyntax): any;
        visitFunctionExpression(node: FunctionExpressionSyntax): any;
        visitOmittedExpression(node: OmittedExpressionSyntax): any;
        visitVariableDeclaration(node: VariableDeclarationSyntax): any;
        visitVariableDeclarator(node: VariableDeclaratorSyntax): any;
        visitArgumentList(node: ArgumentListSyntax): any;
        visitParameterList(node: ParameterListSyntax): any;
        visitTypeArgumentList(node: TypeArgumentListSyntax): any;
        visitTypeParameterList(node: TypeParameterListSyntax): any;
        visitHeritageClause(node: HeritageClauseSyntax): any;
        visitEqualsValueClause(node: EqualsValueClauseSyntax): any;
        visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any;
        visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any;
        visitElseClause(node: ElseClauseSyntax): any;
        visitCatchClause(node: CatchClauseSyntax): any;
        visitFinallyClause(node: FinallyClauseSyntax): any;
        visitTypeParameter(node: TypeParameterSyntax): any;
        visitConstraint(node: ConstraintSyntax): any;
        visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any;
        visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): any;
        visitParameter(node: ParameterSyntax): any;
        visitEnumElement(node: EnumElementSyntax): any;
        visitTypeAnnotation(node: TypeAnnotationSyntax): any;
        visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any;
        visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any;
    }

    export class SyntaxVisitor implements ISyntaxVisitor {
        public defaultVisit(node: ISyntaxNodeOrToken): any {
            return null;
        }

        public visitToken(token: ISyntaxToken): any {
            return this.defaultVisit(token);
        }

        public visitSourceUnit(node: SourceUnitSyntax): any {
            return this.defaultVisit(node);
        }

        public visitQualifiedName(node: QualifiedNameSyntax): any {
            return this.defaultVisit(node);
        }

        public visitObjectType(node: ObjectTypeSyntax): any {
            return this.defaultVisit(node);
        }

        public visitFunctionType(node: FunctionTypeSyntax): any {
            return this.defaultVisit(node);
        }

        public visitArrayType(node: ArrayTypeSyntax): any {
            return this.defaultVisit(node);
        }

        public visitConstructorType(node: ConstructorTypeSyntax): any {
            return this.defaultVisit(node);
        }

        public visitGenericType(node: GenericTypeSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeQuery(node: TypeQuerySyntax): any {
            return this.defaultVisit(node);
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitExportAssignment(node: ExportAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitGetAccessor(node: GetAccessorSyntax): any {
            return this.defaultVisit(node);
        }

        public visitSetAccessor(node: SetAccessorSyntax): any {
            return this.defaultVisit(node);
        }

        public visitPropertySignature(node: PropertySignatureSyntax): any {
            return this.defaultVisit(node);
        }

        public visitCallSignature(node: CallSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        public visitConstructSignature(node: ConstructSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        public visitIndexSignature(node: IndexSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        public visitMethodSignature(node: MethodSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        public visitBlock(node: BlockSyntax): any {
            return this.defaultVisit(node);
        }

        public visitIfStatement(node: IfStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitVariableStatement(node: VariableStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitReturnStatement(node: ReturnStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitBreakStatement(node: BreakStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitContinueStatement(node: ContinueStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitForStatement(node: ForStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitForInStatement(node: ForInStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitThrowStatement(node: ThrowStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitWhileStatement(node: WhileStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTryStatement(node: TryStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitDoStatement(node: DoStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitWithStatement(node: WithStatementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitDeleteExpression(node: DeleteExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeOfExpression(node: TypeOfExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitVoidExpression(node: VoidExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitConditionalExpression(node: ConditionalExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitBinaryExpression(node: BinaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitCastExpression(node: CastExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitElementAccessExpression(node: ElementAccessExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitFunctionExpression(node: FunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitOmittedExpression(node: OmittedExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): any {
            return this.defaultVisit(node);
        }

        public visitArgumentList(node: ArgumentListSyntax): any {
            return this.defaultVisit(node);
        }

        public visitParameterList(node: ParameterListSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): any {
            return this.defaultVisit(node);
        }

        public visitHeritageClause(node: HeritageClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitEqualsValueClause(node: EqualsValueClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitElseClause(node: ElseClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitCatchClause(node: CatchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitFinallyClause(node: FinallyClauseSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeParameter(node: TypeParameterSyntax): any {
            return this.defaultVisit(node);
        }

        public visitConstraint(node: ConstraintSyntax): any {
            return this.defaultVisit(node);
        }

        public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        public visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        public visitParameter(node: ParameterSyntax): any {
            return this.defaultVisit(node);
        }

        public visitEnumElement(node: EnumElementSyntax): any {
            return this.defaultVisit(node);
        }

        public visitTypeAnnotation(node: TypeAnnotationSyntax): any {
            return this.defaultVisit(node);
        }

        public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
            return this.defaultVisit(node);
        }

        public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
            return this.defaultVisit(node);
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class SyntaxWalker implements ISyntaxVisitor {
        public visitToken(token: ISyntaxToken): void {
        }

        public visitNode(node: ISyntaxNode): void {
            visitNodeOrToken(this, node);
        }

        public visitNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
            if (isToken(nodeOrToken)) { 
                this.visitToken(<ISyntaxToken>nodeOrToken);
            }
            else {
                this.visitNode(<ISyntaxNode>nodeOrToken);
            }
        }

        private visitOptionalToken(token: ISyntaxToken): void {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        }

        public visitOptionalNode(node: ISyntaxNode): void {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        }

        public visitOptionalNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        }

        public visitList(list: ISyntaxNodeOrToken[]): void {
            for (var i = 0, n = list.length; i < n; i++) {
               this.visitNodeOrToken(list[i]);
            }
        }

        public visitSeparatedList(list: ISyntaxNodeOrToken[]): void {
            for (var i = 0, n = childCount(list); i < n; i++) {
                var item = childAt(list, i);
                this.visitNodeOrToken(item);
            }
        }

        public visitSourceUnit(node: SourceUnitSyntax): void {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        }

        public visitQualifiedName(node: QualifiedNameSyntax): void {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        }

        public visitObjectType(node: ObjectTypeSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        }

        public visitFunctionType(node: FunctionTypeSyntax): void {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        }

        public visitArrayType(node: ArrayTypeSyntax): void {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        }

        public visitConstructorType(node: ConstructorTypeSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        }

        public visitGenericType(node: GenericTypeSyntax): void {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        }

        public visitTypeQuery(node: TypeQuerySyntax): void {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.name);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.moduleReference);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitExportAssignment(node: ExportAssignmentSyntax): void {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): void {
            this.visitList(node.modifiers);
            this.visitNode(node.indexSignature);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitGetAccessor(node: GetAccessorSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        }

        public visitSetAccessor(node: SetAccessorSyntax): void {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        }

        public visitPropertySignature(node: PropertySignatureSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitCallSignature(node: CallSignatureSyntax): void {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitConstructSignature(node: ConstructSignatureSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        }

        public visitIndexSignature(node: IndexSignatureSyntax): void {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitMethodSignature(node: MethodSignatureSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        }

        public visitBlock(node: BlockSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        }

        public visitIfStatement(node: IfStatementSyntax): void {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        }

        public visitVariableStatement(node: VariableStatementSyntax): void {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitReturnStatement(node: ReturnStatementSyntax): void {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): void {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        }

        public visitBreakStatement(node: BreakStatementSyntax): void {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitContinueStatement(node: ContinueStatementSyntax): void {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitForStatement(node: ForStatementSyntax): void {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitForInStatement(node: ForInStatementSyntax): void {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): void {
            this.visitToken(node.semicolonToken);
        }

        public visitThrowStatement(node: ThrowStatementSyntax): void {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitWhileStatement(node: WhileStatementSyntax): void {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitTryStatement(node: TryStatementSyntax): void {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): void {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitDoStatement(node: DoStatementSyntax): void {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): void {
            this.visitToken(node.debuggerKeyword);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitWithStatement(node: WithStatementSyntax): void {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): void {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        }

        public visitDeleteExpression(node: DeleteExpressionSyntax): void {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitTypeOfExpression(node: TypeOfExpressionSyntax): void {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitVoidExpression(node: VoidExpressionSyntax): void {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitConditionalExpression(node: ConditionalExpressionSyntax): void {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        }

        public visitBinaryExpression(node: BinaryExpressionSyntax): void {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        }

        public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): void {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        }

        public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): void {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        }

        public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        }

        public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): void {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): void {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): void {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        }

        public visitCastExpression(node: CastExpressionSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        }

        public visitElementAccessExpression(node: ElementAccessExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        }

        public visitFunctionExpression(node: FunctionExpressionSyntax): void {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        }

        public visitOmittedExpression(node: OmittedExpressionSyntax): void {
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): void {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitArgumentList(node: ArgumentListSyntax): void {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        }

        public visitParameterList(node: ParameterListSyntax): void {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        }

        public visitHeritageClause(node: HeritageClauseSyntax): void {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        }

        public visitEqualsValueClause(node: EqualsValueClauseSyntax): void {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        }

        public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): void {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        }

        public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): void {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        }

        public visitElseClause(node: ElseClauseSyntax): void {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        }

        public visitCatchClause(node: CatchClauseSyntax): void {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        }

        public visitFinallyClause(node: FinallyClauseSyntax): void {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        }

        public visitTypeParameter(node: TypeParameterSyntax): void {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        }

        public visitConstraint(node: ConstraintSyntax): void {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        }

        public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): void {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        }

        public visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): void {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        }

        public visitParameter(node: ParameterSyntax): void {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitList(node.modifiers);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitEnumElement(node: EnumElementSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitTypeAnnotation(node: TypeAnnotationSyntax): void {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        }

        public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): void {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        }

        public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): void {
            this.visitNodeOrToken(node.moduleName);
        }
    }
}
module TypeScript {
    export function nodeStructuralEquals(node1: TypeScript.ISyntaxNode, node2: TypeScript.ISyntaxNode): boolean {
        if (node1 === node2) { return true; }
        if (node1 === null || node2 === null) { return false; }
        if (node1.kind() !== node2.kind()) { return false; }
        if (childCount(node1) !== childCount(node2)) { return false; }

        for (var i = 0, n = childCount(node1); i < n; i++) {
            var element1 = childAt(node1, i);
            var element2 = childAt(node2, i);

            if (!elementStructuralEquals(element1, element2)) {
                return false;
            }
        }

        return true;
    }

    export function nodeOrTokenStructuralEquals(node1: TypeScript.ISyntaxNodeOrToken, node2: TypeScript.ISyntaxNodeOrToken): boolean {
        if (node1 === node2) {
            return true;
        }

        if (node1 === null || node2 === null) {
            return false;
        }

        if (TypeScript.isToken(node1)) {
            return TypeScript.isToken(node2) ? tokenStructuralEquals(<TypeScript.ISyntaxToken>node1, <TypeScript.ISyntaxToken>node2) : false;
        }

        return TypeScript.isNode(node2) ? nodeStructuralEquals(<TypeScript.ISyntaxNode>node1, <TypeScript.ISyntaxNode>node2) : false;
    }

    export function tokenStructuralEquals(token1: TypeScript.ISyntaxToken, token2: TypeScript.ISyntaxToken): boolean {
        if (token1 === token2) {
            return true;
        }

        if (token1 === null || token2 === null) {
            return false;
        }

        return token1.kind() === token2.kind() &&
            TypeScript.width(token1) === TypeScript.width(token2) &&
            token1.fullWidth() === token2.fullWidth() &&
            token1.fullStart() === token2.fullStart() &&
            TypeScript.fullEnd(token1) === TypeScript.fullEnd(token2) &&
            TypeScript.start(token1) === TypeScript.start(token2) &&
            TypeScript.end(token1) === TypeScript.end(token2) &&
            token1.text() === token2.text() &&
            triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) &&
            triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
    }

    export function triviaListStructuralEquals(triviaList1: TypeScript.ISyntaxTriviaList, triviaList2: TypeScript.ISyntaxTriviaList): boolean {
        if (triviaList1.count() !== triviaList2.count()) {
            return false;
        }

        for (var i = 0, n = triviaList1.count(); i < n; i++) {
            if (!triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                return false;
            }
        }

        return true;
    }

    export function triviaStructuralEquals(trivia1: TypeScript.ISyntaxTrivia, trivia2: TypeScript.ISyntaxTrivia): boolean {
        return trivia1.kind === trivia2.kind &&
            trivia1.fullWidth() === trivia2.fullWidth() &&
            trivia1.fullText() === trivia2.fullText();
    }

    function listStructuralEquals<T extends TypeScript.ISyntaxNodeOrToken>(list1: T[], list2: T[]): boolean {
        if (childCount(list1) !== childCount(list2)) {
            return false;
        }

        for (var i = 0, n = childCount(list1); i < n; i++) {
            var child1 = childAt(list1, i);
            var child2 = childAt(list2, i);

            if (!nodeOrTokenStructuralEquals(child1, child2)) {
                return false;
            }
        }

        return true;
    }

    function separatedListStructuralEquals<T extends TypeScript.ISyntaxNodeOrToken>(list1: T[], list2: T[]): boolean {
        if (childCount(list1) !== childCount(list2)) {
            return false;
        }

        for (var i = 0, n = childCount(list1); i < n; i++) {
            var element1 = childAt(list1, i);
            var element2 = childAt(list2, i);
            if (!nodeOrTokenStructuralEquals(element1, element2)) {
                return false;
            }
        }

        return true;
    }

    export function elementStructuralEquals(element1: TypeScript.ISyntaxElement, element2: TypeScript.ISyntaxElement) {
        if (element1 === element2) {
            return true;
        }

        if (element1 === null || element2 === null) {
            return false;
        }

        if (element2.kind() !== element2.kind()) {
            return false;
        }

        if (TypeScript.fullStart(element1) !== TypeScript.fullStart(element2)) {
            return false;
        }

        if (TypeScript.start(element1) !== TypeScript.start(element2)) {
            return false;
        }

        if (TypeScript.end(element1) !== TypeScript.end(element2)) {
            return false;
        }

        if (TypeScript.fullEnd(element1) !== TypeScript.fullEnd(element2)) {
            return false;
        }

        if (TypeScript.isToken(element1)) {
            return tokenStructuralEquals(<TypeScript.ISyntaxToken>element1, <TypeScript.ISyntaxToken>element2);
        }
        else if (TypeScript.isNode(element1)) {
            return nodeStructuralEquals(<TypeScript.ISyntaxNode>element1, <TypeScript.ISyntaxNode>element2);
        }
        else if (TypeScript.isList(element1)) {
            return listStructuralEquals(<TypeScript.ISyntaxNodeOrToken[]>element1, <TypeScript.ISyntaxNodeOrToken[]>element2);
        }
        else if (TypeScript.isSeparatedList(element1)) {
            return separatedListStructuralEquals(<TypeScript.ISyntaxNodeOrToken[]>element1, <TypeScript.ISyntaxNodeOrToken[]>element2);
        }

        throw TypeScript.Errors.invalidOperation();
    }

    export function treeStructuralEquals(tree1: TypeScript.SyntaxTree, tree2: TypeScript.SyntaxTree): boolean {
        if (!TypeScript.ArrayUtilities.sequenceEquals(tree1.diagnostics(), tree2.diagnostics(), TypeScript.Diagnostic.equals)) {
            return false;
        }

        return nodeStructuralEquals(tree1.sourceUnit(), tree2.sourceUnit());
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class Unicode {
        /*
            As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
            IdentifierStart ::
                Can contain Unicode 3.0.0  categories:
                Uppercase letter (Lu),
                Lowercase letter (Ll),
                Titlecase letter (Lt),
                Modifier letter (Lm),
                Other letter (Lo), or
                Letter number (Nl).
            IdentifierPart :: =
                Can contain IdentifierStart + Unicode 3.0.0  categories:
                Non-spacing mark (Mn),
                Combining spacing mark (Mc),
                Decimal number (Nd), or
                Connector punctuation (Pc).

            Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
            http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
        */
        static unicodeES3IdentifierStart = [170,170,  181,181,  186,186,  192,214,  216,246,  248,543,  546,563,  592,685,  688,696,  699,705,  720,721,  736,740,  750,750,  890,890,  902,902,  904,906,  908,908,  910,929,  931,974,  976,983,  986,1011,  1024,1153,  1164,1220,  1223,1224,  1227,1228,  1232,1269,  1272,1273,  1329,1366,  1369,1369,  1377,1415,  1488,1514,  1520,1522,  1569,1594,  1600,1610,  1649,1747,  1749,1749,  1765,1766,  1786,1788,  1808,1808,  1810,1836,  1920,1957,  2309,2361,  2365,2365,  2384,2384,  2392,2401,  2437,2444,  2447,2448,  2451,2472,  2474,2480,  2482,2482,  2486,2489,  2524,2525,  2527,2529,  2544,2545,  2565,2570,  2575,2576,  2579,2600,  2602,2608,  2610,2611,  2613,2614,  2616,2617,  2649,2652,  2654,2654,  2674,2676,  2693,2699,  2701,2701,  2703,2705,  2707,2728,  2730,2736,  2738,2739,  2741,2745,  2749,2749,  2768,2768,  2784,2784,  2821,2828,  2831,2832,  2835,2856,  2858,2864,  2866,2867,  2870,2873,  2877,2877,  2908,2909,  2911,2913,  2949,2954,  2958,2960,  2962,2965,  2969,2970,  2972,2972,  2974,2975,  2979,2980,  2984,2986,  2990,2997,  2999,3001,  3077,3084,  3086,3088,  3090,3112,  3114,3123,  3125,3129,  3168,3169,  3205,3212,  3214,3216,  3218,3240,  3242,3251,  3253,3257,  3294,3294,  3296,3297,  3333,3340,  3342,3344,  3346,3368,  3370,3385,  3424,3425,  3461,3478,  3482,3505,  3507,3515,  3517,3517,  3520,3526,  3585,3632,  3634,3635,  3648,3654,  3713,3714,  3716,3716,  3719,3720,  3722,3722,  3725,3725,  3732,3735,  3737,3743,  3745,3747,  3749,3749,  3751,3751,  3754,3755,  3757,3760,  3762,3763,  3773,3773,  3776,3780,  3782,3782,  3804,3805,  3840,3840,  3904,3911,  3913,3946,  3976,3979,  4096,4129,  4131,4135,  4137,4138,  4176,4181,  4256,4293,  4304,4342,  4352,4441,  4447,4514,  4520,4601,  4608,4614,  4616,4678,  4680,4680,  4682,4685,  4688,4694,  4696,4696,  4698,4701,  4704,4742,  4744,4744,  4746,4749,  4752,4782,  4784,4784,  4786,4789,  4792,4798,  4800,4800,  4802,4805,  4808,4814,  4816,4822,  4824,4846,  4848,4878,  4880,4880,  4882,4885,  4888,4894,  4896,4934,  4936,4954,  5024,5108,  5121,5740,  5743,5750,  5761,5786,  5792,5866,  6016,6067,  6176,6263,  6272,6312,  7680,7835,  7840,7929,  7936,7957,  7960,7965,  7968,8005,  8008,8013,  8016,8023,  8025,8025,  8027,8027,  8029,8029,  8031,8061,  8064,8116,  8118,8124,  8126,8126,  8130,8132,  8134,8140,  8144,8147,  8150,8155,  8160,8172,  8178,8180,  8182,8188,  8319,8319,  8450,8450,  8455,8455,  8458,8467,  8469,8469,  8473,8477,  8484,8484,  8486,8486,  8488,8488,  8490,8493,  8495,8497,  8499,8505,  8544,8579,  12293,12295,  12321,12329,  12337,12341,  12344,12346,  12353,12436,  12445,12446,  12449,12538,  12540,12542,  12549,12588,  12593,12686,  12704,12727,  13312,19893,  19968,40869,  40960,42124,  44032,55203,  63744,64045,  64256,64262,  64275,64279,  64285,64285,  64287,64296,  64298,64310,  64312,64316,  64318,64318,  64320,64321,  64323,64324,  64326,64433,  64467,64829,  64848,64911,  64914,64967,  65008,65019,  65136,65138,  65140,65140,  65142,65276,  65313,65338,  65345,65370,  65382,65470,  65474,65479,  65482,65487,  65490,65495,  65498,65500,  ];
        static unicodeES3IdentifierPart =  [170,170,  181,181,  186,186,  192,214,  216,246,  248,543,  546,563,  592,685,  688,696,  699,705,  720,721,  736,740,  750,750,  768,846,  864,866,  890,890,  902,902,  904,906,  908,908,  910,929,  931,974,  976,983,  986,1011,  1024,1153,  1155,1158,  1164,1220,  1223,1224,  1227,1228,  1232,1269,  1272,1273,  1329,1366,  1369,1369,  1377,1415,  1425,1441,  1443,1465,  1467,1469,  1471,1471,  1473,1474,  1476,1476,  1488,1514,  1520,1522,  1569,1594,  1600,1621,  1632,1641,  1648,1747,  1749,1756,  1759,1768,  1770,1773,  1776,1788,  1808,1836,  1840,1866,  1920,1968,  2305,2307,  2309,2361,  2364,2381,  2384,2388,  2392,2403,  2406,2415,  2433,2435,  2437,2444,  2447,2448,  2451,2472,  2474,2480,  2482,2482,  2486,2489,  2492,2492,  2494,2500,  2503,2504,  2507,2509,  2519,2519,  2524,2525,  2527,2531,  2534,2545,  2562,2562,  2565,2570,  2575,2576,  2579,2600,  2602,2608,  2610,2611,  2613,2614,  2616,2617,  2620,2620,  2622,2626,  2631,2632,  2635,2637,  2649,2652,  2654,2654,  2662,2676,  2689,2691,  2693,2699,  2701,2701,  2703,2705,  2707,2728,  2730,2736,  2738,2739,  2741,2745,  2748,2757,  2759,2761,  2763,2765,  2768,2768,  2784,2784,  2790,2799,  2817,2819,  2821,2828,  2831,2832,  2835,2856,  2858,2864,  2866,2867,  2870,2873,  2876,2883,  2887,2888,  2891,2893,  2902,2903,  2908,2909,  2911,2913,  2918,2927,  2946,2947,  2949,2954,  2958,2960,  2962,2965,  2969,2970,  2972,2972,  2974,2975,  2979,2980,  2984,2986,  2990,2997,  2999,3001,  3006,3010,  3014,3016,  3018,3021,  3031,3031,  3047,3055,  3073,3075,  3077,3084,  3086,3088,  3090,3112,  3114,3123,  3125,3129,  3134,3140,  3142,3144,  3146,3149,  3157,3158,  3168,3169,  3174,3183,  3202,3203,  3205,3212,  3214,3216,  3218,3240,  3242,3251,  3253,3257,  3262,3268,  3270,3272,  3274,3277,  3285,3286,  3294,3294,  3296,3297,  3302,3311,  3330,3331,  3333,3340,  3342,3344,  3346,3368,  3370,3385,  3390,3395,  3398,3400,  3402,3405,  3415,3415,  3424,3425,  3430,3439,  3458,3459,  3461,3478,  3482,3505,  3507,3515,  3517,3517,  3520,3526,  3530,3530,  3535,3540,  3542,3542,  3544,3551,  3570,3571,  3585,3642,  3648,3662,  3664,3673,  3713,3714,  3716,3716,  3719,3720,  3722,3722,  3725,3725,  3732,3735,  3737,3743,  3745,3747,  3749,3749,  3751,3751,  3754,3755,  3757,3769,  3771,3773,  3776,3780,  3782,3782,  3784,3789,  3792,3801,  3804,3805,  3840,3840,  3864,3865,  3872,3881,  3893,3893,  3895,3895,  3897,3897,  3902,3911,  3913,3946,  3953,3972,  3974,3979,  3984,3991,  3993,4028,  4038,4038,  4096,4129,  4131,4135,  4137,4138,  4140,4146,  4150,4153,  4160,4169,  4176,4185,  4256,4293,  4304,4342,  4352,4441,  4447,4514,  4520,4601,  4608,4614,  4616,4678,  4680,4680,  4682,4685,  4688,4694,  4696,4696,  4698,4701,  4704,4742,  4744,4744,  4746,4749,  4752,4782,  4784,4784,  4786,4789,  4792,4798,  4800,4800,  4802,4805,  4808,4814,  4816,4822,  4824,4846,  4848,4878,  4880,4880,  4882,4885,  4888,4894,  4896,4934,  4936,4954,  4969,4977,  5024,5108,  5121,5740,  5743,5750,  5761,5786,  5792,5866,  6016,6099,  6112,6121,  6160,6169,  6176,6263,  6272,6313,  7680,7835,  7840,7929,  7936,7957,  7960,7965,  7968,8005,  8008,8013,  8016,8023,  8025,8025,  8027,8027,  8029,8029,  8031,8061,  8064,8116,  8118,8124,  8126,8126,  8130,8132,  8134,8140,  8144,8147,  8150,8155,  8160,8172,  8178,8180,  8182,8188,  8255,8256,  8319,8319,  8400,8412,  8417,8417,  8450,8450,  8455,8455,  8458,8467,  8469,8469,  8473,8477,  8484,8484,  8486,8486,  8488,8488,  8490,8493,  8495,8497,  8499,8505,  8544,8579,  12293,12295,  12321,12335,  12337,12341,  12344,12346,  12353,12436,  12441,12442,  12445,12446,  12449,12542,  12549,12588,  12593,12686,  12704,12727,  13312,19893,  19968,40869,  40960,42124,  44032,55203,  63744,64045,  64256,64262,  64275,64279,  64285,64296,  64298,64310,  64312,64316,  64318,64318,  64320,64321,  64323,64324,  64326,64433,  64467,64829,  64848,64911,  64914,64967,  65008,65019,  65056,65059,  65075,65076,  65101,65103,  65136,65138,  65140,65140,  65142,65276,  65296,65305,  65313,65338,  65343,65343,  65345,65370,  65381,65470,  65474,65479,  65482,65487,  65490,65495,  65498,65500,  ];

        /*
            As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
            IdentifierStart ::
                Can contain Unicode 6.2  categories:
                Uppercase letter (Lu),
                Lowercase letter (Ll),
                Titlecase letter (Lt),
                Modifier letter (Lm),
                Other letter (Lo), or
                Letter number (Nl).
            IdentifierPart ::
                Can contain IdentifierStart + Unicode 6.2  categories:
                Non-spacing mark (Mn),
                Combining spacing mark (Mc),
                Decimal number (Nd),
                Connector punctuation (Pc),
                <ZWNJ>, or
                <ZWJ>.

            Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
            http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
        */
        static unicodeES5IdentifierStart = [170,170,  181,181,  186,186,  192,214,  216,246,  248,705,  710,721,  736,740,  748,748,  750,750,  880,884,  886,887,  890,893,  902,902,  904,906,  908,908,  910,929,  931,1013,  1015,1153,  1162,1319,  1329,1366,  1369,1369,  1377,1415,  1488,1514,  1520,1522,  1568,1610,  1646,1647,  1649,1747,  1749,1749,  1765,1766,  1774,1775,  1786,1788,  1791,1791,  1808,1808,  1810,1839,  1869,1957,  1969,1969,  1994,2026,  2036,2037,  2042,2042,  2048,2069,  2074,2074,  2084,2084,  2088,2088,  2112,2136,  2208,2208,  2210,2220,  2308,2361,  2365,2365,  2384,2384,  2392,2401,  2417,2423,  2425,2431,  2437,2444,  2447,2448,  2451,2472,  2474,2480,  2482,2482,  2486,2489,  2493,2493,  2510,2510,  2524,2525,  2527,2529,  2544,2545,  2565,2570,  2575,2576,  2579,2600,  2602,2608,  2610,2611,  2613,2614,  2616,2617,  2649,2652,  2654,2654,  2674,2676,  2693,2701,  2703,2705,  2707,2728,  2730,2736,  2738,2739,  2741,2745,  2749,2749,  2768,2768,  2784,2785,  2821,2828,  2831,2832,  2835,2856,  2858,2864,  2866,2867,  2869,2873,  2877,2877,  2908,2909,  2911,2913,  2929,2929,  2947,2947,  2949,2954,  2958,2960,  2962,2965,  2969,2970,  2972,2972,  2974,2975,  2979,2980,  2984,2986,  2990,3001,  3024,3024,  3077,3084,  3086,3088,  3090,3112,  3114,3123,  3125,3129,  3133,3133,  3160,3161,  3168,3169,  3205,3212,  3214,3216,  3218,3240,  3242,3251,  3253,3257,  3261,3261,  3294,3294,  3296,3297,  3313,3314,  3333,3340,  3342,3344,  3346,3386,  3389,3389,  3406,3406,  3424,3425,  3450,3455,  3461,3478,  3482,3505,  3507,3515,  3517,3517,  3520,3526,  3585,3632,  3634,3635,  3648,3654,  3713,3714,  3716,3716,  3719,3720,  3722,3722,  3725,3725,  3732,3735,  3737,3743,  3745,3747,  3749,3749,  3751,3751,  3754,3755,  3757,3760,  3762,3763,  3773,3773,  3776,3780,  3782,3782,  3804,3807,  3840,3840,  3904,3911,  3913,3948,  3976,3980,  4096,4138,  4159,4159,  4176,4181,  4186,4189,  4193,4193,  4197,4198,  4206,4208,  4213,4225,  4238,4238,  4256,4293,  4295,4295,  4301,4301,  4304,4346,  4348,4680,  4682,4685,  4688,4694,  4696,4696,  4698,4701,  4704,4744,  4746,4749,  4752,4784,  4786,4789,  4792,4798,  4800,4800,  4802,4805,  4808,4822,  4824,4880,  4882,4885,  4888,4954,  4992,5007,  5024,5108,  5121,5740,  5743,5759,  5761,5786,  5792,5866,  5870,5872,  5888,5900,  5902,5905,  5920,5937,  5952,5969,  5984,5996,  5998,6000,  6016,6067,  6103,6103,  6108,6108,  6176,6263,  6272,6312,  6314,6314,  6320,6389,  6400,6428,  6480,6509,  6512,6516,  6528,6571,  6593,6599,  6656,6678,  6688,6740,  6823,6823,  6917,6963,  6981,6987,  7043,7072,  7086,7087,  7098,7141,  7168,7203,  7245,7247,  7258,7293,  7401,7404,  7406,7409,  7413,7414,  7424,7615,  7680,7957,  7960,7965,  7968,8005,  8008,8013,  8016,8023,  8025,8025,  8027,8027,  8029,8029,  8031,8061,  8064,8116,  8118,8124,  8126,8126,  8130,8132,  8134,8140,  8144,8147,  8150,8155,  8160,8172,  8178,8180,  8182,8188,  8305,8305,  8319,8319,  8336,8348,  8450,8450,  8455,8455,  8458,8467,  8469,8469,  8473,8477,  8484,8484,  8486,8486,  8488,8488,  8490,8493,  8495,8505,  8508,8511,  8517,8521,  8526,8526,  8544,8584,  11264,11310,  11312,11358,  11360,11492,  11499,11502,  11506,11507,  11520,11557,  11559,11559,  11565,11565,  11568,11623,  11631,11631,  11648,11670,  11680,11686,  11688,11694,  11696,11702,  11704,11710,  11712,11718,  11720,11726,  11728,11734,  11736,11742,  11823,11823,  12293,12295,  12321,12329,  12337,12341,  12344,12348,  12353,12438,  12445,12447,  12449,12538,  12540,12543,  12549,12589,  12593,12686,  12704,12730,  12784,12799,  13312,19893,  19968,40908,  40960,42124,  42192,42237,  42240,42508,  42512,42527,  42538,42539,  42560,42606,  42623,42647,  42656,42735,  42775,42783,  42786,42888,  42891,42894,  42896,42899,  42912,42922,  43000,43009,  43011,43013,  43015,43018,  43020,43042,  43072,43123,  43138,43187,  43250,43255,  43259,43259,  43274,43301,  43312,43334,  43360,43388,  43396,43442,  43471,43471,  43520,43560,  43584,43586,  43588,43595,  43616,43638,  43642,43642,  43648,43695,  43697,43697,  43701,43702,  43705,43709,  43712,43712,  43714,43714,  43739,43741,  43744,43754,  43762,43764,  43777,43782,  43785,43790,  43793,43798,  43808,43814,  43816,43822,  43968,44002,  44032,55203,  55216,55238,  55243,55291,  63744,64109,  64112,64217,  64256,64262,  64275,64279,  64285,64285,  64287,64296,  64298,64310,  64312,64316,  64318,64318,  64320,64321,  64323,64324,  64326,64433,  64467,64829,  64848,64911,  64914,64967,  65008,65019,  65136,65140,  65142,65276,  65313,65338,  65345,65370,  65382,65470,  65474,65479,  65482,65487,  65490,65495,  65498,65500,  ];
        static unicodeES5IdentifierPart =  [170,170,  181,181,  186,186,  192,214,  216,246,  248,705,  710,721,  736,740,  748,748,  750,750,  768,884,  886,887,  890,893,  902,902,  904,906,  908,908,  910,929,  931,1013,  1015,1153,  1155,1159,  1162,1319,  1329,1366,  1369,1369,  1377,1415,  1425,1469,  1471,1471,  1473,1474,  1476,1477,  1479,1479,  1488,1514,  1520,1522,  1552,1562,  1568,1641,  1646,1747,  1749,1756,  1759,1768,  1770,1788,  1791,1791,  1808,1866,  1869,1969,  1984,2037,  2042,2042,  2048,2093,  2112,2139,  2208,2208,  2210,2220,  2276,2302,  2304,2403,  2406,2415,  2417,2423,  2425,2431,  2433,2435,  2437,2444,  2447,2448,  2451,2472,  2474,2480,  2482,2482,  2486,2489,  2492,2500,  2503,2504,  2507,2510,  2519,2519,  2524,2525,  2527,2531,  2534,2545,  2561,2563,  2565,2570,  2575,2576,  2579,2600,  2602,2608,  2610,2611,  2613,2614,  2616,2617,  2620,2620,  2622,2626,  2631,2632,  2635,2637,  2641,2641,  2649,2652,  2654,2654,  2662,2677,  2689,2691,  2693,2701,  2703,2705,  2707,2728,  2730,2736,  2738,2739,  2741,2745,  2748,2757,  2759,2761,  2763,2765,  2768,2768,  2784,2787,  2790,2799,  2817,2819,  2821,2828,  2831,2832,  2835,2856,  2858,2864,  2866,2867,  2869,2873,  2876,2884,  2887,2888,  2891,2893,  2902,2903,  2908,2909,  2911,2915,  2918,2927,  2929,2929,  2946,2947,  2949,2954,  2958,2960,  2962,2965,  2969,2970,  2972,2972,  2974,2975,  2979,2980,  2984,2986,  2990,3001,  3006,3010,  3014,3016,  3018,3021,  3024,3024,  3031,3031,  3046,3055,  3073,3075,  3077,3084,  3086,3088,  3090,3112,  3114,3123,  3125,3129,  3133,3140,  3142,3144,  3146,3149,  3157,3158,  3160,3161,  3168,3171,  3174,3183,  3202,3203,  3205,3212,  3214,3216,  3218,3240,  3242,3251,  3253,3257,  3260,3268,  3270,3272,  3274,3277,  3285,3286,  3294,3294,  3296,3299,  3302,3311,  3313,3314,  3330,3331,  3333,3340,  3342,3344,  3346,3386,  3389,3396,  3398,3400,  3402,3406,  3415,3415,  3424,3427,  3430,3439,  3450,3455,  3458,3459,  3461,3478,  3482,3505,  3507,3515,  3517,3517,  3520,3526,  3530,3530,  3535,3540,  3542,3542,  3544,3551,  3570,3571,  3585,3642,  3648,3662,  3664,3673,  3713,3714,  3716,3716,  3719,3720,  3722,3722,  3725,3725,  3732,3735,  3737,3743,  3745,3747,  3749,3749,  3751,3751,  3754,3755,  3757,3769,  3771,3773,  3776,3780,  3782,3782,  3784,3789,  3792,3801,  3804,3807,  3840,3840,  3864,3865,  3872,3881,  3893,3893,  3895,3895,  3897,3897,  3902,3911,  3913,3948,  3953,3972,  3974,3991,  3993,4028,  4038,4038,  4096,4169,  4176,4253,  4256,4293,  4295,4295,  4301,4301,  4304,4346,  4348,4680,  4682,4685,  4688,4694,  4696,4696,  4698,4701,  4704,4744,  4746,4749,  4752,4784,  4786,4789,  4792,4798,  4800,4800,  4802,4805,  4808,4822,  4824,4880,  4882,4885,  4888,4954,  4957,4959,  4992,5007,  5024,5108,  5121,5740,  5743,5759,  5761,5786,  5792,5866,  5870,5872,  5888,5900,  5902,5908,  5920,5940,  5952,5971,  5984,5996,  5998,6000,  6002,6003,  6016,6099,  6103,6103,  6108,6109,  6112,6121,  6155,6157,  6160,6169,  6176,6263,  6272,6314,  6320,6389,  6400,6428,  6432,6443,  6448,6459,  6470,6509,  6512,6516,  6528,6571,  6576,6601,  6608,6617,  6656,6683,  6688,6750,  6752,6780,  6783,6793,  6800,6809,  6823,6823,  6912,6987,  6992,7001,  7019,7027,  7040,7155,  7168,7223,  7232,7241,  7245,7293,  7376,7378,  7380,7414,  7424,7654,  7676,7957,  7960,7965,  7968,8005,  8008,8013,  8016,8023,  8025,8025,  8027,8027,  8029,8029,  8031,8061,  8064,8116,  8118,8124,  8126,8126,  8130,8132,  8134,8140,  8144,8147,  8150,8155,  8160,8172,  8178,8180,  8182,8188,  8204,8205,  8255,8256,  8276,8276,  8305,8305,  8319,8319,  8336,8348,  8400,8412,  8417,8417,  8421,8432,  8450,8450,  8455,8455,  8458,8467,  8469,8469,  8473,8477,  8484,8484,  8486,8486,  8488,8488,  8490,8493,  8495,8505,  8508,8511,  8517,8521,  8526,8526,  8544,8584,  11264,11310,  11312,11358,  11360,11492,  11499,11507,  11520,11557,  11559,11559,  11565,11565,  11568,11623,  11631,11631,  11647,11670,  11680,11686,  11688,11694,  11696,11702,  11704,11710,  11712,11718,  11720,11726,  11728,11734,  11736,11742,  11744,11775,  11823,11823,  12293,12295,  12321,12335,  12337,12341,  12344,12348,  12353,12438,  12441,12442,  12445,12447,  12449,12538,  12540,12543,  12549,12589,  12593,12686,  12704,12730,  12784,12799,  13312,19893,  19968,40908,  40960,42124,  42192,42237,  42240,42508,  42512,42539,  42560,42607,  42612,42621,  42623,42647,  42655,42737,  42775,42783,  42786,42888,  42891,42894,  42896,42899,  42912,42922,  43000,43047,  43072,43123,  43136,43204,  43216,43225,  43232,43255,  43259,43259,  43264,43309,  43312,43347,  43360,43388,  43392,43456,  43471,43481,  43520,43574,  43584,43597,  43600,43609,  43616,43638,  43642,43643,  43648,43714,  43739,43741,  43744,43759,  43762,43766,  43777,43782,  43785,43790,  43793,43798,  43808,43814,  43816,43822,  43968,44010,  44012,44013,  44016,44025,  44032,55203,  55216,55238,  55243,55291,  63744,64109,  64112,64217,  64256,64262,  64275,64279,  64285,64296,  64298,64310,  64312,64316,  64318,64318,  64320,64321,  64323,64324,  64326,64433,  64467,64829,  64848,64911,  64914,64967,  65008,65019,  65024,65039,  65056,65062,  65075,65076,  65101,65103,  65136,65140,  65142,65276,  65296,65305,  65313,65338,  65343,65343,  65345,65370,  65382,65470,  65474,65479,  65482,65487,  65490,65495,  65498,65500,  ];

        static lookupInUnicodeMap(code: number, map: number[]): boolean {
            // Bail out quickly if it couldn't possibly be in the map.
            if (code < map[0]) {
                return false;
            }

            // Perform binary search in one of the unicode range maps
            var lo: number = 0;
            var hi: number = map.length;
            var mid: number;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                // mid has to be even to catch a range's beginning
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                }
                else {
                    lo = mid + 2;
                }
            }

            return false;
        }

        public static isIdentifierStart(code: number, languageVersion: LanguageVersion) {
            if (languageVersion === LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            }
            else if (languageVersion === LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            }
            else {
                throw Errors.argumentOutOfRange("languageVersion");
            }
        }

        public static isIdentifierPart(code: number, languageVersion: LanguageVersion) {
            if (languageVersion === LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            }
            else if (languageVersion === LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            }
            else {
                throw Errors.argumentOutOfRange("languageVersion");
            }
        }
    }
}
///<reference path='references.ts' />

module TypeScript {
    export enum CharacterCodes {
        nullCharacter = 0,
        maxAsciiCharacter = 127,

        lineFeed = 10,              // \n
        carriageReturn = 13,        // \r
        lineSeparator = 0x2028,
        paragraphSeparator = 0x2029,

        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems 
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        nextLine = 0x0085,

        // Unicode 3.0 space characters
        space = 0x0020,   // " "
        nonBreakingSpace = 0x00A0,   //
        enQuad = 0x2000,
        emQuad = 0x2001,
        enSpace = 0x2002,
        emSpace = 0x2003,
        threePerEmSpace = 0x2004,
        fourPerEmSpace = 0x2005,
        sixPerEmSpace = 0x2006,
        figureSpace = 0x2007,
        punctuationSpace = 0x2008,
        thinSpace = 0x2009,
        hairSpace = 0x200A,
        zeroWidthSpace = 0x200B,
        narrowNoBreakSpace = 0x202F,
        ideographicSpace = 0x3000,

        _ = 95,
        $ = 36,

        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,

        a = 97,
        b = 98,
        c = 99,
        d = 100,
        e = 101,
        f = 102,
        g = 103,
        h = 104,
        i = 105,
        j = 106,
        k = 107,
        l = 108,
        m = 109,
        n = 110,
        o = 111,
        p = 112,
        q = 113,
        r = 114,
        s = 115,
        t = 116,
        u = 117,
        v = 118,
        w = 119,
        x = 120,
        y = 121,
        z = 122,

        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,

        ampersand = 38,             // &
        asterisk = 42,              // *
        at = 64,                    // @
        backslash = 92,             // \
        bar = 124,                  // |
        caret = 94,                 // ^
        closeBrace = 125,           // }
        closeBracket = 93,          // ]
        closeParen = 41,            // )
        colon = 58,                 // : 
        comma = 44,                 // ,
        dot = 46,                   // .
        doubleQuote = 34,           // "
        equals = 61,                // =
        exclamation = 33,           // !
        greaterThan = 62,           // >
        lessThan = 60,              // <
        minus = 45,                 // -
        openBrace = 123,            // {
        openBracket = 91,           // [
        openParen = 40,             // (
        percent = 37,               // %
        plus = 43,                  // +
        question = 63,              // ?
        semicolon = 59,             // ;
        singleQuote = 39,           // '
        slash = 47,                 // /
        tilde = 126,                // ~

        backspace = 8,              // \b
        formFeed = 12,              // \f
        byteOrderMark = 0xFEFF,
        tab = 9,                    // \t
        verticalTab = 11,           // \v
    }
}
///<reference path='references.ts' />

module TypeScript {
    export module LineMap1 {
        export function fromSimpleText(text: ISimpleText): LineMap {
            return new LineMap(() => TextUtilities.parseLineStarts({ charCodeAt: index => text.charCodeAt(index), length: text.length() }), text.length());
        }

        export function fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): LineMap {
            return new LineMap(() => scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        }

        export function fromString(text: string): LineMap {
            return new LineMap(() => TextUtilities.parseLineStarts(text), text.length);
        }
    }
}
///<reference path='..\core\references.ts' />

///<reference path='characterCodes.ts' />
///<reference path='scriptSnapshot.ts' />
///<reference path='text.ts' />
///<reference path='textLine.ts' />
///<reference path='lineMap.ts' />
///<reference path='textFactory.ts' />
///<reference path='textUtilities.ts' />
///<reference path='textSpan.ts' />

// TextChangeRange depends on TextSpan.
///<reference path='textChangeRange.ts' />
///<reference path='references.ts' />

module TypeScript {
    // Represents an immutable snapshot of a script at a specified time.  Once acquired, the 
    // snapshot is observably immutable.  i.e. the same calls with the same parameters will return
    // the same values.
    export interface IScriptSnapshot {
        // Get's a portion of the script snapshot specified by [start, end).  
        getText(start: number, end: number): string;

        // Get's the length of this script snapshot.
        getLength(): number;

        // This call returns the array containing the start position of every line.  
        // i.e."[0, 10, 55]".  TODO: consider making this optional.  The language service could
        // always determine this (albeit in a more expensive manner).
        getLineStartPositions(): number[];

        // Returns a text change range representing what text has changed since the specified version.
        // If the change cannot be determined (say, because a file was opened/closed), then 'null' 
        // should be returned.
        getTextChangeRangeSinceVersion(scriptVersion: number): TextChangeRange;
    }

    export module ScriptSnapshot {
        class StringScriptSnapshot implements IScriptSnapshot {
            private _lineStartPositions: number[] = null;

            constructor(private text: string) {
            }

            public getText(start: number, end: number): string {
                return this.text.substring(start, end);
            }

            public getLength(): number {
                return this.text.length;
            }

            public getLineStartPositions(): number[]{
                if (!this._lineStartPositions) {
                    this._lineStartPositions = TextUtilities.parseLineStarts(this.text);
                }

                return this._lineStartPositions;
            }

            public getTextChangeRangeSinceVersion(scriptVersion: number): TypeScript.TextChangeRange {
                throw Errors.notYetImplemented();
            }
        }

        export function fromString(text: string): IScriptSnapshot {
            return new StringScriptSnapshot(text);
        }
    }
}
///<reference path='references.ts' />

/**
 * Represents an immutable snapshot of text.
 */
module TypeScript {
    export interface ISimpleText {
        /**
         * Total number of characters in the text source.
         */
        length(): number;

        /**
         * Copy the count contents of IText starting from sourceIndex to destination starting at
         * destinationIndex.
         */
        copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void;

        substr(start: number, length: number): string;

        /**
         * Gets the a new IText that corresponds to the contents of this IText for the given span.
         */
        subText(span: TextSpan): ISimpleText;

        charCodeAt(index: number): number;
        lineMap(): LineMap;
    }

    /**
     * Represents an immutable snapshot of text.
     */
    export interface IText extends ISimpleText {
        /**
         * Total number of lines in the text.
         */
        lineCount(): number;

        /**
         * Returns the collection of line information for the IText instance.
         */
        lines(): ITextLine[];

        /**
         * Return the char at position in the IText.
         */
        charCodeAt(position: number): number;

        /**
         * Gets the line corresponding to the provided line number.
         */
        getLineFromLineNumber(lineNumber: number): ITextLine;

        /**
         * Gets the line which encompasses the provided position.
         */
        getLineFromPosition(position: number): ITextLine;

        /**
         * Gets the number of the line that contains the character at the specified position.
         */
        getLineNumberFromPosition(position: number): number;

        /**
         * Gets a line number, and position within that line, for the character at the 
         * specified position
         */
        getLinePosition(position: number): LineAndCharacter;

        /**
         * Returns a string representation of the contents of this IText within the given span.
         */
        toString(span?: TextSpan): string;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export class TextChangeRange {
        public static unchanged = new TextChangeRange(new TextSpan(0, 0), 0);

        private _span: TextSpan;
        private _newLength: number;

        /**
         * Initializes a new instance of TextChangeRange.
         */
        constructor(span: TextSpan, newLength: number) {
            if (newLength < 0) {
                throw Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }

        /**
         * The span of text before the edit which is being changed
         */
        public span(): TextSpan {
            return this._span;
        }

        /**
         * Width of the span after the edit.  A 0 here would represent a delete
         */
        public newLength(): number {
            return this._newLength;
        }

        public newSpan(): TextSpan {
            return new TextSpan(this.span().start(), this.newLength());
        }

        public isUnchanged(): boolean {
            return this.span().isEmpty() && this.newLength() === 0;
        }

        /**
         * Called to merge all the changes that occurred between one version of a script snapshot to 
         * the next into a single change.  i.e. say a user did a box selection and made an edit.  That
         * will show up as N text change ranges between version V of a script and version V+1.  This
         * function collapses those N changes into a single change range valid between V and V+1.
         */
        public static collapseChangesFromSingleVersion(changes: TextChangeRange[]): TextChangeRange {
            var diff = 0;
            var start = Constants.Max31BitInteger;
            var end = 0;

            // TODO: we are assuming that changes are normalized. That is currently not guaranteed,
            // but changes that we get from IDE are normalized. Idealy changes should come in a kind
            // of normalized change collection instead of IEnumerable to really guarantee that they
            // are normalized.
            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();

                if (change.span().start() < start) {
                    start = change.span().start();
                }

                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }

            if (start > end) {
                return null;
            }

            var combined = TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;

            return new TextChangeRange(combined, newLen);
        }

        /**
         * Called to merge all the changes that occurred across several versions of a script snapshot 
         * into a single change.  i.e. if a user keeps making successive edits to a script we will
         * have a text change from V1 to V2, V2 to V3, ..., Vn.  
         * 
         * This function will then merge those changes into a single change range valid between V1 and
         * Vn.
         */
        public static collapseChangesAcrossMultipleVersions(changes: TextChangeRange[]): TextChangeRange {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length === 1) {
                return changes[0];
            }

            // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
            // as it makes things much easier to reason about.
            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                // Consider the following case:
                // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
                // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
                // i.e. the span starting at 30 with length 30 is increased to length 40.
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      -------------------------------------------------------------------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      -------------------------------------------------------------------------------------------------------
                //                                     |                            \                                          
                //                                     |                               \                                       
                //   T2                                |                                 \                                     
                //                                     |                                   \                                   
                //                                     |                                      \                                
                //      -------------------------------------------------------------------------------------------------------
                //
                // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
                // it's just the min of the old and new starts.  i.e.:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      ------------------------------------------------------------*------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      ----------------------------------------$-------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // (Note the dots represent the newly inferrred start.
                // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
                // absolute positions at the asterixes, and the relative change between the dollar signs. Basically, we see
                // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
                // means:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      --------------------------------------------------------------------------------*----------------------
                //                |                                                                     /                      
                //                |                                                                /----                       
                //  T1            |                                                           /----                            
                //                |                                                      /----                                 
                //                |                                                 /----                                      
                //      ------------------------------------------------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // In other words (in this case), we're recognizing that the second edit happened after where the first edit
                // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
                // that's the same as if we started at char 80 instead of 60.  
                //
                // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rahter
                // than pusing the first edit forward to match the second, we'll push the second edit forward to match the
                // first.
                //
                // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
                // semantics: { { start: 10, length: 70 }, newLength: 60 }
                //
                // The math then works out as follows.
                // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the 
                // final result like so:
                //
                // {
                //      oldStart3: Min(oldStart1, oldStart2),
                //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
                //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
                // }

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = MathPrototype.min(oldStart1, oldStart2);
                oldEndN = MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TextSpan.fromBounds(oldStartN, oldEndN), /*newLength: */newEndN - oldStartN);
        }
    }
}
///<reference path='references.ts' />

module TypeScript.TextFactory {
    /**
     * Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
     * Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
     * Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
     */
    function getStartAndLengthOfLineBreakEndingAt(
        text: IText, index: number, info: LinebreakInfo): void {

        var c = text.charCodeAt(index);
        if (c === CharacterCodes.lineFeed) {
            if (index > 0 && text.charCodeAt(index - 1) === CharacterCodes.carriageReturn) {
                // "\r\n" is the only 2-character line break.
                info.startPosition = index - 1;
                info.length = 2;
            }
            else {
                info.startPosition = index;
                info.length = 1;
            }
        }
        else if (TextUtilities.isAnyLineBreakCharacter(c)) {
            info.startPosition = index;
            info.length = 1;
        }
        else {
            info.startPosition = index + 1;
            info.length = 0;
        }
    }

    class LinebreakInfo {
        constructor(public startPosition: number,
                     public length: number) {
        }
    }

    class TextLine implements ITextLine {
        private _text: IText = null;
        private _textSpan: TextSpan = null;
        private _lineBreakLength: number;
        private _lineNumber: number;

        constructor(text: IText, body: TextSpan, lineBreakLength: number, lineNumber: number) {
            if (text === null) {
                throw Errors.argumentNull('text');
            }
            Debug.assert(lineBreakLength >= 0);
            Debug.assert(lineNumber >= 0);
            this._text = text;
            this._textSpan = body;
            this._lineBreakLength = lineBreakLength;
            this._lineNumber = lineNumber;
        }

        public start(): number {
            return this._textSpan.start();
        }

        public end(): number {
            return this._textSpan.end();
        }

        public endIncludingLineBreak(): number {
            return this.end() + this._lineBreakLength;
        }

        public extent(): TextSpan {
            return this._textSpan;
        }

        public extentIncludingLineBreak(): TextSpan {
            return TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
        }

        public toString(): string {
            return this._text.toString(this._textSpan);
        }

        public lineNumber(): number {
            return this._lineNumber;
        }
    }

    class TextBase implements IText {
        /**
         * The length of the text represented by StringText.
         */
        public length(): number {
            throw Errors.abstract();
        }

        /**
         * Returns a character at given position. Throws an ArgumentOutOfRangeException when position is negative or 
         * greater than length.
         * @param position The position to get the character from.
         */
        public charCodeAt(position: number): number {
            throw Errors.abstract();
        }

        checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        /**
         * Provides a string representation of the StringText located within given span. Throws an ArgumentOutOfRangeException when given span is outside of the text range.
         */
        public toString(span: TextSpan = null): string {
            throw Errors.abstract();
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this, span);
        }

        public substr(start: number, length: number): string {
            throw Errors.abstract();
        }

        /**
         * Copy a range of characters from this IText to a destination array.
         */
        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            throw Errors.abstract();
        }

        /**
         * The length of the text represented by StringText.
         */
        public lineCount(): number {
            return this._lineStarts().length;
        }

        /**
         * The sequence of lines represented by StringText.
         */
        public lines(): ITextLine[] {
            var lines: ITextLine[] = [];

            var length = this.lineCount();
            for (var i = 0; i < length; ++i) {
                lines[i] = this.getLineFromLineNumber(i);
            }

            return lines;
        }

        public lineMap(): LineMap {
            return new LineMap(() => this._lineStarts(), this.length());
        }

        public _lineStarts(): number[]{
            throw Errors.abstract();
        }

        private linebreakInfo = new LinebreakInfo(0, 0);
        public getLineFromLineNumber(lineNumber: number): ITextLine {
            var lineStarts = this._lineStarts();

            if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                throw Errors.argumentOutOfRange("lineNumber");
            }

            var first = lineStarts[lineNumber];
            if (lineNumber === lineStarts.length - 1) {
                return new TextLine(this, new TextSpan(first, this.length() - first), 0, lineNumber);
            }
            else {
                getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                return new TextLine(this, new TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
            }

        }

        private lastLineFoundForPosition: ITextLine = null;
        public getLineFromPosition(position: number): ITextLine {
            // After asking about a location on a particular line
            // it is common to ask about other position in the same line again.
            // try to see if this is the case.
            var lastFound = this.lastLineFoundForPosition;
            if (lastFound !== null &&
                lastFound.start() <= position &&
                lastFound.endIncludingLineBreak() > position) {
                return lastFound;
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            var result = this.getLineFromLineNumber(lineNumber);
            this.lastLineFoundForPosition = result;
            return result;
        }

        public getLineNumberFromPosition(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            if (position === this.length()) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }

            // Binary search to find the right line
            var lineNumber = ArrayUtilities.binarySearch(this._lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        }

        public getLinePosition(position: number): LineAndCharacter {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new LineAndCharacter(lineNumber, position - this._lineStarts()[lineNumber]);
        }
    }

    /**
     * An IText that represents a subrange of another IText.
     */
    class SubText extends TextBase {
        private text: IText;
        private span: TextSpan;

        /**
         * The line start position of each line.
         */
        private _lazyLineStarts: number[] = null;

        constructor(text: IText, span: TextSpan) {
            super();

            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        public length(): number {
            return this.span.length();
        }

        public charCodeAt(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.text.charCodeAt(this.span.start() + position);
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        public substr(start: number, length: number): string {
            var startInOriginalText = this.span.start() + start;
            return this.text.substr(startInOriginalText, length);
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }

        public _lineStarts(): number[] {
            if (!this._lazyLineStarts) {
                this._lazyLineStarts = TextUtilities.parseLineStarts({ charCodeAt: index => this.charCodeAt(index), length: this.length() });
            }

            return this._lazyLineStarts;
        }
    }

    /**
     * Implementation of IText based on a System.String input
     */
    class StringText extends TextBase {
        /**
         * Underlying string on which this IText instance is based
         */
        private source: string = null;

        /**
         * The line start position of each line.
         */
        private _lazyLineStarts: number[] = null;

        /**
         * Initializes an instance of StringText with provided data.
         */
        constructor(data: string) {
            super();

            if (data === null) {
                throw Errors.argumentNull("data");
            }

            this.source = data;
        }

        /**
         * The length of the text represented by StringText.
         */
        public length(): number {
            return this.source.length;
        }

        /**
         * Returns a character at given position. Throws an ArgumentOutOfRangeException when position is negative or 
         * greater than length.
         * @param position The position to get the character from.
         */
        public charCodeAt(position: number): number {
            if (position < 0 || position >= this.source.length) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.source.charCodeAt(position);
        }

        public substr(start: number, length: number) {
            return this.source.substr(start, length);
        }

        /**
         * Provides a string representation of the StringText located within given span. Throws an ArgumentOutOfRangeException when given span is outside of the text range.
         */
        public toString(span: TextSpan = null): string {
            if (span === null) {
                span = new TextSpan(0, this.length());
            }

            this.checkSubSpan(span);

            if (span.start() === 0 && span.length() === this.length()) {
                return this.source;
            }

            return this.source.substr(span.start(), span.length());
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
        }

        public _lineStarts(): number[] {
            if (this._lazyLineStarts === null) {
                this._lazyLineStarts = TextUtilities.parseLineStarts(this.source);
            }

            return this._lazyLineStarts;
        }
    }

    export function createText(value: string): IText {
        return new StringText(value);
    }
}

module TypeScript.SimpleText {
    /**
     * An IText that represents a subrange of another IText.
     */
    class SimpleSubText implements ISimpleText {
        private text: ISimpleText = null;
        private span: TextSpan = null;
        private _lineMap: LineMap = null;

        constructor(text: ISimpleText, span: TextSpan) {
            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        private checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        private checkSubPosition(position: number): void {
            if (position < 0 || position >= this.length()) {
                throw Errors.argumentOutOfRange("position");
            }
        }

        public length(): number {
            return this.span.length();
        }

        public subText(span: TextSpan): ISimpleText {
            this.checkSubSpan(span);

            return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        public substr(start: number, length: number): string {
            var span = this.getCompositeSpan(start, length);
            return this.text.substr(span.start(), span.length());
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }

        public charCodeAt(index: number): number {
            this.checkSubPosition(index);
            return this.text.charCodeAt(this.span.start() + index);
        }

        public lineMap(): LineMap {
            if (this._lineMap === null) {
                this._lineMap = LineMap1.fromSimpleText(this);
            }

            return this._lineMap;
        }
    }

    class SimpleStringText implements ISimpleText {
        private _lineMap: LineMap = null;

        constructor(private value: string) {
        }

        public length(): number {
            return this.value.length;
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
        }

        public substr(start: number, length: number): string {
            return this.value.substr(start, length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }

        public charCodeAt(index: number): number {
            return this.value.charCodeAt(index);
        }

        public lineMap(): LineMap {
            if (!this._lineMap) {
                this._lineMap = LineMap1.fromString(this.value);
            }

            return this._lineMap;
        }
    }

    class SubstrStringText implements ISimpleText {
        private _lineMap: LineMap = null;

        constructor(private value: string, private _from: number, private _length: number) {
        }

        public length(): number {
            return this._length;
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.value, sourceIndex + this._from, destination, destinationIndex, count);
        }

        private static charArray: number[] = ArrayUtilities.createArray<number>(1024, 0);

        public substr(start: number, length: number): string {
            return this.value.substr(start + this._from, length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }

        public charCodeAt(index: number): number {
            return this.value.charCodeAt(index + this._from);
        }

        public lineMap(): LineMap {
            if (!this._lineMap) {
                this._lineMap = LineMap1.fromSimpleText(this);
            }

            return this._lineMap;
        }
    }

    // Class which wraps a host IScriptSnapshot and exposes an ISimpleText for newer compiler code. 
    class SimpleScriptSnapshotText implements ISimpleText {
        private _lineMap: LineMap = null;

        constructor(public scriptSnapshot: IScriptSnapshot) {
        }

        public charCodeAt(index: number): number {
            return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
        }

        public length(): number {
            return this.scriptSnapshot.getLength();
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
            StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
        }

        public substr(start: number, length: number): string {
            return this.scriptSnapshot.getText(start, start + length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }

        public lineMap(): LineMap {
            if (this._lineMap === null) {
                this._lineMap = new LineMap(() => this.scriptSnapshot.getLineStartPositions(), this.length());
            }

            return this._lineMap;
        }
    }

    export function fromSubstr(value: string, from: number, length: number): ISimpleText {
        return new SubstrStringText(value, from, length);
    }

    export function fromString(value: string): ISimpleText {
        return new SimpleStringText(value);
    }

    export function fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): ISimpleText {
        return new SimpleScriptSnapshotText(scriptSnapshot);
    }
}
///<reference path='references.ts' />

/**
 * Immutable representation of a line in an IText instance.
 */
module TypeScript {
    export interface ITextLine {
        /**
         * Start of the line.
         */
        start(): number;

        /**
         * End of the line not including the line break.
         */
        end(): number;

        /**
         * End of the line including the line break.
         */
        endIncludingLineBreak(): number;

        /**
         * Extent of the line not including the line break.
         */
        extent(): TextSpan;

        /**
         * Extent of the line including the line break.
         */
        extentIncludingLineBreak(): TextSpan;

        /**
         * Gets the text of the line excluding the line break.
         */
        toString(): string;

        /**
         * Gets the line number for this line.
         */
        lineNumber(): number;
    }
}
///<reference path='references.ts' />

module TypeScript {
    export interface ISpan {
        start(): number;
        end(): number;
    }

    export class TextSpan implements ISpan {
        private _start: number;
        private _length: number;

        /**
         * Creates a TextSpan instance beginning with the position Start and having the Length
         * specified with length.
         */
        constructor(start: number, length: number) {
            if (start < 0) {
                Errors.argument("start");
            }

            if (length < 0) {
                Errors.argument("length");
            }

            this._start = start;
            this._length = length;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public end(): number {
            return this._start + this._length;
        }

        public isEmpty(): boolean {
            return this._length === 0;
        }

        /**
         * Determines whether the position lies within the span. Returns true if the position is greater than or equal to Start and strictly less 
         * than End, otherwise false.
         * @param position The position to check.
         */
        public containsPosition(position: number): boolean {
            return position >= this._start && position < this.end();
        }

        /**
         * Determines whether span falls completely within this span. Returns true if the specified span falls completely within this span, otherwise false.
         * @param span The span to check.
         */
        public containsTextSpan(span: TextSpan): boolean {
            return span._start >= this._start && span.end() <= this.end();
        }

        /**
         * Determines whether the given span overlaps this span. Two spans are considered to overlap 
         * if they have positions in common and neither is empty. Empty spans do not overlap with any 
         * other span. Returns true if the spans overlap, false otherwise.
         * @param span The span to check.
         */
        public overlapsWith(span: TextSpan): boolean {
            var overlapStart = MathPrototype.max(this._start, span._start);
            var overlapEnd = MathPrototype.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        }

        /**
         * Returns the overlap with the given span, or null if there is no overlap.
         * @param span The span to check.
         */
        public overlap(span: TextSpan): TextSpan {
            var overlapStart = MathPrototype.max(this._start, span._start);
            var overlapEnd = MathPrototype.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        }

        /**
         * Determines whether span intersects this span. Two spans are considered to 
         * intersect if they have positions in common or the end of one span 
         * coincides with the start of the other span. Returns true if the spans intersect, false otherwise.
         * @param The span to check.
         */
        public intersectsWithTextSpan(span: TextSpan): boolean {
            return span._start <= this.end() && span.end() >= this._start;
        }

        public intersectsWith(start: number, length: number): boolean {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        }

        /**
         * Determines whether the given position intersects this span. 
         * A position is considered to intersect if it is between the start and
         * end positions (inclusive) of this span. Returns true if the position intersects, false otherwise.
         * @param position The position to check.
         */
        public intersectsWithPosition(position: number): boolean {
            return position <= this.end() && position >= this._start;
        }

        /**
         * Returns the intersection with the given span, or null if there is no intersection.
         * @param span The span to check.
         */
        public intersection(span: TextSpan): TextSpan {
            var intersectStart = MathPrototype.max(this._start, span._start);
            var intersectEnd = MathPrototype.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        }

        /**
         * Creates a new TextSpan from the given start and end positions
         * as opposed to a position and length.
         */
        public static fromBounds(start: number, end: number): TextSpan {
            Debug.assert(start >= 0);
            Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        }
    }
}
///<reference path='references.ts' />

module TypeScript.TextUtilities {
    export interface ICharacterSequence {
        charCodeAt(index: number): number;
        length: number;
    }

    export function parseLineStarts(text: ICharacterSequence): number[]{
        var length = text.length;

        // Corner case check
        if (0 === length) {
            var result = new Array<number>();
            result.push(0);
            return result;
        }

        var position = 0;
        var index = 0;
        var arrayBuilder = new Array<number>();
        var lineNumber = 0;

        // The following loop goes through every character in the text. It is highly
        // performance critical, and thus inlines knowledge about common line breaks
        // and non-line breaks.
        while (index < length) {
            var c = text.charCodeAt(index);
            var lineBreakLength: number;

            // common case - ASCII & not a line break
            if (c > CharacterCodes.carriageReturn && c <= 127) {
                index++;
                continue;
            }
            else if (c === CharacterCodes.carriageReturn && index + 1 < length && text.charCodeAt(index + 1) === CharacterCodes.lineFeed) {
                lineBreakLength = 2;
            }
            else if (c === CharacterCodes.lineFeed) {
                lineBreakLength = 1;
            }
            else {
                lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
            }

            if (0 === lineBreakLength) {
                index++;
            }
            else {
                arrayBuilder.push(position);
                index += lineBreakLength;
                position = index;
                lineNumber++;
            }
        }

        // Create a start for the final line.  
        arrayBuilder.push(position);

        return arrayBuilder;
    }

    export function getLengthOfLineBreakSlow(text: ICharacterSequence, index: number, c: number): number {
        if (c === CharacterCodes.carriageReturn) {
            var next = index + 1;
            return (next < text.length) && CharacterCodes.lineFeed === text.charCodeAt(next) ? 2 : 1;
        }
        else if (isAnyLineBreakCharacter(c)) {
            return 1;
        }
        else {
            return 0;
        }
    }

    export function getLengthOfLineBreak(text: ICharacterSequence, index: number): number {
        var c = text.charCodeAt(index);

        // common case - ASCII & not a line break
        if (c > CharacterCodes.carriageReturn && c <= 127) {
            return 0;
        }

        return getLengthOfLineBreakSlow(text, index, c);
    }

    export function isAnyLineBreakCharacter(c: number): boolean {
        return c === CharacterCodes.lineFeed ||
               c === CharacterCodes.carriageReturn ||
               c === CharacterCodes.nextLine ||
               c === CharacterCodes.lineSeparator ||
               c === CharacterCodes.paragraphSeparator;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {
    class DeclCollectionContext {
        public isDeclareFile = false;
        public parentChain: PullDecl[] = [];

        constructor(public document: Document, public propagateEnumConstants: boolean) {
        }

        public getParent() { return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null; }

        public pushParent(parentDecl: PullDecl) { if (parentDecl) { this.parentChain[this.parentChain.length] = parentDecl; } }

        public popParent() { this.parentChain.length--; }

        public setDeclForAST(ast: ISyntaxElement, decl: PullDecl): void {
            Debug.assert(decl.fileName() === this.document.fileName);
            this.document._setDeclForAST(ast, decl);
        }

        public setASTForDecl(decl: PullDecl, ast: ISyntaxElement): void {
            Debug.assert(decl.fileName() === this.document.fileName);
            this.document._setASTForDecl(decl, ast);
        }
    }

    function moduleElementsHasExportAssignment(moduleElements: IModuleElementSyntax[]): boolean {
        for (var i = 0, n = moduleElements.length; i < n; i++) {
            if (moduleElements[i].kind() === SyntaxKind.ExportAssignment) {
                return true;
            }
        }

        return false;
    }

    function containingModuleHasExportAssignment(ast: ISyntaxElement): boolean {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === SyntaxKind.ModuleDeclaration) {
                var moduleDecl = <ModuleDeclarationSyntax>ast;
                return moduleElementsHasExportAssignment(moduleDecl.moduleElements);
            }
            else if (ast.kind() === SyntaxKind.SourceUnit) {
                var sourceUnit = <SourceUnitSyntax>ast;
                return moduleElementsHasExportAssignment(sourceUnit.moduleElements);
            }

            ast = ast.parent;
        }

        return false;
    }

    function isParsingAmbientModule(ast: ISyntaxElement, context: DeclCollectionContext): boolean {
        ast = ast.parent;
        while (ast) {
            if (ast.kind() === SyntaxKind.ModuleDeclaration) {
                if (hasModifier((<ModuleDeclarationSyntax>ast).modifiers, PullElementFlags.Ambient)) {
                    return true;
                }
            }

            ast = ast.parent;
        }

        return false;
    }

    function preCollectImportDecls(ast: ISyntaxElement, context: DeclCollectionContext): void {
        var importDecl = <ImportDeclarationSyntax>ast;
        var declFlags = PullElementFlags.None;

        var parent = context.getParent();

        if (hasModifier(importDecl.modifiers, PullElementFlags.Exported) && !containingModuleHasExportAssignment(ast)) {
            declFlags |= PullElementFlags.Exported;
        }

        var decl = new NormalPullDecl(tokenValueText(importDecl.identifier), importDecl.identifier.text(), PullElementKind.TypeAlias, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        // Note: it is intentional that a import does not get added to hte context stack.  An
        // import does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    function preCollectScriptDecls(sourceUnit: SourceUnitSyntax, context: DeclCollectionContext): void {
        var fileName = syntaxTree(sourceUnit).fileName();

        var isExternalModule = context.document.isExternalModule();

        var decl: PullDecl = new RootPullDecl(context.document, /*name:*/ fileName, fileName, PullElementKind.Script, PullElementFlags.None, isExternalModule);
        context.setDeclForAST(sourceUnit, decl);
        context.setASTForDecl(decl, sourceUnit);

        context.isDeclareFile = context.document.isDeclareFile();

        context.pushParent(decl);

        // if it's an external module, create another decl to represent that module inside the top 
        // level script module.

        if (isExternalModule) {
            var declFlags = PullElementFlags.Exported;
            if (isDTSFile(fileName)) {
                declFlags |= PullElementFlags.Ambient;
            }

            var moduleContainsExecutableCode = containsExecutableCode(sourceUnit.moduleElements);
            var kind = PullElementKind.DynamicModule;
            var valueText = quoteStr(fileName);

            var decl: PullDecl = new NormalPullDecl(valueText, fileName, kind, declFlags, context.getParent());

            context.setASTForDecl(decl, sourceUnit);
            // Note: we're overring what the script points to.  For files with an external module, 
            // the script node will point at the external module declaration.
            context.setDeclForAST(sourceUnit, decl);

            if (!moduleElementsHasExportAssignment(sourceUnit.moduleElements) || moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, sourceUnit, context);
            }

            context.pushParent(decl);
        }
    }

    function preCollectEnumDecls(enumDecl: EnumDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var enumName = tokenValueText(enumDecl.identifier);

        if ((hasModifier(enumDecl.modifiers, PullElementFlags.Exported) || isParsingAmbientModule(enumDecl, context)) && !containingModuleHasExportAssignment(enumDecl)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasModifier(enumDecl.modifiers, PullElementFlags.Ambient) || isParsingAmbientModule(enumDecl, context) || context.isDeclareFile) {
            declFlags |= PullElementFlags.Ambient;
        }

        // Consider an enum 'always initialized'.
        declFlags |= PullElementFlags.Enum;
        var kind = PullElementKind.Enum;

        var enumDeclaration = new NormalPullDecl(enumName, enumDecl.identifier.text(), kind, declFlags, context.getParent());
        context.setDeclForAST(enumDecl, enumDeclaration);
        context.setASTForDecl(enumDeclaration, enumDecl);

        // create the value decl
        var valueDecl = new NormalPullDecl(enumDeclaration.name, enumDeclaration.getDisplayName(), PullElementKind.Variable, enumDeclaration.flags, context.getParent());
        enumDeclaration.setValueDecl(valueDecl);
        context.setASTForDecl(valueDecl, enumDecl);

        context.pushParent(enumDeclaration);
    }

    function createEnumElementDecls(propertyDecl: EnumElementSyntax, context: DeclCollectionContext): void {
        var parent = context.getParent();

        var decl = new PullEnumElementDecl(tokenValueText(propertyDecl.propertyName), propertyDecl.propertyName.text(), parent);
        context.setDeclForAST(propertyDecl, decl);
        context.setASTForDecl(decl, propertyDecl);

        // Note: it is intentional that a enum element does not get added to hte context stack.  An 
        // enum element does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    function preCollectModuleDecls(moduleDecl: ModuleDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;

        var moduleContainsExecutableCode = containsExecutableCode(moduleDecl.moduleElements);

        var isDynamic = moduleDecl.stringLiteral !== null;

        if ((hasModifier(moduleDecl.modifiers, PullElementFlags.Exported) || isParsingAmbientModule(moduleDecl, context)) && !containingModuleHasExportAssignment(moduleDecl)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasModifier(moduleDecl.modifiers, PullElementFlags.Ambient) || isParsingAmbientModule(moduleDecl, context) || context.isDeclareFile) {
            declFlags |= PullElementFlags.Ambient;
        }

        var kind = isDynamic ? PullElementKind.DynamicModule : PullElementKind.Container;

        if (moduleDecl.stringLiteral) {
            var valueText = quoteStr(tokenValueText(moduleDecl.stringLiteral));
            var text = moduleDecl.stringLiteral.text();

            var decl = new NormalPullDecl(valueText, text, kind, declFlags, context.getParent());

            context.setDeclForAST(moduleDecl, decl);
            context.setDeclForAST(moduleDecl.stringLiteral, decl);
            context.setASTForDecl(decl, moduleDecl.stringLiteral);

            if (!moduleElementsHasExportAssignment(moduleDecl.moduleElements) || moduleContainsExecutableCode) {
                createModuleVariableDecl(decl, moduleDecl.stringLiteral, context);
            }

            context.pushParent(decl);
        }
        else {
            // Module has a name or dotted name.
            var moduleNames = ASTHelpers.getModuleNames(moduleDecl.name);
            for (var i = 0, n = moduleNames.length; i < n; i++) {
                var moduleName = moduleNames[i];

                // All the inner module decls are exported.
                var specificFlags = declFlags;
                if (i > 0) {
                    specificFlags |= PullElementFlags.Exported;
                }

                var decl = new NormalPullDecl(tokenValueText(moduleName), moduleName.text(), kind, specificFlags, context.getParent());

                //// The innermost moduleDecl maps to the entire ModuleDeclaration node.
                //// All the other ones map to the name node.  i.e. module A.B.C { }
                ////
                //// The decl for C points to the entire module declaration.  The decls for A and B
                //// will point at the A and B nodes respectively.
                //var ast = (i === (moduleName.length - 1))
                //    ? moduleDecl
                //    : moduleName;
                context.setDeclForAST(moduleDecl, decl);
                context.setDeclForAST(moduleName, decl);
                context.setASTForDecl(decl, moduleName);

                if (moduleContainsExecutableCode) {
                    createModuleVariableDecl(decl, moduleName, context);
                }

                context.pushParent(decl);
            }
        }
    }

    function createModuleVariableDecl(decl: PullDecl, moduleNameAST: ISyntaxElement, context: DeclCollectionContext): void {
        decl.setFlags(decl.flags | getInitializationFlag(decl));

        // create the value decl
        var valueDecl = new NormalPullDecl(decl.name, decl.getDisplayName(), PullElementKind.Variable, decl.flags, context.getParent());
        decl.setValueDecl(valueDecl);
        context.setASTForDecl(valueDecl, moduleNameAST);
    }

    function containsExecutableCode(members: IModuleElementSyntax[]): boolean {
        for (var i = 0, n = members.length; i < n; i++) {
            var member = members[i];

            // October 11, 2013
            // Internal modules are either instantiated or non-instantiated. A non-instantiated 
            // module is an internal module containing only interface types and other non - 
            // instantiated modules. 
            //
            // Note: small spec deviation.  We don't consider an import statement sufficient to
            // consider a module instantiated (except the case of 'export import' handled below ).
            // After all, if there is an import, but no actual code that references the imported value, 
            // then there's no need to emit the import or the module.
            if (member.kind() === SyntaxKind.ModuleDeclaration) {
                var moduleDecl = <ModuleDeclarationSyntax>member;

                // If we have a module in us, and it contains executable code, then we
                // contain executable code.
                if (containsExecutableCode(moduleDecl.moduleElements)) {
                    return true;
                }
            }
            else if (member.kind() === SyntaxKind.ImportDeclaration) {
                // pessimistically assume 'export import' declaration will be the alias to something instantiated
                // we cannot figure out it exactly until the resolution time.
                if (hasModifier((<ImportDeclarationSyntax>member).modifiers, PullElementFlags.Exported)) {
                    return true;
                }
            }
            else if (member.kind() !== SyntaxKind.InterfaceDeclaration && member.kind() !== SyntaxKind.ExportAssignment) {
                // In case of export assignment we should be really checking meaning of Export assignment identifier, but thats TODO for later
                // If we contain anything that's not an interface declaration, then we contain
                // executable code.
                return true;
            }
        }

        return false;
    }

    function preCollectClassDecls(classDecl: ClassDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;

        if ((hasModifier(classDecl.modifiers, PullElementFlags.Exported) || isParsingAmbientModule(classDecl, context)) && !containingModuleHasExportAssignment(classDecl)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasModifier(classDecl.modifiers, PullElementFlags.Ambient) || isParsingAmbientModule(classDecl, context) || context.isDeclareFile) {
            declFlags |= PullElementFlags.Ambient;
        }

        var parent = context.getParent();

        var decl = new NormalPullDecl(tokenValueText(classDecl.identifier), classDecl.identifier.text(), PullElementKind.Class, declFlags, parent);

        var constructorDecl = new NormalPullDecl(
            tokenValueText(classDecl.identifier),
            classDecl.identifier.text(),
            PullElementKind.Variable,
            declFlags | PullElementFlags.ClassConstructorVariable,
            parent);

        decl.setValueDecl(constructorDecl);

        context.setDeclForAST(classDecl, decl);
        context.setASTForDecl(decl, classDecl);
        context.setASTForDecl(constructorDecl, classDecl);

        context.pushParent(decl);
    }

    function preCollectObjectTypeDecls(objectType: ObjectTypeSyntax, context: DeclCollectionContext): void {
        // if this is the 'body' of an interface declaration, then we don't want to create a decl 
        // here.  We want the interface decl to be the parent decl of all the members we visit.
        if (objectType.parent.kind() === SyntaxKind.InterfaceDeclaration) {
            return;
        }

        var declFlags = PullElementFlags.None;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", PullElementKind.ObjectType, declFlags, parent);
        context.setDeclForAST(objectType, decl);
        context.setASTForDecl(decl, objectType);

        context.pushParent(decl);
    }

    function preCollectInterfaceDecls(interfaceDecl: InterfaceDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;

        if ((hasModifier(interfaceDecl.modifiers, PullElementFlags.Exported) || isParsingAmbientModule(interfaceDecl, context)) && !containingModuleHasExportAssignment(interfaceDecl)) {
            declFlags |= PullElementFlags.Exported;
        }

        var parent = context.getParent();

        var decl = new NormalPullDecl(tokenValueText(interfaceDecl.identifier), interfaceDecl.identifier.text(), PullElementKind.Interface, declFlags, parent);
        context.setDeclForAST(interfaceDecl, decl);
        context.setASTForDecl(decl, interfaceDecl);

        context.pushParent(decl);
    }

    function preCollectParameterDecl(argDecl: ParameterSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;

        if (hasModifier(argDecl.modifiers, PullElementFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (argDecl.questionToken !== null || argDecl.equalsValueClause !== null || argDecl.dotDotDotToken !== null) {
            declFlags |= PullElementFlags.Optional;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(argDecl.identifier), argDecl.identifier.text(), PullElementKind.Parameter, declFlags, parent);

        // If it has a default arg, record the fact that the parent has default args (we will need this during resolution)
        if (argDecl.equalsValueClause) {
            parent.flags |= PullElementFlags.HasDefaultArgs;
        }

        if (parent.kind === PullElementKind.ConstructorMethod) {
            decl.setFlag(PullElementFlags.ConstructorParameter);
        }
        
        // if it's a property type, we'll need to add it to the parent's parent as well
        var isPublicOrPrivate = hasModifier(argDecl.modifiers, PullElementFlags.Public) || hasModifier(argDecl.modifiers, PullElementFlags.Private);
        var isInConstructor = parent.kind === PullElementKind.ConstructorMethod;
        if (isPublicOrPrivate && isInConstructor) {
            var parentsParent = context.parentChain[context.parentChain.length - 2];
            // optional parameters don't introduce optional properties - always drop isOptional flag on the property declaration
            var propDeclFlags = declFlags & ~PullElementFlags.Optional;
            var propDecl = new NormalPullDecl(tokenValueText(argDecl.identifier), argDecl.identifier.text(), PullElementKind.Property, propDeclFlags, parentsParent);
            propDecl.setValueDecl(decl);
            decl.setFlag(PullElementFlags.PropertyParameter);
            propDecl.setFlag(PullElementFlags.PropertyParameter);

            if (parent.kind === PullElementKind.ConstructorMethod) {
                propDecl.setFlag(PullElementFlags.ConstructorParameter);
            }

            context.setASTForDecl(decl, argDecl);
            context.setASTForDecl(propDecl, argDecl);
            context.setDeclForAST(argDecl, propDecl);
        }
        else {
            context.setASTForDecl(decl, argDecl);
            context.setDeclForAST(argDecl, decl);
        }

        // Record this decl in its parent in the declGroup with the corresponding name
        parent.addVariableDeclToGroup(decl);
        
        // Note: it is intentional that a parameter does not get added to hte context stack.  A 
        // parameter does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    function preCollectTypeParameterDecl(typeParameterDecl: TypeParameterSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(typeParameterDecl.identifier), typeParameterDecl.identifier.text(), PullElementKind.TypeParameter, declFlags, parent);
        context.setASTForDecl(decl, typeParameterDecl);
        context.setDeclForAST(typeParameterDecl, decl);

        // Note: it is intentional that a type parameter does not get added to hte context stack.
        // A type parameter does not introduce a new name scope, so it shouldn't be in the 
        // context decl stack.
        // context.pushParent(decl);
    }

    // interface properties
    function createPropertySignature(propertyDecl: PropertySignatureSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Public;
        var parent = context.getParent();
        var declType = PullElementKind.Property;

        if (propertyDecl.questionToken !== null) {
            declFlags |= PullElementFlags.Optional;
        }

        var decl = new NormalPullDecl(tokenValueText(propertyDecl.propertyName), propertyDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(propertyDecl, decl);
        context.setASTForDecl(decl, propertyDecl);

        // Note: it is intentional that a var decl does not get added to hte context stack.  A var
        // decl does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    // class member variables
    function createMemberVariableDeclaration(memberDecl: MemberVariableDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Property;

        if (hasModifier(memberDecl.modifiers, PullElementFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (hasModifier(memberDecl.modifiers, PullElementFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        var parent = context.getParent();

        var decl = new NormalPullDecl(tokenValueText(memberDecl.variableDeclarator.propertyName), memberDecl.variableDeclarator.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(memberDecl, decl);
        context.setDeclForAST(memberDecl.variableDeclarator, decl);
        context.setASTForDecl(decl, memberDecl);

        // Note: it is intentional that a var decl does not get added to hte context stack.  A var
        // decl does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    function createVariableDeclaration(varDecl: VariableDeclaratorSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Variable;

        var modifiers = ASTHelpers.getVariableDeclaratorModifiers(varDecl);
        if ((hasModifier(modifiers, PullElementFlags.Exported) || isParsingAmbientModule(varDecl, context)) && !containingModuleHasExportAssignment(varDecl)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasModifier(modifiers, PullElementFlags.Ambient) || isParsingAmbientModule(varDecl, context) || context.isDeclareFile) {
            declFlags |= PullElementFlags.Ambient;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(varDecl.propertyName), varDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(varDecl, decl);
        context.setASTForDecl(decl, varDecl);

        if (parent) {
            // Record this decl in its parent in the declGroup with the corresponding name
            parent.addVariableDeclToGroup(decl);
        }

        // Note: it is intentional that a var decl does not get added to hte context stack.  A var
        // decl does not introduce a new name scope, so it shouldn't be in the context decl stack.
        // context.pushParent(decl);
    }

    function preCollectVarDecls(ast: ISyntaxElement, context: DeclCollectionContext): void {
        if (ast.parent.kind() === SyntaxKind.MemberVariableDeclaration) {
            // Already handled this node.
            return;
        }

        var varDecl = <VariableDeclaratorSyntax>ast;
        createVariableDeclaration(varDecl, context);
    }

    // function type expressions
    function createFunctionTypeDeclaration(functionTypeDeclAST: FunctionTypeSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Signature;
        var declType = PullElementKind.FunctionType;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(functionTypeDeclAST, decl);
        context.setASTForDecl(decl, functionTypeDeclAST);

        context.pushParent(decl);
    }

    // constructor types
    function createConstructorTypeDeclaration(constructorTypeDeclAST: ConstructorTypeSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.ConstructorType;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(constructorTypeDeclAST, decl);
        context.setASTForDecl(decl, constructorTypeDeclAST);

        context.pushParent(decl);
    }

    // function declaration
    function createFunctionDeclaration(funcDeclAST: FunctionDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Function;

        if ((hasModifier(funcDeclAST.modifiers, PullElementFlags.Exported) || isParsingAmbientModule(funcDeclAST, context)) && !containingModuleHasExportAssignment(funcDeclAST)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasModifier(funcDeclAST.modifiers, PullElementFlags.Ambient) || isParsingAmbientModule(funcDeclAST, context) || context.isDeclareFile) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (!funcDeclAST.block) {
            declFlags |= PullElementFlags.Signature;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(funcDeclAST.identifier), funcDeclAST.identifier.text(), declType, declFlags, parent);
        context.setDeclForAST(funcDeclAST, decl);
        context.setASTForDecl(decl, funcDeclAST);

        context.pushParent(decl);
    }

    // function expression
    function createAnyFunctionExpressionDeclaration(
        functionExpressionDeclAST: ISyntaxElement,
        id: ISyntaxToken,
        context: DeclCollectionContext,
        displayName: ISyntaxToken = null): void {

        var declFlags = PullElementFlags.None;

        if (functionExpressionDeclAST.kind() === SyntaxKind.SimpleArrowFunctionExpression ||
            functionExpressionDeclAST.kind() === SyntaxKind.ParenthesizedArrowFunctionExpression) {
            declFlags |= PullElementFlags.ArrowFunction;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var name = id ? id.text() : "";
        var displayNameText = displayName ? displayName.text() : "";
        var decl: PullDecl = new PullFunctionExpressionDecl(name, declFlags, parent, displayNameText);
        context.setDeclForAST(functionExpressionDeclAST, decl);
        context.setASTForDecl(decl, functionExpressionDeclAST);

        context.pushParent(decl);

        if (functionExpressionDeclAST.kind() === SyntaxKind.SimpleArrowFunctionExpression) {
            var simpleArrow = <SimpleArrowFunctionExpressionSyntax>functionExpressionDeclAST;
            var declFlags = PullElementFlags.Public;

            var parent = context.getParent();

            if (hasFlag(parent.flags, PullElementFlags.DeclaredInAWithBlock)) {
                declFlags |= PullElementFlags.DeclaredInAWithBlock;
            }

            var decl: PullDecl = new NormalPullDecl(tokenValueText(simpleArrow.identifier), simpleArrow.identifier.text(), PullElementKind.Parameter, declFlags, parent);

            context.setASTForDecl(decl, simpleArrow.identifier);
            context.setDeclForAST(simpleArrow.identifier, decl);

            // Record this decl in its parent in the declGroup with the corresponding name
            parent.addVariableDeclToGroup(decl);
        }
    }

    function createMemberFunctionDeclaration(funcDecl: MemberFunctionDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Method;

        if (hasModifier(funcDecl.modifiers, PullElementFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasModifier(funcDecl.modifiers, PullElementFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (!funcDecl.block) {
            declFlags |= PullElementFlags.Signature;
        }

        var parent = context.getParent();

        var decl = new NormalPullDecl(tokenValueText(funcDecl.propertyName), funcDecl.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(funcDecl, decl);
        context.setASTForDecl(decl, funcDecl);

        context.pushParent(decl);
    }

    // index signatures
    function createIndexSignatureDeclaration(indexSignatureDeclAST: IndexSignatureSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Signature;
        var declType = PullElementKind.IndexSignature;

        var parent = context.getParent();

        var decl = new NormalPullDecl("", "" , declType, declFlags, parent);
        context.setDeclForAST(indexSignatureDeclAST, decl);
        context.setASTForDecl(decl, indexSignatureDeclAST);

        context.pushParent(decl);
    }

    // call signatures
    function createCallSignatureDeclaration(callSignature: CallSignatureSyntax, context: DeclCollectionContext): void {
        var isChildOfObjectType = callSignature.parent && callSignature.parent.parent &&
            callSignature.parent.kind() === SyntaxKind.SeparatedList &&
            callSignature.parent.parent.kind() === SyntaxKind.ObjectType;

        if (!isChildOfObjectType) {
            // This was a call signature that was part of some other entity (like a function 
            // declaration or construct signature).  Those are already handled specially and
            // we don't want to end up making another call signature for them.  We only want
            // to make an actual call signature if we're a standalone call signature in an 
            // object/interface type.
            return;
        }

        var declFlags = PullElementFlags.Signature;
        var declType = PullElementKind.CallSignature;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(callSignature, decl);
        context.setASTForDecl(decl, callSignature);

        context.pushParent(decl);
    }

    function createMethodSignatureDeclaration(method: MethodSignatureSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Method;

        declFlags |= PullElementFlags.Public;
        declFlags |= PullElementFlags.Signature;

        if (method.questionToken !== null) {
            declFlags |= PullElementFlags.Optional;
        }

        var parent = context.getParent();

        var decl = new NormalPullDecl(tokenValueText(method.propertyName), method.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(method, decl);
        context.setASTForDecl(decl, method);

        context.pushParent(decl);
    }

    // construct signatures
    function createConstructSignatureDeclaration(constructSignatureDeclAST: ConstructSignatureSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Signature;
        var declType = PullElementKind.ConstructSignature;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(constructSignatureDeclAST, decl);
        context.setASTForDecl(decl, constructSignatureDeclAST);

        context.pushParent(decl);
    }

    // class constructors
    function createClassConstructorDeclaration(constructorDeclAST: ConstructorDeclarationSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.ConstructorMethod;

        if (!constructorDeclAST.block) {
            declFlags |= PullElementFlags.Signature;
        }

        var parent = context.getParent();

        if (parent) {
            // if the parent is exported, the constructor decl must be as well
            var parentFlags = parent.flags;

            if (parentFlags & PullElementFlags.Exported) {
                declFlags |= PullElementFlags.Exported;
            }
        }

        var decl = new NormalPullDecl(parent.name, parent.getDisplayName(), declType, declFlags, parent);
        context.setDeclForAST(constructorDeclAST, decl);
        context.setASTForDecl(decl, constructorDeclAST);

        context.pushParent(decl);
    }

    function createGetAccessorDeclaration(getAccessorDeclAST: GetAccessorSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.GetAccessor;

        if (hasModifier(getAccessorDeclAST.modifiers, PullElementFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasModifier(getAccessorDeclAST.modifiers, PullElementFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(getAccessorDeclAST.propertyName), getAccessorDeclAST.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(getAccessorDeclAST, decl);
        context.setASTForDecl(decl, getAccessorDeclAST);

        context.pushParent(decl);
    }

    function createFunctionExpressionDeclaration(expression: FunctionExpressionSyntax, context: DeclCollectionContext): void {
        createAnyFunctionExpressionDeclaration(expression, expression.identifier, context);
    }

    function createSetAccessorDeclaration(setAccessorDeclAST: SetAccessorSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.SetAccessor;

        if (hasModifier(setAccessorDeclAST.modifiers, PullElementFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasModifier(setAccessorDeclAST.modifiers, PullElementFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(setAccessorDeclAST.propertyName), setAccessorDeclAST.propertyName.text(), declType, declFlags, parent);
        context.setDeclForAST(setAccessorDeclAST, decl);
        context.setASTForDecl(decl, setAccessorDeclAST);

        context.pushParent(decl);
    }

    function preCollectCatchDecls(ast: CatchClauseSyntax, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.CatchBlock;

        var parent = context.getParent();

        if (parent && (parent.kind === PullElementKind.WithBlock || (parent.flags & PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);

        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.CatchVariable;

        // Create a decl for the catch clause variable.
        var parent = context.getParent();

        if (hasFlag(parent.flags, PullElementFlags.DeclaredInAWithBlock)) {
            declFlags |= PullElementFlags.DeclaredInAWithBlock;
        }

        var decl = new NormalPullDecl(tokenValueText(ast.identifier), ast.identifier.text(), declType, declFlags, parent);
        context.setDeclForAST(ast.identifier, decl);
        context.setASTForDecl(decl, ast.identifier);

        if (parent) {
            // Record this decl in its parent in the declGroup with the corresponding name
            parent.addVariableDeclToGroup(decl);
        }
    }

    function preCollectWithDecls(ast: ISyntaxElement, context: DeclCollectionContext): void {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.WithBlock;

        var parent = context.getParent();

        var decl = new NormalPullDecl("", "", declType, declFlags, parent);
        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);
    }

    function preCollectObjectLiteralDecls(ast: ISyntaxElement, context: DeclCollectionContext): void {
        var decl = new NormalPullDecl(
            "", "", PullElementKind.ObjectLiteral, PullElementFlags.None, context.getParent());

        context.setDeclForAST(ast, decl);
        context.setASTForDecl(decl, ast);

        context.pushParent(decl);
    }

    function preCollectSimplePropertyAssignmentDecls(propertyAssignment: SimplePropertyAssignmentSyntax, context: DeclCollectionContext): void {
        var assignmentText = getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);
        var span = TextSpan.fromBounds(start(propertyAssignment), end(propertyAssignment));

        var decl = new NormalPullDecl(assignmentText.memberName, assignmentText.actualText, PullElementKind.Property, PullElementFlags.Public, context.getParent());

        context.setDeclForAST(propertyAssignment, decl);
        context.setASTForDecl(decl, propertyAssignment);

        // Note: it is intentional that a property assignment does not get added to hte context 
        // stack.  A prop assignment does not introduce a new name scope, so it shouldn't be in
        // the context decl stack.
        // context.pushParent(decl);
    }

    function preCollectFunctionPropertyAssignmentDecls(propertyAssignment: FunctionPropertyAssignmentSyntax, context: DeclCollectionContext): void {
        var assignmentText = getPropertyAssignmentNameTextFromIdentifier(propertyAssignment.propertyName);

        var decl = new NormalPullDecl(assignmentText.memberName, assignmentText.actualText, PullElementKind.Property, PullElementFlags.Public, context.getParent());

        context.setDeclForAST(propertyAssignment, decl);
        context.setASTForDecl(decl, propertyAssignment);

        createAnyFunctionExpressionDeclaration(
            propertyAssignment, propertyAssignment.propertyName, context, propertyAssignment.propertyName);
    }

    function preCollectDecls(ast: ISyntaxElement, context: DeclCollectionContext) {
        switch (ast.kind()) {
            case SyntaxKind.SourceUnit:
                preCollectScriptDecls(<SourceUnitSyntax>ast, context);
                break;
            case SyntaxKind.EnumDeclaration:
                preCollectEnumDecls(<EnumDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.EnumElement:
                createEnumElementDecls(<EnumElementSyntax>ast, context);
                break;
            case SyntaxKind.ModuleDeclaration:
                preCollectModuleDecls(<ModuleDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.ClassDeclaration:
                preCollectClassDecls(<ClassDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.InterfaceDeclaration:
                preCollectInterfaceDecls(<InterfaceDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.ObjectType:
                preCollectObjectTypeDecls(<ObjectTypeSyntax>ast, context);
                break;
            case SyntaxKind.Parameter:
                preCollectParameterDecl(<ParameterSyntax>ast, context);
                break;
            case SyntaxKind.MemberVariableDeclaration:
                createMemberVariableDeclaration(<MemberVariableDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.PropertySignature:
                createPropertySignature(<PropertySignatureSyntax>ast, context);
                break;
            case SyntaxKind.VariableDeclarator:
                preCollectVarDecls(ast, context);
                break;
            case SyntaxKind.ConstructorDeclaration:
                createClassConstructorDeclaration(<ConstructorDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.GetAccessor:
                createGetAccessorDeclaration(<GetAccessorSyntax>ast, context);
                break;
            case SyntaxKind.SetAccessor:
                createSetAccessorDeclaration(<SetAccessorSyntax>ast, context);
                break;
            case SyntaxKind.FunctionExpression:
                createFunctionExpressionDeclaration(<FunctionExpressionSyntax>ast, context);
                break;
            case SyntaxKind.MemberFunctionDeclaration:
                createMemberFunctionDeclaration(<MemberFunctionDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.IndexSignature:
                createIndexSignatureDeclaration(<IndexSignatureSyntax>ast, context);
                break;
            case SyntaxKind.FunctionType:
                createFunctionTypeDeclaration(<FunctionTypeSyntax>ast, context);
                break;
            case SyntaxKind.ConstructorType:
                createConstructorTypeDeclaration(<ConstructorTypeSyntax>ast, context);
                break;
            case SyntaxKind.CallSignature:
                createCallSignatureDeclaration(<CallSignatureSyntax>ast, context);
                break;
            case SyntaxKind.ConstructSignature:
                createConstructSignatureDeclaration(<ConstructSignatureSyntax>ast, context);
                break;
            case SyntaxKind.MethodSignature:
                createMethodSignatureDeclaration(<MethodSignatureSyntax>ast, context);
                break;
            case SyntaxKind.FunctionDeclaration:
                createFunctionDeclaration(<FunctionDeclarationSyntax>ast, context);
                break;
            case SyntaxKind.SimpleArrowFunctionExpression:
            case SyntaxKind.ParenthesizedArrowFunctionExpression:
                createAnyFunctionExpressionDeclaration(ast, /*id*/null, context);
                break;
            case SyntaxKind.ImportDeclaration:
                preCollectImportDecls(ast, context);
                break;
            case SyntaxKind.TypeParameter:
                preCollectTypeParameterDecl(<TypeParameterSyntax>ast, context);
                break;
            case SyntaxKind.CatchClause:
                preCollectCatchDecls(<CatchClauseSyntax>ast, context);
                break;
            case SyntaxKind.WithStatement:
                preCollectWithDecls(ast, context);
                break;
            case SyntaxKind.ObjectLiteralExpression:
                preCollectObjectLiteralDecls(ast, context);
                break;
            case SyntaxKind.SimplePropertyAssignment:
                preCollectSimplePropertyAssignmentDecls(<SimplePropertyAssignmentSyntax>ast, context);
                break;
            case SyntaxKind.FunctionPropertyAssignment:
                preCollectFunctionPropertyAssignmentDecls(<FunctionPropertyAssignmentSyntax>ast, context);
                break;
        }
    }

    function isContainer(decl: PullDecl): boolean {
        return decl.kind === PullElementKind.Container || decl.kind === PullElementKind.DynamicModule || decl.kind === PullElementKind.Enum;
    }

    function getInitializationFlag(decl: PullDecl): PullElementFlags {
        if (decl.kind & PullElementKind.Container) {
            return PullElementFlags.InitializedModule;
        }
        else if (decl.kind & PullElementKind.DynamicModule) {
            return PullElementFlags.InitializedDynamicModule;
        }

        return PullElementFlags.None;
    }

    function hasInitializationFlag(decl: PullDecl): boolean {
        var kind = decl.kind;

        if (kind & PullElementKind.Container) {
            return (decl.flags & PullElementFlags.InitializedModule) !== 0;
        }
        else if (kind & PullElementKind.DynamicModule) {
            return (decl.flags & PullElementFlags.InitializedDynamicModule) !== 0;
        }

        return false;
    }

    function postCollectDecls(ast: ISyntaxElement, context: DeclCollectionContext) {
        var currentDecl = context.getParent();

        // We only want to pop the module decls when we're done with the module itself, and not 
        // when we are done with the module names.
        if (ast.kind() === SyntaxKind.IdentifierName || ast.kind() === SyntaxKind.StringLiteral) {
            if (currentDecl.kind === PullElementKind.Container || currentDecl.kind === PullElementKind.DynamicModule) {
                return;
            }
        }

        if (ast.kind() === SyntaxKind.ModuleDeclaration) {
            var moduleDeclaration = <ModuleDeclarationSyntax>ast;
            if (moduleDeclaration.stringLiteral) {
                Debug.assert(currentDecl.ast() === moduleDeclaration.stringLiteral);
                context.popParent();
            }
            else {
                var moduleNames = ASTHelpers.getModuleNames(moduleDeclaration.name);
                for (var i = moduleNames.length - 1; i >= 0; i--) {
                    var moduleName = moduleNames[i];
                    Debug.assert(currentDecl.ast() === moduleName);
                    context.popParent();
                    currentDecl = context.getParent();
                }
            }
        }

        if (ast.kind() === SyntaxKind.EnumDeclaration) {
            // Now that we've created all the child decls for the enum elements, determine what 
            // (if any) their constant values should be.
            computeEnumElementConstantValues(<EnumDeclarationSyntax>ast, currentDecl, context);
        }

        // Don't pop the topmost decl.  We return that out at the end.
        while (currentDecl.getParentDecl() && currentDecl.ast() === ast) {
            context.popParent();
            currentDecl = context.getParent();
        }
    }

    function computeEnumElementConstantValues(ast: EnumDeclarationSyntax, enumDecl: PullDecl, context: DeclCollectionContext): void {
        Debug.assert(enumDecl.kind === PullElementKind.Enum);

        // If this is a non ambient enum, then it starts with a constant section of enum elements.
        // Thus, elements without an initializer in these sections will be assumed to have a 
        // constant value.
        //
        // However, if this an enum in an ambient context, then non initialized elements are 
        // thought to have a computed value and are not in a constant section.
        var isAmbientEnum = hasFlag(enumDecl.flags, PullElementFlags.Ambient);
        var inConstantSection = !isAmbientEnum;
        var currentConstantValue = 0;
        var enumMemberDecls = <PullEnumElementDecl[]>enumDecl.getChildDecls();

        for (var i = 0, n = ast.enumElements.length; i < n; i++) {
            var enumElement = ast.enumElements[i];
            var enumElementDecl = ArrayUtilities.first(enumMemberDecls, d =>
                d.ast() === enumElement);

            Debug.assert(enumElementDecl.kind === PullElementKind.EnumMember);

            if (enumElement.equalsValueClause === null) {
                // Didn't have an initializer.  If we're in a constant section, then this appears
                // to have the value of the current constant.  If we're in a non-constant section
                // then this gets no value.
                if (inConstantSection) {
                    enumElementDecl.constantValue = currentConstantValue;
                    currentConstantValue++;
                }
            }
            else {
                // Enum element had an initializer.  If it's a constant, then then enum gets that 
                // value, and we transition to (or stay in) a constant section (as long as we're
                // not in an ambient context.
                //
                // If it's not a constant, then we transition to a non-constant section.
                enumElementDecl.constantValue = computeEnumElementConstantValue(enumElement.equalsValueClause.value, enumMemberDecls, context);
                if (enumElementDecl.constantValue !== null && !isAmbientEnum) {
                    // This enum element had a constant value.  We're now in a constant section.
                    // Any successive enum elements should get their values from this constant
                    // value onwards.
                    inConstantSection = true;
                    currentConstantValue = enumElementDecl.constantValue + 1;
                }
                else {
                    // Didn't get a constant value.  We're not in a constant section.
                    inConstantSection = false;
                }
            }

            Debug.assert(enumElementDecl.constantValue !== undefined);
        }
    }

    function computeEnumElementConstantValue(expression: ISyntaxElement, enumMemberDecls: PullEnumElementDecl[], context: DeclCollectionContext): number {
        Debug.assert(expression);

        if (ASTHelpers.isIntegerLiteralAST(expression)) {
            // Always produce a value for an integer literal.
            var token: ISyntaxToken;
            switch (expression.kind()) {
                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                    token = <ISyntaxToken>(<PrefixUnaryExpressionSyntax>expression).operand;
                    break;
                default:
                    token = <ISyntaxToken>expression;
            }

            var value = tokenValue(token);
            return value && expression.kind() === SyntaxKind.NegateExpression ? -value : value;
        }
        else if (context.propagateEnumConstants) {
            // It wasn't a numeric literal.  However, the experimental switch to be more aggressive
            // about propogating enum constants is enabled.  See if we can still figure out the
            // constant value for this enum element.
            switch (expression.kind()) {
                case SyntaxKind.IdentifierName:
                    // If it's a name, see if we already had an enum value named this.  If so,
                    // return that value.  Note, only search backward in the enum for a match.
                    var name = <ISyntaxToken>expression;
                    var matchingEnumElement = ArrayUtilities.firstOrDefault(enumMemberDecls, d => d.name === tokenValueText(name));

                    return matchingEnumElement ? matchingEnumElement.constantValue : null;

                case SyntaxKind.LeftShiftExpression:
                    // Handle the common case of a left shifted value.
                    var binaryExpression = <BinaryExpressionSyntax>expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }

                    return left << right;

                case SyntaxKind.BitwiseOrExpression:
                    // Handle the common case of an or'ed value.
                    var binaryExpression = <BinaryExpressionSyntax>expression;
                    var left = computeEnumElementConstantValue(binaryExpression.left, enumMemberDecls, context);
                    var right = computeEnumElementConstantValue(binaryExpression.right, enumMemberDecls, context);
                    if (left === null || right === null) {
                        return null;
                    }

                    return left | right;
            }

            // TODO: add more cases.
            return null;
        }
        else {
            // Wasn't an integer literal, and we're not aggressively propagating constants.
            // There is no constant value for this expression.
            return null;
        }
    }

    export module DeclarationCreator {
        export function create(document: Document, compilationSettings: ImmutableCompilationSettings): PullDecl {
            var declCollectionContext = new DeclCollectionContext(document, compilationSettings.propagateEnumConstants());
            
            // create decls
            getAstWalkerFactory().simpleWalk(document.sourceUnit(), preCollectDecls, postCollectDecls, declCollectionContext);

            return declCollectionContext.getParent();
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {
    var pullDeclID = 0;
    var sentinelEmptyPullDeclArray: any[] = [];

    export interface IASTForDeclMap {
        _getASTForDecl(decl: PullDecl): ISyntaxElement;
    }

    export class PullDecl {
        // Properties that will not change over the lifetime of the decl
        public kind: PullElementKind;
        public name: string;
        private declDisplayName: string;

        public declID = pullDeclID++;
        public flags: PullElementFlags = PullElementFlags.None;

        private declGroups: IIndexable<PullDeclGroup> = null;

        // Child decls
        private childDecls: PullDecl[] = null;
        private typeParameters: PullDecl[] = null;
        // In the case of classes, initialized modules and enums, we need to track the implicit
        // value set to the constructor or instance type.  We can use this field to make sure that on
        // edits and updates we don't leak the val decl or symbol
        private synthesizedValDecl: PullDecl = null;
        // backreference from the value decl back to non-value part
        private containerDecl: PullDecl = null;

        // Caches
        // Mappings from names to decls.  Public only for diffing purposes.
        public childDeclTypeCache: IIndexable<PullDecl[]> = null;
        public childDeclValueCache: IIndexable<PullDecl[]> = null;
        public childDeclNamespaceCache: IIndexable<PullDecl[]> = null;
        public childDeclTypeParameterCache: IIndexable<PullDecl[]> = null;

        constructor(declName: string, displayName: string, kind: PullElementKind, declFlags: PullElementFlags) {
            this.name = declName;
            this.kind = kind;
            this.flags = declFlags;

            if (displayName !== this.name) {
                this.declDisplayName = displayName;
            }
        }

        public getASTForDeclMap(): IASTForDeclMap {
            throw Errors.abstract();
        }

        public fileName(): string {
            throw Errors.abstract();
        }

        public getParentPath(): PullDecl[] {
            throw Errors.abstract();
        }

        public getParentDecl(): PullDecl {
            throw Errors.abstract();
        }

        public isExternalModule(): boolean {
            throw Errors.abstract();
        }

        // The enclosing decl is different from the parent decl. It is a syntactic ancestor decl
        // that introduces the scope in which this decl is defined.
        // Call this to get the enclosing decl of *this* decl
        public getEnclosingDecl(): PullDecl {
            throw Errors.abstract();
        }

        // Note: Call this on the *parent* decl of the decl whose enclosing decl you want.
        // This will assume you have already skipped the current decl on your way to the
        // enclosing decl.
        public _getEnclosingDeclFromParentDecl(): PullDecl {
            // Skip over the decls that cannot introduce a scope
            var decl = this;
            while (decl) {
                switch (decl.kind) {
                    default:
                        return decl;
                    case PullElementKind.Variable:
                    case PullElementKind.TypeParameter:
                    case PullElementKind.Parameter:
                    case PullElementKind.TypeAlias:
                    case PullElementKind.EnumMember:
                }

                decl = decl.getParentDecl();
            }

            Debug.fail();
        }

        /** Use getName for type checking purposes, and getDisplayName to report an error or display info to the user.
         * They will differ when the identifier is an escaped unicode character or the identifier "__proto__".
         */

        public getDisplayName() {
            return this.declDisplayName === undefined ? this.name : this.declDisplayName;
        }

        public setSymbol(symbol: PullSymbol, semanticInfoChain: SemanticInfoChain): void {
            semanticInfoChain.setSymbolForDecl(this, symbol);
        }

        public ensureSymbolIsBound(semanticInfoChain: SemanticInfoChain) {
            if (!this.hasBeenBound(semanticInfoChain) && this.kind !== PullElementKind.Script) {
                var binder = semanticInfoChain.getBinder();
                binder.bindDeclToPullSymbol(this);
            }
        }

        public getSymbol(semanticInfoChain: SemanticInfoChain): PullSymbol {
            if (this.kind === PullElementKind.Script) {
                return null;
            }

            this.ensureSymbolIsBound(semanticInfoChain);

            return semanticInfoChain.getSymbolForDecl(this);
        }

        public hasSymbol(semanticInfoChain: SemanticInfoChain) {
            var symbol = semanticInfoChain.getSymbolForDecl(this);
            return !!symbol;
        }

        public setSignatureSymbol(signatureSymbol: PullSignatureSymbol, semanticInfoChain: SemanticInfoChain): void {
            semanticInfoChain.setSignatureSymbolForDecl(this, signatureSymbol);
        }

        public getSignatureSymbol(semanticInfoChain: SemanticInfoChain): PullSignatureSymbol { 
            this.ensureSymbolIsBound(semanticInfoChain);
            return semanticInfoChain.getSignatureSymbolForDecl(this);
        }

        public hasSignatureSymbol(semanticInfoChain: SemanticInfoChain) {
            var signatureSymbol = semanticInfoChain.getSignatureSymbolForDecl(this);
            return !!signatureSymbol;
        }

        public setFlags(flags: PullElementFlags) { this.flags = flags; }

        public setFlag(flags: PullElementFlags) { this.flags |= flags; }

        public setValueDecl(valDecl: PullDecl) {
            this.synthesizedValDecl = valDecl;
            valDecl.containerDecl = this;
        }

        public getValueDecl() { return this.synthesizedValDecl; }

        public getContainerDecl() { return this.containerDecl; }

        private getChildDeclCache(declKind: PullElementKind): IIndexable<PullDecl[]> {
            if (declKind === PullElementKind.TypeParameter) {
                if (!this.childDeclTypeParameterCache) {
                    this.childDeclTypeParameterCache = createIntrinsicsObject<PullDecl[]>();
                }

                return this.childDeclTypeParameterCache;
            }
            else if (hasFlag(declKind, PullElementKind.SomeContainer)) {
                if (!this.childDeclNamespaceCache) {
                    this.childDeclNamespaceCache = createIntrinsicsObject<PullDecl[]>();
                }

                return this.childDeclNamespaceCache;
            }
            else if (hasFlag(declKind, PullElementKind.SomeType)) {
                if (!this.childDeclTypeCache) {
                    this.childDeclTypeCache = createIntrinsicsObject<PullDecl[]>();
                }

                return this.childDeclTypeCache;
            }
            else {
                if (!this.childDeclValueCache) {
                    this.childDeclValueCache = createIntrinsicsObject<PullDecl[]>();
                }

                return this.childDeclValueCache;
            }
        }        
        // Should only be called by subclasses.
        public addChildDecl(childDecl: PullDecl): void {
            if (childDecl.kind === PullElementKind.TypeParameter) {
                if (!this.typeParameters) {
                    this.typeParameters = [];
                }
                this.typeParameters[this.typeParameters.length] = childDecl;
            }
            else {
                if (!this.childDecls) {
                    this.childDecls = [];
                }
                this.childDecls[this.childDecls.length] = childDecl;
            }

            // add to the appropriate cache
            var declName = childDecl.name;

            if (!(childDecl.kind & PullElementKind.SomeSignature)) {
                var cache = this.getChildDeclCache(childDecl.kind);
                var childrenOfName = cache[declName];
                if (!childrenOfName) {
                    childrenOfName = [];
                }

                childrenOfName.push(childDecl);
                cache[declName] = childrenOfName;
            }
        }

        // Search for a child decl with the given name.  'isType' is used to specify whether or 
        // not child types or child values are returned.
        public searchChildDecls(declName: string, searchKind: PullElementKind): PullDecl[]{
            // find the decl with the optional type
            // if necessary, cache the decl
            // may be wise to return a chain of decls, or take a parent decl as a parameter

            var cacheVal: PullDecl[] = null;

            if (searchKind & PullElementKind.SomeType) {
                cacheVal = this.childDeclTypeCache ? this.childDeclTypeCache[declName] : null;
            }
            else if (searchKind & PullElementKind.SomeContainer) {
                cacheVal = this.childDeclNamespaceCache ? this.childDeclNamespaceCache[declName] : null;
            }
            else {
                cacheVal = this.childDeclValueCache ? this.childDeclValueCache[declName] : null;
            }

            if (cacheVal) {
                return cacheVal;
            }
            else {
                // If we didn't find it, and they were searching for types, then also check the 
                // type parameter cache.
                if (searchKind & PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache ? this.childDeclTypeParameterCache[declName] : null;

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return sentinelEmptyPullDeclArray;
            }
         }

        public getChildDecls(): PullDecl[] {
            return this.childDecls || sentinelEmptyPullDeclArray;
        }

        public getTypeParameters(): PullDecl[] {
            return this.typeParameters || sentinelEmptyPullDeclArray;
        }

        public addVariableDeclToGroup(decl: PullDecl) {
            if (!this.declGroups) {
                this.declGroups = createIntrinsicsObject<PullDeclGroup>();
            }

            var declGroup = this.declGroups[decl.name];
            if (declGroup) {
                declGroup.addDecl(decl);
            }
            else {
                declGroup = new PullDeclGroup(decl.name);
                declGroup.addDecl(decl);
                this.declGroups[decl.name] = declGroup;
            }
        }

        public getVariableDeclGroups(): PullDecl[][] {
            var declGroups: PullDecl[][] = null;

            if (this.declGroups) {
                for (var declName in this.declGroups) {
                    if (this.declGroups[declName]) {
                        if (declGroups === null) {
                            declGroups = [];
                        }

                        declGroups.push(this.declGroups[declName].getDecls());
                    }
                }
            }

            return declGroups || sentinelEmptyPullDeclArray;
        }

        public hasBeenBound(semanticInfoChain: SemanticInfoChain) {
            return this.hasSymbol(semanticInfoChain) || this.hasSignatureSymbol(semanticInfoChain);
        }

        public isSynthesized(): boolean {
            return false;
        }

        public ast(): ISyntaxElement {
            return this.isSynthesized() ? null : this.getASTForDeclMap()._getASTForDecl(this);
        }

        public isRootDecl() {
            throw Errors.abstract();
        }
    }

    // A root decl represents the top level decl for a file.  By specializing this decl, we 
    // provide a location, per file, to store data that all decls in the file would otherwise
    // have to duplicate.  For example, there is no need to store the 'fileName' in each decl.
    // Instead, only the root decl needs to store this data.  Decls underneath it can determine
    // the file name by queryign their parent.  In other words, a Root Decl allows us to trade
    // space for logarithmic speed. 
    export class RootPullDecl extends PullDecl {
        private _isExternalModule: boolean;
        private _fileName: string;

        constructor(private astToDeclMap: IASTForDeclMap, name: string, fileName: string, kind: PullElementKind, declFlags: PullElementFlags, isExternalModule: boolean) {
            super(name, name, kind, declFlags);
            this._isExternalModule = isExternalModule;
            this._fileName = fileName;
        }

        public fileName(): string {
            return this._fileName;
        }

        public getASTForDeclMap(): IASTForDeclMap {
            return this.astToDeclMap;
        }

        public getParentPath(): PullDecl[]{
            return [this];
        }

        public getParentDecl(): PullDecl {
            return null;
        }

        public isExternalModule(): boolean {
            return this._isExternalModule;
        }

        // We never want the enclosing decl to be null, so if we are at a top level decl, return it
        public getEnclosingDecl() {
            return this;
        }

        public isRootDecl() {
            return true;
        }
    }

    export class NormalPullDecl extends PullDecl {
        private parentDecl: PullDecl = null;
        public _rootDecl: RootPullDecl;
        private parentPath: PullDecl[] = null;

        constructor(declName: string, displayName: string, kind: PullElementKind, declFlags: PullElementFlags, parentDecl: PullDecl, addToParent = true) {
            super(declName, displayName, kind, declFlags);

            // Link to parent
            this.parentDecl = parentDecl;
            if (addToParent) {
                parentDecl.addChildDecl(this);
            }

            if (this.parentDecl) {
                if (this.parentDecl.isRootDecl()) {
                    this._rootDecl = <RootPullDecl>this.parentDecl;
                }
                else {
                    this._rootDecl = (<NormalPullDecl>this.parentDecl)._rootDecl;
                }
            } else {
                // Synthetic
                Debug.assert(this.isSynthesized());
                this._rootDecl = null;
            }

            //if (!parentDecl && !this.isSynthesized() && kind !== PullElementKind.Primitive) {
            //    throw Errors.invalidOperation("Orphaned decl " + PullElementKind[kind]);
            //}
        }

        public fileName(): string {
            return this._rootDecl.fileName();
        }

        public getASTForDeclMap(): IASTForDeclMap {
            return this._rootDecl.getASTForDeclMap();
        }

        public getParentDecl(): PullDecl {
            return this.parentDecl;
        }

        public getParentPath(): PullDecl[] {
            if (!this.parentPath) {
                var path: PullDecl[] = [this];
                var parentDecl = this.parentDecl;

                while (parentDecl) {
                    if (parentDecl && path[path.length - 1] !== parentDecl
                        && !(parentDecl.kind & (PullElementKind.ObjectLiteral | PullElementKind.ObjectType))) {
                        path.unshift(parentDecl);
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                this.parentPath = path;
            }

            return this.parentPath;
        }

        public isExternalModule(): boolean {
            return false;
        }

        public getEnclosingDecl(): PullDecl {
            return this.parentDecl && this.parentDecl._getEnclosingDeclFromParentDecl();
        }

        public isRootDecl() {
            return false;
        }
    }

    export class PullEnumElementDecl extends NormalPullDecl {
        public constantValue: number = null;

        constructor(declName: string, displayName: string, parentDecl: PullDecl) {
            super(declName, displayName, PullElementKind.EnumMember, PullElementFlags.Public, parentDecl);
        }
    }

    export class PullFunctionExpressionDecl extends NormalPullDecl {
        private functionExpressionName: string;

        constructor(expressionName: string, declFlags: PullElementFlags, parentDecl: PullDecl, displayName: string = "") {
            super("", displayName, PullElementKind.FunctionExpression, declFlags, parentDecl);
            this.functionExpressionName = expressionName;
        }

        public getFunctionExpressionName(): string {
            return this.functionExpressionName;
        }
    }

    export class PullSynthesizedDecl extends NormalPullDecl {
        // This is a synthesized decl; its life time should match that of the symbol using it, and 
        // not that of its parent decl. To enforce this we are not making it reachable from its 
        // parent, but will set the parent link.
        constructor(declName: string, displayName: string, kind: PullElementKind, declFlags: PullElementFlags, parentDecl: PullDecl) {
            super(declName, displayName, kind, declFlags, parentDecl, /*addToParent*/ false);
        }

        public isSynthesized(): boolean {
            return true;
        }

        public fileName(): string {
            return this._rootDecl ? this._rootDecl.fileName() : "";
        }
    }

    export class PullDeclGroup {

        private _decls: PullDecl[] = [];

        constructor(public name: string) {
        }

        public addDecl(decl: PullDecl) {
            if (decl.name === this.name) {
                this._decls[this._decls.length] = decl;
            }
        }

        public getDecls() {
            return this._decls;
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {

    export enum PullElementFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        Optional = 1 << 7,
        Signature = 1 << 11,
        Enum = 1 << 12,
        ArrowFunction = 1 << 13,

        ClassConstructorVariable = 1 << 14,
        InitializedModule = 1 << 15,
        InitializedDynamicModule = 1 << 16,

        MustCaptureThis = 1 << 18,

        DeclaredInAWithBlock = 1 << 21,

        HasReturnStatement = 1 << 22,

        PropertyParameter = 1 << 23,

        IsAnnotatedWithAny = 1 << 24,

        HasDefaultArgs = 1 << 25,

        ConstructorParameter = 1 << 26,

        ImplicitVariable = ClassConstructorVariable | InitializedModule | InitializedDynamicModule | Enum,
        SomeInitializedModule = InitializedModule | InitializedDynamicModule | Enum,
    }

    function mapFlagToTokenKind(flag: PullElementFlags): SyntaxKind {
        switch (flag) {
            case PullElementFlags.Ambient:
                return SyntaxKind.DeclareKeyword;
            case PullElementFlags.Exported:
                return SyntaxKind.ExportKeyword;
            case PullElementFlags.Public:
                return SyntaxKind.PublicKeyword;
            case PullElementFlags.Private:
                return SyntaxKind.PrivateKeyword;
            case PullElementFlags.Static:
                return SyntaxKind.StaticKeyword;
            default:
                throw Errors.invalidOperation();
        }

    }

    export function hasModifier(modifiers: ISyntaxToken[], flag: PullElementFlags): boolean {
        var kind = mapFlagToTokenKind(flag);

        for (var i = 0, n = modifiers.length; i < n; i++) {
            var modifier = modifiers[i];

            if (modifier.kind() === kind) {
                return true;
            }
        }

        return false;
    }

    export enum PullElementKind {
        None = 0,
        Global = 0,

        Script = 1 << 0,
        Primitive = 1 << 1,

        Container = 1 << 2,
        Class = 1 << 3,
        Interface = 1 << 4,
        DynamicModule = 1 << 5,
        Enum = 1 << 6,
        TypeAlias = 1 << 7,
        ObjectLiteral = 1 << 8,

        Variable = 1 << 9,
        CatchVariable = 1 << 10,
        Parameter = 1 << 11,
        Property = 1 << 12,
        TypeParameter = 1 << 13,

        Function = 1 << 14,
        ConstructorMethod = 1 << 15,
        Method = 1 << 16,
        FunctionExpression = 1 << 17,

        GetAccessor = 1 << 18,
        SetAccessor = 1 << 19,

        CallSignature = 1 << 20,
        ConstructSignature = 1 << 21,
        IndexSignature = 1 << 22,

        ObjectType = 1 << 23,
        FunctionType = 1 << 24,
        ConstructorType = 1 << 25,

        EnumMember = 1 << 26,

        WithBlock = 1 << 27,
        CatchBlock = 1 << 28,

        // WARNING: To prevent JS VMs from wrapping these values as floats, we don't want to utilize more than the 31 bits above.  (Doing so would
        // seriously slow down bitwise operations

        All = Script | Global | Primitive | Container | Class | Interface | DynamicModule | Enum | TypeAlias |
            ObjectLiteral | Variable | Parameter | Property | TypeParameter | Function | ConstructorMethod | Method |
            FunctionExpression | GetAccessor | SetAccessor | CallSignature | ConstructSignature | IndexSignature | ObjectType |
            FunctionType | ConstructorType | EnumMember | WithBlock | CatchBlock,

        SomeFunction = Function | ConstructorMethod | Method | FunctionExpression | GetAccessor | SetAccessor,

        // Warning: SomeValue and SomeType (along with their constituents) must be disjoint
        SomeValue = Variable | Parameter | Property | EnumMember | SomeFunction,

        SomeType = Script | Global | Primitive | Class | Interface |
                    Enum | ObjectLiteral | ObjectType | FunctionType | ConstructorType | TypeParameter,

        AcceptableAlias = Variable | SomeFunction | Class | Interface | Enum | Container | ObjectType | FunctionType | ConstructorType,

        SomeContainer = Container | DynamicModule | TypeAlias,

        SomeSignature = CallSignature | ConstructSignature | IndexSignature,

        SomeTypeReference = Interface | ObjectType | FunctionType | ConstructorType,

        SomeInstantiatableType = Class | Interface | TypeParameter,
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {

    export module PullHelpers {

        // This helps in case we would like to make sure we have type while we are resolving/infering types for it
        // without infering back to any because we incorrectly detected recursive resolution of function
        export function resolveDeclaredSymbolToUseType(symbol: PullSymbol) {
            if (symbol.isSignature()) {
                if (!(<PullSignatureSymbol>symbol).returnType) {
                    symbol._resolveDeclaredSymbol();
                }
            }
            else if (!symbol.type) {
                symbol._resolveDeclaredSymbol();
            }
        }

        export interface SignatureInfoForFuncDecl {
            signature: PullSignatureSymbol;
            allSignatures: PullSignatureSymbol[];
        }

        export function getSignatureForFuncDecl(functionDecl: PullDecl, semanticInfoChain: SemanticInfoChain) {
            var funcDecl = functionDecl.ast();
            var funcSymbol = functionDecl.getSymbol(semanticInfoChain);

            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol(semanticInfoChain);
            }

            var functionSignature: PullSignatureSymbol = null;
            var typeSymbolWithAllSignatures: PullTypeSymbol = null;
            if (funcSymbol.isSignature()) {
                functionSignature = <PullSignatureSymbol>funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol(semanticInfoChain).type;
            }
            else {
                functionSignature = functionDecl.getSignatureSymbol(semanticInfoChain);
                typeSymbolWithAllSignatures = funcSymbol.type;
            }
            var signatures: PullSignatureSymbol[];

            if (funcDecl.kind() === SyntaxKind.ConstructorDeclaration || functionDecl.kind === PullElementKind.ConstructSignature) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            }
            else if (functionDecl.kind === PullElementKind.IndexSignature) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            }
            else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }

            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }

        export function getAccessorSymbol(getterOrSetter: ISyntaxElement, semanticInfoChain: SemanticInfoChain): PullAccessorSymbol {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter);
            var getterOrSetterSymbol = functionDecl.getSymbol(semanticInfoChain);

            return <PullAccessorSymbol>getterOrSetterSymbol;
        }

        export function getGetterAndSetterFunction(funcDecl: ISyntaxElement, semanticInfoChain: SemanticInfoChain): { getter: GetAccessorSyntax; setter: SetAccessorSyntax; } {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain);
            var result: { getter: GetAccessorSyntax; setter: SetAccessorSyntax; } = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = <GetAccessorSyntax>semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = <SetAccessorSyntax>semanticInfoChain.getASTForDecl(setterDecl);
            }

            return result;
        }

        export function symbolIsEnum(source: PullSymbol): boolean {
            return source && (source.kind & (PullElementKind.Enum | PullElementKind.EnumMember)) !== 0;
        }

        export function symbolIsModule(symbol: PullSymbol) {
            return symbol && (symbol.kind === PullElementKind.Container || isOneDeclarationOfKind(symbol, PullElementKind.Container));
        }

        function isOneDeclarationOfKind(symbol: PullSymbol, kind: TypeScript.PullElementKind): boolean {
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (decls[i].kind === kind) {
                    return true;
                }
            }

            return false;
        }

        export function isNameNumeric(name: string) {
            // Coerce the name to a number, and then use isFinite to make sure it is not Infinity or NaN
            return isFinite(+name);
        }


        export function typeSymbolsAreIdentical(a: PullTypeSymbol, b: PullTypeSymbol): boolean {
            // initialized types are omitted, since the type reference points back to the generic type
            // declaration.  (E.g., the referencedTypeSymbol of 'Foo<number>' would be 'Foo<T>'
            if (a.isTypeReference() && !a.getIsSpecialized()) {
                a = (<TypeReferenceSymbol>a).referencedTypeSymbol;
            }

            if (b.isTypeReference() && !b.getIsSpecialized()) {
                b = (<TypeReferenceSymbol>b).referencedTypeSymbol;
            }

            return a === b;
        }

        export function getRootType(type: PullTypeSymbol): PullTypeSymbol {
            var rootType: PullTypeSymbol = <PullTypeSymbol>type.getRootSymbol();

            while (true) {
                if (type === rootType) {
                    return type;
                }

                type = rootType;
                rootType = <PullTypeSymbol>type.getRootSymbol();
            }
        }

        export function isSymbolLocal(symbol: PullSymbol) {
            var container = symbol.getContainer();
            if (container) {
                var containerKind = container.kind;
                if (containerKind & (TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.FunctionType)) {
                    return true;
                }

                if (containerKind === TypeScript.PullElementKind.ConstructorType && !symbol.anyDeclHasFlag(TypeScript.PullElementFlags.Static | TypeScript.PullElementFlags.Exported)) {
                    // container kind can be ConstructorType when
                    // - symbol represents static member of the class or exported value in the clodule
                    // - symbol represents local varable in the constructor
                    // 'IsSymbolLocal' should return true only for the second category
                    return true;
                }
            }

            return false;
        }

        export function isExportedSymbolInClodule(symbol: PullSymbol) {
            var container = symbol.getContainer();
            return container && container.kind === TypeScript.PullElementKind.ConstructorType && symbolIsModule(container) && symbol.anyDeclHasFlag(PullElementFlags.Exported);
        }

        export function isSymbolDeclaredInScopeChain(symbol: PullSymbol, scopeSymbol: PullSymbol): boolean {
            Debug.assert(symbol);
            var symbolDeclarationScope = symbol.getContainer();

            // If we are looking for something other than global scope, look in the scope chain
            while (scopeSymbol) {
                // symbol is declared in same as scope symbol
                if (scopeSymbol === symbolDeclarationScope) {
                    return true;
                }

                // look in the outer scope of scopeSymbol
                scopeSymbol = scopeSymbol.getContainer();
            }

            if (scopeSymbol === null && symbolDeclarationScope === null) {
                // Both are global scopes.
                return true;
            }

            return false;
        }

        // Caller of walkPullTypeSymbolStructure should implement this interface to walk the members, signatures
        export interface PullTypeSymbolStructureWalker {
            memberSymbolWalk(memberSymbol: PullSymbol): boolean;
            callSignatureWalk(signatureSymbol: PullSignatureSymbol): boolean;
            constructSignatureWalk(signatureSymbol: PullSignatureSymbol): boolean;
            indexSignatureWalk(signatureSymbol: PullSignatureSymbol): boolean;
            signatureParameterWalk(parameterSymbol: PullSymbol): boolean;
            signatureReturnTypeWalk(returnType: PullTypeSymbol): boolean;
        }

        // Walks the signature
        function walkSignatureSymbol(signatureSymbol: PullSignatureSymbol, walker: PullTypeSymbolStructureWalker) {
            var continueWalk = true;
            var parameters = signatureSymbol.parameters;
            if (parameters) {
                for (var i = 0; continueWalk && i < parameters.length; i++) {
                    continueWalk = walker.signatureParameterWalk(parameters[i]);
                }
            }

            if (continueWalk) {
                continueWalk = walker.signatureReturnTypeWalk(signatureSymbol.returnType);
            }

            return continueWalk;
        }

        // Walk the type symbol structure
        export function walkPullTypeSymbolStructure(typeSymbol: PullTypeSymbol, walker: PullTypeSymbolStructureWalker) {
            var continueWalk = true;
            // Members
            var members = typeSymbol.getMembers();
            for (var i = 0; continueWalk && i < members.length; i++) {
                continueWalk = walker.memberSymbolWalk(members[i]);
            }

            if (continueWalk) {
                // Call signatures
                var callSigantures = typeSymbol.getCallSignatures();
                for (var i = 0; continueWalk && i < callSigantures.length; i++) {
                    continueWalk = walker.callSignatureWalk(callSigantures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(callSigantures[i], walker);
                    }
                }
            }

            if (continueWalk) {
                // Construct signatures
                var constructSignatures = typeSymbol.getConstructSignatures();
                for (var i = 0; continueWalk && i < constructSignatures.length; i++) {
                    continueWalk = walker.constructSignatureWalk(constructSignatures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(constructSignatures[i], walker);
                    }

                }
            }

            if (continueWalk) {
                // Index signatures
                var indexSignatures = typeSymbol.getIndexSignatures();
                for (var i = 0; continueWalk && i < indexSignatures.length; i++) {
                    continueWalk = walker.indexSignatureWalk(indexSignatures[i]);
                    if (continueWalk) {
                        continueWalk = walkSignatureSymbol(indexSignatures[i], walker);
                    }
                }
            }
        }

        // Helper class to walk the other decls
        export class OtherPullDeclsWalker {
            // The below walk just gives example of the usage of walk:
            // This is list of decls that are currently binding other decl. 
            // We maintain this so that we dont keep binding other decls in the stack. 
            // eg. if we have this:
            // module a{            // decl1
            // }
            // module a {           // decl2
            // }
            // module a {           // decl3
            // }
            // module a {           // decl4
            // }
            // If we do not keep track of these decls we would end up binding decl4 on stack when binding decl1, decl2, decl3 as below:
            // After binding decl1, we would go and try to bind other decls of 'a'
            // as part of it we would try to bind decl1, since its already bound we proceed to decl2
            // After binding decl2, we go bind other decls of 'a' and find that decl1 and decl2 are already bound
            // So as we bind decl3, and then go and try to bind other decls of 'a' which ends us up in binding decl4.
            // Thus the stack would be proportional to decls for given particular symbol.
            //
            // To avoid this before binding other symbols we always check if the list of decls contains 
            // the decl whose other decls we are already binding and if yes we skip the binding other decls
            // In the above eg. when we start binding other decls of 'a' after binding decl1, we go bind decl2
            // but when binding other decls of decl2, we find that it contains decl1, which is already binding its other decls
            // hence we dont do other decl binding and return and do same process for rest of the decls, thus ending up 
            // binding only current decl if we are binding that symbol as part of binding other decls
            private currentlyWalkingOtherDecls: PullDecl[] = [];
            public walkOtherPullDecls(currentDecl: PullDecl, otherDecls: PullDecl[], callBack: (otherDecl: PullDecl) => void) {
                if (otherDecls) {
                    var isAlreadyWalkingOtherDecl = ArrayUtilities.any(this.currentlyWalkingOtherDecls,
                        inWalkingOtherDecl => ArrayUtilities.contains(otherDecls, inWalkingOtherDecl));

                    // If we are already binding other decls for this 
                    if (!isAlreadyWalkingOtherDecl) {
                        this.currentlyWalkingOtherDecls.push(currentDecl);
                        for (var i = 0; i < otherDecls.length; i++) {
                            if (otherDecls[i] !== currentDecl) {
                                callBack(otherDecls[i]);
                            }
                        }
                        var currentlyWalkingOtherDeclsDecl = this.currentlyWalkingOtherDecls.pop();
                        Debug.assert(currentlyWalkingOtherDeclsDecl == currentDecl);
                    }
                }
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {
    export class WrapsTypeParameterCache {
        private _wrapsTypeParameterCache = BitVector.getBitVector(/*allowedUndefined*/ true);

        // 0 indicates that it does not wrap type parameter
        // undefined indicates that the info wasn't available from cache
        // rest indicates the valid type parameter id
        //
        // The obvious way to answer the question, "Does this type wrap any type parameter
        // from a given map?" is via a boolean. However, using a boolean would make the
        // cache less effective. So we instead return the ID of SOME type parameter that is
        // both in the typeParameterArgumentMap and is set to true in the cache. If all
        // type parameters in the map are set to false in the cache, we return 0. And if
        // neither of those apply, we need more information, so we return undefined.
        //
        // For example, consider a type or signature that wraps type
        // parameters with ID's [1, 5, 6]. We are asked if it wraps some type parameter from
        // the map [2, 4, 6]. Of course it does, because it wraps 6. If we cached true
        // for map [2, 4, 6], this would not help us if we were later asked if it wraps
        // something from [1, 3, 6], since it is not the same map that we were asked about
        // before. However, by caching the 6, we are implicitly caching true for ANY map
        // that contains a 6.
        //
        // On the negative side, if we find that nothing is wrapped from [2, 3, 4], we should
        // cache false for each type parameter (2, 3, and 4). This way if we are later asked
        // about [3, 4], we know to return false.
        //
        // Another way to think about this is that if we wrap some type parameter, then
        // we have only learned that we wrap ONE type parameter. If we do not wrap any
        // type parameter, we have learned that for ALL type parameters in the map.
        public getWrapsTypeParameter(typeParameterArgumentMap: TypeSubstitutionMap): number {
            // Find result from cache
            var someTypeParameterWasMissingFromCache = false;
            for (var typeParameterID in typeParameterArgumentMap) {
                if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                    var cachedValue = this._wrapsTypeParameterCache.valueAt(typeParameterID);
                    if (cachedValue) {
                        // Cached value indicates that the type parameter is wrapped
                        return typeParameterID;
                    }
                    someTypeParameterWasMissingFromCache = someTypeParameterWasMissingFromCache || cachedValue === undefined;
                }
            }

            // If everything was cached, then this type doesnt wrap the type parameter
            if (!someTypeParameterWasMissingFromCache) {
                return 0;
            }

            return undefined;
        }

        public setWrapsTypeParameter(typeParameterArgumentMap: TypeSubstitutionMap, wrappingTypeParameterID: number) {
            if (wrappingTypeParameterID) {
                // wrappingTypeParameterID is the known type parameter that is wrapped
                // We dont know about other type parameters present in the map and hence we cant set their values
                this._wrapsTypeParameterCache.setValueAt(wrappingTypeParameterID, true);
            }
            else {
                // When the wrappingTypeParameterID = 0, it means that there wasnt any typeparameter in the map
                // that was wrapped, and hence set values for all the ids as false, so that it could be used later
                for (var typeParameterID in typeParameterArgumentMap) {
                    if (typeParameterArgumentMap.hasOwnProperty(typeParameterID)) {
                        this._wrapsTypeParameterCache.setValueAt(typeParameterID, false);
                    }
                }
            }
        }
    }

    export module PullInstantiationHelpers {
        // This class helps in creating the type substitution map
        // But it creates another copy only if the type substitution map is changing
        // helping in not modifying entried in the existing map
        export class MutableTypeParameterSubstitutionMap {
            public createdDuplicateTypeSubstitutionMap = false;
            constructor(public typeParameterSubstitutionMap: TypeSubstitutionMap) {
            }
            public ensureCopyOfUnderlyingMap() {
                if (!this.createdDuplicateTypeSubstitutionMap) {
                    var passedInTypeArgumentMap = this.typeParameterSubstitutionMap;
                    this.typeParameterSubstitutionMap = [];
                    for (var typeParameterID in passedInTypeArgumentMap) {
                        if (passedInTypeArgumentMap.hasOwnProperty(typeParameterID)) {
                            this.typeParameterSubstitutionMap[typeParameterID] = passedInTypeArgumentMap[typeParameterID];
                        }
                    }
                    this.createdDuplicateTypeSubstitutionMap = true;
                }
            }
        }

        // Instantiate the type arguments
        // This instantiates all the type parameters the symbol can reference and the type argument in the end
        // will contain the final instantiated version for each typeparameter
        // eg. if the type is already specialized, we need to create a new type substitution map that represents 
        // the mapping of type arguments we've just received to type arguments as previously passed through
        // If we have below sample
        //interface IList<T> {
        //    owner: IList<IList<T>>;
        //}
        //class List<U> implements IList<U> {
        //    owner: IList<IList<U>>;
        //}
        //class List2<V> extends List<V> {
        //    owner: List2<List2<V>>;
        //}
        // When instantiating List<V> with U = V and trying to get owner property we would have the map that
        // says U = V, but when creating the IList<V> we want to updates its type substitution maps to say T = V because 
        // IList<T>  would now be instantiated with V
        export function instantiateTypeArgument(resolver: PullTypeResolver, symbol: InstantiableSymbol,
            mutableTypeParameterMap: MutableTypeParameterSubstitutionMap) {
            if (symbol.getIsSpecialized()) {
                // Get the type substitution map from the signature and update our type substitution map
                var rootTypeArgumentMap = symbol.getTypeParameterSubstitutionMap();
                var newTypeArgumentMap: PullTypeSymbol[] = [];
                var allowedTypeParameters = symbol.getAllowedToReferenceTypeParameters();
                for (var i = 0; i < allowedTypeParameters.length; i++) {
                    var typeParameterID = allowedTypeParameters[i].pullSymbolID;
                    var typeArg = rootTypeArgumentMap[typeParameterID];
                    if (typeArg) {
                        newTypeArgumentMap[typeParameterID] = resolver.instantiateType(typeArg, mutableTypeParameterMap.typeParameterSubstitutionMap);
                    }
                }

                // We are repeating this loop just to make sure we arent poluting the typeParameterSubstitutionMap passed in
                // when we are insantiating the type arguments
                for (var i = 0; i < allowedTypeParameters.length; i++) {
                    var typeParameterID = allowedTypeParameters[i].pullSymbolID;
                    if (newTypeArgumentMap[typeParameterID] && mutableTypeParameterMap.typeParameterSubstitutionMap[typeParameterID] != newTypeArgumentMap[typeParameterID]) {
                        mutableTypeParameterMap.ensureCopyOfUnderlyingMap();
                        mutableTypeParameterMap.typeParameterSubstitutionMap[typeParameterID] = newTypeArgumentMap[typeParameterID];
                    }
                }
            }
        }

        // Removes any entries that this instantiable symbol cannot reference
        // eg. In any type, typeparameter map should only contain information about the allowed to reference type parameters 
        // so remove unnecessary entries that are outside these scope, eg. from above sample we need to remove entry U = V
        // and keep only T = V
        export function cleanUpTypeParameterSubstitutionMap(symbol: InstantiableSymbol, mutableTypeParameterSubstitutionMap: MutableTypeParameterSubstitutionMap) {
            var allowedToReferenceTypeParameters = symbol.getAllowedToReferenceTypeParameters();
            for (var typeParameterID in mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap) {
                if (mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap.hasOwnProperty(typeParameterID)) {
                    if (!ArrayUtilities.any(allowedToReferenceTypeParameters, (typeParameter) => typeParameter.pullSymbolID == typeParameterID)) {
                        mutableTypeParameterSubstitutionMap.ensureCopyOfUnderlyingMap();
                        delete mutableTypeParameterSubstitutionMap.typeParameterSubstitutionMap[typeParameterID];
                    }
                }
            }
        }

        // This method get the allowed to reference type parameter in any decl
        // eg. in below code 
        // interface IList<T> {
        //     owner: /*Any type here can only refere to type parameter T*/;
        //     map<U>(a: /*any type parameter here can only refere to U and T*/
        // }
        export function getAllowedToReferenceTypeParametersFromDecl(decl: PullDecl, semanticInfoChain: SemanticInfoChain): PullTypeParameterSymbol[]{
            var allowedToReferenceTypeParameters: PullTypeParameterSymbol[] = [];

            var allowedToUseDeclTypeParameters = false;
            var getTypeParametersFromParentDecl = false;

            switch (decl.kind) {
                case PullElementKind.Method:
                    if (hasFlag(decl.flags, PullElementFlags.Static)) {
                        // Static method/property cannot use type parameters from parent
                        allowedToUseDeclTypeParameters = true;
                        break;
                    }
                // Non static methods, construct and call signatures have type paramters
                // and can use type parameters from parent decl too
                case PullElementKind.FunctionType:
                case PullElementKind.ConstructorType:
                case PullElementKind.ConstructSignature:
                case PullElementKind.CallSignature:
                case PullElementKind.FunctionExpression:
                case PullElementKind.Function:
                    allowedToUseDeclTypeParameters = true;
                    getTypeParametersFromParentDecl = true;
                    break;

                case PullElementKind.Property:
                    if (hasFlag(decl.flags, PullElementFlags.Static)) {
                        // Static method/property cannot use type parameters from parent 
                        break;
                    }
                // Dont have own type parameters, but can get it from parents
                case PullElementKind.Parameter:
                case PullElementKind.GetAccessor:
                case PullElementKind.SetAccessor:
                case PullElementKind.ConstructorMethod:
                case PullElementKind.IndexSignature:
                case PullElementKind.ObjectType:
                case PullElementKind.ObjectLiteral:
                case PullElementKind.TypeParameter:
                    getTypeParametersFromParentDecl = true;
                    break;

                case PullElementKind.Class:
                case PullElementKind.Interface:
                    allowedToUseDeclTypeParameters = true;
                    break;
            }

            if (getTypeParametersFromParentDecl) {
                allowedToReferenceTypeParameters = allowedToReferenceTypeParameters.concat(
                    getAllowedToReferenceTypeParametersFromDecl(decl.getParentDecl(), semanticInfoChain));
            }

            if (allowedToUseDeclTypeParameters) {
                var typeParameterDecls = decl.getTypeParameters();
                for (var i = 0; i < typeParameterDecls.length; i++) {
                    allowedToReferenceTypeParameters.push(<PullTypeParameterSymbol>typeParameterDecls[i].getSymbol(semanticInfoChain));
                }
            }

            return allowedToReferenceTypeParameters;
        }

        export function createTypeParameterSubstitutionMap(typeParameters: PullTypeParameterSymbol[], typeArguments: PullTypeSymbol[]): TypeSubstitutionMap {
            return updateTypeParameterSubstitutionMap(typeParameters, typeArguments, {});
        }

        export function updateTypeParameterSubstitutionMap(typeParameters: PullTypeParameterSymbol[], typeArguments: PullTypeSymbol[], typeParameterSubstitutionMap: TypeSubstitutionMap): TypeSubstitutionMap {
            for (var i = 0; i < typeParameters.length; i++) {
                // The reason we call getRootSymbol below is to handle the case where a signature
                // has a type parameter constrained to an outer type parameter. Because signatures
                // are instantiated from the root signature, the map needs to be in terms of the root
                // type parameter. For example,
                // interface I<T> {
                //     foo<U extends T>(u: U): U;
                // }
                // var i: I<string>;
                // var f = i.foo(""); // f should be string
                //
                // When we instantiate T to string, we create a new U, but instantiations of the
                // signature must be against the root U.
                // Note that when this type of situation does not apply, getRootSymbol is the
                // identity function.
                typeParameterSubstitutionMap[typeParameters[i].getRootSymbol().pullSymbolID] = typeArguments[i];
            }
            return typeParameterSubstitutionMap;
        }

        export function updateMutableTypeParameterSubstitutionMap(typeParameters: PullTypeParameterSymbol[], typeArguments: PullTypeSymbol[], mutableMap: MutableTypeParameterSubstitutionMap): void {
            for (var i = 0; i < typeParameters.length; i++) {
                // See comment in updateTypeParameterArgumentMap for why we use getRootSymbol
                var typeParameterId = typeParameters[i].getRootSymbol().pullSymbolID;
                if (mutableMap.typeParameterSubstitutionMap[typeParameterId] !== typeArguments[i]) {
                    mutableMap.ensureCopyOfUnderlyingMap();
                    mutableMap.typeParameterSubstitutionMap[typeParameterId] = typeArguments[i];
                }
            }
        }

        export function twoTypesAreInstantiationsOfSameNamedGenericType(type1: PullTypeSymbol, type2: PullTypeSymbol) {
            var type1IsGeneric = type1.isGeneric() && type1.getTypeArguments() !== null;
            var type2IsGeneric = type2.isGeneric() && type2.getTypeArguments() !== null;

            if (type1IsGeneric && type2IsGeneric) {
                var type1Root = PullHelpers.getRootType(type1);
                var type2Root = PullHelpers.getRootType(type2);
                return type1Root === type2Root;
            }

            return false;
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {

    // PULLTODO: Get rid of these
    export var declCacheHit = 0;
    export var declCacheMiss = 0;
    export var symbolCacheHit = 0;
    export var symbolCacheMiss = 0;

    var sentinalEmptyArray: any[] = [];

    export class SemanticInfoChain {

        private static EmptyASTToDeclMap: IASTForDeclMap = {
            _getASTForDecl(decl: PullDecl): ISyntaxElement {
                return null;
            }
        }

        private documents: Document[] = [];
        private fileNameToDocument = createIntrinsicsObject<Document>();

        public anyTypeDecl: PullDecl = null;
        public booleanTypeDecl: PullDecl = null;
        public numberTypeDecl: PullDecl = null;
        public stringTypeDecl: PullDecl = null;
        public nullTypeDecl: PullDecl = null;
        public undefinedTypeDecl: PullDecl = null;
        public voidTypeDecl: PullDecl = null;
        public undefinedValueDecl: PullDecl = null;

        public anyTypeSymbol: PullPrimitiveTypeSymbol = null;
        public booleanTypeSymbol: PullPrimitiveTypeSymbol = null;
        public numberTypeSymbol: PullPrimitiveTypeSymbol = null;
        public stringTypeSymbol: PullPrimitiveTypeSymbol = null;
        public nullTypeSymbol: PullPrimitiveTypeSymbol = null;
        public undefinedTypeSymbol: PullPrimitiveTypeSymbol = null;
        public voidTypeSymbol: PullPrimitiveTypeSymbol = null;
        public undefinedValueSymbol: PullSymbol = null;
        public emptyTypeSymbol: PullTypeSymbol = null;

        // <-- Data to clear when we get invalidated
        private astSymbolMap: PullSymbol[] = [];
        private astAliasSymbolMap: PullTypeAliasSymbol[] = [];
        private astCallResolutionDataMap: PullAdditionalCallResolutionData[] = [];

        private declSymbolMap: PullSymbol[] = [];
        private declSignatureSymbolMap: PullSignatureSymbol[] = [];

        private declCache: IIndexable<PullDecl[]> = null;
        private symbolCache: IIndexable<PullSymbol> = null;
        private fileNameToDiagnostics: IIndexable<Diagnostic[]> = null;

        private _binder: PullSymbolBinder = null;
        private _resolver: PullTypeResolver = null;

        private _topLevelDecls: PullDecl[] = null;
        private _fileNames: string[] = null;

        constructor(private compiler: TypeScriptCompiler, private logger: ILogger) {
            var globalDecl = new RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, /*name:*/ "", /*fileName:*/ "", PullElementKind.Global, PullElementFlags.None, /*isExternalModule:*/ false);
            this.documents[0] = new Document(this.compiler.compilationSettings(), /*fileName:*/ "", /*referencedFiles:*/[], /*scriptSnapshot:*/null, ByteOrderMark.None, /*version:*/0, /*isOpen:*/ false, /*syntaxTree:*/null, globalDecl);

            this.anyTypeDecl = new NormalPullDecl("any", "any", PullElementKind.Primitive, PullElementFlags.None, globalDecl);
            this.booleanTypeDecl = new NormalPullDecl("boolean", "boolean", PullElementKind.Primitive, PullElementFlags.None, globalDecl);
            this.numberTypeDecl = new NormalPullDecl("number", "number", PullElementKind.Primitive, PullElementFlags.None, globalDecl);
            this.stringTypeDecl = new NormalPullDecl("string", "string", PullElementKind.Primitive, PullElementFlags.None, globalDecl);
            this.voidTypeDecl = new NormalPullDecl("void", "void", PullElementKind.Primitive, PullElementFlags.None, globalDecl);
            
            // add the global primitive values for "null" and "undefined"
            // Because you cannot reference them by name, they're not parented by any actual decl.
            this.nullTypeDecl = new RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, "null", "", PullElementKind.Primitive, PullElementFlags.None, /*isExternalModule:*/ false);
            this.undefinedTypeDecl = new RootPullDecl(SemanticInfoChain.EmptyASTToDeclMap, "undefined", "", PullElementKind.Primitive, PullElementFlags.None, /*isExternalModule:*/ false);
            this.undefinedValueDecl = new NormalPullDecl("undefined", "undefined", PullElementKind.Variable, PullElementFlags.Ambient, globalDecl);

            this.invalidate();
        }

        public getDocument(fileName: string): Document {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var document = this.fileNameToDocument[fileName];
            return document || null;
        }

        public lineMap(fileName: string): LineMap {
            return this.getDocument(fileName).lineMap();
        }

        // Returns the names of the files we own, in the same order that they were added to us.
        public fileNames(): string[] {
            if (this._fileNames === null) {
                // Skip the first semantic info (the synthesized one for the global decls).
                this._fileNames = this.documents.slice(1).map(s => s.fileName);
            }

            return this._fileNames;
        }

        // Must pass in a new decl, or an old symbol that has a decl available for ownership transfer
        private bindPrimitiveSymbol<TSymbol extends PullSymbol>(decl: PullDecl, newSymbol: TSymbol): TSymbol {
            newSymbol.addDeclaration(decl);
            this.setSymbolForDecl(decl, newSymbol);
            newSymbol.setResolved();

            return newSymbol;
        }

        // Creates a new type symbol to be bound to this decl. Must be called during
        // invalidation after every edit.
        private addPrimitiveTypeSymbol(decl: PullDecl): PullPrimitiveTypeSymbol {
            var newSymbol = new PullPrimitiveTypeSymbol(decl.name, this);
            return this.bindPrimitiveSymbol(decl, newSymbol);
        }

        // Creates a new value symbol to be bound to this decl, and has the specified type.
        // Must be called during invalidation after every edit.
        private addPrimitiveValueSymbol(decl: PullDecl, type: PullTypeSymbol): PullSymbol {
            var newSymbol = new PullSymbol(decl.name, PullElementKind.Variable, this);
            newSymbol.type = type;
            return this.bindPrimitiveSymbol(decl, newSymbol);
        }

        private resetGlobalSymbols(): void {
            // add primitive types
            this.anyTypeSymbol = this.addPrimitiveTypeSymbol(this.anyTypeDecl);
            this.booleanTypeSymbol = this.addPrimitiveTypeSymbol(this.booleanTypeDecl);
            this.numberTypeSymbol = this.addPrimitiveTypeSymbol(this.numberTypeDecl);
            this.stringTypeSymbol = this.addPrimitiveTypeSymbol(this.stringTypeDecl);
            this.voidTypeSymbol = this.addPrimitiveTypeSymbol(this.voidTypeDecl);
            this.nullTypeSymbol = this.addPrimitiveTypeSymbol(this.nullTypeDecl);
            this.undefinedTypeSymbol = this.addPrimitiveTypeSymbol(this.undefinedTypeDecl);
            this.undefinedValueSymbol = this.addPrimitiveValueSymbol(this.undefinedValueDecl, this.undefinedTypeSymbol);

            // other decls not reachable from the globalDecl
            var emptyTypeDecl = new PullSynthesizedDecl("{}", "{}", PullElementKind.ObjectType, PullElementFlags.None, /*parentDecl*/null);
            var emptyTypeSymbol = new PullTypeSymbol("{}", PullElementKind.ObjectType, this);
            this.setSymbolForDecl(emptyTypeDecl, emptyTypeSymbol);
            emptyTypeSymbol.addDeclaration(emptyTypeDecl);
            emptyTypeSymbol.setResolved();
            this.emptyTypeSymbol = emptyTypeSymbol;
        }

        public addDocument(document: Document): void {
            var fileName = document.fileName;
            fileName = TypeScript.switchToForwardSlashes(fileName);

            var existingIndex = ArrayUtilities.indexOf(this.documents, u => u.fileName === fileName);
            if (existingIndex < 0) {
                // Adding the script for the first time.
                this.documents.push(document);
            }
            else {
                this.documents[existingIndex] = document;
            }

            this.fileNameToDocument[fileName] = document;

            // We changed the scripts we're responsible for.  Invalidate all existing cached
            // semantic information.
            this.invalidate();
        }

        public removeDocument(fileName: string): void {
            Debug.assert(fileName !== "", "Can't remove the semantic info for the global decl.");
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var index = ArrayUtilities.indexOf(this.documents, u => u.fileName === fileName);
            if (index > 0) {
                this.fileNameToDocument[fileName] = undefined;
                this.documents.splice(index, 1);
                this.invalidate();
            }
        }

        private getDeclPathCacheID(declPath: string[], declKind: PullElementKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        }

        // Looks for a top level decl matching the name/kind pair passed in.  This should be used
        // by methods in the binder to see if there is an existing symbol that a declaration should
        // merge into, or if the declaration should create a new symbol.  
        //
        // The doNotGoPastThisDecl argument is important.  it should be the declaration that the
        // binder is currently creating a symbol for.  The chain will search itself from first to
        // last semantic info, and will not go past the file that that decl is declared in.  
        // Furthermore, while searching hte file that that decl is declared in, it will also not
        // consider any decls at a later position in the file.
        //
        // In this manner, it will only find symbols declared 'before' the decl currently being
        // bound.  This gives us a nice ordering guarantee for open ended symbols.  Specifically
        // we'll create a symbol for the first file (in compiler order) that it was found it,
        // and we'll merge all later declarations into that symbol.  This means, for example, that
        // if a consumer tries to augment a lib.d.ts type, that the symbol will be created for
        // lib.d.ts (as that is in the chain prior to all user files).
        public findTopLevelSymbol(name: string, kind: PullElementKind, doNotGoPastThisDecl: PullDecl): PullSymbol {
            var cacheID = this.getDeclPathCacheID([name], kind);

            var symbol = this.symbolCache[cacheID];

            if (!symbol) {

                for (var i = 0, n = this.documents.length; i < n; i++) {
                    var topLevelDecl = this.documents[i].topLevelDecl();

                    var symbol = this.findTopLevelSymbolInDecl(topLevelDecl, name, kind, doNotGoPastThisDecl);
                    if (symbol) {
                        break;
                    }

                    // We finished searching up to the file that included the stopping point decl.  
                    // no need to continue.
                    if (doNotGoPastThisDecl && topLevelDecl.name === doNotGoPastThisDecl.fileName()) {
                        return null;
                    }
                }

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        }

        private findTopLevelSymbolInDecl(topLevelDecl: PullDecl, name: string, kind: PullElementKind, doNotGoPastThisDecl: PullDecl): PullSymbol {
            // If we're currently searching the file that includes the decl we don't want to go 
            // past, then we have to stop searching at the position of that decl.  Otherwise, we
            // search the entire file.
            var doNotGoPastThisPosition = doNotGoPastThisDecl && doNotGoPastThisDecl.fileName() === topLevelDecl.fileName()
                ? start(doNotGoPastThisDecl.ast())
                : -1

            var foundDecls = topLevelDecl.searchChildDecls(name, kind);

            for (var j = 0; j < foundDecls.length; j++) {
                var foundDecl = foundDecls[j];

                // This decl was at or past the stopping point.  Don't search any further.
                if (doNotGoPastThisPosition !== -1 &&
                    foundDecl.ast() &&
                    start(foundDecl.ast()) > doNotGoPastThisPosition) {

                    break;
                }

                var symbol = foundDecls[j].getSymbol(this);
                if (symbol) {
                    return symbol;
                }
            }

            return null;
        }

        public findExternalModule(id: string) {
            id = normalizePath(id);

            // SPEC: Nov 18
            // An external import declaration that specifies a relative external module name (section 11.2.1) resolves the name 
            // relative to the directory of the containing source file.
            // If a source file with the resulting path and file extension '.ts' exists, that file is added as a dependency.
            // Otherwise, if a source file with the resulting path and file extension '.d.ts' exists, that file is added as a dependency.
            var tsFile = id + ".ts"
            var tsCacheID = this.getDeclPathCacheID([tsFile], PullElementKind.DynamicModule);
            symbol = <PullContainerSymbol>this.symbolCache[tsCacheID]
            if (symbol != undefined) {
                return symbol;
            }

            var dtsFile = id + ".d.ts";
            var dtsCacheID = this.getDeclPathCacheID([dtsFile], PullElementKind.DynamicModule);
            var symbol = <PullContainerSymbol>this.symbolCache[dtsCacheID];
            if (symbol) {
                return symbol;
            }


            var dtsSymbol: PullContainerSymbol;
            for (var i = 0; i < this.documents.length; i++) {
                var document = this.documents[i];
                var topLevelDecl = document.topLevelDecl(); // Script

                if (topLevelDecl.isExternalModule()) {
                    var isTsFile = document.fileName === tsFile;
                    if (isTsFile || document.fileName === dtsFile) {
                        var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
                        symbol = <PullContainerSymbol>dynamicModuleDecl.getSymbol(this);

                        if (isTsFile) {
                            this.symbolCache[tsCacheID] = symbol;
                            // .ts file found - can return immediately
                            return symbol;
                        }
                        else {
                            // .d.ts file found - save the symbol and continue looking for .ts file
                            dtsSymbol = symbol;
                        }
                    }
                }
            }

            if (dtsSymbol) {
                this.symbolCache[dtsCacheID] = symbol;
                return dtsSymbol;
            }

            this.symbolCache[dtsCacheID] = null;
            this.symbolCache[tsCacheID] = null;

            return null;
        }

        public findAmbientExternalModuleInGlobalContext(id: string) {
            var cacheID = this.getDeclPathCacheID([id], PullElementKind.DynamicModule);

            var symbol = <PullContainerSymbol>this.symbolCache[cacheID];
            if (symbol == undefined) {
                symbol = null;
                for (var i = 0; i < this.documents.length; i++) {
                    var document = this.documents[i];
                    var topLevelDecl = document.topLevelDecl();

                    if (!topLevelDecl.isExternalModule()) {
                        var dynamicModules = topLevelDecl.searchChildDecls(id, PullElementKind.DynamicModule);
                        if (dynamicModules.length) {
                            symbol = <PullContainerSymbol>dynamicModules[0].getSymbol(this);
                            break;
                        }
                    }
                }

                this.symbolCache[cacheID] = symbol;
            }

            return symbol;
        }

        // a decl path is a list of decls that reference the components of a declaration from the global scope down
        // E.g., string would be "['string']" and "A.B.C" would be "['A','B','C']"
        public findDecls(declPath: string[], declKind: PullElementKind): PullDecl[] {

            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    declCacheHit++;
                    return <PullDecl[]> cachedDecls;
                }
            }

            declCacheMiss++;

            var declsToSearch = this.topLevelDecls();

            var decls: PullDecl[] = sentinelEmptyArray;
            var path: string;
            var foundDecls: PullDecl[] = sentinelEmptyArray;

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = sentinelEmptyArray;

                var kind = (i === declPath.length - 1) ? declKind : PullElementKind.SomeContainer;
                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, kind);

                    for (var k = 0; k < foundDecls.length; k++) {
                        if (decls === sentinelEmptyArray) {
                            decls = [];
                        }
                        decls[decls.length] = foundDecls[k];
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        }

        public findDeclsFromPath(declPath: PullDecl[], declKind: PullElementKind): PullDecl[]{
            var declString: string[] = [];

            for (var i = 0, n = declPath.length; i < n; i++) {
                if (declPath[i].kind & PullElementKind.Script) {
                    continue;
                }

                declString.push(declPath[i].name);
            }
            
            return this.findDecls(declString, declKind);
        }

        public findSymbol(declPath: string[], declType: PullElementKind): PullSymbol {
            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {

                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            symbolCacheMiss++;

            // symbol wasn't cached, so get the decl
            var decls: PullDecl[] = this.findDecls(declPath, declType);
            var symbol: PullSymbol = null;

            if (decls.length) {

                // it might happen that container also has a value side: i.e fundule\clodule.
                // if value side is not bound yet then binding of the module (caused by getSymbol) will create a fresh variable symbol for the value side
                // instead of sharing one with function\enum\class => big problems with name resolution in future.
                // To avoid we make sure that symbol for value decl is already bound prior to getSymbol call for the container decl(if value decl is present)
                var decl = decls[0];
                if (hasFlag(decl.kind, PullElementKind.SomeContainer)) {
                    var valueDecl = decl.getValueDecl();
                    if (valueDecl) {
                        valueDecl.ensureSymbolIsBound(this);
                    }
                }
                symbol = decl.getSymbol(this);

                if (symbol) {
                    // This is just a workaround for making sure all the declarations are bound 
                    // It can be removed later when binder can deal with all declarations of any type
                    for (var i = 1; i < decls.length; i++) {
                        decls[i].ensureSymbolIsBound(this);
                    }

                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        }

        public cacheGlobalSymbol(symbol: PullSymbol, kind: PullElementKind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.name], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.name], symbol.kind);

            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
            }

            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
            }
        }

        public invalidate(oldSettings: ImmutableCompilationSettings = null, newSettings: ImmutableCompilationSettings = null) {
            // A file has changed, increment the type check phase so that future type chech
            // operations will proceed.
            PullTypeResolver.globalTypeCheckPhase++;

            // this.logger.log("Invalidating SemanticInfoChain...");
            var cleanStart = new Date().getTime();

            this.astSymbolMap.length = 0;
            this.astAliasSymbolMap.length = 0;
            this.astCallResolutionDataMap.length = 0;

            this.declCache = createIntrinsicsObject<PullDecl[]>();
            this.symbolCache = createIntrinsicsObject<PullSymbol>();
            this.fileNameToDiagnostics = createIntrinsicsObject<Diagnostic[]>();
            this._binder = null;
            this._resolver = null;
            this._topLevelDecls = null;
            this._fileNames = null;

            this.declSymbolMap.length = 0;
            this.declSignatureSymbolMap.length = 0;

            // Reset global counters
            TypeScript.pullSymbolID = 0;

            this.resetGlobalSymbols();

            var cleanEnd = new Date().getTime();
            // this.logger.log("   time to invalidate: " + (cleanEnd - cleanStart));
        }

        public setSymbolForAST(ast: ISyntaxElement, symbol: PullSymbol): void {
            Debug.assert(!isShared(ast));
            this.astSymbolMap[syntaxID(ast)] = symbol;
        }

        public getSymbolForAST(ast: ISyntaxElement): PullSymbol {
            return this.astSymbolMap[syntaxID(ast)] || null;
        }

        public setAliasSymbolForAST(ast: ISyntaxElement, symbol: PullTypeAliasSymbol): void {
            Debug.assert(!isShared(ast));
            this.astAliasSymbolMap[syntaxID(ast)] = symbol;
        }

        public getAliasSymbolForAST(ast: ISyntaxElement): PullTypeAliasSymbol {
            return isShared(ast) ? null : this.astAliasSymbolMap[syntaxID(ast)];
        }

        public getCallResolutionDataForAST(ast: ISyntaxElement): PullAdditionalCallResolutionData {
            return isShared(ast) ? null : this.astCallResolutionDataMap[syntaxID(ast)];
        }

        public setCallResolutionDataForAST(ast: ISyntaxElement, callResolutionData: PullAdditionalCallResolutionData) {
            Debug.assert(!isShared(ast));
            if (callResolutionData) {
                this.astCallResolutionDataMap[syntaxID(ast)] = callResolutionData;
            }
        }

        public setSymbolForDecl(decl: PullDecl, symbol: PullSymbol): void {
            this.declSymbolMap[decl.declID] = symbol;
        }

        public getSymbolForDecl(decl: PullDecl): PullSymbol {
            return this.declSymbolMap[decl.declID];
        }

        public setSignatureSymbolForDecl(decl: PullDecl, signatureSymbol: PullSignatureSymbol): void {
            this.declSignatureSymbolMap[decl.declID] = signatureSymbol;
        }

        public getSignatureSymbolForDecl(decl: PullDecl): PullSignatureSymbol {
            return this.declSignatureSymbolMap[decl.declID];
        }

        public addDiagnostic(diagnostic: Diagnostic): void {
            var fileName = diagnostic.fileName();
            var diagnostics = this.fileNameToDiagnostics[fileName];
            if (!diagnostics) {
                diagnostics = [];
                this.fileNameToDiagnostics[fileName] = diagnostics;
            }

            diagnostics.push(diagnostic);
        }

        public getDiagnostics(fileName: string): Diagnostic[] {
            var diagnostics = this.fileNameToDiagnostics[fileName];
            return diagnostics || [];
        }

        public getBinder(): PullSymbolBinder {
            if (!this._binder) {
                this._binder = new PullSymbolBinder(this);
            }

            return this._binder;
        }

        public getResolver(): PullTypeResolver {
            if (!this._resolver) {
                this._resolver = new PullTypeResolver(this.compiler.compilationSettings(), this);
            }

            return this._resolver;
        }

        public addSyntheticIndexSignature(containingDecl: PullDecl, containingSymbol: PullTypeSymbol, ast: ISyntaxElement,
            indexParamName: string, indexParamType: PullTypeSymbol, returnType: PullTypeSymbol): void {

            var indexSignature = new PullSignatureSymbol(PullElementKind.IndexSignature, this);
            var indexParameterSymbol = new PullSymbol(indexParamName, PullElementKind.Parameter, this);
            indexParameterSymbol.type = indexParamType;
            indexSignature.addParameter(indexParameterSymbol);
            indexSignature.returnType = returnType;
            indexSignature.setResolved();
            indexParameterSymbol.setResolved();

            containingSymbol.addIndexSignature(indexSignature);

            var indexSigDecl = new PullSynthesizedDecl("", "", PullElementKind.IndexSignature, PullElementFlags.Signature, containingDecl);
            var indexParamDecl = new PullSynthesizedDecl(indexParamName, indexParamName, PullElementKind.Parameter, PullElementFlags.None, indexSigDecl);
            indexSigDecl.setSignatureSymbol(indexSignature, this);
            this.setSymbolForDecl(indexParamDecl, indexParameterSymbol);
            indexSignature.addDeclaration(indexSigDecl);
            indexParameterSymbol.addDeclaration(indexParamDecl);
        }

        public getDeclForAST(ast: ISyntaxElement): PullDecl {
            var document = this.getDocument(syntaxTree(ast).fileName());

            if (document) {
                return document._getDeclForAST(ast);
            }

            return null;
        }

        public getEnclosingDecl(ast: ISyntaxElement): PullDecl {
            return this.getDocument(syntaxTree(ast).fileName()).getEnclosingDecl(ast);
        }

        public setDeclForAST(ast: ISyntaxElement, decl: PullDecl): void {
            this.getDocument(decl.fileName())._setDeclForAST(ast, decl);
        }

        public getASTForDecl(decl: PullDecl): ISyntaxElement {
            var document = this.getDocument(decl.fileName());
            if (document) {
                return document._getASTForDecl(decl);
            }

            return null;
        }

        public setASTForDecl(decl: PullDecl, ast: ISyntaxElement): void {
            this.getDocument(decl.fileName())._setASTForDecl(decl, ast);
        }

        public topLevelDecl(fileName: string): PullDecl {
            var document = this.getDocument(fileName);
            if (document) {
                return document.topLevelDecl();
            }

            return null;
        }

        public topLevelDecls(): PullDecl[] {
            if (!this._topLevelDecls) {
                this._topLevelDecls = ArrayUtilities.select(this.documents, u => u.topLevelDecl());
            }

            return this._topLevelDecls;
        }

        public addDiagnosticFromAST(ast: ISyntaxElement, diagnosticKey: string, _arguments: any[] = null, additionalLocations: Location[] = null): void {
            this.addDiagnostic(this.diagnosticFromAST(ast, diagnosticKey, _arguments, additionalLocations));
        }

        public diagnosticFromAST(ast: ISyntaxElement, diagnosticKey: string, _arguments: any[] = null, additionalLocations: Location[] = null): Diagnostic {
            var syntaxTree = TypeScript.syntaxTree(ast);
            return new Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), start(ast), width(ast), diagnosticKey, _arguments, additionalLocations);
        }

        public diagnosticFromDecl(decl: PullDecl, diagnosticKey: string, _arguments: any[]= null, additionalLocations: Location[]= null): Diagnostic {
            return this.diagnosticFromAST(decl.ast(), diagnosticKey, _arguments, additionalLocations);
        }

        public locationFromAST(ast: ISyntaxElement): Location {
            var syntaxTree = TypeScript.syntaxTree(ast);
            return new Location(syntaxTree.fileName(), syntaxTree.lineMap(), start(ast), width(ast));
        }

        public duplicateIdentifierDiagnosticFromAST(ast: ISyntaxElement, identifier: string, additionalLocationAST: ISyntaxElement): Diagnostic {
            return this.diagnosticFromAST(ast, DiagnosticCode.Duplicate_identifier_0, [identifier],
                additionalLocationAST ? [this.locationFromAST(additionalLocationAST)] : null);
        }

        public addDuplicateIdentifierDiagnosticFromAST(ast: ISyntaxElement, identifier: string, additionalLocationAST: ISyntaxElement): void {
            this.addDiagnostic(this.duplicateIdentifierDiagnosticFromAST(ast, identifier, additionalLocationAST));
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {

    export class PullSymbolBinder {

        private declsBeingBound: number[] = [];
        private inBindingOtherDeclsWalker = new PullHelpers.OtherPullDeclsWalker();

        constructor(private semanticInfoChain: SemanticInfoChain) {
        }

        private getParent(decl: PullDecl, returnInstanceType = false): PullTypeSymbol {
            var parentDecl = decl.getParentDecl();

            if (parentDecl.kind === PullElementKind.Script) {
                return null;
            }

            var parent = parentDecl.getSymbol(this.semanticInfoChain);

            if (!parent && parentDecl && !parentDecl.hasBeenBound(this.semanticInfoChain)) {
                this.bindDeclToPullSymbol(parentDecl);
            }

            parent = parentDecl.getSymbol(this.semanticInfoChain);
            if (parent) {
                var parentDeclKind = parentDecl.kind;
                if (parentDeclKind === PullElementKind.GetAccessor) {
                    parent = (<PullAccessorSymbol>parent).getGetter();
                }
                else if (parentDeclKind === PullElementKind.SetAccessor) {
                    parent = (<PullAccessorSymbol>parent).getSetter();
                }
            }

            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = (<PullContainerSymbol>parent).getInstanceSymbol();

                    if (instanceSymbol) {
                        return instanceSymbol.type;
                    }
                }

                return parent.type;
            }

            return null;
        }

        private findDeclsInContext(startingDecl: PullDecl, declKind: PullElementKind, searchGlobally: boolean): PullDecl[] {

            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.name, declKind);
            }

            var contextSymbolPath = startingDecl.getParentPath();

            // next, link back up to the enclosing context
            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath: string[] = [];

                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].kind & PullElementKind.Script) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].name;
                }

                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }
        }

        // Called by all the bind methods when searching for existing symbols to reuse. Returns the symbol, or null if it does not exist.
        private getExistingSymbol(decl: PullDecl, searchKind: PullElementKind, parent: PullTypeSymbol): PullSymbol {
            var lookingForValue = (searchKind & PullElementKind.SomeValue) !== 0;
            var lookingForType = (searchKind & PullElementKind.SomeType) !== 0;
            var lookingForContainer = (searchKind & PullElementKind.SomeContainer) !== 0;
            var name = decl.name;
            if (parent) {
                var isExported = (decl.flags & PullElementFlags.Exported) !== 0;

                // First search for a nonmember
                var prevSymbol: PullSymbol = null;
                if (lookingForValue) {
                    prevSymbol = parent.findContainedNonMember(name);
                }
                else if (lookingForType) {
                    prevSymbol = parent.findContainedNonMemberType(name, searchKind);
                }
                else if (lookingForContainer) {
                    prevSymbol = parent.findContainedNonMemberContainer(name, searchKind);
                }
                var prevIsExported = !prevSymbol; // We didn't find it as a local, so it must be exported if it exists
                if (!prevSymbol) {
                    if (lookingForValue) {
                        prevSymbol = parent.findMember(name, /*lookInParent*/ false);
                    }
                    else if (lookingForType) {
                        prevSymbol = parent.findNestedType(name, searchKind);
                    }
                    else if (lookingForContainer) {
                        prevSymbol = parent.findNestedContainer(name, searchKind);
                    }
                }

                // If they are both exported, then they should definitely merge
                if (isExported && prevIsExported) {
                    return prevSymbol; // This could actually be null, but that is ok because it means we are not merging with anything
                }
                if (prevSymbol) {
                    // Check if they have the same parent (we use the LAST declaration to get the most positive answer on this)
                    var prevDecls = prevSymbol.getDeclarations();
                    var lastPrevDecl = prevDecls[prevDecls.length - 1];
                    var parentDecl = decl.getParentDecl();
                    var prevParentDecl = lastPrevDecl && lastPrevDecl.getParentDecl();
                    if (parentDecl !== prevParentDecl) {
                        // no merge
                        return null;
                    }

                    // They share the same parent, so merge them
                    return prevSymbol;
                }
            }
            else {
                var parentDecl = decl.getParentDecl();
                if (parentDecl && parentDecl.kind === PullElementKind.Script) {
                    return this.semanticInfoChain.findTopLevelSymbol(name, searchKind, decl);
                }
                else {
                    // The decl is in a control block (catch/with) that has no parent symbol. Luckily this type of parent can only have one decl.
                    var prevDecls = parentDecl && parentDecl.searchChildDecls(name, searchKind);
                    return prevDecls[0] && prevDecls[0].getSymbol(this.semanticInfoChain);
                }
            }

            // Did not find a symbol
            return null;
        }

        // Reports an error and returns false if exports do not match. Otherwise, returns true.
        private checkThatExportsMatch(decl: PullDecl, prevSymbol: PullSymbol, reportError = true): boolean {
            // Get export status of each (check against the last decl of the previous symbol)
            var isExported = (decl.flags & PullElementFlags.Exported) !== 0;
            var prevDecls = prevSymbol.getDeclarations();
            var prevIsExported = (prevDecls[prevDecls.length - 1].flags & PullElementFlags.Exported) !== 0;
            if ((isExported !== prevIsExported) && !prevSymbol.isSignature() && (decl.kind & PullElementKind.SomeSignature) === 0) {
                if (reportError) {
                    var ast = this.semanticInfoChain.getASTForDecl(decl);
                    this.semanticInfoChain.addDiagnosticFromAST(
                        ast, DiagnosticCode.All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported, [decl.getDisplayName()]);
                }
                return false;
            }

            return true;
        }

        private getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(signature: PullSignatureSymbol, currentSignatures: PullSignatureSymbol[]): number {
            var signatureDecl = signature.getDeclarations()[0];
            Debug.assert(signatureDecl);
            var enclosingDecl = signatureDecl.getParentDecl();
            var indexToInsert = ArrayUtilities.indexOf(currentSignatures, someSignature =>
                someSignature.getDeclarations()[0].getParentDecl() !== enclosingDecl);
            return indexToInsert < 0 ? currentSignatures.length : indexToInsert;
        }

        //
        // decl binding
        //

        private bindEnumDeclarationToPullSymbol(enumContainerDecl: PullDecl) {
            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var enumName = enumContainerDecl.name;

            var enumContainerSymbol: PullContainerSymbol = null;
            var enumInstanceSymbol: PullSymbol = null;
            var moduleInstanceTypeSymbol: PullTypeSymbol = null;

            var enumInstanceDecl: PullDecl = enumContainerDecl.getValueDecl();

            var enumDeclKind = enumContainerDecl.kind;

            var parent = this.getParent(enumContainerDecl);
            var parentInstanceSymbol = this.getParent(enumContainerDecl, true);
            var parentDecl = enumContainerDecl.getParentDecl();
            var enumAST = <EnumDeclarationSyntax>this.semanticInfoChain.getASTForDecl(enumContainerDecl);

            var isExported = enumContainerDecl.flags & PullElementFlags.Exported;

            var createdNewSymbol = false;

            enumContainerSymbol = <PullContainerSymbol>this.getExistingSymbol(enumContainerDecl, PullElementKind.Enum, parent);

            if (enumContainerSymbol) {
                if (enumContainerSymbol.kind !== enumDeclKind) {
                    // duplicate symbol error
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        enumAST.identifier, enumContainerDecl.getDisplayName(), enumContainerSymbol.getDeclarations()[0].ast());
                    enumContainerSymbol = null;
                }
                else if (!this.checkThatExportsMatch(enumContainerDecl, enumContainerSymbol)) {
                    enumContainerSymbol = null;
                }
            }

            if (enumContainerSymbol) {
                enumInstanceSymbol = enumContainerSymbol.getInstanceSymbol();
            }
            else {
                enumContainerSymbol = new PullContainerSymbol(enumName, enumDeclKind, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(enumContainerSymbol, PullElementKind.Enum);
                }
            }

            // We add the declaration early so that during any recursive binding of other module decls with the same name, this declaration is present.
            enumContainerSymbol.addDeclaration(enumContainerDecl);
            enumContainerDecl.setSymbol(enumContainerSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(enumAST.identifier, enumContainerSymbol);
            this.semanticInfoChain.setSymbolForAST(enumAST, enumContainerSymbol);

            if (!enumInstanceSymbol) {
                // search for a complementary instance symbol first
                var variableSymbol: PullSymbol = null;
                if (parentInstanceSymbol) {
                    if (isExported) {
                        // We search twice because export visibility does not need to agree
                        variableSymbol = parentInstanceSymbol.findMember(enumName, /*lookInParent*/ false);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);
                        }
                    }
                    else {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(enumName);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findMember(enumName, /*lookInParent*/ false);
                        }
                    }

                    if (variableSymbol) {
                        var declarations = variableSymbol.getDeclarations();

                        if (declarations.length) {
                            var variableSymbolParentDecl = declarations[0].getParentDecl();

                            if (parentDecl !== variableSymbolParentDecl) {
                                variableSymbol = null;
                            }
                        }
                    }
                }
                else if (!(enumContainerDecl.flags & PullElementFlags.Exported)) {
                    // Search locally to this file for a previous declaration that's suitable for augmentation
                    var siblingDecls = parentDecl.getChildDecls();
                    var augmentedDecl: PullDecl = null;

                    for (var i = 0; i < siblingDecls.length; i++) {
                        if (siblingDecls[i] === enumContainerDecl) {
                            break;
                        }

                        if ((siblingDecls[i].name === enumName) && (siblingDecls[i].kind & PullElementKind.SomeValue)) {
                            augmentedDecl = siblingDecls[i];
                            break;
                        }
                    }

                    if (augmentedDecl) {
                        variableSymbol = augmentedDecl.getSymbol(this.semanticInfoChain);

                        if (variableSymbol) {
                            if (variableSymbol.isContainer()) {
                                variableSymbol = (<PullContainerSymbol>variableSymbol).getInstanceSymbol();
                            }
                            else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = (<PullTypeSymbol>variableSymbol).getConstructorMethod();
                            }
                        }
                    }
                }

                // The instance symbol is further set up in bindVariableDeclaration
                if (variableSymbol) {
                    enumInstanceSymbol = variableSymbol;
                    moduleInstanceTypeSymbol = variableSymbol.type;
                }
                else {
                    enumInstanceSymbol = new PullSymbol(enumName, PullElementKind.Variable, this.semanticInfoChain);
                }

                enumContainerSymbol.setInstanceSymbol(enumInstanceSymbol);

                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new PullTypeSymbol("", PullElementKind.ObjectType, this.semanticInfoChain);
                    enumInstanceSymbol.type = moduleInstanceTypeSymbol;
                }

                moduleInstanceTypeSymbol.addDeclaration(enumContainerDecl);

                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(enumContainerSymbol);
                }
            }

            if (createdNewSymbol && parent) {
                if (enumContainerDecl.flags & PullElementFlags.Exported) {
                    parent.addEnclosedMemberType(enumContainerSymbol);
                }
                else {
                    parent.addEnclosedNonMemberType(enumContainerSymbol);
                }
            }

            if (createdNewSymbol) {
                // if the enum container was created, add in the index signature
                this.bindEnumIndexerDeclsToPullSymbols(enumContainerSymbol);
            }
            var valueDecl = enumContainerDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }
        }

        private bindEnumIndexerDeclsToPullSymbols(enumContainerSymbol: PullContainerSymbol): void {
            // Add synthetic index signature to the enum instance
            var enumContainerInstanceTypeSymbol = enumContainerSymbol.getInstanceSymbol().type;

            var syntheticIndexerParameterSymbol = new PullSymbol("x", PullElementKind.Parameter, this.semanticInfoChain);
            syntheticIndexerParameterSymbol.type = this.semanticInfoChain.numberTypeSymbol;
            syntheticIndexerParameterSymbol.setResolved();
            syntheticIndexerParameterSymbol.setIsSynthesized();

            var syntheticIndexerSignatureSymbol = new PullSignatureSymbol(PullElementKind.IndexSignature, this.semanticInfoChain);
            syntheticIndexerSignatureSymbol.addParameter(syntheticIndexerParameterSymbol);
            syntheticIndexerSignatureSymbol.returnType = this.semanticInfoChain.stringTypeSymbol;
            syntheticIndexerSignatureSymbol.setResolved();
            syntheticIndexerSignatureSymbol.setIsSynthesized();


            enumContainerInstanceTypeSymbol.addIndexSignature(syntheticIndexerSignatureSymbol);
        }

        private findExistingVariableSymbolForModuleValueDecl(decl: PullDecl): PullSymbol {
            var isExported = hasFlag(decl.flags, PullElementFlags.Exported);
            var modName = decl.name;
            var parentInstanceSymbol = this.getParent(decl, true);
            var parentDecl = decl.getParentDecl();

            var variableSymbol: PullSymbol = null;
            // search for a complementary instance symbol first
            if (parentInstanceSymbol) {
                if (isExported) {
                    // We search twice because export visibility does not need to agree
                    variableSymbol = parentInstanceSymbol.findMember(modName, /*lookInParent*/ false);

                    if (!variableSymbol) {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                    }
                }
                else {
                    variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);

                    if (!variableSymbol) {
                        variableSymbol = parentInstanceSymbol.findMember(modName, /*lookInParent*/ false);
                    }
                }

                // use currentModuleValueDecl to emphasise that we are merging value side of the module
                if (variableSymbol) {
                    var declarations = variableSymbol.getDeclarations();

                    if (declarations.length) {

                        var variableSymbolParentDecl = declarations[0].getParentDecl();
                        var isExportedOrHasTheSameParent = isExported || (parentDecl === variableSymbolParentDecl);
                        // previously defined variable symbol can be reused if 
                        // - current decl is either exported or has the same parent with the previosly defined symbol
                        // AND
                        // exports match for both current and previous decl
                        var canReuseVariableSymbol = isExportedOrHasTheSameParent && this.checkThatExportsMatch(decl, variableSymbol, false);

                        if (!canReuseVariableSymbol) {
                            variableSymbol = null;
                        }
                    }
                }
            }
            else if (!isExported) {
                // Search locally to this file for a declaration that's suitable for augmentation.
                // Note: we have to check all declarations because it may be hte case (due to
                // recursive binding), that a later module gets bound before us.  
                var siblingDecls = parentDecl.getChildDecls();

                for (var i = 0; i < siblingDecls.length; i++) {
                    var sibling = siblingDecls[i];

                    var siblingIsSomeValue = hasFlag(sibling.kind, PullElementKind.SomeValue);
                    var siblingIsFunctionOrHasImplictVarFlag =
                        hasFlag(sibling.kind, PullElementKind.SomeFunction) ||
                        hasFlag(sibling.flags, PullElementFlags.ImplicitVariable)

                        // We need to determine of this sibling is something this module definition can augment
                        // Augmentable items are: Function declarations, Classes (whos value decl is its constructor method), Enums
                        var isSiblingAnAugmentableVariable =
                        sibling !== decl &&
                        sibling !== decl.getValueDecl() &&
                        sibling.name === modName &&
                        siblingIsSomeValue &&
                        siblingIsFunctionOrHasImplictVarFlag;

                    if (isSiblingAnAugmentableVariable) {

                        // IMPORTANT: We don't want to just call sibling.getSymbol(this.semanticInfoChain) here.  
                        // That would force the sibling to get bound.  Something we don't want
                        // to do while binding ourselves (to avoid recursion issues).
                        if (sibling.hasSymbol(this.semanticInfoChain)) {
                            variableSymbol = sibling.getSymbol(this.semanticInfoChain);
                            if (variableSymbol.isContainer()) {
                                variableSymbol = (<PullContainerSymbol>variableSymbol).getInstanceSymbol();
                            }
                            else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = (<PullTypeSymbol>variableSymbol).getConstructorMethod();
                            }

                            break;
                        }
                    }
                }
            }
            return variableSymbol;
        }

        private bindModuleDeclarationToPullSymbol(moduleContainerDecl: PullDecl) {
            // 1. Test for existing symbol - if it exists, use its symbol
            // 2. If no other symbols exists, create a new symbol and use that one

            var modName = moduleContainerDecl.name;

            var moduleContainerTypeSymbol: PullContainerSymbol = null;
            var moduleKind = moduleContainerDecl.kind;

            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleNameAST = this.semanticInfoChain.getASTForDecl(moduleContainerDecl);
            var moduleDeclAST: ISyntaxElement = ASTHelpers.getEnclosingModuleDeclaration(moduleNameAST);

            if (!moduleDeclAST) {
                Debug.assert(moduleKind === PullElementKind.DynamicModule);
                Debug.assert(moduleNameAST.kind() === SyntaxKind.SourceUnit);
                // This is the module decl for the top level synthesized external module.
                moduleDeclAST = moduleNameAST;
            }

            var isExported = hasFlag(moduleContainerDecl.flags, PullElementFlags.Exported);
            var searchKind = PullElementKind.SomeContainer;
            var isInitializedModule = (moduleContainerDecl.flags & PullElementFlags.SomeInitializedModule) !== 0;

            if (parent && moduleKind === PullElementKind.DynamicModule) {
                // Dynamic modules cannot be parented
                this.semanticInfoChain.addDiagnosticFromAST(
                    moduleNameAST, DiagnosticCode.Ambient_external_module_declaration_must_be_defined_in_global_context, null);
            }

            var createdNewSymbol = false;

            moduleContainerTypeSymbol = <PullContainerSymbol>this.getExistingSymbol(moduleContainerDecl, searchKind, parent);

            if (moduleContainerTypeSymbol) {
                if (moduleContainerTypeSymbol.kind !== moduleKind) {
                    // duplicate symbol error
                    if (isInitializedModule) {
                        this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                            moduleNameAST, moduleContainerDecl.getDisplayName(), /*additionalLocation:*/ moduleContainerTypeSymbol.getDeclarations()[0].ast());
                    }

                    moduleContainerTypeSymbol = null;
                }
                else if (moduleKind === PullElementKind.DynamicModule) {
                    // Dynamic modules cannot be reopened.
                    this.semanticInfoChain.addDiagnosticFromAST(moduleNameAST, DiagnosticCode.Ambient_external_module_declaration_cannot_be_reopened);
                }
                else if (!this.checkThatExportsMatch(moduleContainerDecl, moduleContainerTypeSymbol)) {
                    moduleContainerTypeSymbol = null;
                }
            }

            if (!moduleContainerTypeSymbol) {
                moduleContainerTypeSymbol = new PullContainerSymbol(modName, moduleKind, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }

            // We add the declaration early so that during any recursive binding of other module decls with the same name, this declaration is present.
            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(moduleNameAST, moduleContainerTypeSymbol);
            this.semanticInfoChain.setSymbolForAST(moduleDeclAST, moduleContainerTypeSymbol);

            var currentModuleValueDecl = moduleContainerDecl.getValueDecl();

            // If we have an enum with more than one declaration, then this enum's first element
            // must have an initializer.
            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();

            if (createdNewSymbol) {
                if (parent) {
                    if (moduleContainerDecl.flags & PullElementFlags.Exported) {
                        parent.addEnclosedMemberContainer(moduleContainerTypeSymbol);
                    }
                    else {
                        parent.addEnclosedNonMemberContainer(moduleContainerTypeSymbol);
                    }
                }
            }

            // do not create symbol for the module instance upfront - in some cases it can be harmful.
            // var x: B.C; // 1
            // declare function B(): B.C;
            // declare module B {
            //   export class C {
            //   }
            //}
            // When binding B.C in line 1 we first will bind module B as container (*) ->then we'll bind value side of the module.
            // During binding of the value side will discover that there are 2 value declarations with name B in scope, one - function, another - value decl for the module.
            // Function will be bound first so when we start binding module value decl - we'll find existing symbol that correspond for function and reuse it.
            // If we create instance symbol at point (*) - it will never be used.
            // To avoid this problem we'll bind value decl first and then check if it has symbol - if yes - this symbol will be used as module instance symbol
            if (currentModuleValueDecl) {
                currentModuleValueDecl.ensureSymbolIsBound(this.semanticInfoChain);

                var instanceSymbol: PullSymbol = null;
                var instanceTypeSymbol: PullTypeSymbol = null;
                if (currentModuleValueDecl.hasSymbol(this.semanticInfoChain)) {
                    instanceSymbol = currentModuleValueDecl.getSymbol(this.semanticInfoChain);
                }
                else {
                    // We associate the value decl to the module instance symbol. This should have
                    // already been achieved by ensureSymbolIsBound, but if bindModuleDeclarationToPullSymbol
                    // was called recursively while in the middle of binding the value decl, the cycle
                    // will be short-circuited. With a more organized binding pattern, this situation
                    // shouldn't be possible.
                    instanceSymbol = new PullSymbol(modName, PullElementKind.Variable, this.semanticInfoChain);
                    currentModuleValueDecl.setSymbol(instanceSymbol, this.semanticInfoChain);
                    if (!instanceSymbol.hasDeclaration(currentModuleValueDecl)) {
                        instanceSymbol.addDeclaration(currentModuleValueDecl);
                    }
                }

                if (!instanceSymbol.type) {
                    instanceSymbol.type = new PullTypeSymbol("", PullElementKind.ObjectType, this.semanticInfoChain);
                }

                moduleContainerTypeSymbol.setInstanceSymbol(instanceSymbol);

                if (!instanceSymbol.type.getAssociatedContainerType()) {
                    instanceSymbol.type.setAssociatedContainerType(moduleContainerTypeSymbol);
                }

            }
        }

        // aliases
        private bindImportDeclaration(importDeclaration: PullDecl) {
            var declFlags = importDeclaration.flags;
            var declKind = importDeclaration.kind;
            var importDeclAST = <VariableDeclaratorSyntax>this.semanticInfoChain.getASTForDecl(importDeclaration);

            var isExported = false;
            var importSymbol: PullTypeAliasSymbol = null;
            var declName = importDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);

            importSymbol = <PullTypeAliasSymbol>this.getExistingSymbol(importDeclaration, PullElementKind.SomeContainer, parent);

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                    importDeclAST, importDeclaration.getDisplayName(), importSymbol.getDeclarations()[0].ast());
                importSymbol = null;
            }

            if (!importSymbol) {
                importSymbol = new PullTypeAliasSymbol(declName, this.semanticInfoChain);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, PullElementKind.SomeContainer);
                }
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(importDeclAST, importSymbol);

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addEnclosedMemberContainer(importSymbol);
                }
                else {
                    parent.addEnclosedNonMemberContainer(importSymbol);
                }
            }
        }

        // Preserves required binding order for a declaration with given name to prevent cases like:
        // module A { export module B { var x = 1} }
        // module A { export class B { c } }
        // Here if class declaration is bound before module declaration (i.e. because of IDE activities)
        // we won't report expected 'duplicate identifier' error for the class.
        private ensurePriorDeclarationsAreBound(container: PullSymbol, currentDecl: PullDecl) {
            if (!container) {
                return;
            }

            var parentDecls = container.getDeclarations();
            for (var i = 0; i < parentDecls.length; ++i) {
                var parentDecl = parentDecls[i];
                var childDecls = parentDecl.getChildDecls();
                for (var j = 0; j < childDecls.length; ++j) {

                    var childDecl = childDecls[j];
                    if (childDecl === currentDecl) {
                        return;
                    }

                    if (childDecl.name === currentDecl.name) {
                        childDecl.ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }
        }

        // classes
        private bindClassDeclarationToPullSymbol(classDecl: PullDecl) {

            var className = classDecl.name;
            var classSymbol: PullTypeSymbol = null;

            var constructorSymbol: PullSymbol = null;
            var constructorTypeSymbol: PullTypeSymbol = null;

            var classAST = <ClassDeclarationSyntax>this.semanticInfoChain.getASTForDecl(classDecl);

            var parent = this.getParent(classDecl);

            // TODO: we should in general get all the decls from the parent and bind all of them together,
            // but thats a major change and we should fix it without losing perf, so adding just a todo here.
            this.ensurePriorDeclarationsAreBound(parent, classDecl);

            var parentDecl = classDecl.getParentDecl();
            var isExported = classDecl.flags & PullElementFlags.Exported;
            var isGeneric = false;

            classSymbol = <PullTypeSymbol>this.getExistingSymbol(classDecl, PullElementKind.SomeType, parent);

            // Only error if it is an interface (for classes and enums we will error when we bind the implicit variable)
            if (classSymbol && classSymbol.kind === PullElementKind.Interface) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                    classAST.identifier, classDecl.getDisplayName(), classSymbol.getDeclarations()[0].ast());
                classSymbol = null;
            }

            classSymbol = new PullTypeSymbol(className, PullElementKind.Class, this.semanticInfoChain);

            if (!parent) {
                this.semanticInfoChain.cacheGlobalSymbol(classSymbol, PullElementKind.Class);
            }

            classSymbol.addDeclaration(classDecl);
            classDecl.setSymbol(classSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(classAST.identifier, classSymbol);
            this.semanticInfoChain.setSymbolForAST(classAST, classSymbol);

            if (parent) {
                if (classDecl.flags & PullElementFlags.Exported) {
                    parent.addEnclosedMemberType(classSymbol);
                }
                else {
                    parent.addEnclosedNonMemberType(classSymbol);
                }
            }

            var typeParameterDecls = classDecl.getTypeParameters();

            // PULLREVIEW: Now that we clean type parameters, searching is redundant
            for (var i = 0; i < typeParameterDecls.length; i++) {

                var typeParameterSymbol = classSymbol.findTypeParameter(typeParameterDecls[i].name);

                if (typeParameterSymbol) {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterSymbol.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameterSymbol.getName()]);
                }

                typeParameterSymbol = new PullTypeParameterSymbol(typeParameterDecls[i].name, this.semanticInfoChain);

                classSymbol.addTypeParameter(typeParameterSymbol);
                typeParameterSymbol.addDeclaration(typeParameterDecls[i]);
                typeParameterDecls[i].setSymbol(typeParameterSymbol, this.semanticInfoChain);
            }

            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = constructorSymbol ? constructorSymbol.type : null;

            if (!constructorSymbol) {
                // First, try to find a sibling value decl that is already bound. If there is one, reuse it.
                var siblingValueDecls: PullDecl[] = null;
                if (parentDecl) {
                    siblingValueDecls = parentDecl.searchChildDecls(className, PullElementKind.SomeValue);
                    // The first decl should have the right symbol
                    if (siblingValueDecls && siblingValueDecls[0] && siblingValueDecls[0].hasSymbol(this.semanticInfoChain)) {
                        constructorSymbol = siblingValueDecls[0].getSymbol(this.semanticInfoChain);
                    }
                }

                if (constructorSymbol) {
                    constructorTypeSymbol = constructorSymbol.type;
                }
                else {
                    constructorSymbol = new PullSymbol(className, PullElementKind.ConstructorMethod, this.semanticInfoChain);
                    constructorTypeSymbol = new PullTypeSymbol("", PullElementKind.ConstructorType, this.semanticInfoChain);
                    constructorSymbol.setIsSynthesized();
                    constructorSymbol.type = constructorTypeSymbol;
                }

                classSymbol.setConstructorMethod(constructorSymbol);
                classSymbol.setHasDefaultConstructor();
            }

            if (constructorSymbol.getIsSynthesized()) {
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                constructorTypeSymbol.addDeclaration(classDecl);
            }
            else {
                classSymbol.setHasDefaultConstructor(false);
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            var valueDecl = classDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }

            // Create the constructorTypeSymbol
            this.bindStaticPrototypePropertyOfClass(classAST, classSymbol, constructorTypeSymbol);
        }

        // interfaces
        private bindInterfaceDeclarationToPullSymbol(interfaceDecl: PullDecl) {

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
            var interfaceName = interfaceDecl.name;
            var interfaceSymbol: PullTypeSymbol = null;

            var interfaceAST = <InterfaceDeclarationSyntax>this.semanticInfoChain.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);

            // We're not yet ready to support interfaces augmenting classes (or vice versa)
            var acceptableSharedKind = PullElementKind.Interface; // | PullElementKind.Class | PullElementKind.Enum;

            interfaceSymbol = <PullTypeSymbol>this.getExistingSymbol(interfaceDecl, PullElementKind.SomeType, parent);

            if (interfaceSymbol) {
                if (!(interfaceSymbol.kind & acceptableSharedKind)) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        interfaceAST.identifier, interfaceDecl.getDisplayName(), interfaceSymbol.getDeclarations()[0].ast());
                    interfaceSymbol = null;
                }
                else if (!this.checkThatExportsMatch(interfaceDecl, interfaceSymbol)) {
                    interfaceSymbol = null;
                }
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new PullTypeSymbol(interfaceName, PullElementKind.Interface, this.semanticInfoChain);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol, this.semanticInfoChain);

            if (createdNewSymbol) {

                if (parent) {
                    if (interfaceDecl.flags & PullElementFlags.Exported) {
                        parent.addEnclosedMemberType(interfaceSymbol);
                    }
                    else {
                        parent.addEnclosedNonMemberType(interfaceSymbol);
                    }
                }
            }

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            // PULLREVIEW: Now that we clean type parameters, searching is redundant
            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    interfaceSymbol.addTypeParameter(typeParameter);
                }
                else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    // Because interface declarations can be "split", it's safe to re-use type parameters
                    // of the same name across interface declarations in the same binding phase
                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();

                        if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                            this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);

                            break;
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }
        }

        private bindObjectTypeDeclarationToPullSymbol(objectDecl: PullDecl) {
            var objectSymbolAST: ISyntaxElement = this.semanticInfoChain.getASTForDecl(objectDecl);

            var objectSymbol = new PullTypeSymbol("", PullElementKind.ObjectType, this.semanticInfoChain);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(objectSymbolAST, objectSymbol);

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
        }

        private bindConstructorTypeDeclarationToPullSymbol(constructorTypeDeclaration: PullDecl) {
            var declKind = constructorTypeDeclaration.kind;
            var declFlags = constructorTypeDeclaration.flags;
            var constructorTypeAST = this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);

            var constructorTypeSymbol = new PullTypeSymbol("", PullElementKind.ConstructorType, this.semanticInfoChain);

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol, this.semanticInfoChain);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);

            var signature = new PullSignatureSymbol(PullElementKind.ConstructSignature, this.semanticInfoChain);

            var funcDecl = <ConstructorTypeSyntax>this.semanticInfoChain.getASTForDecl(constructorTypeDeclaration);
            if (lastParameterIsRest(funcDecl.parameterList)) {
                signature.hasVarArgs = true;
            }

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameterList(funcDecl.parameterList), constructorTypeSymbol, signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            // add the implicit construct member for this function type
            constructorTypeSymbol.appendConstructSignature(signature);
        }

        // variables
        private bindVariableDeclarationToPullSymbol(variableDeclaration: PullDecl) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;

            var varDeclAST = this.semanticInfoChain.getASTForDecl(variableDeclaration);
            var nameAST = varDeclAST.kind() === SyntaxKind.ClassDeclaration
                ? (<ClassDeclarationSyntax>varDeclAST).identifier
                : varDeclAST.kind() === SyntaxKind.VariableDeclarator
                    ? (<VariableDeclaratorSyntax>varDeclAST).propertyName
                : varDeclAST.kind() === SyntaxKind.EnumDeclaration
                        ? (<EnumDeclarationSyntax>varDeclAST).identifier
                        : varDeclAST;

            var isExported = (declFlags & PullElementFlags.Exported) !== 0;

            var variableSymbol: PullSymbol = null;

            var declName = variableDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(variableDeclaration, true);

            var parentDecl = variableDeclaration.getParentDecl();

            var isImplicit = (declFlags & PullElementFlags.ImplicitVariable) !== 0;
            var isModuleValue = (declFlags & (PullElementFlags.InitializedModule)) !== 0;
            var isEnumValue = (declFlags & PullElementFlags.Enum) !== 0;
            var isClassConstructorVariable = (declFlags & PullElementFlags.ClassConstructorVariable) !== 0;
            variableSymbol = this.getExistingSymbol(variableDeclaration, PullElementKind.SomeValue, parent);

            if (!variableSymbol && isModuleValue) {
                variableSymbol = this.findExistingVariableSymbolForModuleValueDecl(variableDeclaration.getContainerDecl());
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var decl: PullDecl;
            var decls: PullDecl[];
            var ast: ISyntaxElement;
            var members: PullSymbol[];

            if (variableSymbol) {

                var prevKind = variableSymbol.kind;
                var prevIsEnum = variableSymbol.anyDeclHasFlag(PullElementFlags.Enum);
                var prevIsClassConstructorVariable = variableSymbol.anyDeclHasFlag(PullElementFlags.ClassConstructorVariable);
                var prevIsModuleValue = variableSymbol.allDeclsHaveFlag(PullElementFlags.InitializedModule);
                var prevIsImplicit = variableSymbol.anyDeclHasFlag(PullElementFlags.ImplicitVariable);
                var prevIsFunction = ArrayUtilities.any(variableSymbol.getDeclarations(), decl => decl.kind === PullElementKind.Function);
                var prevIsAmbient = variableSymbol.allDeclsHaveFlag(PullElementFlags.Ambient);
                var isAmbientOrPrevIsAmbient = prevIsAmbient || (variableDeclaration.flags & PullElementFlags.Ambient) !== 0;
                var prevDecl = variableSymbol.getDeclarations()[0];
                var prevParentDecl = prevDecl.getParentDecl();
                var bothAreGlobal = parentDecl && (parentDecl.kind === PullElementKind.Script) && (prevParentDecl.kind === PullElementKind.Script);
                var shareParent = bothAreGlobal || prevDecl.getParentDecl() === variableDeclaration.getParentDecl();
                var prevIsParam = shareParent && prevKind === PullElementKind.Parameter && declKind == PullElementKind.Variable;

                var acceptableRedeclaration = prevIsParam ||
                    (isImplicit &&
                    ((!isEnumValue && !isClassConstructorVariable && prevIsFunction) || // Enums can't mix with functions
                    ((isModuleValue || isEnumValue) && (prevIsModuleValue || prevIsEnum)) || // modules and enums can mix freely
                    (isClassConstructorVariable && prevIsModuleValue && isAmbientOrPrevIsAmbient) || // an ambient class can be declared after a module
                    (isModuleValue && prevIsClassConstructorVariable))); // the module variable can come after the class constructor variable

                // if the previous declaration is a non-ambient class, it must be located in the same file as this declaration
                if (acceptableRedeclaration && (prevIsClassConstructorVariable || prevIsFunction) && !isAmbientOrPrevIsAmbient) {
                    if (prevDecl.fileName() !== variableDeclaration.fileName()) {
                        this.semanticInfoChain.addDiagnostic(this.semanticInfoChain.diagnosticFromDecl(variableDeclaration,
                            DiagnosticCode.Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2, [declName, declName, prevDecl.fileName()]));
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    }
                }

                if (!acceptableRedeclaration || prevIsParam) {
                    // If neither of them are implicit (both explicitly declared as vars), we won't error now. We'll check that the types match during type check.
                    // However, we will error when a variable clobbers a function, or when the two explicit var declarations are not in the same parent declaration
                    if (!prevIsParam && (isImplicit || prevIsImplicit || hasFlag(prevKind, PullElementKind.SomeFunction)) || !shareParent) {
                        this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                            nameAST, variableDeclaration.getDisplayName(), variableSymbol.getDeclarations()[0].ast());
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                    }
                    else { // double var declaration (keep them separate so we can verify type sameness during type check)
                        this.checkThatExportsMatch(variableDeclaration, variableSymbol);
                        variableSymbol = null;
                        parentHadSymbol = false;
                    }
                }

                // If we haven't given an error so far and we merged two decls, check that the exports match
                // Only report the error if they are not both initialized modules (if they are, the bind module code would report the error)
                if (variableSymbol &&
                    !(variableSymbol.type && variableSymbol.type.isError()) &&
                    !this.checkThatExportsMatch(variableDeclaration, variableSymbol, !(isModuleValue && prevIsModuleValue))) {
                        variableSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(declName);
                }
            }

            if ((declFlags & PullElementFlags.ImplicitVariable) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);
                    if (!parent && parentDecl.kind === PullElementKind.Script) {
                        this.semanticInfoChain.cacheGlobalSymbol(variableSymbol, declKind);
                    }
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                this.semanticInfoChain.setSymbolForAST(nameAST, variableSymbol);
                this.semanticInfoChain.setSymbolForAST(varDeclAST, variableSymbol);
            }
            else if (!parentHadSymbol) {

                if (isClassConstructorVariable) {
                    // it's really an implicit class decl, so we need to set the type of the symbol to
                    // the constructor type
                    // Note that we would have already found the class symbol in the search above
                    var classTypeSymbol: PullTypeSymbol = <PullTypeSymbol>variableSymbol;

                    // PULLTODO: In both this case and the case below, we should have already received the
                    // class or module symbol as the variableSymbol found above
                    if (parent) {
                        members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].kind === PullElementKind.Class)) {
                                classTypeSymbol = <PullTypeSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        var containerDecl = variableDeclaration.getContainerDecl()
                        classTypeSymbol = <PullTypeSymbol>containerDecl.getSymbol(this.semanticInfoChain);
                        if (!classTypeSymbol) {
                            classTypeSymbol = <PullTypeSymbol>this.semanticInfoChain.findTopLevelSymbol(declName, PullElementKind.SomeType, variableDeclaration);
                        }
                    }

                    if (classTypeSymbol && (classTypeSymbol.kind !== PullElementKind.Class)) {
                        classTypeSymbol = null;
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) { // protect against duplicate declarations
                        //replaceProperty = variableSymbol && variableSymbol.getIsSynthesized();

                        //if (replaceProperty) {
                        //    previousProperty = variableSymbol;
                        //}

                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                        // set the ISyntaxElement to the constructor method's if possible
                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {

                            decl = decls[decls.length - 1];
                            ast = this.semanticInfoChain.getASTForDecl(decl);
                        }
                    }
                    else {
                        // PULLTODO: Clodules/Interfaces on classes
                        if (!variableSymbol) {
                            variableSymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

                        variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                else if (declFlags & PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol: PullContainerSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = <PullContainerSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        var containerDecl = variableDeclaration.getContainerDecl();
                        moduleContainerTypeSymbol = <PullContainerSymbol>containerDecl.getSymbol(this.semanticInfoChain);
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = <PullContainerSymbol>this.semanticInfoChain.findTopLevelSymbol(declName, PullElementKind.SomeContainer, variableDeclaration);

                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = <PullContainerSymbol>this.semanticInfoChain.findTopLevelSymbol(declName, PullElementKind.Enum, variableDeclaration);
                            }
                        }
                    }

                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
                        if (!variableSymbol) {
                            variableSymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);
                            variableSymbol.type = new PullTypeSymbol("", PullElementKind.ObjectType, this.semanticInfoChain);
                        }
                        // If this method calls bindModuleDeclarationToPullSymbol recursively,
                        // we may associate the variable decl with its symbol in that recursive
                        // call before we do it here. Therefore, make sure the symbol doesn't already
                        // have the decl before adding it. Just like in bindModuleDeclarationToPullSymbol,
                        // we shouldn't need this maneuver with a more iterative binding pattern.
                        if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                            variableSymbol.addDeclaration(variableDeclaration);
                        }
                        variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);
                    }
                    else {
                        Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            }
            else {
                if (!variableSymbol.hasDeclaration(variableDeclaration)) {
                    variableSymbol.addDeclaration(variableDeclaration);
                }
                variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);
            }

            var containerDecl = variableDeclaration.getContainerDecl();
            if (variableSymbol && variableSymbol.type && containerDecl && !variableSymbol.type.hasDeclaration(containerDecl)) {
                variableSymbol.type.addDeclaration(containerDecl)
            }

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addMember(variableSymbol);
                }
                else {
                    parent.addEnclosedNonMember(variableSymbol);
                }
            }
        }

        private bindCatchVariableToPullSymbol(variableDeclaration: PullDecl) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var identifier = <ISyntaxToken>this.semanticInfoChain.getASTForDecl(variableDeclaration);

            var declName = variableDeclaration.name;

            var variableSymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);

            variableSymbol.addDeclaration(variableDeclaration);
            variableDeclaration.setSymbol(variableSymbol, this.semanticInfoChain);

            // Catch variable are of type 'any'.  So we don't need to actually resolve anything later.
            variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;

            this.semanticInfoChain.setSymbolForAST(identifier, variableSymbol);
        }

        // properties
        private bindEnumMemberDeclarationToPullSymbol(propertyDeclaration: PullDecl) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var propDeclAST = <EnumElementSyntax>this.semanticInfoChain.getASTForDecl(propertyDeclaration);

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            var propertySymbol = parent.findMember(declName, /*lookInParent*/ false);

            if (propertySymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                    propDeclAST.propertyName, propertyDeclaration.getDisplayName(), propertySymbol.getDeclarations()[0].ast());
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            if (!parentHadSymbol) {
                propertySymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(propDeclAST.propertyName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(propDeclAST, propertySymbol);

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        }

        private bindPropertyDeclarationToPullSymbol(propertyDeclaration: PullDecl) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;

            var ast = this.semanticInfoChain.getASTForDecl(propertyDeclaration);
            var astName = ast.kind() === SyntaxKind.MemberVariableDeclaration
                ? (<MemberVariableDeclarationSyntax>ast).variableDeclarator.propertyName
                : ast.kind() === SyntaxKind.PropertySignature
                    ? (<PropertySignatureSyntax>ast).propertyName
                    : ast.kind() === SyntaxKind.Parameter
                        ? (<ParameterSyntax>ast).identifier
                        : (<VariableDeclaratorSyntax>ast).propertyName;

            var isStatic = false;
            var isOptional = false;

            var propertySymbol: PullSymbol = null;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            if (hasFlag(declFlags, PullElementFlags.Optional)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            propertySymbol = parent.findMember(declName, /*lookInParent*/ false);

            if (propertySymbol) {
                this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                    astName, propertyDeclaration.getDisplayName(), propertySymbol.getDeclarations()[0].ast());
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            var classTypeSymbol: PullTypeSymbol;

            if (!parentHadSymbol) {
                propertySymbol = new PullSymbol(declName, declKind, this.semanticInfoChain);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol, this.semanticInfoChain);

            this.semanticInfoChain.setSymbolForAST(astName, propertySymbol);
            this.semanticInfoChain.setSymbolForAST(ast, propertySymbol);

            if (isOptional) {
                propertySymbol.isOptional = true;
            }

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        }

        // parameters
        private bindParameterSymbols(functionDeclaration: ISyntaxElement, parameterList: IParameters, funcType: PullTypeSymbol, signatureSymbol: PullSignatureSymbol) {
            // create a symbol for each ast
            // if it's a property, add the symbol to the enclosing type's member list
            var parameters: PullSymbol[] = [];
            var params = createIntrinsicsObject<boolean>();
            var funcDecl = this.semanticInfoChain.getDeclForAST(functionDeclaration);

            if (parameterList) {
                for (var i = 0, n = parameterList.length; i < n; i++) {
                    var argDecl = parameterList.astAt(i);
                    var id = parameterList.identifierAt(i);
                    var decl = this.semanticInfoChain.getDeclForAST(argDecl);
                    var isProperty = hasFlag(decl.flags, PullElementFlags.PropertyParameter);
                    var parameterSymbol = new PullSymbol(tokenValueText(id), PullElementKind.Parameter, this.semanticInfoChain);

                    if ((i === (n - 1)) && parameterList.lastParameterIsRest()) {
                        parameterSymbol.isVarArg = true;
                    }

                    if (params[tokenValueText(id)]) {
                        this.semanticInfoChain.addDiagnosticFromAST(argDecl, DiagnosticCode.Duplicate_identifier_0, [id.text()]);
                    }
                    else {
                        params[tokenValueText(id)] = true;
                    }

                    if (decl) {
                        var isParameterOptional = false;

                        if (isProperty) {
                            decl.ensureSymbolIsBound(this.semanticInfoChain);
                            var valDecl = decl.getValueDecl();

                            // if this is a parameter property, we still need to set the value decl
                            // for the function parameter
                            if (valDecl) {
                                isParameterOptional = TypeScript.hasFlag(valDecl.flags, PullElementFlags.Optional);

                                valDecl.setSymbol(parameterSymbol, this.semanticInfoChain);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        }
                        else {
                            isParameterOptional = TypeScript.hasFlag(decl.flags, PullElementFlags.Optional);

                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol, this.semanticInfoChain);
                        }

                        parameterSymbol.isOptional = isParameterOptional;
                    }

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.isOptional);

                    if (signatureSymbol.isDefinition()) {
                        funcType.addEnclosedNonMember(parameterSymbol);
                    }
                }
            }
        }

        // function declarations
        private bindFunctionDeclarationToPullSymbol(functionDeclaration: PullDecl) {
            var declKind = functionDeclaration.kind;
            var declFlags = functionDeclaration.flags;
            var funcDeclAST = <FunctionDeclarationSyntax>this.semanticInfoChain.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) !== 0;

            var funcName = functionDeclaration.name;

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;

            var parent = this.getParent(functionDeclaration, true);

            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;

            // PULLREVIEW: On a re-bind, there's no need to search far-and-wide: just look in the parent's member list
            var functionSymbol: PullSymbol = null;
            var functionTypeSymbol: PullTypeSymbol = null;

            functionSymbol = this.getExistingSymbol(functionDeclaration, PullElementKind.SomeValue, parent);

            if (functionSymbol) {
                // SPEC: Nov 18
                // When merging a non-ambient function or class declaration and a non-ambient internal module declaration, 
                // the function or class declaration must be located prior to the internal module declaration in the same source file. 
                // => when any of components is ambient - order doesn't matter                
                var acceptableRedeclaration: boolean;
                
                // Duplicate is acceptable if it is another signature (not a duplicate implementation), or an ambient fundule
                if (functionSymbol.kind === PullElementKind.Function) {
                    // normal fundule - we are allowed to add overloads
                    acceptableRedeclaration = isSignature || functionSymbol.allDeclsHaveFlag(PullElementFlags.Signature);
                }
                else {
                    // check if this is ambient fundule?
                    var isCurrentDeclAmbient = hasFlag(functionDeclaration.flags, PullElementFlags.Ambient);
                    acceptableRedeclaration = ArrayUtilities.all(functionSymbol.getDeclarations(), (decl) => {
                        // allowed elements for ambient fundules
                        // - signatures
                        // - initialized modules that can be ambient or not depending on whether current decl is ambient                       
                        var isInitializedModuleOrAmbientDecl = hasFlag(decl.flags, PullElementFlags.InitializedModule) && (isCurrentDeclAmbient || hasFlag(decl.flags, PullElementFlags.Ambient));
                        var isSignature = hasFlag(decl.flags, PullElementFlags.Signature);
                        return isInitializedModuleOrAmbientDecl || isSignature;
                    });
                }

                if (!acceptableRedeclaration) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        funcDeclAST.identifier, functionDeclaration.getDisplayName(), functionSymbol.getDeclarations()[0].ast());
                    functionSymbol.type = this.semanticInfoChain.getResolver().getNewErrorTypeSymbol(funcName);
                }
            }

            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.type;
                parentHadSymbol = true;
            }

            if (!functionSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                functionSymbol = new PullSymbol(funcName, PullElementKind.Function, this.semanticInfoChain);
            }

            if (!functionTypeSymbol) {
                functionTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
                functionSymbol.type = functionTypeSymbol;
                functionTypeSymbol.setFunctionSymbol(functionSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol, this.semanticInfoChain);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfoChain.setSymbolForAST(funcDeclAST.identifier, functionSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, functionSymbol);

            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol);
                }
                else {
                    parent.addEnclosedNonMember(functionSymbol);
                }
            }

            var signature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            if (lastParameterIsRest(funcDeclAST.callSignature.parameterList)) {
                signature.hasVarArgs = true;
            }

            var funcDecl = <FunctionDeclarationSyntax>this.semanticInfoChain.getASTForDecl(functionDeclaration);
            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList), functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            // add the implicit call member for this function type
            functionTypeSymbol.appendCallSignature(signature);
        }

        private bindFunctionExpressionToPullSymbol(functionExpressionDeclaration: PullDecl) {
            var declKind = functionExpressionDeclaration.kind;
            var declFlags = functionExpressionDeclaration.flags;
            var ast = this.semanticInfoChain.getASTForDecl(functionExpressionDeclaration);

            var parameters = ast.kind() === SyntaxKind.SimpleArrowFunctionExpression
                ? ASTHelpers.parametersFromIdentifier((<SimpleArrowFunctionExpressionSyntax>ast).identifier)
                : ASTHelpers.parametersFromParameterList(ASTHelpers.getParameterList(ast));
            var funcExpAST = ast;

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionName = declKind === PullElementKind.FunctionExpression
                ? (<PullFunctionExpressionDecl>functionExpressionDeclaration).getFunctionExpressionName()
                : functionExpressionDeclaration.name;
            var functionSymbol: PullSymbol = new PullSymbol(functionName, declKind, this.semanticInfoChain);
            var functionTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
            functionTypeSymbol.setFunctionSymbol(functionSymbol);

            functionSymbol.type = functionTypeSymbol;

            functionExpressionDeclaration.setSymbol(functionSymbol, this.semanticInfoChain);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);

            var name = funcExpAST.kind() === SyntaxKind.FunctionExpression
                ? (<FunctionExpressionSyntax>funcExpAST).identifier
                : funcExpAST.kind() === SyntaxKind.FunctionPropertyAssignment
                    ? (<FunctionPropertyAssignmentSyntax>funcExpAST).propertyName
                    : null;
            if (name) {
                this.semanticInfoChain.setSymbolForAST(name, functionSymbol);
            }

            this.semanticInfoChain.setSymbolForAST(funcExpAST, functionSymbol);

            var signature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain, /*isDefinition*/ true);

            if (parameters.lastParameterIsRest()) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcExpAST, parameters, functionTypeSymbol, signature);

            // add the implicit call member for this function type
            functionTypeSymbol.appendCallSignature(signature);
        }

        private bindFunctionTypeDeclarationToPullSymbol(functionTypeDeclaration: PullDecl) {
            var declKind = functionTypeDeclaration.kind;
            var declFlags = functionTypeDeclaration.flags;
            var funcTypeAST = <FunctionTypeSyntax>this.semanticInfoChain.getASTForDecl(functionTypeDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);

            functionTypeDeclaration.setSymbol(functionTypeSymbol, this.semanticInfoChain);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfoChain.setSymbolForAST(funcTypeAST, functionTypeSymbol);

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;
            var signature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain, !isSignature);

            if (lastParameterIsRest(funcTypeAST.parameterList)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcTypeAST, ASTHelpers.parametersFromParameterList(funcTypeAST.parameterList), functionTypeSymbol, signature);

            // add the implicit call member for this function type
            functionTypeSymbol.appendCallSignature(signature);
        }

        // method declarations
        private bindMethodDeclarationToPullSymbol(methodDeclaration: PullDecl) {
            var declKind = methodDeclaration.kind;
            var declFlags = methodDeclaration.flags;
            var methodAST = this.semanticInfoChain.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & PullElementFlags.Private) !== 0;
            var isStatic = (declFlags & PullElementFlags.Static) !== 0;
            var isOptional = (declFlags & PullElementFlags.Optional) !== 0;

            var methodName = methodDeclaration.name;

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;

            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;

            var methodSymbol: PullSymbol = null;
            var methodTypeSymbol: PullTypeSymbol = null;

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            methodSymbol = parent.findMember(methodName, /*lookInParent*/ false);

            if (methodSymbol &&
                (methodSymbol.kind !== PullElementKind.Method ||
                (!isSignature && !methodSymbol.allDeclsHaveFlag(PullElementFlags.Signature)))) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        methodAST, methodDeclaration.getDisplayName(), methodSymbol.getDeclarations()[0].ast());
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.type;
                parentHadSymbol = true;
            }

            if (!methodSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                methodSymbol = new PullSymbol(methodName, PullElementKind.Method, this.semanticInfoChain);
            }

            if (!methodTypeSymbol) {
                methodTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
                methodSymbol.type = methodTypeSymbol;
                methodTypeSymbol.setFunctionSymbol(methodSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol, this.semanticInfoChain);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);

            var nameAST = methodAST.kind() === SyntaxKind.MemberFunctionDeclaration
                ? (<MemberFunctionDeclarationSyntax>methodAST).propertyName
                : (<MethodSignatureSyntax>methodAST).propertyName;

            Debug.assert(nameAST)

            this.semanticInfoChain.setSymbolForAST(nameAST, methodSymbol);
            this.semanticInfoChain.setSymbolForAST(methodAST, methodSymbol);

            if (isOptional) {
                methodSymbol.isOptional = true;
            }

            if (!parentHadSymbol) {
                parent.addMember(methodSymbol);
            }

            var sigKind = PullElementKind.CallSignature;

            var signature = new PullSignatureSymbol(sigKind, this.semanticInfoChain, !isSignature);

            var parameterList = ASTHelpers.getParameterList(methodAST);
            if (lastParameterIsRest(parameterList)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterName: string;
            var typeParameterAST: TypeParameterSyntax;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].name;
                typeParameterAST = <TypeParameterSyntax>this.semanticInfoChain.getASTForDecl(typeParameters[i]);

                typeParameter = signature.findTypeParameter(typeParameterName);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameterName, this.semanticInfoChain);
                    signature.addTypeParameter(typeParameter);
                }
                else {
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(methodDeclaration);
            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameterList(ASTHelpers.getParameterList(funcDecl)), methodTypeSymbol, signature);

            // add the implicit call member for this function type
            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(signature, methodTypeSymbol.getOwnCallSignatures());
            methodTypeSymbol.insertCallSignatureAtIndex(signature, signatureIndex);
        }

        private bindStaticPrototypePropertyOfClass(classAST: ClassDeclarationSyntax, classTypeSymbol: PullTypeSymbol, constructorTypeSymbol: PullTypeSymbol) {
            var prototypeStr = "prototype";

            var prototypeSymbol = constructorTypeSymbol.findMember(prototypeStr, /*lookInParent*/ false);
            if (prototypeSymbol && !prototypeSymbol.getIsSynthesized()) {
                // Report duplicate symbol error on existing prototype symbol since class has explicit prototype symbol
                // This kind of scenario can happen with augmented module and class with module member named prototype
                this.semanticInfoChain.addDiagnostic(
                    this.semanticInfoChain.diagnosticFromDecl(prototypeSymbol.getDeclarations()[0], DiagnosticCode.Duplicate_identifier_0, [prototypeSymbol.getDisplayName()]));
            }

            // Add synthetic prototype decl and symbol
            if (!prototypeSymbol || !prototypeSymbol.getIsSynthesized()) {
                var prototypeDecl = new PullSynthesizedDecl(prototypeStr, prototypeStr, PullElementKind.Property,
                    PullElementFlags.Public | PullElementFlags.Static, constructorTypeSymbol.getDeclarations()[0]);

                prototypeSymbol = new PullSymbol(prototypeStr, PullElementKind.Property, this.semanticInfoChain);
                prototypeSymbol.setIsSynthesized();
                prototypeSymbol.addDeclaration(prototypeDecl);
                prototypeSymbol.type = classTypeSymbol;
                constructorTypeSymbol.addMember(prototypeSymbol);

                if (prototypeSymbol.type && prototypeSymbol.type.isGeneric()) {
                    var resolver = this.semanticInfoChain.getResolver();
                    prototypeSymbol.type = resolver.instantiateTypeToAny(prototypeSymbol.type, new PullTypeResolutionContext(resolver));
                }
                prototypeSymbol.setResolved();
            }
        }

        // class constructor declarations
        private bindConstructorDeclarationToPullSymbol(constructorDeclaration: PullDecl) {
            var declKind = constructorDeclaration.kind;
            var declFlags = constructorDeclaration.flags;
            var constructorAST = <ConstructorDeclarationSyntax>this.semanticInfoChain.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.name;

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;

            var parent = this.getParent(constructorDeclaration, true);

            var parentHadSymbol = false;

            var constructorSymbol: PullSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol: PullTypeSymbol = null;

            if (constructorSymbol &&
                (constructorSymbol.kind !== PullElementKind.ConstructorMethod ||
                (!isSignature &&
                constructorSymbol.type &&
                constructorSymbol.type.hasOwnConstructSignatures()))) {

                var hasDefinitionSignature = false;
                var constructorSigs = constructorSymbol.type.getOwnDeclaredConstructSignatures();

                for (var i = 0; i < constructorSigs.length; i++) {
                    if (!constructorSigs[i].anyDeclHasFlag(PullElementFlags.Signature)) {
                        hasDefinitionSignature = true;
                        break;
                    }
                }

                if (hasDefinitionSignature) {
                    this.semanticInfoChain.addDiagnosticFromAST(constructorAST, DiagnosticCode.Multiple_constructor_implementations_are_not_allowed);

                    constructorSymbol = null;
                }
            }

            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.type;
            }
            else {
                constructorSymbol = new PullSymbol(constructorName, PullElementKind.ConstructorMethod, this.semanticInfoChain);
                constructorTypeSymbol = new PullTypeSymbol("", PullElementKind.ConstructorType, this.semanticInfoChain);
            }

            // Even if we're reusing the symbol, it would have been cleared by the call to invalidate above
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.type = constructorTypeSymbol;

            constructorDeclaration.setSymbol(constructorSymbol, this.semanticInfoChain);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            constructorSymbol.setIsSynthesized(false);
            this.semanticInfoChain.setSymbolForAST(constructorAST, constructorSymbol);

            // add a call signature to the constructor method, and a construct signature to the parent class type
            var constructSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature, this.semanticInfoChain, !isSignature);
            constructSignature.returnType = parent;
            constructSignature.addTypeParametersFromReturnType();

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature, this.semanticInfoChain);

            this.bindParameterSymbols(constructorAST, ASTHelpers.parametersFromParameterList(constructorAST.callSignature.parameterList), constructorTypeSymbol, constructSignature);

            if (lastParameterIsRest(constructorAST.callSignature.parameterList)) {
                constructSignature.hasVarArgs = true;
            }

            constructorTypeSymbol.appendConstructSignature(constructSignature);

        }

        private bindConstructSignatureDeclarationToPullSymbol(constructSignatureDeclaration: PullDecl) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = <ConstructSignatureSyntax>this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);

            var constructSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature, this.semanticInfoChain);

            if (lastParameterIsRest(constructorAST.callSignature.parameterList)) {
                constructSignature.hasVarArgs = true;
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = constructSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    constructSignature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature, this.semanticInfoChain);

            var funcDecl = this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameterList(ASTHelpers.getParameterList(funcDecl)), null, constructSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(constructSignatureDeclaration), constructSignature);

            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(constructSignature, parent.getOwnDeclaredConstructSignatures());
            parent.insertConstructSignatureAtIndex(constructSignature, signatureIndex);
        }

        private bindCallSignatureDeclarationToPullSymbol(callSignatureDeclaration: PullDecl) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = <CallSignatureSyntax>this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);

            var callSignature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain);

            if (lastParameterIsRest(callSignatureAST.parameterList)) {
                callSignature.hasVarArgs = true;
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = callSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].name, this.semanticInfoChain);

                    callSignature.addTypeParameter(typeParameter);
                }
                else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]);
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter, this.semanticInfoChain);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature, this.semanticInfoChain);

            var funcDecl = <CallSignatureSyntax>this.semanticInfoChain.getASTForDecl(callSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameterList(funcDecl.parameterList), null, callSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(callSignatureDeclaration), callSignature);

            var signatureIndex = this.getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(callSignature, parent.getOwnCallSignatures());
            parent.insertCallSignatureAtIndex(callSignature, signatureIndex);
        }

        private bindIndexSignatureDeclarationToPullSymbol(indexSignatureDeclaration: PullDecl) {
            var indexSignature = new PullSignatureSymbol(PullElementKind.IndexSignature, this.semanticInfoChain);

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature, this.semanticInfoChain);

            var funcDecl = <IndexSignatureSyntax>this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration);
            this.bindParameterSymbols(funcDecl, ASTHelpers.parametersFromParameter(funcDecl.parameter), null, indexSignature);

            this.semanticInfoChain.setSymbolForAST(this.semanticInfoChain.getASTForDecl(indexSignatureDeclaration), indexSignature);

            var parent = this.getParent(indexSignatureDeclaration);
            parent.addIndexSignature(indexSignature);
            indexSignature.setContainer(parent);
        }

        // getters and setters
        private bindGetAccessorDeclarationToPullSymbol(getAccessorDeclaration: PullDecl) {
            var declKind = getAccessorDeclaration.kind;
            var declFlags = getAccessorDeclaration.flags;
            var funcDeclAST = <GetAccessorSyntax>this.semanticInfoChain.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) !== 0;

            var funcName = getAccessorDeclaration.name;

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;
            var isStatic = false;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol: PullAccessorSymbol = null;
            var getterSymbol: PullSymbol = null;
            var getterTypeSymbol: PullTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = <PullAccessorSymbol>parent.findMember(funcName, /*lookInParent*/ false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        funcDeclAST.propertyName, getAccessorDeclaration.getDisplayName(), accessorSymbol.getDeclarations()[0].ast());
                    accessorSymbol = null;
                }
                else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, DiagnosticCode.Getter_0_already_declared, [getAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            // we have an accessor we can use...
            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.type;
            }

            if (!accessorSymbol) {
                accessorSymbol = new PullAccessorSymbol(funcName, this.semanticInfoChain);
            }

            if (!getterSymbol) {
                getterSymbol = new PullSymbol(funcName, PullElementKind.Function, this.semanticInfoChain);
                getterTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
                getterTypeSymbol.setFunctionSymbol(getterSymbol);

                getterSymbol.type = getterTypeSymbol;

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol, this.semanticInfoChain);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            // Note that the name ISyntaxElement binds to the full accessor symbol, whereas the declaration ISyntaxElement
            // binds to just the getter symbol. This is because when the resolver resolves an
            // accessor declaration ISyntaxElement, it just expects the getter/setter symbol. But when
            // the language service looks up the name of an accessor, it should treat it as a
            // property and display it to the user as such.
            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, getterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            this.bindParameterSymbols(funcDeclAST, ASTHelpers.parametersFromParameterList(funcDeclAST.parameterList), getterTypeSymbol, signature);

            // add the implicit call member for this function type
            getterTypeSymbol.appendCallSignature(signature);
        }

        private bindSetAccessorDeclarationToPullSymbol(setAccessorDeclaration: PullDecl) {
            var declKind = setAccessorDeclaration.kind;
            var declFlags = setAccessorDeclaration.flags;
            var funcDeclAST = <SetAccessorSyntax>this.semanticInfoChain.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) !== 0;

            var funcName = setAccessorDeclaration.name;

            var isSignature: boolean = (declFlags & PullElementFlags.Signature) !== 0;
            var isStatic = false;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol: PullAccessorSymbol = null;
            var setterSymbol: PullSymbol = null;
            var setterTypeSymbol: PullTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = <PullAccessorSymbol>parent.findMember(funcName, /*lookInParent*/ false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfoChain.addDuplicateIdentifierDiagnosticFromAST(
                        funcDeclAST.propertyName, setAccessorDeclaration.getDisplayName(), accessorSymbol.getDeclarations()[0].ast());
                    accessorSymbol = null;
                }
                else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(funcDeclAST, DiagnosticCode.Setter_0_already_declared, [setAccessorDeclaration.getDisplayName()]);
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
                // we have an accessor we can use...
                if (setterSymbol) {
                    setterTypeSymbol = setterSymbol.type;
                }
            }

            if (!accessorSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                accessorSymbol = new PullAccessorSymbol(funcName, this.semanticInfoChain);
            }

            if (!setterSymbol) {
                setterSymbol = new PullSymbol(funcName, PullElementKind.Function, this.semanticInfoChain);
                setterTypeSymbol = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
                setterTypeSymbol.setFunctionSymbol(setterSymbol);

                setterSymbol.type = setterTypeSymbol;

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol, this.semanticInfoChain);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            // Note that the name ISyntaxElement binds to the full accessor symbol, whereas the declaration ISyntaxElement
            // binds to just the setter symbol. This is because when the resolver resolves an
            // accessor declaration ISyntaxElement, it just expects the getter/setter symbol. But when
            // the language service looks up the name of an accessor, it should treat it as a
            // property and display it to the user as such.

            var nameAST = funcDeclAST.propertyName;
            this.semanticInfoChain.setSymbolForAST(nameAST, accessorSymbol);
            this.semanticInfoChain.setSymbolForAST(funcDeclAST, setterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = new PullSignatureSymbol(PullElementKind.CallSignature, this.semanticInfoChain, !isSignature);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature, this.semanticInfoChain);

            // PULLTODO: setter should not have a parameters
            this.bindParameterSymbols(funcDeclAST, ASTHelpers.parametersFromParameterList(funcDeclAST.parameterList), setterTypeSymbol, signature);

            // add the implicit call member for this function type
            setterTypeSymbol.appendCallSignature(signature);
        }

        private getDeclsToBind(decl: PullDecl) {
            var decls: PullDecl[];
            switch (decl.kind) {
                case PullElementKind.Enum:
                case PullElementKind.DynamicModule:
                case PullElementKind.Container:
                case PullElementKind.Interface:
                    decls = this.findDeclsInContext(decl, decl.kind, /*searchGlobally*/ true);
                    break;

                case PullElementKind.Variable:
                case PullElementKind.Function:
                case PullElementKind.Method:
                case PullElementKind.ConstructorMethod:
                    decls = this.findDeclsInContext(decl, decl.kind, /*searchGlobally*/ false);
                    break;

                default:
                    decls = [decl];
            }
            Debug.assert(decls && decls.length > 0);
            Debug.assert(ArrayUtilities.contains(decls, decl));
            return decls;
        }

        private shouldBindDeclaration(decl: PullDecl) {
            return !decl.hasBeenBound(this.semanticInfoChain) && this.declsBeingBound.indexOf(decl.declID) < 0;
        }

        // binding
        public bindDeclToPullSymbol(decl: PullDecl) {
            if (this.shouldBindDeclaration(decl)) {
                // The decl does not have a symbol attached to it and
                // its not already being bound
                this.bindAllDeclsToPullSymbol(decl);
            }
        }

        private bindAllDeclsToPullSymbol(askedDecl: PullDecl) {
            var allDecls = this.getDeclsToBind(askedDecl);
            for (var i = 0; i < allDecls.length; i++) {
                var decl = allDecls[i];
                // This check is necessary for two reasons
                // 1. This decl could be actually something we dont care to bind other decls corresponding to it 
                //    and so it was already bound without binding other decls with same name corresponding to it (e.g parameter)
                // 2. This was bound as part of some recursion
                //    eg:
                //      module A {
                //          var o;
                //      }
                //      enum A {
                //          /*quickInfoHere*/c
                //      }
                //      module A {
                //          var p;
                //      }
                //     As part of binding the member declaration, we would bind enum and hence end up binding all value decls
                //     which are instance vars from module declaration. As part of it, we would want to bind corresponding 
                //     module declaration which in turn would try to bind all the var declarations
                if (this.shouldBindDeclaration(decl)) {
                    this.bindSingleDeclToPullSymbol(decl);
                }
            }
        }

        private bindSingleDeclToPullSymbol(decl: PullDecl) {
            // Add it to the list in case we revisit it during binding
            this.declsBeingBound.push(decl.declID);

            switch (decl.kind) {
                case PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case PullElementKind.Enum:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.DynamicModule:
                case PullElementKind.Container:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Interface:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Class:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Function:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Variable:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.CatchVariable:
                    this.bindCatchVariableToPullSymbol(decl);
                    break;

                case PullElementKind.EnumMember:
                    this.bindEnumMemberDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Property:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Method:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorMethod:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.CallSignature:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructSignature:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.IndexSignature:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.GetAccessor:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.SetAccessor:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ObjectType:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionType:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorType:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionExpression:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case PullElementKind.TypeAlias:
                    this.bindImportDeclaration(decl);
                    break;

                case PullElementKind.Parameter:
                case PullElementKind.TypeParameter:
                    // parameters are bound by their enclosing function or type.  Ensure that that
                    // decl is bound.
                    decl.getParentDecl().getSymbol(this.semanticInfoChain);
                    break;

                case PullElementKind.CatchBlock:
                case PullElementKind.WithBlock:
                    // since we don't bind eagerly, there's nothing to do here
                    break;

                default:
                    CompilerDiagnostics.assert(false, "Unrecognized type declaration");
            }

            // Rremove the decl from the list
            Debug.assert(ArrayUtilities.last(this.declsBeingBound) === decl.declID);
            this.declsBeingBound.pop();
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {
    export var pullSymbolID = 0;
    export var sentinelEmptyArray: any[] = [];

    export class PullSymbol {
        
        // private state
        // The symbol ids start with 1 and not 0 as 0 is reserved to detect false conditions eg. in determining 
        // wrappingTypeParameterID
        public pullSymbolID = ++pullSymbolID;

        public name: string;

        public kind: PullElementKind;

        private _container: PullTypeSymbol = null;
        public type: PullTypeSymbol = null;

        // We cache the declarations to improve look-up speed
        // (but we re-create on edits because deletion from the linked list is
        // much faster)
        private _declarations: PullDecl[] = null;

        public isResolved = false;

        public isOptional = false;

        public inResolution = false;

        private isSynthesized = false;

        public isVarArg = false;

        private rootSymbol: PullSymbol = null;

        private _enclosingSignature: PullSignatureSymbol = null;
        private _docComments: string = null;

        public isPrinting = false;

        public isAny(): boolean {
            return false;
        }

        public isType() {
            return (this.kind & PullElementKind.SomeType) !== 0;
        }

        public isTypeReference() { return false; }

        public isSignature() {
            return (this.kind & PullElementKind.SomeSignature) !== 0;
        }

        public isArrayNamedTypeReference() {
            return false;
        }

        public isPrimitive() {
            return this.kind === PullElementKind.Primitive;
        }

        public isAccessor() {
            return false;
        }

        public isError() {
            return false;
        }

        public isInterface() {
            return this.kind === PullElementKind.Interface;
        }

        public isMethod() {
            return this.kind === PullElementKind.Method;
        }

        public isProperty() {
            return this.kind === PullElementKind.Property;
        }

        public isAlias() { return false; }

        public isContainer() { return false; }

        constructor(name: string, declKind: PullElementKind, public semanticInfoChain:  SemanticInfoChain) {
            this.name = name;
            this.kind = declKind;
        }

        // Finds alias if present representing this symbol
        private findAliasedTypeSymbols(scopeSymbol: PullSymbol, skipScopeSymbolAliasesLookIn?: boolean, lookIntoOnlyExportedAlias?: boolean, aliasSymbols: PullTypeAliasSymbol[]= [], visitedScopeDeclarations: PullDecl[]= []): PullTypeAliasSymbol[] {
            var scopeDeclarations = scopeSymbol.getDeclarations();
            var scopeSymbolAliasesToLookIn: PullTypeAliasSymbol[] = [];

            for (var i = 0; i < scopeDeclarations.length; i++) {
                var scopeDecl = scopeDeclarations[i];
                if (!ArrayUtilities.contains(visitedScopeDeclarations, scopeDecl)) {
                    visitedScopeDeclarations.push(scopeDecl);

                    var childDecls = scopeDecl.getChildDecls();
                    for (var j = 0; j < childDecls.length; j++) {
                        var childDecl = childDecls[j];
                        if (childDecl.kind === PullElementKind.TypeAlias &&
                            (!lookIntoOnlyExportedAlias || (childDecl.flags & PullElementFlags.Exported))) {
                            var symbol = <PullTypeAliasSymbol>childDecl.getSymbol(this.semanticInfoChain);

                            if (PullContainerSymbol.usedAsSymbol(symbol, this) || // this is symbol is used as this alias
                                (this.rootSymbol && PullContainerSymbol.usedAsSymbol(symbol, this.rootSymbol))) { // the root symbol of the alias is used as import symbol
                                aliasSymbols.push(symbol);
                                return aliasSymbols;
                            }

                            if (!skipScopeSymbolAliasesLookIn && PullSymbol._isExternalModuleReferenceAlias(symbol) &&
                                (!symbol.assignedContainer().hasExportAssignment() ||
                                (symbol.assignedContainer().getExportAssignedContainerSymbol() && symbol.assignedContainer().getExportAssignedContainerSymbol().kind === PullElementKind.DynamicModule))) {// It is a dynamic module)) {
                                scopeSymbolAliasesToLookIn.push(symbol);
                            }
                        }
                    }
                }
            }

            // Didnt find alias in the declarations, look for them in the externalImport declarations of dynamic modules
            for (var i = 0; i < scopeSymbolAliasesToLookIn.length; i++) {
                var scopeSymbolAlias = scopeSymbolAliasesToLookIn[i];

                aliasSymbols.push(scopeSymbolAlias);
                var result = this.findAliasedTypeSymbols(
                    scopeSymbolAlias.assignedContainer().hasExportAssignment() ? scopeSymbolAlias.assignedContainer().getExportAssignedContainerSymbol() : scopeSymbolAlias.assignedContainer(),
                /*skipScopeSymbolAliasesLookIn*/ false, /*lookIntoOnlyExportedAlias*/ true, aliasSymbols, visitedScopeDeclarations);
                if (result) {
                    return result;
                }

                aliasSymbols.pop();
            }

            return null;
        }

        // Gets alias with external module reference if present representing this symbol
        public getExternalAliasedSymbols(scopeSymbol: PullSymbol) {
            if (!scopeSymbol) {
                return null;
            }

            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].kind === PullElementKind.DynamicModule) {
                var symbols = this.findAliasedTypeSymbols(scopePath[scopePath.length - 1]);
                return symbols;
            }

            return null;
        }

        public static _isExternalModuleReferenceAlias(aliasSymbol: PullTypeAliasSymbol) {
            if (aliasSymbol) {
                // Has value symbol
                if (aliasSymbol.assignedValue()) {
                    return false;
                }

                // Has type that is not same as container
                if (aliasSymbol.assignedType() && aliasSymbol.assignedType() !== aliasSymbol.assignedContainer()) {
                    return false;
                }

                // Its internal module
                if (aliasSymbol.assignedContainer() && aliasSymbol.assignedContainer().kind !== PullElementKind.DynamicModule) {
                    return false;
                }

                return true;
            }

            return false;
        }

        // Gets exported alias with internal module reference if present representing this symbol
        private getExportedInternalAliasSymbol(scopeSymbol: PullSymbol) {
            if (scopeSymbol) {
                if (this.kind !== PullElementKind.TypeAlias) {
                    var scopePath = scopeSymbol.pathToRoot();
                    for (var i = 0; i < scopePath.length; i++) {
                        var internalAliases = this.findAliasedTypeSymbols(scopeSymbol, /*skipScopeSymbolAliasesLookIn*/ true, /*lookIntoOnlyExportedAlias*/ true);
                        if (internalAliases) {
                            Debug.assert(internalAliases.length === 1);
                            return internalAliases[0];
                        }
                    }
                }
            }

            return null;
        }

        // Get alias Name using the name getter methods
        public getAliasSymbolName(
            scopeSymbol: PullSymbol,
            aliasNameGetter: (symbol: PullTypeAliasSymbol) => string, // get the name for the alias
            aliasPartsNameGetter: (symbol: PullTypeAliasSymbol) => string, // get the name of parts of the alias
            skipInternalAlias?: boolean): string {
            if (!skipInternalAlias) {
                var internalAlias = this.getExportedInternalAliasSymbol(scopeSymbol);
                if (internalAlias) {
                    return aliasNameGetter(internalAlias);
                }
            }

            var externalAliases = this.getExternalAliasedSymbols(scopeSymbol);
            // Use only alias symbols to the dynamic module and it isnt expressed in terms of this symbol itself
            if (externalAliases && externalAliases[0] != this && PullSymbol._isExternalModuleReferenceAlias(externalAliases[externalAliases.length - 1])) {
                var aliasFullName = aliasNameGetter(externalAliases[0]);
                if (!aliasFullName) {
                    return null;
                }
                for (var i = 1, symbolsLen = externalAliases.length; i < symbolsLen; i++) {
                    aliasFullName = aliasFullName + "." + aliasPartsNameGetter(externalAliases[i]);
                }
                return aliasFullName;
            }

            return null;
        }

        public _getResolver(): PullTypeResolver {
            return this.semanticInfoChain.getResolver();
        }

        public _resolveDeclaredSymbol() {
            return this._getResolver().resolveDeclaredSymbol(this);
        }

        /** Use getName for type checking purposes, and getDisplayName to report an error or display info to the user.
         * They will differ when the identifier is an escaped unicode character or the identifier "__proto__".
         */
        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            var aliasName = this.getAliasSymbolName(scopeSymbol, (symbol) => symbol.getName(scopeSymbol, useConstraintInName), (symbol) => symbol.getName());
            return aliasName || this.name;
        }

        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, skipInternalAliasName?: boolean): string {
            var aliasDisplayName = this.getAliasSymbolName(scopeSymbol,
                (symbol) => symbol.getDisplayName(scopeSymbol, useConstraintInName),
                (symbol) => symbol.getDisplayName(), skipInternalAliasName);
            if (aliasDisplayName) {
                return aliasDisplayName;
            }

            // Get the actual name associated with a declaration for this symbol
            var decls = this.getDeclarations();
            var name = decls.length && decls[0].getDisplayName();

            // In case the decl does not have a name like in the case of named function expression
            return (name && name.length) ? name : this.name;
        }

        public getIsSpecialized() { return false; }

        public getRootSymbol() {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        }
        public setRootSymbol(symbol: PullSymbol) { this.rootSymbol = symbol; }

        public isRootSymbol(): boolean {
            return !this.rootSymbol;
        }

        public setIsSynthesized(value = true) {
            Debug.assert(this.rootSymbol == null);
            this.isSynthesized = value;
        }

        public getIsSynthesized() {
            if (this.rootSymbol) {
                return this.rootSymbol.getIsSynthesized();
            }
            return this.isSynthesized;
        }

        public setEnclosingSignature(signature: PullSignatureSymbol) {
            this._enclosingSignature = signature;
        }

        public getEnclosingSignature(): PullSignatureSymbol {
            return this._enclosingSignature;
        }

        // declaration methods
        public addDeclaration(decl: PullDecl) {
            Debug.assert(!!decl);

            if (this.rootSymbol) {
                return;
            }

            if (!this._declarations) {
                this._declarations = [decl];
            }
            else {
                this._declarations[this._declarations.length] = decl;
            }
        }

        public getDeclarations(): PullDecl[] {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }

            if (!this._declarations) {
                this._declarations = [];
            }

            return this._declarations;
        }

        public hasDeclaration(decl: PullDecl): boolean {
            if (!this._declarations) {
                return false;
            }

            return ArrayUtilities.any(this._declarations, eachDecl => eachDecl === decl);
        }

        // link methods

        public setContainer(containerSymbol: PullTypeSymbol) {
            if (this.rootSymbol) {
                return;
            }

            this._container = containerSymbol;
        }

        public getContainer(): PullTypeSymbol {
            if (this.rootSymbol) {
                return this.rootSymbol.getContainer();
            }

            return this._container;
        }

        public setResolved() {
            this.isResolved = true;
            this.inResolution = false;
        }

        public startResolving() {
            this.inResolution = true;
        }

        public setUnresolved() {
            this.isResolved = false;
            this.inResolution = false;
        }

        public anyDeclHasFlag(flag: PullElementFlags): boolean {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (hasFlag(declarations[i].flags, flag)) {
                    return true;
                }
            }
            return false;
        }

        public allDeclsHaveFlag(flag: PullElementFlags): boolean {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!hasFlag(declarations[i].flags, flag)) {
                    return false;
                }
            }
            return true;
        }

        public pathToRoot() {
            var path: PullSymbol[] = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = (<PullTypeSymbol>node).getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                var nodeKind = node.kind;
                if (nodeKind === PullElementKind.Parameter) {
                    break;
                }
                else {
                    node = node.getContainer();
                }
            }
            return path;
        }

        private static unqualifiedNameReferencesDifferentSymbolInScope(symbol: PullSymbol, scopePath: PullSymbol[], endScopePathIndex: number) {
            // Declaration path is reverse of symbol path
            // That is for symbol A.B.C.W the symbolPath = W C B A 
            // while declPath = A B C W
            var declPath = scopePath[0].getDeclarations()[0].getParentPath();
            for (var i = 0, declIndex = declPath.length - 1; i <= endScopePathIndex; i++, declIndex--) {
                // We should be doing this for all that is type/namespace/value kinds but for now we do this only for 
                // containers and types in another container
                if (scopePath[i].isContainer()) {
                    var scopeContainer = <PullContainerSymbol>scopePath[i];
                    if (symbol.isContainer()) {
                        // Non exported container 
                        var memberSymbol = scopeContainer.findContainedNonMemberContainer(symbol.name, PullElementKind.SomeContainer);
                        if (memberSymbol
                            && memberSymbol != symbol
                            && memberSymbol.getDeclarations()[0].getParentDecl() == declPath[declIndex]) {
                            // If we found different non exported symbol that is originating in same parent
                            // So symbol with this name would refer to the memberSymbol instead of symbol
                            return true;
                        }

                        // Exported container
                        var memberSymbol = scopeContainer.findNestedContainer(symbol.name, PullElementKind.SomeContainer);
                        if (memberSymbol && memberSymbol != symbol) {
                            return true;
                        }
                    }
                    else if (symbol.isType()) {
                        // Non exported type 
                        var memberSymbol = scopeContainer.findContainedNonMemberType(symbol.name, PullElementKind.SomeType);
                        var symbolRootType = PullHelpers.getRootType(<PullTypeSymbol>symbol);
                        if (memberSymbol
                            && PullHelpers.getRootType(memberSymbol) != symbolRootType
                            && memberSymbol.getDeclarations()[0].getParentDecl() == declPath[declIndex]) {
                            // If we found different non exported symbol that is originating in same parent
                            // So symbol with this name would refer to the memberSymbol instead of symbol
                            return true;
                        }

                        // Exported type
                        var memberSymbol = scopeContainer.findNestedType(symbol.name, PullElementKind.SomeType);
                        if (memberSymbol && PullHelpers.getRootType(memberSymbol) != symbolRootType) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // Find the path of this symbol in common ancestor of this symbol and b Symbol
        private findQualifyingSymbolPathInScopeSymbol(scopeSymbol: PullSymbol): PullSymbol[] {
            var thisPath = this.pathToRoot();
            if (thisPath.length === 1) {
                // Global symbol
                return thisPath;
            }

            var scopeSymbolPath: PullSymbol[];
            if (scopeSymbol) {
                scopeSymbolPath = scopeSymbol.pathToRoot();
            }
            else {
                // If scopeSymbol wasnt provided, then the path is full path
                return thisPath;
            }

            var thisCommonAncestorIndex = ArrayUtilities.indexOf(thisPath, thisNode => ArrayUtilities.contains(scopeSymbolPath, thisNode));
            if (thisCommonAncestorIndex > 0) {
                // If the symbols matched that does not mean we can use the symbol before the common ancestor directly.
                // e.g
                //module A.C {
                //    export interface Z {
                //    }
                //}
                //module A.B.C {
                //    export class W implements A.C.Z /*This*/ {
                //    }
                //}
                // When trying to get Name of A.C.Z in the context A.B.C.W 
                // We find that thisPath = [Z C A] and scopeSymbolPath = [W C B A]
                // thisCommonAncestorIndex = 2
                // But we cant use (thisCommonAncestorIndex - 1)C of C.Z as the reference path because 
                // C in A.B.C.W references A.B.C rather than A.C

                var thisCommonAncestor = thisPath[thisCommonAncestorIndex];
                var scopeCommonAncestorIndex = ArrayUtilities.indexOf(scopeSymbolPath, scopeNode => scopeNode === thisCommonAncestor);
                Debug.assert(thisPath.length - thisCommonAncestorIndex === scopeSymbolPath.length - scopeCommonAncestorIndex);

                for (; thisCommonAncestorIndex < thisPath.length; thisCommonAncestorIndex++, scopeCommonAncestorIndex++) {
                    if (!PullSymbol.unqualifiedNameReferencesDifferentSymbolInScope(
                        thisPath[thisCommonAncestorIndex - 1], scopeSymbolPath, scopeCommonAncestorIndex)) {
                        // scope symbol can reference symbol at index commonAncestor - 1 by name itself
                        break;
                    }
                }
            }

            if (thisCommonAncestorIndex >= 0 && thisCommonAncestorIndex < thisPath.length) {
                return thisPath.slice(0, thisCommonAncestorIndex);
            }
            else {
                return thisPath;
            }
        }

        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean) {
            var str = this.getNameAndTypeName(scopeSymbol);
            return str;
        }

        public getNamePartForFullName() {
            return this.getDisplayName(null /*scopeSymbol*/, true /*useConstraintInName*/);
        }

        public fullName(scopeSymbol?: PullSymbol): string {
            var path = this.pathToRoot();
            var fullName = "";

            var aliasFullName = this.getAliasSymbolName(scopeSymbol, (symbol) => symbol.fullName(scopeSymbol), (symbol) => symbol.getNamePartForFullName());
            if (aliasFullName) {
                return aliasFullName;
            }

            for (var i = 1; i < path.length; i++) {
                var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, (symbol) => symbol === this ? null : symbol.fullName(scopeSymbol), (symbol) => symbol.getNamePartForFullName());
                if (aliasFullName) {
                    fullName = aliasFullName + "." + fullName;
                    break;
                }

                var scopedName = path[i].getNamePartForFullName();
                if (path[i].kind === PullElementKind.DynamicModule && !isQuoted(scopedName)) {
                    // Same file as dynamic module - do not include this name
                    break;
                }

                if (scopedName === "") {
                    // If the item does not have a name, stop enumarting them, e.g. Object literal
                    break;
                }

                fullName = scopedName + "." + fullName;
            }

            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        }

        public getScopedName(scopeSymbol?: PullSymbol, skipTypeParametersInName?: boolean, useConstraintInName?: boolean, skipInternalAliasName?: boolean): string {
            var path = this.findQualifyingSymbolPathInScopeSymbol(scopeSymbol);
            var fullName = "";

            var aliasFullName = this.getAliasSymbolName(scopeSymbol, (symbol) => symbol.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName),
                (symbol) => symbol.getNamePartForFullName(), skipInternalAliasName);
            if (aliasFullName) {
                return aliasFullName;
            }

            for (var i = 1; i < path.length; i++) {
                var kind = path[i].kind;
                if (kind === PullElementKind.Container || kind === PullElementKind.DynamicModule) {
                    var aliasFullName = path[i].getAliasSymbolName(scopeSymbol, (symbol) => symbol.getScopedName(scopeSymbol, skipTypeParametersInName, /*useConstraintInName*/ false, skipInternalAliasName),
                        (symbol) => symbol.getNamePartForFullName(), skipInternalAliasName);
                    if (aliasFullName) {
                        fullName = aliasFullName + "." + fullName;
                        break;
                    }

                    if (kind === PullElementKind.Container) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    }
                    else {
                        // Dynamic module 
                        var displayName = path[i].getDisplayName();
                        if (isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                }
                else {
                    // Any other type of container is not part of the name
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName, skipInternalAliasName);
            return fullName;
        }

        public getScopedNameEx(scopeSymbol?: PullSymbol, skipTypeParametersInName?: boolean, useConstraintInName?: boolean, getPrettyTypeName?: boolean, getTypeParamMarkerInfo?: boolean, skipInternalAliasName?: boolean) {
            var name = this.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);
            return MemberName.create(name);
        }

        public getTypeName(scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        }

        public getTypeNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean) {
            var type = this.type;
            if (type) {
                var memberName: MemberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, /*skipTypeParametersInName*/ false, /*useConstraintInName:*/ true, getPrettyTypeName);
                }

                return memberName;
            }
            return MemberName.create("");
        }

        private getTypeNameForFunctionSignature(prefix: string, scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean) {
            var type = this.type;
            if (type && !type.isNamedTypeSymbol() && this.kind !== PullElementKind.Property && this.kind !== PullElementKind.Variable && this.kind !== PullElementKind.Parameter) {
                var signatures = type.getCallSignatures();
                if (signatures.length === 1 || (getPrettyTypeName && signatures.length)) {
                    var typeName = new MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, /*shortform*/ false, /*brackets*/ false, scopeSymbol, getPrettyTypeName);
                    typeName.addAll(signatureName);
                    return typeName;
                }
            }

            return null;
        }

        public getNameAndTypeName(scopeSymbol?: PullSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        }

        public getNameAndTypeNameEx(scopeSymbol?: PullSymbol) {
            var type = this.type;
            var nameStr = this.getDisplayName(scopeSymbol);
            if (type) {
                nameStr = nameStr + (this.isOptional ? "?" : "");
                var memberName: MemberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return MemberName.create(nameStr);
        }

        static getTypeParameterString(typars: PullTypeSymbol[], scopeSymbol?: PullSymbol, useContraintInName?: boolean) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, /*getTypeParamMarkerInfo:*/ undefined, useContraintInName).toString();
        }

        static getTypeParameterStringEx(typeParameters: PullTypeSymbol[], scopeSymbol?: PullSymbol, getTypeParamMarkerInfo?: boolean, useContraintInName?: boolean) {
            var builder = new MemberNameArray();
            builder.prefix = "";

            if (typeParameters && typeParameters.length) {
                builder.add(MemberName.create("<"));

                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(MemberName.create(", "));
                    }

                    if (getTypeParamMarkerInfo) {
                        builder.add(new MemberName());
                    }

                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, /*skipTypeParametersInName*/ false, useContraintInName));

                    if (getTypeParamMarkerInfo) {
                        builder.add(new MemberName());
                    }
                }

                builder.add(MemberName.create(">"));
            }

            return builder;
        }

        static getIsExternallyVisible(symbol: PullSymbol, fromIsExternallyVisibleSymbol: PullSymbol, inIsExternallyVisibleSymbols: PullSymbol[]) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            }
            else {
                inIsExternallyVisibleSymbols = [];
            }

            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }

            inIsExternallyVisibleSymbols.push(fromIsExternallyVisibleSymbol);

            var result = symbol.isExternallyVisible(inIsExternallyVisibleSymbols);

            Debug.assert(ArrayUtilities.last(inIsExternallyVisibleSymbols) === fromIsExternallyVisibleSymbol);
            inIsExternallyVisibleSymbols.pop();

            return result;
        }

        public isExternallyVisible(inIsExternallyVisibleSymbols?: PullSymbol[]): boolean {
            // Primitive
            var kind = this.kind;
            if (kind === PullElementKind.Primitive) {
                return true;
            }

            if (this.rootSymbol) {
                return PullSymbol.getIsExternallyVisible(this.rootSymbol, this, inIsExternallyVisibleSymbols);
            }

            // Type - use container to determine privacy info
            if (this.isType()) {
                var associatedContainerSymbol = (<PullTypeSymbol>this).getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }

            // Private member
            if (this.anyDeclHasFlag(PullElementFlags.Private)) {
                return false;
            }

            // If the container for this symbol is null, then this symbol is visible
            var container = this.getContainer();
            if (container === null) {
                var decls = this.getDeclarations();
                if (decls.length) {
                    var parentDecl = decls[0].getParentDecl();
                    if (parentDecl) {
                        var parentSymbol = parentDecl.getSymbol(this.semanticInfoChain);
                        if (!parentSymbol || parentDecl.kind === PullElementKind.Script) {
                            return true;
                        }

                        return PullSymbol.getIsExternallyVisible(parentSymbol, this, inIsExternallyVisibleSymbols);
                    }
                }

                return true;
            }

            // If export assignment check if this is the symbol that is exported
            if (container.kind === PullElementKind.DynamicModule ||
                (container.getAssociatedContainerType() && container.getAssociatedContainerType().kind === PullElementKind.DynamicModule)) {
                var containerSymbol = container.kind === PullElementKind.DynamicModule
                    ? <PullContainerSymbol>container
                    : <PullContainerSymbol>container.getAssociatedContainerType();
                if (PullContainerSymbol.usedAsSymbol(containerSymbol, this)) {
                    return true;
                }
            }

            // If non exported member and is not class properties and method, it is not visible
            if (!this.anyDeclHasFlag(PullElementFlags.Exported) && kind !== PullElementKind.Property && kind !== PullElementKind.Method) {
                return false;
            }

            // Visible if parent is visible
            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        }

        private getDocCommentsOfDecl(decl: TypeScript.PullDecl): TypeScript.Comment[] {
            var ast = decl.ast();

            if (ast) {
                var enclosingModuleDeclaration = ASTHelpers.getModuleDeclarationFromNameAST(ast);
                if (ASTHelpers.isLastNameOfModule(enclosingModuleDeclaration, ast)) {
                    return ASTHelpers.docComments(enclosingModuleDeclaration);
                }

                if (ast.kind() !== TypeScript.SyntaxKind.ModuleDeclaration || decl.kind !== TypeScript.PullElementKind.Variable) {
                    return ASTHelpers.docComments(ast);
                }
            }

            return [];
        }

        private getDocCommentArray(symbol: TypeScript.PullSymbol) {
            var docComments: TypeScript.Comment[] = [];
            if (!symbol) {
                return docComments;
            }

            var isParameter = symbol.kind === TypeScript.PullElementKind.Parameter;
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (isParameter && decls[i].kind === TypeScript.PullElementKind.Property) {
                    // Ignore declaration for property that was defined as parameter because they both 
                    // point to same doc comment
                    continue;
                }
                docComments = docComments.concat(this.getDocCommentsOfDecl(decls[i]));
            }
            return docComments;
        }

        private static getDefaultConstructorSymbolForDocComments(classSymbol: TypeScript.PullTypeSymbol) {
            if (classSymbol.getHasDefaultConstructor()) {
                // get from parent if possible
                var extendedTypes = classSymbol.getExtendedTypes();
                if (extendedTypes.length) {
                    return PullSymbol.getDefaultConstructorSymbolForDocComments(extendedTypes[0]);
                }
            }

            return classSymbol.type.getConstructSignatures()[0];
        }

        private getDocCommentText(comments: Comment[]) {
            var docCommentText = new Array<string>();
            for (var c = 0; c < comments.length; c++) {
                var commentText = this.getDocCommentTextValue(comments[c]);
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        }

        private getDocCommentTextValue(comment: Comment) {
            return this.cleanJSDocComment(comment.fullText());
        }

        public docComments(useConstructorAsClass?: boolean): string {
            var decls = this.getDeclarations();
            if (useConstructorAsClass && decls.length && decls[0].kind === TypeScript.PullElementKind.ConstructorMethod) {
                var classDecl = decls[0].getParentDecl();
                return this.getDocCommentText(this.getDocCommentsOfDecl(classDecl));
            }

            if (this._docComments === null) {
                var docComments: string = "";
                if (!useConstructorAsClass && this.kind === TypeScript.PullElementKind.ConstructSignature &&
                    decls.length && decls[0].kind === TypeScript.PullElementKind.Class) {
                    var classSymbol = (<TypeScript.PullSignatureSymbol>this).returnType;
                    var extendedTypes = classSymbol.getExtendedTypes();
                    if (extendedTypes.length) {
                        docComments = extendedTypes[0].getConstructorMethod().docComments();
                    }
                    else {
                        docComments = "";
                    }
                }
                else if (this.kind === TypeScript.PullElementKind.Parameter) {
                    var parameterComments: string[] = [];

                    var funcContainer = this.getEnclosingSignature();
                    var funcDocComments = this.getDocCommentArray(funcContainer);
                    var paramComment = this.getParameterDocCommentText(this.getDisplayName(), funcDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }

                    var paramSelfComment = this.getDocCommentText(this.getDocCommentArray(this));
                    if (paramSelfComment != "") {
                        parameterComments.push(paramSelfComment);
                    }
                    docComments = parameterComments.join("\n");
                }
                else {
                    var getSymbolComments = true;
                    if (this.kind === TypeScript.PullElementKind.FunctionType) {
                        var functionSymbol = (<TypeScript.PullTypeSymbol>this).getFunctionSymbol();

                        if (functionSymbol) {
                            docComments = functionSymbol._docComments || "";
                            getSymbolComments = false;
                        }
                        else {
                            var declarationList = this.getDeclarations();
                            if (declarationList.length > 0) {
                                docComments = declarationList[0].getSymbol(this.semanticInfoChain)._docComments || "";
                                getSymbolComments = false;
                            }
                        }
                    }
                    if (getSymbolComments) {
                        docComments = this.getDocCommentText(this.getDocCommentArray(this));
                        if (docComments === "") {
                            if (this.kind === TypeScript.PullElementKind.CallSignature) {
                                var callTypeSymbol = (<TypeScript.PullSignatureSymbol>this).functionType;
                                if (callTypeSymbol && callTypeSymbol.getCallSignatures().length === 1) {
                                    docComments = callTypeSymbol.docComments();
                                }
                            }
                        }
                    }
                }

                this._docComments = docComments;
            }

            return this._docComments;
        }

        private getParameterDocCommentText(param: string, fncDocComments: Comment[]) {
            if (fncDocComments.length === 0 || fncDocComments[0].kind() !== SyntaxKind.MultiLineCommentTrivia) {
                // there were no fnc doc comments and the comment is not block comment then it cannot have 
                // @param comment that can be parsed
                return "";
            }

            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].fullText();
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!this.isSpaceChar(commentContents, j)) {
                        // This is not param tag but a tag line @paramxxxxx
                        continue;
                    }

                    // This is param tag. Check if it is what we are looking for
                    j = this.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }

                    // Ignore the type expression
                    if (commentContents.charCodeAt(j) === CharacterCodes.openBrace) {
                        j++;
                        // Consume the type
                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            // { character means we need to find another } to match the found one
                            if (charCode === CharacterCodes.openBrace) {
                                curlies++;
                                continue;
                            }

                            // } char
                            if (charCode === CharacterCodes.closeBrace) {
                                curlies--;
                                if (curlies === 0) {
                                    // We do not have any more } to match the type expression is ignored completely
                                    break;
                                }
                                else {
                                    // there are more { to be matched with }
                                    continue;
                                }
                            }

                            // Found start of another tag
                            if (charCode === CharacterCodes.at) {
                                break;
                            }
                        }

                        // End of the comment
                        if (j === commentContents.length) {
                            break;
                        }

                        // End of the tag, go onto looking for next tag
                        if (charCode === CharacterCodes.at) {
                            continue;
                        }

                        j = this.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    // Parameter name
                    if (param !== commentContents.substr(j, param.length) || !this.isSpaceChar(commentContents, j + param.length)) {
                        // this is not the parameter we are looking for
                        continue;
                    }

                    // Found the parameter we were looking for
                    j = this.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }

                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    // Find alignement spaces to remove
                    var paramSpacesToRemove: number = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = this.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    // Clean jsDocComment and return
                    return this.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        }

        private cleanJSDocComment(content: string, spacesToRemove?: number) {
            var docCommentLines = new Array<string>();
            content = content.replace("/**", ""); // remove /**
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2); // remove last */
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = this.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    // Whole line empty, read next line
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.start;
                for (var i = line.indexOf("@", cleanLinePos.start); 0 <= i && i < cleanLinePos.end; i = line.indexOf("@", i + 1)) {
                    // We have encoutered @. 
                    // If we were omitting param comment, we dont have to do anything
                    // other wise the content of the text till @ tag goes as doc comment
                    var wasInParamtag = inParamTag;

                    // Parse contents next to @
                    if (line.indexOf("param", i + 1) === i + 1 && this.isSpaceChar(line, i + 6)) {
                        // It is param tag. 

                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        // New start of contents 
                        prevPos = i;
                        inParamTag = true;
                    }
                    else if (wasInParamtag) {
                        // Non param tag start
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.end);
                }

                // Add line to comment text if it is not only white space line
                var newCleanPos = this.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }

            return docCommentLines.join("\n");
        }

        private consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = MathPrototype.min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== CharacterCodes.space && charCode !== CharacterCodes.tab) {
                    return startIndex;
                }
            }

            if (endIndex !== line.length) {
                return endIndex;
            }

            return -1;
        }

        private isSpaceChar(line: string, index: number) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                // If the character is space
                return charCode === CharacterCodes.space || charCode === CharacterCodes.tab;
            }

            // If the index is end of the line it is space
            return index === length;
        }

        private cleanDocCommentLine(line: string, jsDocStyleComment: boolean, jsDocLineSpaceToRemove?: number) {
            var nonSpaceIndex = this.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') { // remove leading * in case of jsDocComment
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = this.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    }
                    else {
                        return null;
                    }
                }

                return {
                    start: nonSpaceIndex,
                    end: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        }
    }

    // This interface should be implemented by symbols that can be instantiated. (eg. PullTypeSymbol, PullSignatureSymbol)
    export interface InstantiableSymbol {
        // Is the symbol specialized
        getIsSpecialized(): boolean;

        // Type parameters this symbol can reference
        // eg. in below code 
        // interface IList<T> {
        //     owner: /*Any type here can only refere to type parameter T*/;
        //     map<U>(a: /*any type parameter here can only refere to U and T*/
        // }
        getAllowedToReferenceTypeParameters(): PullTypeParameterSymbol[];

        // Type parameter argument map for this symbol
        getTypeParameterSubstitutionMap(): TypeSubstitutionMap;
    }

    export class PullSignatureSymbol extends PullSymbol implements InstantiableSymbol {
        private _memberTypeParameterNameCache: IIndexable<PullTypeParameterSymbol> = null;
        private _stringConstantOverload: boolean = undefined;

        public parameters: PullSymbol[] = sentinelEmptyArray;
        public _typeParameters: PullTypeParameterSymbol[] = null;
        public returnType: PullTypeSymbol = null;
        public functionType: PullTypeSymbol = null;

        public hasOptionalParam = false;
        public nonOptionalParamCount = 0;

        public hasVarArgs = false;

        private _allowedToReferenceTypeParameters: PullTypeParameterSymbol[] = null;
        private _instantiationCache: IIndexable<PullSignatureSymbol> = null;

        public hasBeenChecked = false;
        public inWrapCheck = false;
        public inWrapInfiniteExpandingReferenceCheck = false;

        private _wrapsTypeParameterCache: WrapsTypeParameterCache;

        constructor(kind: PullElementKind, semanticInfoChain: SemanticInfoChain, private _isDefinition = false) {
            super("", kind, semanticInfoChain);
        }

        public isDefinition() { return this._isDefinition; }

        // GTODO
        public isGeneric() {
            var typeParameters = this.getTypeParameters();
            return !!typeParameters && typeParameters.length !== 0;
        }

        public addParameter(parameter: PullSymbol, isOptional = false) {
            if (this.parameters === sentinelEmptyArray) {
                this.parameters = [];
            }

            this.parameters[this.parameters.length] = parameter;
            this.hasOptionalParam = isOptional;

            if (!parameter.getEnclosingSignature()) {
                parameter.setEnclosingSignature(this);
            }

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        }

        public addTypeParameter(typeParameter: PullTypeParameterSymbol) {
            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            if (!this._memberTypeParameterNameCache) {
                this._memberTypeParameterNameCache = createIntrinsicsObject<PullTypeParameterSymbol>();
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;

            this._memberTypeParameterNameCache[typeParameter.getName()] = typeParameter;
        }

        public addTypeParametersFromReturnType() {
            var typeParameters = this.returnType.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                this.addTypeParameter(typeParameters[i]);
            }
        }

        public getTypeParameters(): PullTypeParameterSymbol[]{
            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            return this._typeParameters;
        }

        public findTypeParameter(name: string): PullTypeParameterSymbol {
            var memberSymbol: PullTypeParameterSymbol;

            if (!this._memberTypeParameterNameCache) {

                this._memberTypeParameterNameCache = createIntrinsicsObject<PullTypeParameterSymbol>();

                for (var i = 0; i < this.getTypeParameters().length; i++) {
                    this._memberTypeParameterNameCache[this._typeParameters[i].getName()] = this._typeParameters[i];
                }
            }

            memberSymbol = this._memberTypeParameterNameCache[name];

            return memberSymbol;
        }

        public getTypeParameterSubstitutionMap(): TypeSubstitutionMap { return null; }

        public getAllowedToReferenceTypeParameters(): PullTypeParameterSymbol[] {
            Debug.assert(this.getRootSymbol() == this);
            if (!this._allowedToReferenceTypeParameters) {
                // If the type is not named, it cannot have its own type parameters
                // But it can refer to typeParameters from enclosing type
                this._allowedToReferenceTypeParameters = PullInstantiationHelpers.getAllowedToReferenceTypeParametersFromDecl(this.getDeclarations()[0], this.semanticInfoChain);
            }

            return this._allowedToReferenceTypeParameters;
        }

        public getIsInstantiated() {
            return false;
        }

        public addSpecialization(specializedVersionOfThisSignature: PullSignatureSymbol, typeArgumentMap: TypeSubstitutionMap): void {
            Debug.assert(this.getRootSymbol() == this);
            if (!this._instantiationCache) {
                this._instantiationCache = createIntrinsicsObject<PullSignatureSymbol>();
            }

            this._instantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)] = specializedVersionOfThisSignature;
        }

        public getSpecialization(typeArgumentMap: TypeSubstitutionMap): PullSignatureSymbol {
            Debug.assert(this.getRootSymbol() == this);
            if (!this._instantiationCache) {
                return null;
            }

            var result = this._instantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)];
            return result || null;
        }

        public isStringConstantOverloadSignature() {
            if (this._stringConstantOverload === undefined) {
                var params = this.parameters;
                this._stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].type;
                    if (paramType && paramType.isPrimitive() && (<PullPrimitiveTypeSymbol>paramType).isStringConstant()) {
                        this._stringConstantOverload = true;
                    }
                }
            }

            return this._stringConstantOverload;
        }

        // Gets the type of parameter at given index
        public getParameterTypeAtIndex(iParam: number) {
            if (iParam < this.parameters.length - 1 || (iParam < this.parameters.length && !this.hasVarArgs)) {
                return this.parameters[iParam].type;
            }
            else if (this.hasVarArgs) {
                var paramType = this.parameters[this.parameters.length - 1].type;
                if (paramType.isArrayNamedTypeReference()) {
                    paramType = paramType.getElementType();
                }
                return paramType
            }

            return null;
        }

        static getSignatureTypeMemberName(candidateSignature: PullSignatureSymbol, signatures: PullSignatureSymbol[], scopeSymbol: PullSymbol) {
            var allMemberNames = new MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, /*prefix*/ "", /*shortform*/ false, /*brackets*/ false, scopeSymbol, /*getPrettyName*/ true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        }

        static getSignaturesTypeNameEx(signatures: PullSignatureSymbol[],
            prefix: string,
            shortform: boolean,
            brackets: boolean,
            scopeSymbol?: PullSymbol,
            getPrettyTypeName?: boolean,
            candidateSignature?: PullSignatureSymbol) {

            var result: MemberName[] = [];
            if (!signatures) {
                return result;
            }

            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                // Overloaded signature with candidateSignature = definition - cannot be used.
                candidateSignature = null;
            }

            for (var i = 0; i < len; i++) {
                // the definition signature shouldn't be printed if there are overloads
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = <MemberNameArray>result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = getLocalizedText(DiagnosticCode._0_overload_s, [foundDefinition ? len - 2 : len - 1]);
                lastMemberName.add(MemberName.create(overloadString));
            }

            return result;
        }

        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), /*shortform*/ false, /*brackets*/ false, scopeSymbol, /*getParamMarkerInfo*/ undefined, useConstraintInName).toString();
            return s;
        }

        public getSignatureTypeNameEx(prefix: string, shortform: boolean, brackets: boolean, scopeSymbol?: PullSymbol, getParamMarkerInfo?: boolean, getTypeParamMarkerInfo?: boolean) {
            var typeParamterBuilder = new MemberNameArray();

            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(
                this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, /*useConstraintInName*/true));

            if (brackets) {
                typeParamterBuilder.add(MemberName.create("["));
            }
            else {
                typeParamterBuilder.add(MemberName.create("("));
            }

            var builder = new MemberNameArray();
            builder.prefix = prefix;

            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            }
            else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }

            var params = this.parameters;
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].type;
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].isVarArg;
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].isOptional) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new MemberName());
                }
                builder.add(MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(MemberName.create("] => "));
                }
                else {
                    builder.add(MemberName.create(") => "));
                }
            }
            else {
                if (brackets) {
                    builder.add(MemberName.create("]: "));
                }
                else {
                    builder.add(MemberName.create("): "));
                }
            }

            if (this.returnType) {
                builder.add(this.returnType.getScopedNameEx(scopeSymbol));
            }
            else {
                builder.add(MemberName.create("any"));
            }

            return builder;
        }

        public forAllParameterTypes(length: number, predicate: (parameterType: PullTypeSymbol, iterationIndex: number) => boolean): boolean {
            if (this.parameters.length < length && !this.hasVarArgs) {
                length = this.parameters.length;
            }

            for (var i = 0; i < length; i++) {
                var paramType = this.getParameterTypeAtIndex(i);
                if (!predicate(paramType, i)) {
                    return false;
                }
            }

            return true;
        }

        public forAllCorrespondingParameterTypesInThisAndOtherSignature(
            otherSignature: PullSignatureSymbol,
            predicate: (thisSignatureParameterType: PullTypeSymbol, otherSignatureParameterType: PullTypeSymbol, iterationIndex: number) => boolean): boolean {
            // First determine the length
            var length: number;
            if (this.hasVarArgs) {
                length = otherSignature.hasVarArgs
                    ? Math.max(this.parameters.length, otherSignature.parameters.length)
                    : otherSignature.parameters.length;
            }
            else {
                length = otherSignature.hasVarArgs
                    ? this.parameters.length
                    : Math.min(this.parameters.length, otherSignature.parameters.length);
            }

            for (var i = 0; i < length; i++) {
                // Finally, call the callback using the knowledge of whether each param is a rest param
                var thisParamType = this.getParameterTypeAtIndex(i);
                var otherParamType = otherSignature.getParameterTypeAtIndex(i);
                if (!predicate(thisParamType, otherParamType, i)) {
                    return false;
                }
            }

            return true;
        }

        public wrapsSomeTypeParameter(typeParameterArgumentMap: TypeSubstitutionMap): boolean {
            return this.getWrappingTypeParameterID(typeParameterArgumentMap) !== 0;
        }

        // 0 means there was no type parameter ID wrapping
        // otherwise typeParameterID that was wrapped
        // 
        // While it would be intuitive to return a boolean, this actually doesn't work
        // for the WrapsTypeParameterCache. See the comment at the top of the WrapsTypeParameterCache
        // class for an explanation.
        public getWrappingTypeParameterID(typeParameterArgumentMap: TypeSubstitutionMap): number {
            if (this.inWrapCheck) {
                return 0;
            }

            // Find result from cache
            this._wrapsTypeParameterCache = this._wrapsTypeParameterCache || new WrapsTypeParameterCache();
        
            var wrappingTypeParameterID = this._wrapsTypeParameterCache.getWrapsTypeParameter(typeParameterArgumentMap);
            if (wrappingTypeParameterID === undefined) {
                this.inWrapCheck = true;
                wrappingTypeParameterID = this.getWrappingTypeParameterIDWorker(typeParameterArgumentMap);
                this.inWrapCheck = false;
                this._wrapsTypeParameterCache.setWrapsTypeParameter(typeParameterArgumentMap, wrappingTypeParameterID);
            }

            return wrappingTypeParameterID;
        }

        // A signature wraps a type parameter if any of the following are true:
        // 1. Return type wraps the type parameter
        // 2. Some parameter type wraps the type parameter
        // 3. Some constraint wraps the type parameter
        public getWrappingTypeParameterIDWorker(typeParameterArgumentMap: TypeSubstitutionMap): number {
            PullHelpers.resolveDeclaredSymbolToUseType(this);
            var wrappingTypeParameterID = 0;
            if (this.returnType) {
                wrappingTypeParameterID = this.returnType.getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            // Continue iterating over parameter types to find if they wrap type parameter,
            // only until we find the first wrapping Type parameter
            var parameters = this.parameters;
            for (var i = 0; i < parameters.length; i++) {
                PullHelpers.resolveDeclaredSymbolToUseType(parameters[i]);
                wrappingTypeParameterID = parameters[i].type.getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            var typeParameters = this.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                PullHelpers.resolveDeclaredSymbolToUseType(typeParameters[i]);
                var constraint = typeParameters[i].getConstraint();
                if (constraint) {
                    wrappingTypeParameterID = constraint.getWrappingTypeParameterID(typeParameterArgumentMap);
                    if (wrappingTypeParameterID !== 0) {
                        return wrappingTypeParameterID;
                    }
                }
            }

            return 0;
        }

        public _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix) {
            var wrapsIntoInfinitelyExpandingTypeReference = knownWrapMap.valueAt(this.pullSymbolID, enclosingType.pullSymbolID);
            if (wrapsIntoInfinitelyExpandingTypeReference != undefined) {
                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            if (this.inWrapInfiniteExpandingReferenceCheck) {
                return false;
            }

            this.inWrapInfiniteExpandingReferenceCheck = true;
            wrapsIntoInfinitelyExpandingTypeReference =
            this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType, knownWrapMap);
            knownWrapMap.setValueAt(this.pullSymbolID, enclosingType.pullSymbolID, wrapsIntoInfinitelyExpandingTypeReference);
            this.inWrapInfiniteExpandingReferenceCheck = false;

            return wrapsIntoInfinitelyExpandingTypeReference;
        }

        public _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix) {
            if (this.returnType &&
                this.returnType._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap)) {
                return true;
            }

            var parameters = this.parameters;

            for (var i = 0; i < parameters.length; i++) {
                if (parameters[i].type &&
                    parameters[i].type._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            return false;
        }
    }

    export class PullTypeSymbol extends PullSymbol implements InstantiableSymbol {
        private _members: PullSymbol[] = sentinelEmptyArray;
        private _enclosedMemberTypes: PullTypeSymbol[] = null;
        private _enclosedMemberContainers: PullTypeSymbol[] = null;
        private _typeParameters: PullTypeParameterSymbol[] = null;
        private _allowedToReferenceTypeParameters: PullTypeParameterSymbol[] = null;

        private _specializedVersionsOfThisType: PullTypeSymbol[] = null;
        private _arrayVersionOfThisType: PullTypeSymbol = null;

        private _implementedTypes: PullTypeSymbol[] = null;
        private _extendedTypes: PullTypeSymbol[] = null;

        private _typesThatExplicitlyImplementThisType: PullTypeSymbol[] = null;
        private _typesThatExtendThisType: PullTypeSymbol[] = null;

        private _callSignatures: PullSignatureSymbol[] = null;
        private _allCallSignatures: PullSignatureSymbol[] = null;
        private _constructSignatures: PullSignatureSymbol[] = null;
        private _allConstructSignatures: PullSignatureSymbol[] = null;
        private _indexSignatures: PullSignatureSymbol[] = null;
        private _allIndexSignatures: PullSignatureSymbol[] = null;
        private _allIndexSignaturesOfAugmentedType: PullSignatureSymbol[] = null;

        private _memberNameCache: IIndexable<PullSymbol> = null;
        private _enclosedTypeNameCache: IIndexable<PullTypeSymbol> = null;
        private _enclosedContainerCache: IIndexable<PullTypeSymbol> = null;
        private _typeParameterNameCache: IIndexable<PullTypeParameterSymbol> = null;
        private _containedNonMemberNameCache: IIndexable<PullSymbol> = null;
        private _containedNonMemberTypeNameCache: IIndexable<PullTypeSymbol> = null;
        private _containedNonMemberContainerCache: IIndexable<PullTypeSymbol> = null;

        // The instanatiation cache we use when we are instantiating this type with a single 
        // non-object type.
        private _simpleInstantiationCache: PullTypeSymbol[] = null;

        // The instantiation cache we use in all other circumstances.  i.e. instantiating with
        // multiple types, or instantiating with object types.
        private _complexInstantiationCache: IIndexable<PullTypeSymbol> = null;


        // GTODO
        private _hasGenericSignature = false;
        private _hasGenericMember = false;

        private _hasBaseTypeConflict = false;

        private _knownBaseTypeCount = 0;

        private _associatedContainerTypeSymbol: PullTypeSymbol = null;

        private _constructorMethod: PullSymbol = null;
        private _hasDefaultConstructor = false;

        // TODO: Really only used to track doc comments...
        private _functionSymbol: PullSymbol = null;
        private _inMemberTypeNameEx = false;

        public inSymbolPrivacyCheck = false;
        public inWrapCheck = false;
        public inWrapInfiniteExpandingReferenceCheck = false;

        public typeReference: TypeReferenceSymbol = null;

        private _widenedType: PullTypeSymbol = null;

        private _wrapsTypeParameterCache: WrapsTypeParameterCache;

        constructor(name: string, kind: PullElementKind, semanticInfoChain: SemanticInfoChain) {
            super(name, kind, semanticInfoChain);
            this.type = this;
        }

        // Returns true if this is type reference to Array<T>.  Note that because this is a type
        // reference, it will have type arguments, not type parameters.
        private _isArrayNamedTypeReference: boolean = undefined;
        public isArrayNamedTypeReference() {
            if (this._isArrayNamedTypeReference === undefined) {
                this._isArrayNamedTypeReference = this.computeIsArrayNamedTypeReference();
            }

            return this._isArrayNamedTypeReference;
        }

        private computeIsArrayNamedTypeReference(): boolean {
            var typeArgs = this.getTypeArguments()
            if (typeArgs && this.getTypeArguments().length === 1 &&
                this.name === "Array") {

                var declaration = this.getDeclarations()[0];

                // If we're a child of the global module (i.e. we have a parent decl, but our 
                // parent has no parent), then we're the Array<T> type.
                if (declaration &&
                    declaration.getParentDecl() &&
                    declaration.getParentDecl().getParentDecl() === null) {

                    return true;
                }
            }

            return false;
        }

        public isType() { return true; }
        public isClass() {
            return this.kind === PullElementKind.Class || (this._constructorMethod !== null);
        }
        public isFunction() { return (this.kind & (PullElementKind.ConstructorType | PullElementKind.FunctionType)) !== 0; }
        public isConstructor() {
            return this.kind === PullElementKind.ConstructorType ||
                (this._associatedContainerTypeSymbol && this._associatedContainerTypeSymbol.isClass());
        }
        public isTypeParameter() { return false; }
        public isTypeVariable() { return false; }
        public isError() { return false; }
        public isEnum() { return this.kind === PullElementKind.Enum; }

        public getTypeParameterSubstitutionMap(): TypeSubstitutionMap {
            return null;
        }

        public isObject(): boolean {
            return hasFlag(this.kind,
                PullElementKind.Class | PullElementKind.ConstructorType | PullElementKind.Enum | PullElementKind.FunctionType |
                PullElementKind.Interface | PullElementKind.ObjectType | PullElementKind.ObjectLiteral);
        }

        public isFunctionType(): boolean {
            return this.getCallSignatures().length > 0 || this.getConstructSignatures().length > 0;
        }

        public getKnownBaseTypeCount() { return this._knownBaseTypeCount; }
        public resetKnownBaseTypeCount() { this._knownBaseTypeCount = 0; }
        public incrementKnownBaseCount() { this._knownBaseTypeCount++; }

        public setHasBaseTypeConflict(): void {
            this._hasBaseTypeConflict = true;
        }
        public hasBaseTypeConflict(): boolean {
            return this._hasBaseTypeConflict;
        }

        public hasMembers(): boolean {

            if (this._members !== sentinelEmptyArray) {
                return true;
            }

            var parents = this.getExtendedTypes();

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }

            return false;
        }

        // GTODO
        public setHasGenericSignature() { this._hasGenericSignature = true; }
        public getHasGenericSignature() { return this._hasGenericSignature; }

        // GTODO
        public setHasGenericMember() { this._hasGenericMember = true; }
        public getHasGenericMember() { return this._hasGenericMember; }

        public setAssociatedContainerType(type: PullTypeSymbol): void {
            this._associatedContainerTypeSymbol = type;
        }

        public getAssociatedContainerType(): PullTypeSymbol {
            return this._associatedContainerTypeSymbol;
        }

        // REVIEW
        public getArrayType(): PullTypeSymbol { return this._arrayVersionOfThisType; }

        public getElementType(): PullTypeSymbol {
            return null;
        }

        public setArrayType(arrayType: PullTypeSymbol) {
            this._arrayVersionOfThisType = arrayType;
        }

        public getFunctionSymbol(): PullSymbol {
            return this._functionSymbol;
        }

        public setFunctionSymbol(symbol: PullSymbol): void {
            if (symbol) {
                this._functionSymbol = symbol;
            }
        }

        // TODO: This seems to conflate exposed members with private non-Members
        public findContainedNonMember(name: string): PullSymbol {
            if (!this._containedNonMemberNameCache) {
                return null;
            }

            return this._containedNonMemberNameCache[name];
        }

        public findContainedNonMemberType(typeName: string, kind = PullElementKind.None): PullTypeSymbol {
            if (!this._containedNonMemberTypeNameCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberTypeNameCache[typeName];

            if (nonMemberSymbol && kind !== PullElementKind.None) {
                nonMemberSymbol = hasFlag(nonMemberSymbol.kind, kind) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        }

        public findContainedNonMemberContainer(containerName: string, kind = PullElementKind.None): PullTypeSymbol {
            if (!this._containedNonMemberContainerCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberContainerCache[containerName];

            if (nonMemberSymbol && kind !== PullElementKind.None) {
                nonMemberSymbol = hasFlag(nonMemberSymbol.kind, kind) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        }

        public addMember(memberSymbol: PullSymbol): void {
            if (!memberSymbol) {
                return;
            }

            memberSymbol.setContainer(this);

            if (!this._memberNameCache) {
                this._memberNameCache = createIntrinsicsObject<PullSymbol>();
            }

            if (this._members === sentinelEmptyArray) {
                this._members = [];
            }

            this._members.push(memberSymbol);
            this._memberNameCache[memberSymbol.name] = memberSymbol;
        }

        public addEnclosedMemberType(enclosedType: PullTypeSymbol): void {

            if (!enclosedType) {
                return;
            }

            enclosedType.setContainer(this);

            if (!this._enclosedTypeNameCache) {
                this._enclosedTypeNameCache = createIntrinsicsObject<PullTypeSymbol>();
            }

            if (!this._enclosedMemberTypes) {
                this._enclosedMemberTypes = [];
            }

            this._enclosedMemberTypes[this._enclosedMemberTypes.length] = enclosedType;
            this._enclosedTypeNameCache[enclosedType.name] = enclosedType;
        }

        public addEnclosedMemberContainer(enclosedContainer: PullTypeSymbol): void {

            if (!enclosedContainer) {
                return;
            }

            enclosedContainer.setContainer(this);

            if (!this._enclosedContainerCache) {
                this._enclosedContainerCache = createIntrinsicsObject<PullTypeSymbol>();
            }

            if (!this._enclosedMemberContainers) {
                this._enclosedMemberContainers = [];
            }

            this._enclosedMemberContainers[this._enclosedMemberContainers.length] = enclosedContainer;
            this._enclosedContainerCache[enclosedContainer.name] = enclosedContainer;
        }

        public addEnclosedNonMember(enclosedNonMember: PullSymbol): void {

            if (!enclosedNonMember) {
                return;
            }

            enclosedNonMember.setContainer(this);

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = createIntrinsicsObject<PullSymbol>();
            }

            this._containedNonMemberNameCache[enclosedNonMember.name] = enclosedNonMember;
        }

        public addEnclosedNonMemberType(enclosedNonMemberType: PullTypeSymbol): void {

            if (!enclosedNonMemberType) {
                return;
            }

            enclosedNonMemberType.setContainer(this);

            if (!this._containedNonMemberTypeNameCache) {
                this._containedNonMemberTypeNameCache = createIntrinsicsObject<PullTypeSymbol>();
            }

            this._containedNonMemberTypeNameCache[enclosedNonMemberType.name] = enclosedNonMemberType;
        }

        public addEnclosedNonMemberContainer(enclosedNonMemberContainer: PullTypeSymbol): void {

            if (!enclosedNonMemberContainer) {
                return;
            }

            enclosedNonMemberContainer.setContainer(this);

            if (!this._containedNonMemberContainerCache) {
                this._containedNonMemberContainerCache = createIntrinsicsObject<PullTypeSymbol>();
            }

            this._containedNonMemberContainerCache[enclosedNonMemberContainer.name] = enclosedNonMemberContainer;
        }

        public addTypeParameter(typeParameter: PullTypeParameterSymbol): void {
            if (!typeParameter) {
                return;
            }

            if (!typeParameter.getContainer()) {
                typeParameter.setContainer(this);
            }

            if (!this._typeParameterNameCache) {
                this._typeParameterNameCache = createIntrinsicsObject<PullTypeParameterSymbol>();
            }

            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;
            this._typeParameterNameCache[typeParameter.getName()] = typeParameter;
        }

        public getMembers(): PullSymbol[] {
            return this._members;
        }

        public setHasDefaultConstructor(hasOne= true): void {
            this._hasDefaultConstructor = hasOne;
        }

        public getHasDefaultConstructor(): boolean {
            return this._hasDefaultConstructor;
        }

        public getConstructorMethod(): PullSymbol {
            return this._constructorMethod;
        }

        public setConstructorMethod(constructorMethod: PullSymbol): void {
            this._constructorMethod = constructorMethod;
        }

        public getTypeParameters(): PullTypeParameterSymbol[] {
            if (!this._typeParameters) {
                return sentinelEmptyArray;
            }

            return this._typeParameters;
        }

        public getAllowedToReferenceTypeParameters(): PullTypeParameterSymbol[] {
            if (!!(this.kind && PullElementKind.SomeInstantiatableType) && this.isNamedTypeSymbol() && !this.isTypeParameter()) {
                return this.getTypeParameters();
            }

            if (!this._allowedToReferenceTypeParameters) {
                // If the type is not named, it cannot have its own type parameters
                // But it can refer to typeParameters from enclosing type
                this._allowedToReferenceTypeParameters = PullInstantiationHelpers.getAllowedToReferenceTypeParametersFromDecl(this.getDeclarations()[0], this.semanticInfoChain);
            }

            return this._allowedToReferenceTypeParameters;
        }

        // GTODO
        public isGeneric(): boolean {
            return (this._typeParameters && this._typeParameters.length > 0) ||
                this._hasGenericSignature ||
                this._hasGenericMember ||
                this.isArrayNamedTypeReference();
        }

        private canUseSimpleInstantiationCache(typeArgumentMap: TypeSubstitutionMap): boolean {
            if (this.isTypeParameter()) {
                return true;
            }

            var typeParameters = this.getTypeParameters();
            return typeArgumentMap && this.isNamedTypeSymbol() && typeParameters.length === 1 && typeArgumentMap[typeParameters[0].pullSymbolID].kind !== PullElementKind.ObjectType;
        }

        private getSimpleInstantiationCacheId(typeArgumentMap: TypeSubstitutionMap) {
            return typeArgumentMap[this.getTypeParameters()[0].pullSymbolID].pullSymbolID;
        }

        public addSpecialization(specializedVersionOfThisType: PullTypeSymbol, typeArgumentMap: TypeSubstitutionMap): void {
            if (this.canUseSimpleInstantiationCache(typeArgumentMap)) {
                if (!this._simpleInstantiationCache) {
                    this._simpleInstantiationCache = [];
                }

                this._simpleInstantiationCache[this.getSimpleInstantiationCacheId(typeArgumentMap)] = specializedVersionOfThisType;
            }
            else {
                if (!this._complexInstantiationCache) {
                    this._complexInstantiationCache = createIntrinsicsObject<PullTypeSymbol>();
                }

                this._complexInstantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)] = specializedVersionOfThisType;
            }

            if (!this._specializedVersionsOfThisType) {
                this._specializedVersionsOfThisType = [];
            }

            this._specializedVersionsOfThisType.push(specializedVersionOfThisType);
        }

        public getSpecialization(typeArgumentMap: TypeSubstitutionMap): PullTypeSymbol {
            if (this.canUseSimpleInstantiationCache(typeArgumentMap)) {
                if (!this._simpleInstantiationCache) {
                    return null;
                }

                var result = this._simpleInstantiationCache[this.getSimpleInstantiationCacheId(typeArgumentMap)];
                return result || null;
            }
            else {
                if (!this._complexInstantiationCache) {
                    return null;
                }

                if (this.getAllowedToReferenceTypeParameters().length == 0) {
                    return this;
                }

                var result = this._complexInstantiationCache[getIDForTypeSubstitutions(this, typeArgumentMap)];
                return result || null;
            }
        }

        public getKnownSpecializations(): PullTypeSymbol[] {
            if (!this._specializedVersionsOfThisType) {
                return sentinelEmptyArray;
            }

            return this._specializedVersionsOfThisType;
        }

        // GTODO
        public getTypeArguments(): PullTypeSymbol[] {
            return null;
        }

        public getTypeArgumentsOrTypeParameters(): PullTypeSymbol[] {
            return this.getTypeParameters();
        }

        private addCallOrConstructSignaturePrerequisiteBase(signature: PullSignatureSymbol): void {
            if (signature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            signature.functionType = this;
        }

        private addCallSignaturePrerequisite(callSignature: PullSignatureSymbol): void {
            if (!this._callSignatures) {
                this._callSignatures = [];
            }

            this.addCallOrConstructSignaturePrerequisiteBase(callSignature);
        }

        public appendCallSignature(callSignature: PullSignatureSymbol): void {
            this.addCallSignaturePrerequisite(callSignature);
            this._callSignatures.push(callSignature);
        }

        public insertCallSignatureAtIndex(callSignature: PullSignatureSymbol, index: number): void {
            this.addCallSignaturePrerequisite(callSignature);
            Debug.assert(index <= this._callSignatures.length);
            if (index === this._callSignatures.length) {
                this._callSignatures.push(callSignature);
            }
            else {
                this._callSignatures.splice(index, /*deleteCount*/ 0, callSignature);
            }
        }

        private addConstructSignaturePrerequisite(constructSignature: PullSignatureSymbol): void {
            if (!this._constructSignatures) {
                this._constructSignatures = [];
            }

            this.addCallOrConstructSignaturePrerequisiteBase(constructSignature);
        }

        public appendConstructSignature(constructSignature: PullSignatureSymbol): void {
            this.addConstructSignaturePrerequisite(constructSignature);
            this._constructSignatures.push(constructSignature);
        }

        public insertConstructSignatureAtIndex(constructSignature: PullSignatureSymbol, index: number): void {
            this.addConstructSignaturePrerequisite(constructSignature);
            Debug.assert(index <= this._constructSignatures.length);
            if (index === this._constructSignatures.length) {
                this._constructSignatures.push(constructSignature);
            }
            else {
                this._constructSignatures.splice(index, /*deleteCount*/ 0, constructSignature);
            }
        }

        public addIndexSignature(indexSignature: PullSignatureSymbol): void {
            if (!this._indexSignatures) {
                this._indexSignatures = [];
            }

            this._indexSignatures[this._indexSignatures.length] = indexSignature;

            if (indexSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            indexSignature.functionType = this;
        }

        public hasOwnCallSignatures(): boolean {
            return this._callSignatures !== null;
        }

        public getOwnCallSignatures(): PullSignatureSymbol[] {
            return this._callSignatures || sentinelEmptyArray;
        }

        public getCallSignatures(): PullSignatureSymbol[] {
            if (this._allCallSignatures) {
                return this._allCallSignatures;
            }

            var signatures: PullSignatureSymbol[] = [];

            if (this._callSignatures) {
                signatures = signatures.concat(this._callSignatures);
            }

            // Check for inherited call signatures
            // Only interfaces can inherit call signatures
            if (this._extendedTypes && this.kind === PullElementKind.Interface) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    // October 16, 2013: Section 7.1:
                    // A call signature declaration hides a base type call signature that is
                    // identical when return types are ignored.
                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._callSignatures, this._extendedTypes[i].getCallSignatures(), signatures);
                }
            }

            this._allCallSignatures = signatures;

            return signatures;
        }

        public hasOwnConstructSignatures(): boolean {
            return this._constructSignatures !== null;
        }

        public getOwnDeclaredConstructSignatures(): PullSignatureSymbol[] {
            return this._constructSignatures || sentinelEmptyArray;
        }

        public getConstructSignatures(): PullSignatureSymbol[]{
            if (this._allConstructSignatures) {
                return this._allConstructSignatures;
            }

            var signatures: PullSignatureSymbol[] = [];

            if (this._constructSignatures) {
                signatures = signatures.concat(this._constructSignatures);
            }
            else if (this.isConstructor()) {
                if (this._extendedTypes && this._extendedTypes.length > 0) {
                    signatures = this.getBaseClassConstructSignatures(this._extendedTypes[0]);
                }
                else {
                    signatures = [this.getDefaultClassConstructSignature()];
                }
            }

            // If it's a constructor type, we don't inherit construct signatures
            // (E.g., we'd be looking at the statics on a class, where we want
            // to inherit members, but not construct signatures
            if (this._extendedTypes && this.kind === PullElementKind.Interface) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    // October 16, 2013: Section 7.1:
                    // A construct signature declaration hides a base type construct signature that is
                    // identical when return types are ignored.
                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._constructSignatures, this._extendedTypes[i].getConstructSignatures(), signatures);
                }
            }

            this._allConstructSignatures = signatures;

            return signatures;
        }

        public hasOwnIndexSignatures(): boolean {
            return this._indexSignatures !== null;
        }

        public getOwnIndexSignatures(): PullSignatureSymbol[] {
            return this._indexSignatures || sentinelEmptyArray;
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            if (this._allIndexSignatures) {
                return this._allIndexSignatures;
            }

            var signatures: PullSignatureSymbol[] = [];

            if (this._indexSignatures) {
                signatures = signatures.concat(this._indexSignatures);
            }

            if (this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    // October 16, 2013: Section 7.1:
                    // A string index signature declaration hides a base type string index signature.
                    // A numeric index signature declaration hides a base type numeric index signature.
                    this._getResolver()._addUnhiddenSignaturesFromBaseType(this._indexSignatures, this._extendedTypes[i].getIndexSignatures(), signatures);
                }
            }

            this._allIndexSignatures = signatures;

            return signatures;
        }

        // The augmented form of an object type T adds to T those members of the global interface
        // type 'Object' that aren't hidden by members in T. Furthermore, if T has one or more call
        // or construct signatures, the augmented form of T adds to T the members of the global 
        // interface type 'Function' that aren't hidden by members in T. Members in T hide 'Object'
        // or 'Function' interface members in the following manner:
        // ...
        // An index signature hides an 'Object' or 'Function' index signature with the same parameter type.
        public getIndexSignaturesOfAugmentedType(resolver: PullTypeResolver, globalFunctionInterface: PullTypeSymbol, globalObjectInterface: PullTypeSymbol): PullSignatureSymbol[] {
            if (!this._allIndexSignaturesOfAugmentedType) {
                // Start with the types own and inherited index signatures
                var initialIndexSignatures = this.getIndexSignatures();
                var shouldAddFunctionSignatures = false;
                var shouldAddObjectSignatures = false;

                if (globalFunctionInterface && this.isFunctionType() && this !== globalFunctionInterface) {
                    var functionIndexSignatures = globalFunctionInterface.getIndexSignatures();
                    if (functionIndexSignatures.length) {
                        shouldAddFunctionSignatures = true;
                    }
                }

                if (globalObjectInterface && this !== globalObjectInterface) {
                    var objectIndexSignatures = globalObjectInterface.getIndexSignatures();
                    if (objectIndexSignatures.length) {
                        shouldAddObjectSignatures = true;
                    }
                }

                // The 'then' block of this conditional should almost never be entered, since
                // Object and Function in lib.d.ts have no index signatures. This could only
                // happen if the user has added index signatures to Object or Function.
                if (shouldAddFunctionSignatures || shouldAddObjectSignatures) {
                    // First, copy the existing signatures into a new array
                    // .slice(0) is an idiom for copying
                    this._allIndexSignaturesOfAugmentedType = initialIndexSignatures.slice(0);
                    if (shouldAddFunctionSignatures) {
                        // The following call mutates this._allIndexSignaturesOfAugmentedType
                        resolver._addUnhiddenSignaturesFromBaseType(initialIndexSignatures, functionIndexSignatures, this._allIndexSignaturesOfAugmentedType);
                    }
                    if (shouldAddObjectSignatures) {
                        if (shouldAddFunctionSignatures) {
                            // Concat function index signatures to make sure we don't add object signatures
                            // hidden by function signatures.
                            initialIndexSignatures = initialIndexSignatures.concat(functionIndexSignatures);
                        }
                        resolver._addUnhiddenSignaturesFromBaseType(initialIndexSignatures, objectIndexSignatures, this._allIndexSignaturesOfAugmentedType);
                    }
                }
                else {
                    this._allIndexSignaturesOfAugmentedType = initialIndexSignatures;
                }
            }

            return this._allIndexSignaturesOfAugmentedType;
        }

        private getBaseClassConstructSignatures(baseType: PullTypeSymbol): PullSignatureSymbol[] {
            Debug.assert(this.isConstructor() && baseType.isConstructor());
            var instanceTypeSymbol = this.getAssociatedContainerType();
            Debug.assert(instanceTypeSymbol.getDeclarations().length === 1);
            if (baseType.hasBase(this)) {
                return null;
            }

            var baseConstructSignatures = baseType.getConstructSignatures();
            var signatures: PullSignatureSymbol[] = [];
            for (var i = 0; i < baseConstructSignatures.length; i++) {
                var baseSignature = baseConstructSignatures[i];
                // Make sure the base signature is resolved, so that the parameter symbols from the new 
                // siganture are used, they will have the type associated with them. 
                baseSignature._resolveDeclaredSymbol();
                var currentSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature, this.semanticInfoChain, baseSignature.isDefinition());
                currentSignature.returnType = instanceTypeSymbol;
                currentSignature.addTypeParametersFromReturnType();
                for (var j = 0; j < baseSignature.parameters.length; j++) {
                    currentSignature.addParameter(baseSignature.parameters[j], baseSignature.parameters[j].isOptional);
                }
                if (baseSignature.parameters.length > 0) {
                    currentSignature.hasVarArgs = baseSignature.parameters[baseSignature.parameters.length - 1].isVarArg;
                }

                // Assume the class has only one decl, since it can't mix with anything
                currentSignature.addDeclaration(instanceTypeSymbol.getDeclarations()[0]);
                this.addCallOrConstructSignaturePrerequisiteBase(currentSignature);
                signatures.push(currentSignature);
            }

            return signatures;
        }

        private getDefaultClassConstructSignature(): PullSignatureSymbol {
            Debug.assert(this.isConstructor());
            var instanceTypeSymbol = this.getAssociatedContainerType();
            Debug.assert(instanceTypeSymbol.getDeclarations().length == 1);
            var signature = new PullSignatureSymbol(PullElementKind.ConstructSignature, this.semanticInfoChain, /*isDefinition*/ true);
            signature.returnType = instanceTypeSymbol;
            signature.addTypeParametersFromReturnType();
            signature.addDeclaration(instanceTypeSymbol.getDeclarations()[0]);
            this.addCallOrConstructSignaturePrerequisiteBase(signature);

            return signature;
        }

        public addImplementedType(implementedType: PullTypeSymbol): void {
            if (!implementedType) {
                return;
            }

            if (!this._implementedTypes) {
                this._implementedTypes = [];
            }

            this._implementedTypes[this._implementedTypes.length] = implementedType;

            implementedType.addTypeThatExplicitlyImplementsThisType(this);
        }

        public getImplementedTypes(): PullTypeSymbol[] {
            if (!this._implementedTypes) {
                return sentinelEmptyArray;
            }

            return this._implementedTypes;
        }

        public addExtendedType(extendedType: PullTypeSymbol): void {
            if (!extendedType) {
                return;
            }

            if (!this._extendedTypes) {
                this._extendedTypes = [];
            }

            this._extendedTypes[this._extendedTypes.length] = extendedType;

            extendedType.addTypeThatExtendsThisType(this);
        }

        public getExtendedTypes(): PullTypeSymbol[] {
            if (!this._extendedTypes) {
                return sentinelEmptyArray;
            }

            return this._extendedTypes;
        }

        public addTypeThatExtendsThisType(type: PullTypeSymbol): void {
            if (!type) {
                return;
            }

            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            this._typesThatExtendThisType[this._typesThatExtendThisType.length] = type;
        }

        public getTypesThatExtendThisType(): PullTypeSymbol[] {
            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            return this._typesThatExtendThisType;
        }

        public addTypeThatExplicitlyImplementsThisType(type: PullTypeSymbol): void {
            if (!type) {
                return;
            }

            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            this._typesThatExplicitlyImplementThisType[this._typesThatExplicitlyImplementThisType.length] = type;
        }

        public getTypesThatExplicitlyImplementThisType(): PullTypeSymbol[] {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExplicitlyImplementThisType;
        }

        public hasBase(potentialBase: PullTypeSymbol, visited: PullSymbol[]= []): boolean {
            // Check if this is the potential base:
            //      A extends A  => this === potentialBase
            //      A<T> extends A<T>  => this.getRootSymbol() === potentialBase
            //      A<T> extends A<string> => this === potentialBase.getRootSymbol()
            if (this === potentialBase || this.getRootSymbol() === potentialBase || this === potentialBase.getRootSymbol()) {
                return true;
            }

            if (ArrayUtilities.contains(visited, this)) {
                return true;
            }

            visited.push(this);

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            // Clean the list if we are returning false to ensure we are not leaving symbols that 
            // were not in the path. No need to do that if we return true, as that will short circuit
            // the search
            visited.pop();

            return false;
        }

        public isValidBaseKind(baseType: PullTypeSymbol, isExtendedType: boolean): boolean {
            // Error type symbol is invalid base kind
            if (baseType.isError()) {
                return false;
            }

            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    // Class extending non class Type is invalid
                    return baseType.kind === PullElementKind.Class;
                }
            }
            else {
                if (!thisIsClass) {
                    // Interface implementing baseType is invalid
                    return false;
                }
            }

            // Interface extending non interface or class 
            // or class implementing non interface or class - are invalid
            return !!(baseType.kind & (PullElementKind.Interface | PullElementKind.Class));
        }

        public findMember(name: string, lookInParent: boolean): PullSymbol {
            var memberSymbol: PullSymbol = null;

            if (this._memberNameCache) {
                memberSymbol = this._memberNameCache[name];
            }

            if (memberSymbol || !lookInParent) {
                return memberSymbol;
            }

            // check parents
            if (this._extendedTypes) {

                for (var i = 0; i < this._extendedTypes.length; i++) {
                    memberSymbol = this._extendedTypes[i].findMember(name, lookInParent);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            return null;
        }

        public findNestedType(name: string, kind = PullElementKind.None): PullTypeSymbol {
            var memberSymbol: PullTypeSymbol;

            if (!this._enclosedTypeNameCache) {
                return null;
            }

            memberSymbol = this._enclosedTypeNameCache[name];

            if (memberSymbol && kind !== PullElementKind.None) {
                memberSymbol = hasFlag(memberSymbol.kind, kind) ? memberSymbol : null;
            }

            return memberSymbol;
        }

        public findNestedContainer(name: string, kind = PullElementKind.None): PullTypeSymbol {
            var memberSymbol: PullTypeSymbol;

            if (!this._enclosedContainerCache) {
                return null;
            }

            memberSymbol = this._enclosedContainerCache[name];

            if (memberSymbol && kind !== PullElementKind.None) {
                memberSymbol = hasFlag(memberSymbol.kind, kind) ? memberSymbol : null;
            }

            return memberSymbol;
        }

        public getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): PullSymbol[] {

            var allMembers: PullSymbol[] = [];

            // Add members
            if (this._members !== sentinelEmptyArray) {

                for (var i = 0, n = this._members.length; i < n; i++) {
                    var member = this._members[i];
                    if ((member.kind & searchDeclKind) && (memberVisiblity !== GetAllMembersVisiblity.externallyVisible || !member.anyDeclHasFlag(PullElementFlags.Private))) {
                        allMembers[allMembers.length] = member;
                    }
                }
            }

            // Add parent members
            if (this._extendedTypes) {
                // Do not look for the parent's private members unless we need to enumerate all members
                var extenedMembersVisibility = memberVisiblity !== GetAllMembersVisiblity.all ? GetAllMembersVisiblity.externallyVisible : GetAllMembersVisiblity.all;

                for (var i = 0, n = this._extendedTypes.length; i < n; i++) {
                    var extendedMembers = this._extendedTypes[i].getAllMembers(searchDeclKind, /*memberVisiblity*/ extenedMembersVisibility);

                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!(this._memberNameCache && this._memberNameCache[extendedMember.name])) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            if (this.isContainer()) {
                if (this._enclosedMemberTypes) {
                    for (var i = 0; i < this._enclosedMemberTypes.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberTypes[i];
                    }
                }
                if (this._enclosedMemberContainers) {
                    for (var i = 0; i < this._enclosedMemberContainers.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberContainers[i];
                    }
                }
            }

            return allMembers;
        }

        public findTypeParameter(name: string): PullTypeParameterSymbol {
            if (!this._typeParameterNameCache) {
                return null;
            }

            return this._typeParameterNameCache[name];
        }

        public setResolved(): void {
            super.setResolved();
        }

        public getNamePartForFullName(): string {
            var name = super.getNamePartForFullName();

            var typars = this.getTypeArgumentsOrTypeParameters();
            var typarString = PullSymbol.getTypeParameterString(typars, this, /*useConstraintInName:*/ true);
            return name + typarString;
        }

        public getScopedName(scopeSymbol?: PullSymbol, skipTypeParametersInName?: boolean, useConstraintInName?: boolean, skipInternalAliasName?: boolean): string {
            return this.getScopedNameEx(scopeSymbol, skipTypeParametersInName, useConstraintInName, /*getPrettyTypeName*/ false, /*getTypeParamMarkerInfskipInternalAliasName*/ false, skipInternalAliasName).toString();
        }

        public isNamedTypeSymbol(): boolean {
            var kind = this.kind;
            if (kind === PullElementKind.Primitive || // primitives
                kind === PullElementKind.Class || // class
                kind === PullElementKind.Container || // module
                kind === PullElementKind.DynamicModule || // dynamic module
                kind === PullElementKind.TypeAlias || // dynamic module
                kind === PullElementKind.Enum || // enum
                kind === PullElementKind.TypeParameter || //TypeParameter
                ((kind === PullElementKind.Interface || kind === PullElementKind.ObjectType) && this.name !== "")) {
                return true;
            }

            return false;
        }

        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            var s = this.getScopedNameEx(scopeSymbol, /*skipTypeParametersInName*/ false, useConstraintInName).toString();
            return s;
        }

        public getScopedNameEx(
            scopeSymbol?: PullSymbol,
            skipTypeParametersInName?: boolean,
            useConstraintInName?: boolean,
            getPrettyTypeName?: boolean,
            getTypeParamMarkerInfo?: boolean,
            skipInternalAliasName?: boolean,
            shouldAllowArrayType: boolean = true): MemberName {

            if (this.isArrayNamedTypeReference() && shouldAllowArrayType) {
                var elementType = this.getElementType();
                var elementMemberName = elementType ?
                    (elementType.isArrayNamedTypeReference() || elementType.isNamedTypeSymbol() ?
                    elementType.getScopedNameEx(
                        scopeSymbol,
                        /*skipTypeParametersInName*/ false,
                        /*useConstraintInName*/ false,
                        getPrettyTypeName,
                        getTypeParamMarkerInfo,
                        skipInternalAliasName) :
                    elementType.getMemberTypeNameEx(/*topLevel*/ false, scopeSymbol, getPrettyTypeName)) :
                    MemberName.create("any");
                return MemberName.create(elementMemberName, "", "[]");
            }

            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(/*topLevel*/ true, scopeSymbol, getPrettyTypeName);
            }

            if (skipTypeParametersInName) {
                return MemberName.create(super.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName));
            }
            else {
                var builder = new MemberNameArray();
                builder.prefix = super.getScopedName(scopeSymbol, skipTypeParametersInName, useConstraintInName, skipInternalAliasName);

                var typars = this.getTypeArgumentsOrTypeParameters();
                builder.add(PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName));

                return builder;
            }
        }

        public hasOnlyOverloadCallSignatures(): boolean {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        }

        public getTypeOfSymbol() {
            // typeof Module/Class/Enum
            var associatedContainerType = this.getAssociatedContainerType();
            if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                return associatedContainerType;
            }

            // typeof Function
            var functionSymbol = this.getFunctionSymbol();
            if (functionSymbol && functionSymbol.kind === PullElementKind.Function && !PullHelpers.isSymbolLocal(functionSymbol)) {
                // workaround for missing 'bindAllDeclsInOrder' for classes: do not return typeof symbol for functions defined in module part of clodules (they are considered non-local)
                return PullHelpers.isExportedSymbolInClodule(functionSymbol) ? null : functionSymbol;
            }

            return null;
        }

        private getMemberTypeNameEx(topLevel: boolean, scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean): MemberName {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            var typeOfSymbol = this.getTypeOfSymbol();
            if (typeOfSymbol) {
                var nameForTypeOf = typeOfSymbol.getScopedNameEx(scopeSymbol, /*skipTypeParametersInName*/ true);
                return MemberName.create(nameForTypeOf, "typeof ", "");
            }

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                if (this._inMemberTypeNameEx) {
                    // If recursive without type name possible if function expression type
                    return MemberName.create("any");
                }

                this._inMemberTypeNameEx = true;

                var allMemberNames = new MemberNameArray();
                var curlies = !topLevel || indexSignatures.length !== 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    if (members[i].kind === PullElementKind.Method && members[i].type.hasOnlyOverloadCallSignatures()) {
                        // Add all Call signatures of the method
                        var methodCallSignatures = members[i].type.getCallSignatures();
                        var nameStr = members[i].getDisplayName(scopeSymbol) + (members[i].isOptional ? "?" : "");;
                        var methodMemberNames = PullSignatureSymbol.getSignaturesTypeNameEx(methodCallSignatures, nameStr, /*shortform*/ false, /*brackets*/ false, scopeSymbol);
                        allMemberNames.addAll(methodMemberNames);
                    }
                    else {
                        var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                        if (memberTypeName.isArray() && (<MemberNameArray>memberTypeName).delim === delim) {
                            allMemberNames.addAll((<MemberNameArray>memberTypeName).entries);
                        }
                        else {
                            allMemberNames.add(memberTypeName);
                        }
                    }
                    curlies = true;
                }

                // Use pretty Function overload signature if this is just a call overload
                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                var useShortFormSignature = !curlies && (signatureCount === 1);
                var signatureMemberName: MemberName[];

                if (callSignatures.length > 0) {
                    signatureMemberName =
                    PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, /*prefix*/ "", useShortFormSignature, /*brackets*/ false, scopeSymbol, getPrettyFunctionOverload);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (constructSignatures.length > 0) {
                    signatureMemberName =
                    PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, /*brackets*/ false, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (indexSignatures.length > 0) {
                    signatureMemberName =
                    PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, /*prefix*/ "", useShortFormSignature, /*brackets*/ true, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                    allMemberNames.prefix = "{ ";
                    allMemberNames.suffix = "}";
                    allMemberNames.delim = delim;
                }
                else if (allMemberNames.entries.length > 1) {
                    allMemberNames.delim = delim;
                }

                this._inMemberTypeNameEx = false;

                return allMemberNames;

            }

            return MemberName.create("{}");
        }

        public getGenerativeTypeClassification(enclosingType: PullTypeSymbol): GenerativeTypeClassification {
            return GenerativeTypeClassification.Closed;
        }

        // REVIEW: Should cache these checks

        // The argument map prevents us from accidentally flagging method type parameters, or (if we
        // ever decide to go that route) allows for partial specialization
        public wrapsSomeTypeParameter(typeParameterArgumentMap: CandidateInferenceInfo[]): boolean;
        public wrapsSomeTypeParameter(typeParameterArgumentMap: TypeSubstitutionMap, skipTypeArgumentCheck?: boolean): boolean;
        public wrapsSomeTypeParameter(typeParameterArgumentMap: any[], skipTypeArgumentCheck?: boolean): boolean {
            return this.getWrappingTypeParameterID(typeParameterArgumentMap, skipTypeArgumentCheck) != 0;
        }

        // 0 means there was no type parameter ID wrapping
        // otherwise typeParameterID that was wrapped
        // 
        // While it would be intuitive to return a boolean, this actually doesn't work
        // for the WrapsTypeParameterCache. See the comment at the top of the WrapsTypeParameterCache
        // class for an explanation.
        public getWrappingTypeParameterID(typeParameterArgumentMap: TypeSubstitutionMap, skipTypeArgumentCheck?: boolean): number {
            // if we encounter a type parameter, we're obviously wrapping
            if (this.isTypeParameter()) {
                if (typeParameterArgumentMap[this.pullSymbolID] || typeParameterArgumentMap[this.getRootSymbol().pullSymbolID]) {
                    return this.pullSymbolID;
                }
            }

            // Note here that we do NOT check the type parameter's constraint. If we did, we would
            // think that any reference to the type parameter wraps something if its constraint does.
            // Instead, the containing signature is responsible for checking if the constraint wraps.
            // For example, consider the following type:
            //
            // interface A<S> {
            //     foo: S;
            // }
            //
            // interface B<T> {
            //     <U extends T>(x: A<U>);
            // }
            //
            // The type reference A<U> does not wrap T. If we checked the constraint here, we would
            // return true for that. However, the signature <U extends T>(x: A<U>); does indeed wrap
            // T.

            if (this.inWrapCheck) {
                return 0;
            }

            // Find result from cache
            this._wrapsTypeParameterCache = this._wrapsTypeParameterCache || new WrapsTypeParameterCache();
            var wrappingTypeParameterID = this._wrapsTypeParameterCache.getWrapsTypeParameter(typeParameterArgumentMap);
            if (wrappingTypeParameterID === undefined) {
                this.inWrapCheck = true;
                wrappingTypeParameterID = this.getWrappingTypeParameterIDWorker(typeParameterArgumentMap, skipTypeArgumentCheck);
                this.inWrapCheck = false;
                // Update the cache
                this._wrapsTypeParameterCache.setWrapsTypeParameter(typeParameterArgumentMap, wrappingTypeParameterID);
            }
            return wrappingTypeParameterID;
        }

        private getWrappingTypeParameterIDWorker(typeParameterArgumentMap: TypeSubstitutionMap, skipTypeArgumentCheck: boolean): number {
            var wrappingTypeParameterID = 0;

            if (!skipTypeArgumentCheck) {
                var typeArguments = this.getTypeArguments();

                // If there are no type arguments, we could be instantiating the 'root' type
                // declaration
                if (this.isGeneric() && !typeArguments) {
                    typeArguments = this.getTypeParameters();
                }

                // if it's a generic type, scan the type arguments to see which may wrap type parameters
                if (typeArguments) {
                    for (var i = 0; !wrappingTypeParameterID && i < typeArguments.length; i++) {
                        wrappingTypeParameterID = typeArguments[i].getWrappingTypeParameterID(typeParameterArgumentMap);
                        if (wrappingTypeParameterID !== 0) {
                            return wrappingTypeParameterID;
                        }
                    }
                }
            }

            // if it's not a named type, we'll need to introspect its member list
            if (skipTypeArgumentCheck || !(this.kind & PullElementKind.SomeInstantiatableType) || !this.name) {
                // otherwise, walk the member list and signatures, checking for wraps
                var members = this.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all);
                for (var i = 0; i < members.length; i++) {
                    PullHelpers.resolveDeclaredSymbolToUseType(members[i]);
                    wrappingTypeParameterID = members[i].type.getWrappingTypeParameterID(typeParameterArgumentMap);
                    if (wrappingTypeParameterID !== 0) {
                        return wrappingTypeParameterID;
                    }
                }

                // We are ORing numbers here, which means that if any invocation returns 0, we will proceed to the next
                // signature group.
                return this.getWrappingTypeParameterIDFromSignatures(this.getCallSignatures(), typeParameterArgumentMap)
                    || this.getWrappingTypeParameterIDFromSignatures(this.getConstructSignatures(), typeParameterArgumentMap)
                    || this.getWrappingTypeParameterIDFromSignatures(this.getIndexSignatures(), typeParameterArgumentMap);
            }

            return 0;
        }

        private getWrappingTypeParameterIDFromSignatures(signatures: PullSignatureSymbol[], typeParameterArgumentMap: TypeSubstitutionMap): number {
            for (var i = 0; i < signatures.length; i++) {
                var wrappingTypeParameterID = signatures[i].getWrappingTypeParameterID(typeParameterArgumentMap);
                if (wrappingTypeParameterID !== 0) {
                    return wrappingTypeParameterID;
                }
            }

            return 0;
        }


        // Detect if a type parameter is wrapped in a wrapped form that generates infinite expansion.  E.g., for 'T'
        //  class C<T> {
        //      p1: T; <- no
        //      p2: C<T>; <- no
        //      p3: C<C<T>> <- yes
        //  }
        public wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType: PullTypeSymbol) {
            // Only named types can form infinite expansion
            Debug.assert(this.isNamedTypeSymbol());
            Debug.assert(PullHelpers.getRootType(enclosingType) == enclosingType); // Enclosing type passed has to be the root symbol
            var knownWrapMap = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ true);
            var wrapsIntoInfinitelyExpandingTypeReference =
                this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType, knownWrapMap);
            knownWrapMap.release();
            return wrapsIntoInfinitelyExpandingTypeReference;
        }

        public _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix): boolean {
            var wrapsIntoInfinitelyExpandingTypeReference = knownWrapMap.valueAt(this.pullSymbolID, enclosingType.pullSymbolID);
            if (wrapsIntoInfinitelyExpandingTypeReference != undefined) {
                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            if (this.inWrapInfiniteExpandingReferenceCheck) {
                return false;
            }

            this.inWrapInfiniteExpandingReferenceCheck = true;
            wrapsIntoInfinitelyExpandingTypeReference =
                this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType, knownWrapMap);
            knownWrapMap.setValueAt(this.pullSymbolID, enclosingType.pullSymbolID, wrapsIntoInfinitelyExpandingTypeReference);
            this.inWrapInfiniteExpandingReferenceCheck = false;

            return wrapsIntoInfinitelyExpandingTypeReference;
        }

        private _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix) {

            var thisRootType = PullHelpers.getRootType(this);


            if (thisRootType != enclosingType) {
                var thisIsNamedType = this.isNamedTypeSymbol();

                if (thisIsNamedType) {
                    if (thisRootType.inWrapInfiniteExpandingReferenceCheck) {
                        // No need to iterating members of the type again if we are checking members of some 
                        // version of this type
                        return false;
                    }

                    thisRootType.inWrapInfiniteExpandingReferenceCheck = true;
                }

                var wrapsIntoInfinitelyExpandingTypeReference = this._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceStructure(
                    enclosingType, knownWrapMap);

                if (thisIsNamedType) {
                    thisRootType.inWrapInfiniteExpandingReferenceCheck = false;
                }

                return wrapsIntoInfinitelyExpandingTypeReference;
            }

            // Spec section 3.8.7: Recursive Types
            // A type reference which, directly or indirectly, references G through open type references and 
            // which contains a wrapped form of any of Gs type parameters in one or more type arguments is classified
            // as an infinitely expanding type reference.A type is said to wrap a type parameter if it references 
            // the type parameter but isnt simply the type parameter itself.
            var enclosingTypeParameters = enclosingType.getTypeParameters();
            var typeArguments = this.getTypeArguments();
            for (var i = 0; i < typeArguments.length; i++) {
                if (ArrayUtilities.contains(enclosingTypeParameters, typeArguments[i])) {
                    // Just a reference to type parameter
                    continue;
                }

                // Type arguments wraps type parameter
                if (typeArguments[i].wrapsSomeTypeParameter((<InstantiatedTypeReferenceSymbol>this).getTypeParameterSubstitutionMap())) {
                    return true;
                }
            }

            return false;
        }

        private _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceStructure(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix) {
            var members = this.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all);
            for (var i = 0; i < members.length; i++) {
                if (members[i].type && members[i].type._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(
                    enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            var sigs = this.getCallSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            sigs = this.getConstructSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            sigs = this.getIndexSignatures();
            for (var i = 0; i < sigs.length; i++) {
                if (sigs[i]._wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType, knownWrapMap)) {
                    return true;
                }
            }

            return false;
        }

        // This is the same signature as PullTypeResolver.widenType (except that the positions
        // of the resolver are switched). This method just returns the cached value of the widened
        // type, otherwise, calls into the resolver.
        public widenedType(resolver: PullTypeResolver, ast: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            if (!this._widenedType) {
                this._widenedType = resolver.widenType(this, ast, context);
            }
            return this._widenedType;
        }
    }

    export class PullPrimitiveTypeSymbol extends PullTypeSymbol {
        constructor(name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, PullElementKind.Primitive, semanticInfoChain);

            this.isResolved = true;
        }

        public isAny(): boolean {
            return !this.isStringConstant() && this.name === "any";
        }

        public isNull(): boolean {
            return !this.isStringConstant() && this.name === "null";
        }

        public isUndefined(): boolean {
            return !this.isStringConstant() && this.name === "undefined";
        }

        public isStringConstant() { return false; }

        public setUnresolved() {
            // do nothing...
        }

        // Overrides the PullSymbol.getDisplayName to give the appearance of widening. The spec
        // doesn't say anything about displaying types, but we should leave no trace of undefined
        // or null.
        public getDisplayName() {
            if (this.isNull() || this.isUndefined()) {
                return "any";
            }
            else {
                return super.getDisplayName();
            }
        }
    }

    export class PullStringConstantTypeSymbol extends PullPrimitiveTypeSymbol {
        constructor(name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, semanticInfoChain);
        }

        public isStringConstant() {
            return true;
        }
    }

    export class PullErrorTypeSymbol extends PullPrimitiveTypeSymbol {

        constructor(public _anyType: PullTypeSymbol, name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, semanticInfoChain);

            Debug.assert(this._anyType);
            this.isResolved = true;
        }

        public isError() {
            return true;
        }

        public _getResolver(): PullTypeResolver {
            return this._anyType._getResolver();
        }

        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        }

        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, skipInternalAliasName?: boolean): string {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        }

        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean) {
            return this._anyType.getName(scopeSymbol, useConstraintInName);
        }
    }

    // represents the module "namespace" type
    export class PullContainerSymbol extends PullTypeSymbol {
        public instanceSymbol: PullSymbol = null;

        private assignedValue: PullSymbol = null;
        private assignedType: PullTypeSymbol = null;
        private assignedContainer: PullContainerSymbol = null;

        constructor(name: string, kind: PullElementKind, semanticInfoChain: SemanticInfoChain) {
            super(name, kind, semanticInfoChain);
        }

        public isContainer() { return true; }

        public setInstanceSymbol(symbol: PullSymbol) {
            this.instanceSymbol = symbol;
        }

        public getInstanceSymbol(): PullSymbol {
            return this.instanceSymbol;
        }

        public setExportAssignedValueSymbol(symbol: PullSymbol) {
            this.assignedValue = symbol;
        }

        public getExportAssignedValueSymbol() {
            return this.assignedValue;
        }

        public setExportAssignedTypeSymbol(type: PullTypeSymbol) {
            this.assignedType = type;
        }

        public getExportAssignedTypeSymbol() {
            return this.assignedType;
        }

        public setExportAssignedContainerSymbol(container: PullContainerSymbol) {
            this.assignedContainer = container;
        }

        public getExportAssignedContainerSymbol() {
            return this.assignedContainer;
        }

        public hasExportAssignment() {
            return !!this.assignedValue || !!this.assignedType || !!this.assignedContainer;
        }

        // Determine if 'symbol' is used as containerSymbol
        static usedAsSymbol(containerSymbol: PullSymbol, symbol: PullSymbol): boolean {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }

            if (!containerSymbol.isAlias() && containerSymbol.type === symbol) {
                return true;
            }

            var moduleSymbol = <PullContainerSymbol>containerSymbol;
            var valueExportSymbol = moduleSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = moduleSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = moduleSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                // If the container symbol has export assignment then 'symbol' is used as containerSymbol if
                // any of export assigned symbol is same as 'symbol'
                if (valueExportSymbol === symbol
                    || typeExportSymbol == symbol
                    || containerExportSymbol == symbol) {
                    return true;
                }

                // If the container symbol doesnt export itself, check if export assigned container symbol is used as 'symbol'
                if (containerExportSymbol != containerSymbol) {
                    return PullContainerSymbol.usedAsSymbol(containerExportSymbol, symbol);
                }
            }

            return false;
        }

        public getInstanceType() {
            return this.instanceSymbol ? this.instanceSymbol.type : null;
        }
    }

    export class PullTypeAliasSymbol extends PullTypeSymbol {
        private _assignedValue: PullSymbol = null;
        private _assignedType: PullTypeSymbol = null;
        private _assignedContainer: PullContainerSymbol = null;

        private _isUsedAsValue = false;
        private _typeUsedExternally = false;
        private _isUsedInExportAlias = false;
        private retrievingExportAssignment = false;
        private linkedAliasSymbols: PullTypeAliasSymbol[] = null;

        constructor(name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, PullElementKind.TypeAlias, semanticInfoChain);
        }

        public isUsedInExportedAlias(): boolean {
            this._resolveDeclaredSymbol();
            return this._isUsedInExportAlias;
        }

        public typeUsedExternally(): boolean {
            this._resolveDeclaredSymbol();
            return this._typeUsedExternally;
        }

        public isUsedAsValue(): boolean {
            this._resolveDeclaredSymbol();
            return this._isUsedAsValue;
        }

        public setTypeUsedExternally(): void {
            this._typeUsedExternally = true;
        }

        public setIsUsedInExportedAlias(): void {
            this._isUsedInExportAlias = true;
            if (this.linkedAliasSymbols) {
                this.linkedAliasSymbols.forEach(s => s.setIsUsedInExportedAlias());
            }
        }

        public addLinkedAliasSymbol(contingentValueSymbol: PullTypeAliasSymbol) {
            if (!this.linkedAliasSymbols) {
                this.linkedAliasSymbols = [contingentValueSymbol];
            }
            else {
                this.linkedAliasSymbols.push(contingentValueSymbol);
            }
        }

        public setIsUsedAsValue(): void {
            this._isUsedAsValue = true;
            if (this.linkedAliasSymbols) {
                this.linkedAliasSymbols.forEach(s => s.setIsUsedAsValue());
            }
        }

        public assignedValue(): PullSymbol {
            this._resolveDeclaredSymbol();
            return this._assignedValue;
        }

        public assignedType(): PullTypeSymbol {
            this._resolveDeclaredSymbol();
            return this._assignedType;
        }

        public assignedContainer(): PullContainerSymbol {
            this._resolveDeclaredSymbol();
            return this._assignedContainer;
        }

        public isAlias() { return true; }
        public isContainer() { return true; }

        public setAssignedValueSymbol(symbol: PullSymbol): void {
            this._assignedValue = symbol;
        }

        public getExportAssignedValueSymbol(): PullSymbol {
            if (this._assignedValue) {
                return this._assignedValue;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedContainer) {
                if (this._assignedContainer.hasExportAssignment()) {
                    this.retrievingExportAssignment = true;
                    var sym = this._assignedContainer.getExportAssignedValueSymbol();
                    this.retrievingExportAssignment = false;
                    return sym;
                }

                return this._assignedContainer.getInstanceSymbol();
            }

            return null;
        }

        public setAssignedTypeSymbol(type: PullTypeSymbol): void {
            this._assignedType = type;
        }

        public getExportAssignedTypeSymbol(): PullTypeSymbol {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedType) {
                if (this._assignedType.isAlias()) {
                    this.retrievingExportAssignment = true;
                    var sym = (<PullTypeAliasSymbol>this._assignedType).getExportAssignedTypeSymbol();
                    this.retrievingExportAssignment = false;
                }
                else if (this._assignedType !== this._assignedContainer) {
                    return this._assignedType;
                }
            }

            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this._assignedContainer;
        }

        public setAssignedContainerSymbol(container: PullContainerSymbol): void {
            this._assignedContainer = container;
        }

        public getExportAssignedContainerSymbol(): PullContainerSymbol {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this._assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this._assignedContainer.getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this._assignedContainer;
        }

        public getMembers(): PullSymbol[] {
            if (this._assignedType) {
                return this._assignedType.getMembers();
            }

            return sentinelEmptyArray;
        }

        public getCallSignatures(): PullSignatureSymbol[] {
            if (this._assignedType) {
                return this._assignedType.getCallSignatures();
            }

            return sentinelEmptyArray;
        }

        public getConstructSignatures(): PullSignatureSymbol[] {
            if (this._assignedType) {
                return this._assignedType.getConstructSignatures();
            }

            return sentinelEmptyArray;
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            if (this._assignedType) {
                return this._assignedType.getIndexSignatures();
            }

            return sentinelEmptyArray;
        }

        public findMember(name: string): PullSymbol {
            if (this._assignedType) {
                return this._assignedType.findMember(name, /*lookInParent*/ true);
            }

            return null;
        }

        public findNestedType(name: string): PullTypeSymbol {
            if (this._assignedType) {
                return this._assignedType.findNestedType(name);
            }

            return null;
        }

        public findNestedContainer(name: string): PullTypeSymbol {
            if (this._assignedType) {
                return this._assignedType.findNestedContainer(name);
            }

            return null;
        }

        public getAllMembers(searchDeclKind: PullElementKind, memberVisibility: GetAllMembersVisiblity): PullSymbol[] {
            if (this._assignedType) {
                return this._assignedType.getAllMembers(searchDeclKind, memberVisibility);
            }

            return sentinelEmptyArray;
        }
    }

    export class PullTypeParameterSymbol extends PullTypeSymbol {
        private _constraint: PullTypeSymbol = null;

        constructor(name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, PullElementKind.TypeParameter, semanticInfoChain);
        }

        public isTypeParameter() { return true; }

        public setConstraint(constraintType: PullTypeSymbol) {
            this._constraint = constraintType;
        }

        public getConstraint(): PullTypeSymbol {
            return this._constraint;
        }

        // Section 3.4.1 (November 18, 2013):
        // The base constraint of a type parameter T is defined as follows:
        //  If T has no declared constraint, T's base constraint is the empty object type {}
        //  If T's declared constraint is a type parameter, T's base constraint is that of the type parameter.
        //  Otherwise, T's base constraint is T's declared constraint.
        public getBaseConstraint(semanticInfoChain: SemanticInfoChain): PullTypeSymbol {
            var preBaseConstraint = this.getConstraintRecursively({});
            Debug.assert(preBaseConstraint === null || !preBaseConstraint.isTypeParameter());
            return preBaseConstraint || semanticInfoChain.emptyTypeSymbol;
        }

        // Returns null if you hit a cycle or no constraint
        // The visitedTypeParameters bag is for catching cycles
        private getConstraintRecursively(visitedTypeParameters: { [n: number]: PullTypeParameterSymbol }): PullTypeSymbol {
            var constraint = this.getConstraint();

            if (constraint) {
                if (constraint.isTypeParameter()) {
                    var constraintAsTypeParameter = <PullTypeParameterSymbol>constraint;
                    if (!visitedTypeParameters[constraintAsTypeParameter.pullSymbolID]) {
                        visitedTypeParameters[constraintAsTypeParameter.pullSymbolID] = constraintAsTypeParameter;
                        return constraintAsTypeParameter.getConstraintRecursively(visitedTypeParameters);
                    }
                }
                else {
                    return constraint;
                }
            }

            return null;
        }

        // The default constraint is just like the base constraint, but without recursively traversing
        // type parameters.
        public getDefaultConstraint(semanticInfoChain: SemanticInfoChain): PullTypeSymbol {
            return this._constraint || semanticInfoChain.emptyTypeSymbol;
        }

        // Note: This is a deviation from the spec. Using the constraint to get signatures is only
        // warranted when we explicitly ask for an apparent type.
        public getCallSignatures(): PullSignatureSymbol[] {
            if (this._constraint) {
                return this._constraint.getCallSignatures();
            }

            return super.getCallSignatures();
        }

        public getConstructSignatures(): PullSignatureSymbol[] {
            if (this._constraint) {
                return this._constraint.getConstructSignatures();
            }

            return super.getConstructSignatures();
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            if (this._constraint) {
                return this._constraint.getIndexSignatures();
            }

            return super.getIndexSignatures();
        }

        public isGeneric() { return true; }

        public fullName(scopeSymbol?: PullSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }

            return name;
        }

        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            var name = super.getName(scopeSymbol);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        }

        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, skipInternalAliasName?: boolean) {
            var name = super.getDisplayName(scopeSymbol, useConstraintInName, skipInternalAliasName);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        }

        public isExternallyVisible(inIsExternallyVisibleSymbols?: PullSymbol[]): boolean {
            return true;
        }
    }

    export class PullAccessorSymbol extends PullSymbol {

        private _getterSymbol: PullSymbol = null;
        private _setterSymbol: PullSymbol = null;

        constructor(name: string, semanticInfoChain: SemanticInfoChain) {
            super(name, PullElementKind.Property, semanticInfoChain);
        }

        public isAccessor() { return true; }

        public setSetter(setter: PullSymbol) {
            if (!setter) {
                return;
            }

            this._setterSymbol = setter;
        }

        public getSetter(): PullSymbol {
            return this._setterSymbol;
        }

        public setGetter(getter: PullSymbol) {
            if (!getter) {
                return;
            }

            this._getterSymbol = getter;
        }

        public getGetter(): PullSymbol {
            return this._getterSymbol;
        }
    }

    export function getIDForTypeSubstitutions(instantiatingType: PullTypeSymbol, typeArgumentMap: TypeSubstitutionMap): string;
    export function getIDForTypeSubstitutions(instantiatingSignature: PullSignatureSymbol, typeArgumentMap: TypeSubstitutionMap): string;
    export function getIDForTypeSubstitutions(instantiatingTypeOrSignature: PullSymbol, typeArgumentMap: TypeSubstitutionMap): string {
        var substitution = "";
        var members: PullSymbol[] = null;

        var allowedToReferenceTypeParameters = (<PullTypeSymbol>instantiatingTypeOrSignature).getAllowedToReferenceTypeParameters();
        for (var i = 0; i < allowedToReferenceTypeParameters.length; i++) {
            var typeParameter = allowedToReferenceTypeParameters[i];
            var typeParameterID = typeParameter.pullSymbolID;
            var typeArg = typeArgumentMap[typeParameterID];
            if (!typeArg) {
                typeArg = typeParameter;
            }
            substitution += typeParameterID + ":" + getIDForTypeSubstitutionsOfType(typeArg);
        }

        return substitution;
    }

    function getIDForTypeSubstitutionsOfType(type: PullTypeSymbol): string {
        var structure: string;
        if (type.isError()) {
            structure = "E" + getIDForTypeSubstitutionsOfType((<PullErrorTypeSymbol>type)._anyType);
        }
        else if (!type.isNamedTypeSymbol()) {
            structure = getIDForTypeSubstitutionsFromObjectType(type);
        }

        if (!structure) {
            structure = type.pullSymbolID + "#";
        }

        return structure;
    }

    function getIDForTypeSubstitutionsFromObjectType(type: PullTypeSymbol): string {
        if (type.isResolved) {
            var getIDForTypeSubStitutionWalker = new GetIDForTypeSubStitutionWalker();
            PullHelpers.walkPullTypeSymbolStructure(type, getIDForTypeSubStitutionWalker);
        }

        return null;
    }

    class GetIDForTypeSubStitutionWalker implements PullHelpers.PullTypeSymbolStructureWalker {
        public structure = "";
        memberSymbolWalk(memberSymbol: PullSymbol) {
            this.structure += memberSymbol.name + "@" + getIDForTypeSubstitutionsOfType(memberSymbol.type);
            return true;
        }
        callSignatureWalk(signatureSymbol: PullSignatureSymbol) {
            this.structure += "(";
            return true;
        }
        constructSignatureWalk(signatureSymbol: PullSignatureSymbol) {
            this.structure += "new(";
            return true;
        }
        indexSignatureWalk(signatureSymbol: PullSignatureSymbol) {
            this.structure += "[](";
            return true;
        }
        signatureParameterWalk(parameterSymbol: PullSymbol) {
            this.structure += parameterSymbol.name + "@" + getIDForTypeSubstitutionsOfType(parameterSymbol.type);
            return true;
        }
        signatureReturnTypeWalk(returnType: PullTypeSymbol) {
            this.structure += ")" + getIDForTypeSubstitutionsOfType(returnType);
            return true;
        }
    }


    export enum GetAllMembersVisiblity {
        // All properties of the type regardless of their accessibility level
        all = 0,

        // Only properties that are accessible on a class instance, i.e. public and private members of 
        // the current class, and only public members of any bases it extends
        internallyVisible = 1,

        // Only public members of classes
        externallyVisible = 2,
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {

    // This represents the state of the enclosing type walker that is a flag indicating if we are walking enclosingType
    // and the list of symbols walked of a generic type. It is represented as these two things because even when 
    // we are in the enclosing type that is not generic, we have set enclosing type, but there wont be any need of relevant
    // signature and type reference symbols as they wont be needed to determine if the typereference in this enclosing type
    // would be infinitely recursive. Having set the flag that we have already set enclosing type, would help in 
    // perf because we wouldnt keep calculating enclosing type again and again on any of the inner traversals when not necessary
    export class EnclosingTypeWalkerState {
        // Is walker into any of the enclosing type. This could be true if the enclosing type is class or interface
        // irrespective of whether it is generic or not.
        public _hasSetEnclosingType: boolean;

        // These are set of symbols that walker is walking. Note that they are set only if the enclosing type is generic
        // This is stack of symbols as they are walked. 
        // Eg. 
        // interface IList<T> {
        //     owner(): IList<IList<T>>;
        // }
        // In above example when looking at type reference IList<IList<T>> it would have 
        // [IList<T>, owner's signature symbol, IList<IList<T>>]
        public _currentSymbols: PullSymbol[];

        // Gets thye default enclosing type walker state
        // Default state is enclosing type walker isnt walking any enclosing type and hence hasSetEnclosingType = false and no current symbols
        static getDefaultEnclosingTypeWalkerState(): EnclosingTypeWalkerState {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = false;
            return defaultEnclosingTypeWalkerState;
        }

        // Gets the enclosing type walker state when enclosingType is non generic
        // In this case, the hasSetEnclosingType is true but the currentSymbols is not set because it doesnt need those symbols
        // to evaluate if typeReference would be infinitely expanding
        static getNonGenericEnclosingTypeWalkerState(): EnclosingTypeWalkerState {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = true;
            return defaultEnclosingTypeWalkerState;
        }

        // Gets the enclosing type walker state when enclosingType is generic
        static getGenericEnclosingTypeWalkerState(genericEnclosingType: PullTypeSymbol): EnclosingTypeWalkerState {
            var defaultEnclosingTypeWalkerState = new EnclosingTypeWalkerState();
            defaultEnclosingTypeWalkerState._hasSetEnclosingType = true;
            defaultEnclosingTypeWalkerState._currentSymbols = [PullHelpers.getRootType(genericEnclosingType)];
            return defaultEnclosingTypeWalkerState;
        }
    }

    // This is the walker that walks the type and type reference associated with the declaration.
    // This will make sure that any time, generative classification is asked, we have the right type of the declaration
    // and we can evaluate it in the correct context
    // interface IList<T> {
    //     owner: IList<IList<T>>;
    //     owner2: IList<IList<string>>;
    // }
    // class List<U> implements IList<U> {
    //     owner: List<List<U>>;
    // }
    // In the above example, when checking if owner of List<U> is subtype of owner of IList<U>
    // we want to traverse IList<T> to make sure when generative classification is asked we know exactly 
    // which type parameters and which type need to be checked for infinite wrapping
    // This also is essential so that we dont incorrectly think owner2's type reference as infinitely expanding when 
    // checking members of IList<string>
    export class PullTypeEnclosingTypeWalker {
        // Default state of the enclosingTypeWalker, so we dont end up creating empty states again and again
        private static _defaultEnclosingTypeWalkerState = EnclosingTypeWalkerState.getDefaultEnclosingTypeWalkerState();

        // Default state for non genericEnclosingTypeWalker
        private static _nonGenericEnclosingTypeWalkerState = EnclosingTypeWalkerState.getNonGenericEnclosingTypeWalkerState();

        // Current state of the enclosing type walker
        private enclosingTypeWalkerState: EnclosingTypeWalkerState;

        constructor(private semanticInfoChain: SemanticInfoChain) {
            this.setDefaultTypeWalkerState();
        }

        private setDefaultTypeWalkerState() {
            this.enclosingTypeWalkerState = PullTypeEnclosingTypeWalker._defaultEnclosingTypeWalkerState;
        }

        private setNonGenericEnclosingTypeWalkerState() {
            this.enclosingTypeWalkerState = PullTypeEnclosingTypeWalker._nonGenericEnclosingTypeWalkerState;
        } 

        private canSymbolOrDeclBeUsedAsEnclosingTypeHelper(name: string, kind: PullElementKind) {
            return name && (kind === PullElementKind.Class || kind === PullElementKind.Interface);
        }

        private canDeclBeUsedAsEnclosingType(decl: PullDecl) {
            return this.canSymbolOrDeclBeUsedAsEnclosingTypeHelper(decl.name, decl.kind);
        }

        private canSymbolBeUsedAsEnclosingType(symbol: PullSymbol) {
            return this.canSymbolOrDeclBeUsedAsEnclosingTypeHelper(symbol.name, symbol.kind);
        }
        
        // Enclosing type is the first symbol in the symbols visited
        public getEnclosingType() {
            var currentSymbols = this.enclosingTypeWalkerState._currentSymbols;
            if (currentSymbols) {
                // We dont allocate current symbols as empty list any more
                Debug.assert(currentSymbols.length > 0);
                return <PullTypeSymbol>currentSymbols[0];
            }

            return null;
        }

        // We can/should walk the structure only if the enclosing type is generic
        public _canWalkStructure() {
            var enclosingType = this.getEnclosingType();
            Debug.assert(!enclosingType || enclosingType.isGeneric());
            return !!enclosingType;
        }

        // Current symbol is the last symbol in the current symbols list
        public _getCurrentSymbol() {
            var currentSymbols = this.enclosingTypeWalkerState._currentSymbols;
            if (currentSymbols && currentSymbols.length) {
                return currentSymbols[currentSymbols.length - 1];
            }

            return null;
        }

        // Gets the generative classification of the current symbol in the enclosing type
        public getGenerativeClassification() {
            if (this._canWalkStructure()) {
                var currentType = <PullTypeSymbol>this._getCurrentSymbol();
                if (!currentType) {
                    // This may occur if we are trying to walk type parameter in the original declaration
                    return GenerativeTypeClassification.Unknown;
                }

                var variableNeededToFixNodeJitterBug = this.getEnclosingType();

                return currentType.getGenerativeTypeClassification(variableNeededToFixNodeJitterBug);
            }

            return GenerativeTypeClassification.Closed;
        }

        private _pushSymbol(symbol: PullSymbol) {
            return this.enclosingTypeWalkerState._currentSymbols.push(symbol);
        }

        private _popSymbol() {
            return this.enclosingTypeWalkerState._currentSymbols.pop();
        }

        private setSymbolAsEnclosingType(type: PullTypeSymbol) {
            if (type.isGeneric()) {
                // Set the state of the new generic type
                this.enclosingTypeWalkerState = EnclosingTypeWalkerState.getGenericEnclosingTypeWalkerState(type);
            } else {
                // Non generic Type
                this.setNonGenericEnclosingTypeWalkerState();
            }
        }

        // Sets the enclosing type along with parent declaration symbols
        private _setEnclosingTypeOfParentDecl(decl: PullDecl, setSignature: boolean) {
            var parentDecl = decl.getParentDecl();
            // If we are already at module/script, we are done walking up the parent
            if (parentDecl && !(parentDecl.kind & (PullElementKind.SomeContainer | PullElementKind.Script))) {
                // Always set signatures in parents
                if (this.canDeclBeUsedAsEnclosingType(parentDecl)) {
                    this.setSymbolAsEnclosingType(<PullTypeSymbol>parentDecl.getSymbol(this.semanticInfoChain));
                } else {
                    this._setEnclosingTypeOfParentDecl(parentDecl, /*setSignature*/ true);
                }

                if (this._canWalkStructure()) {
                    // Update the current decl in the 
                    var symbol = decl.getSymbol(this.semanticInfoChain);
                    if (symbol) {
                        // If symbol is raw PullSymbol (not a type or a signature, but
                        // rather a variable, function, etc), use its type instead
                        if (!symbol.isType() && !symbol.isSignature()) {
                            symbol = symbol.type;
                        }

                        this._pushSymbol(symbol);
                    }

                    // Set signature symbol if asked
                    if (setSignature) {
                        var signature = decl.getSignatureSymbol(this.semanticInfoChain);
                        if (signature) {
                            this._pushSymbol(signature);
                        }
                    }
                }
            }
        }

        public setEnclosingTypeForSymbol(symbol: PullSymbol): EnclosingTypeWalkerState {
            var currentEnclosingTypeWalkerState = this.enclosingTypeWalkerState;
            if (this.canSymbolBeUsedAsEnclosingType(symbol)) {
                this.setSymbolAsEnclosingType(<PullTypeSymbol>symbol);
            }
            else {
                // We are going to walk declarations, so first set the default type walker state,
                // So the walker doesnt incorrectly assume us already in enclosingTypeWalker state
                this.setDefaultTypeWalkerState();

                // Walk the decls and its parents to set the enclosing type
                var decls = symbol.getDeclarations();
                for (var i = 0; i < decls.length; i++) {
                    var decl = decls[i];
                    this._setEnclosingTypeOfParentDecl(decl, symbol.isSignature());

                    // If the parent was able to set the enclosing type, we are done, no need to walk more decls
                    if (this.enclosingTypeWalkerState._hasSetEnclosingType) {
                        break;
                    }
                }

                if (!this.enclosingTypeWalkerState._hasSetEnclosingType) {
                    // We have started walking enclosing type, but this symbol might be a symbol with declaration that doesnt 
                    // have parentDecl, eg. SyntheticDecl of emptyObjectType, in that case we wouldnt have set the flag
                    // _hasSetEnclosingType as path of walking its decls, 
                    // so set it now to indicate we have started walking the enclosing type, its not a generic type
                    this.setNonGenericEnclosingTypeWalkerState();
                }
            }
            return currentEnclosingTypeWalkerState;
        }

        // Start walking type
        public startWalkingType(symbol: PullTypeSymbol): EnclosingTypeWalkerState {
            var currentState = this.enclosingTypeWalkerState;

            // We want to set the new enclosing type using symbol if we arent already walking any enclosing Type 
            // or the symbol itself can be used as new enclosing type as then we want to be walking in the new enclosingType and not the old one.
            // We dont need to set new enclosing type if we are walking signature because they dont declare new enclosing type as the enclosing type
            // can only be class or interface and in case of signature we would have either set it earlier, or would do when we are actually 
            // using type reference from parameter/return types
            var setEnclosingTypeForSymbol = !this.enclosingTypeWalkerState._hasSetEnclosingType || this.canSymbolBeUsedAsEnclosingType(symbol);
            if (setEnclosingTypeForSymbol) {
                this.setEnclosingTypeForSymbol(symbol);
            }
            return currentState;
        }

        // Finish walking type
        public endWalkingType(stateWhenStartedWalkingTypes: EnclosingTypeWalkerState) {
            this.enclosingTypeWalkerState = stateWhenStartedWalkingTypes;
        }

        // Walk members
        public walkMemberType(memberName: string, resolver: PullTypeResolver) {
            if (this._canWalkStructure()) {
                var currentType = <PullTypeSymbol>this._getCurrentSymbol();
                var memberSymbol = currentType ? resolver._getNamedPropertySymbolOfAugmentedType(memberName, currentType) : null;
                this._pushSymbol(memberSymbol ? memberSymbol.type : null);
            }
        }

        public postWalkMemberType() {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        // Walk signature
        public walkSignature(kind: PullElementKind, index: number) {
            if (this._canWalkStructure()) {
                var currentType = <PullTypeSymbol>this._getCurrentSymbol();
                var signatures: PullSignatureSymbol[];
                if (currentType) {
                    if (kind == PullElementKind.CallSignature) {
                        signatures = currentType.getCallSignatures();
                    }
                    else if (kind == PullElementKind.ConstructSignature) {
                        signatures = currentType.getConstructSignatures();
                    }
                    else {
                        signatures = currentType.getIndexSignatures();
                    }
                }

                this._pushSymbol(signatures ? signatures[index] : null);
            }
        }

        public postWalkSignature() {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        public walkTypeArgument(index: number): void {
            if (this._canWalkStructure()) {
                var typeArgument: PullTypeSymbol = null;
                var currentType = <PullTypeSymbol>this._getCurrentSymbol();
                if (currentType) {
                    var typeArguments = currentType.getTypeArguments();
                    typeArgument = typeArguments ? typeArguments[index] : null;
                }
                this._pushSymbol(typeArgument);
            }
        }

        public postWalkTypeArgument(): void {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        // Walk type parameter constraint
        public walkTypeParameterConstraint(index: number) {
            if (this._canWalkStructure()) {
                var typeParameters: PullTypeParameterSymbol[];
                var currentSymbol = this._getCurrentSymbol();
                if (currentSymbol) {
                    if (currentSymbol.isSignature()) {
                        typeParameters = (<PullSignatureSymbol>currentSymbol).getTypeParameters();
                    } else {
                        Debug.assert(currentSymbol.isType());
                        typeParameters = (<PullTypeSymbol>currentSymbol).getTypeParameters();
                    }
                }
                this._pushSymbol(typeParameters ? typeParameters[index].getConstraint() : null);
            }
        }

        public postWalkTypeParameterConstraint() {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        // Walk return type
        public walkReturnType() {
            if (this._canWalkStructure()) {
                var currentSignature = <PullSignatureSymbol>this._getCurrentSymbol();
                this._pushSymbol(currentSignature ? currentSignature.returnType : null);
            }
        }

        public postWalkReturnType() {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        // Walk parameter type
        public walkParameterType(iParam: number) {
            if (this._canWalkStructure()) {
                var currentSignature = <PullSignatureSymbol>this._getCurrentSymbol();
                this._pushSymbol(currentSignature ? currentSignature.getParameterTypeAtIndex(iParam) : null);
            }
        }
        public postWalkParameterType() {
            if (this._canWalkStructure()) {
                this._popSymbol();
            }
        }

        // Get both kind of index signatures
        public getBothKindOfIndexSignatures(resolver: PullTypeResolver, context: PullTypeResolutionContext, includeAugmentedType: boolean) {
            if (this._canWalkStructure()) {
                var currentType = <PullTypeSymbol>this._getCurrentSymbol();
                if (currentType) {
                    return resolver._getBothKindsOfIndexSignatures(currentType, context, includeAugmentedType);
                }
            }
            return null;
        }

        // Walk index signature return type
        public walkIndexSignatureReturnType(indexSigInfo: IndexSignatureInfo, useStringIndexSignature: boolean,
            onlySignature?: boolean) {
            if (this._canWalkStructure()) {
                var indexSig = indexSigInfo ? (useStringIndexSignature ? indexSigInfo.stringSignature : indexSigInfo.numericSignature) : null;
                this._pushSymbol(indexSig);
                if (!onlySignature) {
                    this._pushSymbol(indexSig ? indexSig.returnType : null);
                }
            }
        }

        public postWalkIndexSignatureReturnType(onlySignature?: boolean) {
            if (this._canWalkStructure()) {
                if (!onlySignature) {
                    this._popSymbol(); // return type
                }
                this._popSymbol(); // index signature type
            }
        }

        // Reset the state of the enclosing type walker
        public resetEnclosingTypeWalkerState(): EnclosingTypeWalkerState {
            var currentState = this.enclosingTypeWalkerState;
            this.setDefaultTypeWalkerState();
            return currentState;
        }

        // Set new state of the enclosing type walker
        public setEnclosingTypeWalkerState(enclosingTypeWalkerState: EnclosingTypeWalkerState) {
            if (enclosingTypeWalkerState) {
                this.enclosingTypeWalkerState = enclosingTypeWalkerState;
            }
            else {
                // This could happend when the context didnt have existing type walker and hence resetEnclosingTypeWalkerState would have
                // saved the state as null, but now that we have walker, we want to set the state as default that is it isnt walking any enclosing type
                this.setDefaultTypeWalkerState();
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
///<reference path="..\typescript.ts" />

module TypeScript {
    export enum GenerativeTypeClassification {
        Unknown,
        Open,
        Closed,
        InfinitelyExpanding
    }

    export interface TypeSubstitutionMap {
        [n: number]: PullTypeSymbol;
    }

    // Type references and instantiated type references
    export class TypeReferenceSymbol extends PullTypeSymbol {
        public static createTypeReference(type: PullTypeSymbol): TypeReferenceSymbol {

            if (type.isTypeReference()) {
                return <TypeReferenceSymbol>type;
            }

            var typeReference = type.typeReference;

            if (!typeReference) {
                typeReference = new TypeReferenceSymbol(type);
                type.typeReference = typeReference;
            }

            return typeReference;
        }

        // use the root symbol to model the actual type
        // do not call this directly!
        constructor(public referencedTypeSymbol: PullTypeSymbol) {
            super(referencedTypeSymbol.name, referencedTypeSymbol.kind, referencedTypeSymbol.semanticInfoChain);

            Debug.assert(referencedTypeSymbol !== null, "Type root symbol may not be null");

            this.setRootSymbol(referencedTypeSymbol);

            this.typeReference = this;
        }

        public isTypeReference() {
            return true;
        }

        public isResolved = true;

        public setResolved() { }

        // do nothing on invalidate
        public setUnresolved(): void { }
        public invalidate(): void { }

        public ensureReferencedTypeIsResolved(): void {
            this._getResolver().resolveDeclaredSymbol(this.referencedTypeSymbol);
        }

        public getReferencedTypeSymbol(): PullTypeSymbol {
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol;
        }

        public _getResolver(): PullTypeResolver {
            return this.referencedTypeSymbol._getResolver();
        }

        // type symbol shims
        public hasMembers(): boolean {
            // no need to resolve first - members are collected during binding

            return this.referencedTypeSymbol.hasMembers();
        }

        public setAssociatedContainerType(type: PullTypeSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": setAssociatedContainerType");
        }

        public getAssociatedContainerType(): PullTypeSymbol {
            return this.referencedTypeSymbol.getAssociatedContainerType();
        }

        public getFunctionSymbol(): PullSymbol {
            // necessary because the function symbol may be set during type resolution to
            // facilitate doc comments
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getFunctionSymbol();
        }
        public setFunctionSymbol(symbol: PullSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": setFunctionSymbol");
        }

        public addContainedNonMember(nonMember: PullSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addContainedNonMember");
        }
        public findContainedNonMemberContainer(containerName: string, kind = PullElementKind.None): PullTypeSymbol {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.findContainedNonMemberContainer(containerName, kind);
        }

        public addMember(memberSymbol: PullSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addMember");
        }
        public addEnclosedMemberType(enclosedType: PullTypeSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberType");
        }
        public addEnclosedMemberContainer(enclosedContainer: PullTypeSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedMemberContainer");
        }
        public addEnclosedNonMember(enclosedNonMember: PullSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMember");
        }
        public addEnclosedNonMemberType(enclosedNonMemberType: PullTypeSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberType");
        }
        public addEnclosedNonMemberContainer(enclosedNonMemberContainer: PullTypeSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addEnclosedNonMemberContainer");
        }
        public addTypeParameter(typeParameter: PullTypeParameterSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addTypeParameter");
        }
        public addConstructorTypeParameter(typeParameter: PullTypeParameterSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addConstructorTypeParameter");
        }

        public findContainedNonMember(name: string): PullSymbol {
            // need to ensure the referenced type is resolved so we can find the non-member
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findContainedNonMember(name);
        }

        public findContainedNonMemberType(typeName: string, kind = PullElementKind.None): PullTypeSymbol {
            // similar to the above, need to ensure that the type is resolved so we can introspect any
            // contained types
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findContainedNonMemberType(typeName, kind);
        }

        public getMembers(): PullSymbol[]{
            // need to resolve the referenced types to get the members
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getMembers();
        }

        public setHasDefaultConstructor(hasOne = true): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ":setHasDefaultConstructor");
        }
        public getHasDefaultConstructor(): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getHasDefaultConstructor();
        }
        public getConstructorMethod(): PullSymbol {
            // need to resolve so we don't accidentally substitute in a default constructor
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructorMethod();
        }
        public setConstructorMethod(constructorMethod: PullSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": setConstructorMethod");
        }
        public getTypeParameters(): PullTypeParameterSymbol[]{
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeParameters();
        }

        public isGeneric(): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isGeneric();
        }

        public addSpecialization(specializedVersionOfThisType: PullTypeSymbol, substitutingTypes: PullTypeSymbol[]): void {
            //Debug.fail("Reference symbol " + this.pullSymbolIDString + ": addSpecialization");
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.addSpecialization(specializedVersionOfThisType, substitutingTypes);
        }
        public getSpecialization(substitutingTypes: PullTypeSymbol[]): PullTypeSymbol {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getSpecialization(substitutingTypes);
        }
        public getKnownSpecializations(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getKnownSpecializations();
        }
        public getTypeArguments(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArguments();
        }
        public getTypeArgumentsOrTypeParameters(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypeArgumentsOrTypeParameters();
        }

        public appendCallSignature(callSignature: PullSignatureSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": appendCallSignature");
        }
        public insertCallSignatureAtIndex(callSignature: PullSignatureSymbol, index: number): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": insertCallSignatureAtIndex");
        }
        public appendConstructSignature(callSignature: PullSignatureSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": appendConstructSignature");
        }
        public insertConstructSignatureAtIndex(callSignature: PullSignatureSymbol, index: number): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": insertConstructSignatureAtIndex");
        }
        public addIndexSignature(indexSignature: PullSignatureSymbol): void {
            Debug.fail("Reference symbol " + this.pullSymbolID + ": addIndexSignature");
        }

        public hasOwnCallSignatures(): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnCallSignatures();
        }
        public getCallSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getCallSignatures();
        }
        public hasOwnConstructSignatures(): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnConstructSignatures();
        }
        public getConstructSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getConstructSignatures();
        }
        public hasOwnIndexSignatures(): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.hasOwnIndexSignatures();
        }
        public getIndexSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getIndexSignatures();
        }

        public addImplementedType(implementedType: PullTypeSymbol): void {
            this.referencedTypeSymbol.addImplementedType(implementedType);
        }
        public getImplementedTypes(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getImplementedTypes();
        }
        public addExtendedType(extendedType: PullTypeSymbol): void {
            this.referencedTypeSymbol.addExtendedType(extendedType);
        }
        public getExtendedTypes(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getExtendedTypes();
        }
        public addTypeThatExtendsThisType(type: PullTypeSymbol): void {
            this.referencedTypeSymbol.addTypeThatExtendsThisType(type);
        }
        public getTypesThatExtendThisType(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExtendThisType();
        }
        public addTypeThatExplicitlyImplementsThisType(type: PullTypeSymbol): void {
            this.referencedTypeSymbol.addTypeThatExplicitlyImplementsThisType(type);
        }
        public getTypesThatExplicitlyImplementThisType(): PullTypeSymbol[] {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.getTypesThatExplicitlyImplementThisType();
        }

        public isValidBaseKind(baseType: PullTypeSymbol, isExtendedType: boolean): boolean {
            this.ensureReferencedTypeIsResolved();
            return this.referencedTypeSymbol.isValidBaseKind(baseType, isExtendedType);
        }

        public findMember(name: string, lookInParent = true): PullSymbol {
            // ensure that the type is resolved before looking for members
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findMember(name, lookInParent);
        }
        public findNestedType(name: string, kind = PullElementKind.None): PullTypeSymbol {
            // ensure that the type is resolved before looking for nested types
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findNestedType(name, kind);
        }
        public findNestedContainer(name: string, kind = PullElementKind.None): PullTypeSymbol {
            // ensure that the type is resolved before looking for nested containers
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findNestedContainer(name, kind);
        }
        public getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): PullSymbol[]{
            // ensure that the type is resolved before trying to collect all members
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
        }

        public findTypeParameter(name: string): PullTypeParameterSymbol {
            // ensure that the type is resolved before trying to look up a type parameter
            this.ensureReferencedTypeIsResolved();

            return this.referencedTypeSymbol.findTypeParameter(name);
        }

        /*
        public getNamePartForFullName(): string {
            return this.referencedTypeSymbol.getNamePartForFullName();
        }
        public getScopedName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            return this.referencedTypeSymbol.getScopedName(scopeSymbol, useConstraintInName);
        }
        public isNamedTypeSymbol(): boolean {
            return this.referencedTypeSymbol.isNamedTypeSymbol();
        }

        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string {
            return this.referencedTypeSymbol.toString(scopeSymbol, useConstraintInName);
        }

        public getScopedNameEx(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, getPrettyTypeName?: boolean, getTypeParamMarkerInfo?: boolean): MemberName {
            return this.referencedTypeSymbol.getScopedNameEx(scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo);
        }
        */

        public hasOnlyOverloadCallSignatures(): boolean {
            // no need to resolve the referenced type - only computed during printing
            return this.referencedTypeSymbol.hasOnlyOverloadCallSignatures();
        }
    }

    export var nSpecializationsCreated = 0;
    export var nSpecializedSignaturesCreated = 0;  
    export var nSpecializedTypeParameterCreated = 0;

    export class InstantiatedTypeReferenceSymbol extends TypeReferenceSymbol {

        private _instantiatedMembers: PullSymbol[] = null;
        private _allInstantiatedMemberNameCache: { [name: string]: PullSymbol; } = null;
        private _instantiatedMemberNameCache = createIntrinsicsObject<PullSymbol>(); // cache from member names to pull symbols
        private _instantiatedCallSignatures: PullSignatureSymbol[] = null;
        private _instantiatedConstructSignatures: PullSignatureSymbol[] = null;
        private _instantiatedIndexSignatures: PullSignatureSymbol[] = null;
        private _typeArgumentReferences: PullTypeSymbol[] = undefined;
        private _instantiatedConstructorMethod: PullSymbol = null;
        private _instantiatedAssociatedContainerType: PullTypeSymbol = null;
        private _isArray:boolean = undefined;
        public getIsSpecialized() { return !this.isInstanceReferenceType; }

        private _generativeTypeClassification: GenerativeTypeClassification[] = [];

        public getGenerativeTypeClassification(enclosingType: PullTypeSymbol): GenerativeTypeClassification {
            // Generative type classification is available only on named type symbols
            if (!this.isNamedTypeSymbol()) {
                return GenerativeTypeClassification.Unknown;
            }

            var generativeTypeClassification = this._generativeTypeClassification[enclosingType.pullSymbolID] || GenerativeTypeClassification.Unknown;
            if (generativeTypeClassification === GenerativeTypeClassification.Unknown) {
                // With respect to the enclosing type, is this type reference open, closed or 
                // infinitely expanding?

                // Create a type parameter map for figuring out if the typeParameter wraps
                var typeParameters = enclosingType.getTypeParameters();
                var enclosingTypeParameterMap: PullTypeSymbol[] = [];
                for (var i = 0; i < typeParameters.length; i++) {
                    enclosingTypeParameterMap[typeParameters[i].pullSymbolID] = typeParameters[i];
                }

                var typeArguments = this.getTypeArguments();
                for (var i = 0; i < typeArguments.length; i++) {
                    // Spec section 3.8.7 Recursive Types:
                    // - A type reference without type arguments or with type arguments that do not reference 
                    //      any of G's type parameters is classified as a closed type reference.
                    // - A type reference that references any of G's type parameters in a type argument is 
                    //      classified as an open type reference.
                    if (typeArguments[i].wrapsSomeTypeParameter(enclosingTypeParameterMap, /*skipTypeArgumentCheck*/ true)) {
                        // This type wraps type parameter of the enclosing type so it is at least open
                        generativeTypeClassification = GenerativeTypeClassification.Open;
                        break;
                    }
                }

                // If the type reference is determined to be atleast open, determine if it is infinitely expanding
                if (generativeTypeClassification === GenerativeTypeClassification.Open) {
                    if (this.wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType)) {
                        generativeTypeClassification = GenerativeTypeClassification.InfinitelyExpanding;
                    }
                }
                else {
                    // This type doesnot wrap any type parameter from the enclosing type so it is closed
                    generativeTypeClassification = GenerativeTypeClassification.Closed;
                }

                this._generativeTypeClassification[enclosingType.pullSymbolID] = generativeTypeClassification;
            }

            return generativeTypeClassification;
        }

        // shims

        public isArrayNamedTypeReference(): boolean {
            if (this._isArray === undefined) {
                this._isArray = this.getRootSymbol().isArrayNamedTypeReference() || (this.getRootSymbol() === this._getResolver().getArrayNamedType());
            }
            return this._isArray;
        }

        public getElementType(): PullTypeSymbol {
            if (!this.isArrayNamedTypeReference()) {
                return null;
            }

            var typeArguments = this.getTypeArguments();
            return typeArguments ? typeArguments[0] : null;
        }

        public getReferencedTypeSymbol(): PullTypeSymbol {
            this.ensureReferencedTypeIsResolved();

            if (this.getIsSpecialized()) {
                return this;
            }

            return this.referencedTypeSymbol;
        }

        // The typeParameterSubstitutionMap parameter represents a mapping of PUllSymbolID strings of type parameters to type argument symbols
        // The instantiateFunctionTypeParameters parameter is set to true when a signature is being specialized at a call site, or if its
        // type parameters need to otherwise be specialized (say, during a type relationship check)
        public static create(resolver: PullTypeResolver, type: PullTypeSymbol, typeParameterSubstitutionMap: TypeSubstitutionMap): InstantiatedTypeReferenceSymbol {
            Debug.assert(resolver);

            // check for an existing instantiation

            // If the type substitution map is going to change, we need to create copy so that 
            // we dont polute the map entry passed in by the caller. 
            // (eg. when getting the member type using enclosing types type substitution map)
            var mutableTypeParameterMap = new PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(typeParameterSubstitutionMap);

            // if the type is already specialized, we need to create a new type substitution map that represents 
            // the mapping of type arguments we've just received to type arguments as previously passed through
            // If we have below sample
            //interface IList<T> {
            //    owner: IList<IList<T>>;
            //}
            //class List<U> implements IList<U> {
            //    owner: IList<IList<U>>;
            //}
            //class List2<V> extends List<V> {
            //    owner: List2<List2<V>>;
            //}
            // When instantiating List<V> with U = V and trying to get owner property we would have the map that
            // says U = V, but when creating the IList<V> we want to updates its type substitution maps to say T = V because 
            // IList<T>  would now be instantiated with V
            PullInstantiationHelpers.instantiateTypeArgument(resolver, type, mutableTypeParameterMap);

            // Lookup in cache if this specialization already exists
            var rootType = <PullTypeSymbol>type.getRootSymbol();
            var instantiation = <InstantiatedTypeReferenceSymbol>rootType.getSpecialization(mutableTypeParameterMap.typeParameterSubstitutionMap);
            if (instantiation) {
                return instantiation;
            }

            // In any type, typeparameter map should only contain information about the allowed to reference type parameters 
            // so remove unnecessary entries that are outside these scope, eg. from above sample we need to remove entry U = V
            // and keep only T = V
            PullInstantiationHelpers.cleanUpTypeParameterSubstitutionMap(type, mutableTypeParameterMap);
            typeParameterSubstitutionMap = mutableTypeParameterMap.typeParameterSubstitutionMap;

            // If the reference is made to itself (e.g., referring to Array<T> within the declaration of Array<T>,
            // We want to special-case the reference so later calls to getMember, etc., will delegate directly
            // to the referenced declaration type, and not force any additional instantiation
            var isInstanceReferenceType = (type.kind & PullElementKind.SomeInstantiatableType) != 0;
            var resolvedTypeParameterArgumentMap = typeParameterSubstitutionMap;
            if (isInstanceReferenceType) {
                var typeParameters = rootType.getTypeParameters();
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!PullHelpers.typeSymbolsAreIdentical(typeParameters[i], typeParameterSubstitutionMap[typeParameters[i].pullSymbolID])) {
                        isInstanceReferenceType = false;
                        break;
                    }
                }

                if (isInstanceReferenceType) {
                    typeParameterSubstitutionMap = [];
                }
            }

            // Create the type using type substitution map
            instantiation = new InstantiatedTypeReferenceSymbol(rootType, typeParameterSubstitutionMap, isInstanceReferenceType);

            // Store in the cache
            rootType.addSpecialization(instantiation, resolvedTypeParameterArgumentMap);

            return instantiation;
        }

        constructor(public referencedTypeSymbol: PullTypeSymbol, private _typeParameterSubstitutionMap: TypeSubstitutionMap,
            public isInstanceReferenceType: boolean) {
            super(referencedTypeSymbol);

            nSpecializationsCreated++;
        }

        public isGeneric(): boolean {
            return (<PullTypeSymbol>this.getRootSymbol()).isGeneric();
        }

        public getTypeParameterSubstitutionMap(): TypeSubstitutionMap {
            return this._typeParameterSubstitutionMap;
        }

        public getTypeArguments(): PullTypeSymbol[]{

            if (this.isInstanceReferenceType) {
                return this.getTypeParameters();
            }

            if (this._typeArgumentReferences === undefined) {
                var typeParameters = this.referencedTypeSymbol.getTypeParameters();

                if (typeParameters.length) {
                    var typeArgument: PullTypeSymbol = null;
                    var typeArguments: PullTypeSymbol[] = [];

                    for (var i = 0; i < typeParameters.length; i++) {
                        typeArgument = <PullTypeSymbol>this._typeParameterSubstitutionMap[typeParameters[i].pullSymbolID];

                        if (!typeArgument) {
                            Debug.fail("type argument count mismatch");
                        }

                        if (typeArgument) {
                            typeArguments[typeArguments.length] = typeArgument;
                        }
                    }

                    this._typeArgumentReferences = typeArguments;
                }
                else {
                    this._typeArgumentReferences = null;
                }
            }

            return this._typeArgumentReferences;
        }
        
        public getTypeArgumentsOrTypeParameters() {
            return this.getTypeArguments();
        }


        private populateInstantiatedMemberFromReferencedMember(referencedMember: PullSymbol) {
            var instantiatedMember: PullSymbol;
            PullHelpers.resolveDeclaredSymbolToUseType(referencedMember);

            // if the member does not require further specialization, re-use the referenced symbol
            if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                instantiatedMember = referencedMember;
            }
            else {
                instantiatedMember = new PullSymbol(referencedMember.name, referencedMember.kind, referencedMember.semanticInfoChain);
                instantiatedMember.setRootSymbol(referencedMember);
                instantiatedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterSubstitutionMap);
                instantiatedMember.isOptional = referencedMember.isOptional;
            }
            this._instantiatedMemberNameCache[instantiatedMember.name] = instantiatedMember;
        }

        //
        // lazily evaluated members
        //
        public getMembers(): PullSymbol[] {
            // need to resolve the referenced types to get the members
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getMembers();
            }

            // for each of the referenced type's members, need to properly instantiate their
            // type references
            if (!this._instantiatedMembers) {
                var referencedMembers = this.referencedTypeSymbol.getMembers();
                var referencedMember: PullSymbol = null;
                var instantiatedMember: PullSymbol = null;

                this._instantiatedMembers = [];

                for (var i = 0; i < referencedMembers.length; i++) {
                    referencedMember = referencedMembers[i];

                    this._getResolver().resolveDeclaredSymbol(referencedMember);

                    if (!this._instantiatedMemberNameCache[referencedMember.name]) {
                        this.populateInstantiatedMemberFromReferencedMember(referencedMember);
                    }
                    
                    this._instantiatedMembers[this._instantiatedMembers.length] = this._instantiatedMemberNameCache[referencedMember.name];
                }
            }

            return this._instantiatedMembers;
        }

        public findMember(name: string, lookInParent = true): PullSymbol {
            // ensure that the type is resolved before looking for members
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.findMember(name, lookInParent);
            }

            // if the member exists on the referenced type, need to ensure that it's
            // instantiated

            var memberSymbol = <PullSymbol>this._instantiatedMemberNameCache[name];

            if (!memberSymbol) {
                var referencedMemberSymbol = this.referencedTypeSymbol.findMember(name, lookInParent);

                if (referencedMemberSymbol) {
                    this.populateInstantiatedMemberFromReferencedMember(referencedMemberSymbol);
                    memberSymbol = <PullSymbol>this._instantiatedMemberNameCache[name];
                }
                else {
                    memberSymbol = null;
                }
            }

            return memberSymbol;
        }

        // May need to cache based on search kind / visibility combinations
        public getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): PullSymbol[]{

            // ensure that the type is resolved before trying to collect all members
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);
            }

            var requestedMembers: PullSymbol[] = [];
            var allReferencedMembers = this.referencedTypeSymbol.getAllMembers(searchDeclKind, memberVisiblity);

            if (!this._allInstantiatedMemberNameCache) {
                this._allInstantiatedMemberNameCache = createIntrinsicsObject<PullSymbol>();

                // first, seed with this type's members
                var members = this.getMembers();

                for (var i = 0; i < members.length; i++) {
                    this._allInstantiatedMemberNameCache[members[i].name] = members[i];
                }
            }

            // next, for add any symbols belonging to the parent type, if necessary
            var referencedMember: PullSymbol = null;
            var requestedMember: PullSymbol = null;

            for (var i = 0; i < allReferencedMembers.length; i++) {
                referencedMember = allReferencedMembers[i];

                this._getResolver().resolveDeclaredSymbol(referencedMember);

                if (this._allInstantiatedMemberNameCache[referencedMember.name]) {
                    requestedMembers[requestedMembers.length] = this._allInstantiatedMemberNameCache[referencedMember.name];
                }
                else {
                    if (!referencedMember.type.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                        this._allInstantiatedMemberNameCache[referencedMember.name] = referencedMember;
                        requestedMembers[requestedMembers.length] = referencedMember;
                    }
                    else {
                        requestedMember = new PullSymbol(referencedMember.name, referencedMember.kind, referencedMember.semanticInfoChain);
                        requestedMember.setRootSymbol(referencedMember);

                        requestedMember.type = this._getResolver().instantiateType(referencedMember.type, this._typeParameterSubstitutionMap);
                        requestedMember.isOptional = referencedMember.isOptional;

                        this._allInstantiatedMemberNameCache[requestedMember.name] = requestedMember;
                        requestedMembers[requestedMembers.length] = requestedMember;
                    }
                }
            }
            
            return requestedMembers;
        }

        public getConstructorMethod(): PullSymbol {

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructorMethod();
            }

            if (!this._instantiatedConstructorMethod) {
                var referencedConstructorMethod = this.referencedTypeSymbol.getConstructorMethod();
                this._instantiatedConstructorMethod = new PullSymbol(referencedConstructorMethod.name, referencedConstructorMethod.kind, referencedConstructorMethod.semanticInfoChain);
                this._instantiatedConstructorMethod.setRootSymbol(referencedConstructorMethod);
                this._instantiatedConstructorMethod.setResolved();

                this._instantiatedConstructorMethod.type = InstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedConstructorMethod.type, this._typeParameterSubstitutionMap);
            }


            return this._instantiatedConstructorMethod;
        }

        public getAssociatedContainerType(): PullTypeSymbol {

            if (!this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getAssociatedContainerType();
            }

            if (!this._instantiatedAssociatedContainerType) {
                var referencedAssociatedContainerType = this.referencedTypeSymbol.getAssociatedContainerType();

                if (referencedAssociatedContainerType) {
                    this._instantiatedAssociatedContainerType = InstantiatedTypeReferenceSymbol.create(this._getResolver(), referencedAssociatedContainerType, this._typeParameterSubstitutionMap);
                }
            }

            return this._instantiatedAssociatedContainerType;
        }

        public getCallSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getCallSignatures();
            }

            if (this._instantiatedCallSignatures) {
                return this._instantiatedCallSignatures;
            }

            var referencedCallSignatures = this.referencedTypeSymbol.getCallSignatures();
            this._instantiatedCallSignatures = [];

            for (var i = 0; i < referencedCallSignatures.length; i++) {
                var referencedSignature = referencedCallSignatures[i];
                this._getResolver().resolveDeclaredSymbol(referencedSignature);

                if (!referencedSignature.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = referencedSignature;
                }
                else {
                    var signatureTypeParameterSubstitutionMap = this.augmentSignatureSubstitutionMapWithSynthesizedTypeParameters(referencedSignature);
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedSignature, signatureTypeParameterSubstitutionMap);
                    this._instantiatedCallSignatures[this._instantiatedCallSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedCallSignatures;
        }

        public getConstructSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getConstructSignatures();
            }

            if (this._instantiatedConstructSignatures) {
                return this._instantiatedConstructSignatures;
            }

            var referencedConstructSignatures = this.referencedTypeSymbol.getConstructSignatures();
            this._instantiatedConstructSignatures = [];

            for (var i = 0; i < referencedConstructSignatures.length; i++) {
                var referencedSignature = referencedConstructSignatures[i];
                this._getResolver().resolveDeclaredSymbol(referencedSignature);

                if (!referencedSignature.wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = referencedSignature;
                }
                else {
                    // Construct signatures only get new type parameters if they are not from
                    // class constructors. Otherwise, they must share the type parameters with
                    // the class itself, which means a generic base class reference would actually
                    // instantiate the base constructor with the type arguments of the base class
                    // reference.
                    if (this.isConstructor()) {
                        var signatureTypeParameterArgumentMap = this._typeParameterSubstitutionMap;
                        this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = this._getResolver().instantiateSignature(referencedSignature, signatureTypeParameterArgumentMap);
                    }
                    else {
                        var signatureTypeParameterArgumentMap = this.augmentSignatureSubstitutionMapWithSynthesizedTypeParameters(referencedSignature);
                        this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedSignature, signatureTypeParameterArgumentMap);
                    }
                    this._instantiatedConstructSignatures[this._instantiatedConstructSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedConstructSignatures;
        }

        // This method takes a map of all substitutions that are in scope outside the signature.
        // The output is the composition of that map with all the new substitutions that result
        // from generating new type parameters to replace the root type parameters. Here is an
        // example of what this means:
        //
        // interface Foo<T> {
        //     method<U>(func: (t: T) => U): Foo<U>
        // }
        //
        // Suppose we are inside the reference Foo<U>. The map coming in (this._typeParameterSubstitutionMap)
        // might be [T -> U]. If we just left the signature alone, and performed this substitution, we would
        // get method<U>(func: (t: U) => U): Foo<U>, which is wrong because the U that came in needn't be
        // the same as the new U. So we have to generate a U' that is distinct from U, and then update the
        // map accordingly.
        private augmentSignatureSubstitutionMapWithSynthesizedTypeParameters(referencedSignature: PullSignatureSymbol): TypeSubstitutionMap {
            if (referencedSignature.isGeneric()) {
                // Collect the signature's root type parameters, and for each one, create a new
                // type parameter with the same name. In the above example, getTypeParameters
                // should return an array of U, and newOwnTypeParameters should be an array
                // of U' (a fresh type parameter). Note also that U' keeps track of U as its
                // root type parameter. We assert in order to be sure that all keys in the map
                // are IDs of root type parameters (all of our substitution maps are against the root
                // signature).
                var signaturesOwnTypeParameters = referencedSignature.getTypeParameters();
                var newOwnTypeParameters = new Array<SynthesizedTypeParameterSymbol>(signaturesOwnTypeParameters.length);
                for (var i = 0; i < signaturesOwnTypeParameters.length; i++) {
                    var ownRootTypeParameter = signaturesOwnTypeParameters[i];
                    // Asserts that ownRootTypeParameter is in fact a root type parameter.
                    // This is necessary as all substitution maps are internally based on
                    // root type parameters.
                    Debug.assert(ownRootTypeParameter.getRootSymbol() === ownRootTypeParameter);
                    newOwnTypeParameters[i] = new SynthesizedTypeParameterSymbol(<PullTypeParameterSymbol>ownRootTypeParameter, this._typeParameterSubstitutionMap);
                }
                // We make a copy of this._typeParameterSubstitutionMap that accounts for this new type
                // parameter. In the above example, we copy the map [T -> U], and we output the map
                // [T -> U, U -> U']. Similarly, if we instantiated the same signature inside
                // Foo<U'>, we would get the map [T -> U', U -> U'']. Note that this only works
                // because we do not do recursive lookups in the map when substituting. In other words,
                // we do not use the transitive closure of the map (doing so would cause us to substitute
                // U' for T in the first example, which would be incorrect).
                // See PullInstantiationHelpers.instantiateTypeArgument.
                var signaturesOwnTypeArgumentMap = new PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(this._typeParameterSubstitutionMap);
                for (var i = 0; i < signaturesOwnTypeParameters.length; i++) {
                    signaturesOwnTypeArgumentMap.ensureCopyOfUnderlyingMap();
                    signaturesOwnTypeArgumentMap.typeParameterSubstitutionMap[signaturesOwnTypeParameters[i].pullSymbolID] = newOwnTypeParameters[i];
                }
                return signaturesOwnTypeArgumentMap.typeParameterSubstitutionMap;
            }
            else {
                return this._typeParameterSubstitutionMap;
            }
        }

        public getIndexSignatures(): PullSignatureSymbol[]{
            this.ensureReferencedTypeIsResolved();

            if (this.isInstanceReferenceType) {
                return this.referencedTypeSymbol.getIndexSignatures();
            }

            if (this._instantiatedIndexSignatures) {
                return this._instantiatedIndexSignatures;
            }

            var referencedIndexSignatures = this.referencedTypeSymbol.getIndexSignatures();
            this._instantiatedIndexSignatures = [];

            for (var i = 0; i < referencedIndexSignatures.length; i++) {
                this._getResolver().resolveDeclaredSymbol(referencedIndexSignatures[i]);

                if (!referencedIndexSignatures[i].wrapsSomeTypeParameter(this._typeParameterSubstitutionMap)) {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = referencedIndexSignatures[i];
                }
                else {
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length] = this._getResolver().getOrCreateSignatureWithSubstitution(referencedIndexSignatures[i], this._typeParameterSubstitutionMap);
                    this._instantiatedIndexSignatures[this._instantiatedIndexSignatures.length - 1].functionType = this;
                }
            }

            return this._instantiatedIndexSignatures;
        }
    }

    // The following two classes are very similar. They are both variants of signatures with type
    // parameter substitution maps. The only difference is the InstantiatedSignatureSymbol appears
    // to have no type parameters, whereas the SignatureSymbolWithSubstitution does have type
    // parameters.
    // A signature can reference type parameters and have associated substitutions for those
    // type parameters. Consider the following:
    //
    // interface Foo<T> {
    //     bar<S>(x: T, y: S): Foo<S>; // bar itself is PullSignatureSymbol - it is the root symbol
    //                                 // Foo<S> has SignatureSymbolWithSubstitution with map [T -> S, S -> S'] (case 3 below)
    // }
    //
    // var a: Foo<string>;           // Member bar of Foo<S> has a SignatureSymbolWithSubstitution with map [T -> string] (case 1 below)
    // var b = a.bar<number>("", 0); // call to a.bar produces an InstantiatedSignatureSymbol with map [T -> string, S -> number] (case 2 below)
    //
    // There are 3 reasons a signature may have substitutions for referenced type parameters:
    // 1. There are surrounding type parameter substitutions that need to be applied inside the
    //    signature. For example, in Foo<string>, the parameter x should be of type string.
    //    The substitution map here is [T -> string]
    // 2. The signature is instantiated with type arguments. For example, in the above call to
    //    bar<number>("", 0) on Foo<string>, you'd get an InstantiatedSignatureSymbol
    //    bar(x: string, y: number): Foo<number>, which has map [T -> string, S -> number];
    // 3. We needed to synthesize a new type parameter for the signature (for the reason why,
    //    see the comment on SynthesizedTypeParameter). In this case, inside Foo<S>, bar would have
    //    the signature <S'>(x: S, y: S'): Foo<S'>. This is NOT an instantiated signature, but
    //    just a SignatureSymbolWithSubstitution. The map here is [T -> S, S -> S'].
    //
    // This distinction does not exist for types because the only way to substitute in a type
    // is to instantiate it. That's because types cannot be declared in a context where type
    // parameters are in scope.
    //
    // Note that InstantiatedSignatureSymbol could extend SignatureSymbolWithSubstitution,
    // but that would make the inheritance chain longer. These classes are small enough
    // that we have duplicated most of their logic, and they both just extend PullSignatureSymbol.
    export class InstantiatedSignatureSymbol extends PullSignatureSymbol {
        public getTypeParameterSubstitutionMap(): TypeSubstitutionMap {
            return this._typeParameterSubstitutionMap;
        }

        constructor(rootSignature: PullSignatureSymbol, private _typeParameterSubstitutionMap: TypeSubstitutionMap) {
            super(rootSignature.kind, rootSignature.semanticInfoChain, rootSignature.isDefinition());
            this.setRootSymbol(rootSignature);
            nSpecializedSignaturesCreated++;
            
            // Store in the cache
            rootSignature.addSpecialization(this, _typeParameterSubstitutionMap);
        }

        public getIsSpecialized() {
            return true;
        }

        public getIsInstantiated() {
            return true;
        }

        public _getResolver(): PullTypeResolver {
            return this.getRootSymbol()._getResolver();
        }

        public getTypeParameters(): PullTypeParameterSymbol[] {
            return sentinelEmptyArray;
        }

        public getAllowedToReferenceTypeParameters(): PullTypeParameterSymbol[] {
            var rootSymbol = <PullSignatureSymbol>this.getRootSymbol();
            return rootSymbol.getAllowedToReferenceTypeParameters();
        }
    }

    // Copied example from above InstantiatedSignatureSymbol for convenience. See the explanation above 
    // for the exact difference between InstantiatedSignatureSymbol and SignatureSymbolWithSubstitution.
    //
    // interface Foo<T> {
    //     bar<S>(x: T, y: S): Foo<S>; // bar itself is PullSignatureSymbol - it is the root symbol
    //                                 // Foo<S> has SignatureSymbolWithSubstitution with map [T -> S, S -> S']
    // }
    //
    // var a: Foo<string>;           // Member bar of Foo<S> has a SignatureSymbolWithSubstitution with map [T -> string]
    // var b = a.bar<number>("", 0); // call to a.bar produces an InstantiatedSignatureSymbol with map [T -> string, S -> number]
    export class SignatureSymbolWithSubstitution extends PullSignatureSymbol {
        public getTypeParameterSubstitutionMap(): TypeSubstitutionMap {
            return this._typeParameterSubstitutionMap;
        }

        constructor(rootSignature: PullSignatureSymbol, private _typeParameterSubstitutionMap: TypeSubstitutionMap) {
            super(rootSignature.kind, rootSignature.semanticInfoChain, rootSignature.isDefinition());
            this.setRootSymbol(rootSignature);
            nSpecializedSignaturesCreated++;

            // Store in the cache
            rootSignature.addSpecialization(this, _typeParameterSubstitutionMap);
        }

        public getIsSpecialized() { return true; }

        public _getResolver(): PullTypeResolver {
            return this.getRootSymbol()._getResolver();
        }

        public getTypeParameters(): PullTypeParameterSymbol[] {
            if (!this._typeParameters) {
                var rootSymbol = <PullSignatureSymbol>this.getRootSymbol();
                var rootTypeParameters = rootSymbol.getTypeParameters();

                if (rootTypeParameters.length) {
                    this._typeParameters = [];
                    for (var i = 0; i < rootTypeParameters.length; i++) {
                        // Sometimes, one of the root symbol's type parameters is itself a surrounding type argument
                        // For example
                        // interface Foo<T> {
                        //     boo<S>(x: T, y: S): Foo<S>;
                        // }
                        // In the inner instantiation of Foo<S>, the surrounding T will actually be an S.
                        // Unless we substitute this inner S with an S', the types of x and y will appear
                        // to be the same.
                        // If typeParameterSubstitution does not exist, that means we did not generate
                        // new type parameters (this happens when no surrounding type parameters are
                        // referenced in the signature). In this case, we can just use the root type
                        // parameters of the signature.
                        // If typeParameterSubstitution does exist, it means we have synthesized new
                        // type parameters for this signature, and we should return them instead of
                        // the root type parameters.
                        var typeParameterSubstitution = <SynthesizedTypeParameterSymbol>this._typeParameterSubstitutionMap[rootTypeParameters[i].pullSymbolID];
                        this._typeParameters[this._typeParameters.length] = typeParameterSubstitution || rootTypeParameters[i];
                    }
                }
                else {
                    this._typeParameters = sentinelEmptyArray;
                }
            }

            return this._typeParameters;
        }

        public getAllowedToReferenceTypeParameters(): PullTypeParameterSymbol[] {
            var rootSymbol = <PullSignatureSymbol>this.getRootSymbol();
            return rootSymbol.getAllowedToReferenceTypeParameters();
        }
    }

    
    // Sometimes, one of the root symbol's type parameters is itself a surrounding type argument
    // For example
    // interface Foo<T> {
    //     boo<S>(x: T, y: S): Foo<S>;
    // }
    // In the inner instantiation of Foo<S>, the surrounding T will actually be an S.
    // Unless we substitute this inner S with an S', the types of x and y will appear
    // to be the same. PullSynthesizedTypeParameterSymbol is the S' in this example.
    export class SynthesizedTypeParameterSymbol extends PullTypeParameterSymbol {
        // We specifically do not set a root symbol here. Root symbols are only for instantiation.
        // This is distinct from instantiation.
        constructor(private originalTypeParameter: PullTypeParameterSymbol, private _typeParameterSubstitutionMapForConstraint: TypeSubstitutionMap) {
            super(originalTypeParameter.name, originalTypeParameter.semanticInfoChain);
            var originalTypeParameterDeclarations = originalTypeParameter.getDeclarations();
            for (var i = 0; i < originalTypeParameterDeclarations.length; i++) {
                this.addDeclaration(originalTypeParameterDeclarations[i]);
            }
        }

        public _getResolver(): PullTypeResolver {
            return this.originalTypeParameter._getResolver();
        }

        public getConstraint(): PullTypeSymbol {
            var constraint = super.getConstraint();
            if (!constraint) {
                var originalConstraint = this.originalTypeParameter.getConstraint();
                if (originalConstraint) {
                    constraint = this._getResolver().instantiateType(originalConstraint, this._typeParameterSubstitutionMapForConstraint);
                    this.setConstraint(constraint);
                }
            }
            return constraint;
        }
   }
}
///<reference path='..\references.ts' />

module TypeScript {

    export interface IPullTypeCollection {
        getLength(): number;
        getTypeAtIndex(index: number): PullTypeSymbol;
    }

    enum OverloadApplicabilityStatus {
        NotAssignable,
        AssignableButWithProvisionalErrors,
        AssignableWithNoProvisionalErrors,
        Subtype
    }

    export class PullAdditionalCallResolutionData {
        public targetSymbol: PullSymbol = null;
        public resolvedSignatures: PullSignatureSymbol[] = null;
        public candidateSignature: PullSignatureSymbol = null;
        public actualParametersContextTypeSymbols: PullTypeSymbol[] = null;
        public diagnosticsFromOverloadResolution: Diagnostic[] = [];
    }

    export class PullAdditionalObjectLiteralResolutionData {
        public membersContextTypeSymbols: PullTypeSymbol[] = null;
    }

    // A base origin is for inherited members. It points to which base the member was inherited from.
    class MemberWithBaseOrigin {
        constructor(public memberSymbol: PullSymbol, public baseOrigin: PullTypeSymbol) { }
    }

    class SignatureWithBaseOrigin {
        constructor(public signature: PullSignatureSymbol, public baseOrigin: PullTypeSymbol) { }
    }

    class InheritedIndexSignatureInfo {
        public numberSignatureWithBaseOrigin: SignatureWithBaseOrigin;
        public stringSignatureWithBaseOrigin: SignatureWithBaseOrigin;
    }

    enum CompilerReservedName {
        _this = 1,
        _super,
        arguments,
        _i,
        require,
        exports
    }

    function getCompilerReservedName(name: ISyntaxToken): number {
        var nameText = tokenValueText(name);
        return (<IIndexable<CompilerReservedName>><any>CompilerReservedName)[nameText];
    }

    export interface IndexSignatureInfo {
        numericSignature: PullSignatureSymbol;
        stringSignature: PullSignatureSymbol;
    }

    interface IExpressionWithArgumentListSyntax extends IExpressionSyntax {
        expression: IExpressionSyntax;
        argumentList: ArgumentListSyntax;
    }

    // The resolver associates types with a given AST
    export class PullTypeResolver {
        private _cachedArrayInterfaceType: PullTypeSymbol = null;
        private _cachedNumberInterfaceType: PullTypeSymbol = null;
        private _cachedStringInterfaceType: PullTypeSymbol = null;
        private _cachedBooleanInterfaceType: PullTypeSymbol = null;
        private _cachedObjectInterfaceType: PullTypeSymbol = null;
        private _cachedFunctionInterfaceType: PullTypeSymbol = null;
        private _cachedIArgumentsInterfaceType: PullTypeSymbol = null;
        private _cachedRegExpInterfaceType: PullTypeSymbol = null;
        private _cachedAnyTypeArgs: PullTypeSymbol[][] = null;

        private typeCheckCallBacks: { (context: PullTypeResolutionContext): void; }[] = [];
        private postTypeCheckWorkitems: ISyntaxElement[] = [];

        private _cachedFunctionArgumentsSymbol: PullSymbol = null;

        private assignableCache: IBitMatrix = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ true);
        private subtypeCache: IBitMatrix = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ true);
        private identicalCache: IBitMatrix = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ true);
        private inResolvingOtherDeclsWalker = new PullHelpers.OtherPullDeclsWalker();

        constructor(private compilationSettings: ImmutableCompilationSettings, public semanticInfoChain: SemanticInfoChain) { }

        private cachedArrayInterfaceType() {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (!this._cachedArrayInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedArrayInterfaceType;
        }

        // Returns the named type for the global Array<T> symbol.  Note that this will be 
        // uninstantiated (i.e. it will have type parameters, and not type arguments).
        public getArrayNamedType(): PullTypeSymbol {
            return this.cachedArrayInterfaceType();
        }

        private cachedNumberInterfaceType() {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Number", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedNumberInterfaceType;
        }

        private cachedStringInterfaceType() {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("String", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedStringInterfaceType;
        }

        private cachedBooleanInterfaceType() {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Boolean", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedBooleanInterfaceType;
        }

        private cachedObjectInterfaceType() {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Object", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedObjectInterfaceType;
        }

        private cachedFunctionInterfaceType() {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Function", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedFunctionInterfaceType;
        }

        private cachedIArgumentsInterfaceType() {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("IArguments", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedIArgumentsInterfaceType;
        }

        private cachedRegExpInterfaceType() {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("RegExp", [], PullElementKind.Interface) ||
                    this.semanticInfoChain.emptyTypeSymbol;
            }

            if (this._cachedRegExpInterfaceType && !this._cachedRegExpInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, new PullTypeResolutionContext(this));
            }

            return this._cachedRegExpInterfaceType;
        }

        private cachedFunctionArgumentsSymbol(): PullSymbol {
            if (!this._cachedFunctionArgumentsSymbol) {
                this._cachedFunctionArgumentsSymbol = new PullSymbol("arguments", PullElementKind.Variable, this.semanticInfoChain);
                this._cachedFunctionArgumentsSymbol.type = this.cachedIArgumentsInterfaceType() || this.semanticInfoChain.anyTypeSymbol;
                this._cachedFunctionArgumentsSymbol.setResolved();

                var functionArgumentsDecl = new PullSynthesizedDecl("arguments", "arguments", PullElementKind.Parameter, PullElementFlags.None, /*parentDecl*/ null);
                functionArgumentsDecl.setSymbol(this._cachedFunctionArgumentsSymbol, this.semanticInfoChain);
                this._cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);
            }

            return this._cachedFunctionArgumentsSymbol;
        }

        // Section 3.8.1: November 18, 2013
        // If T is the primitive type Number, Boolean, or String, the apparent type 
        // of T is the augmented form(as defined below) of the global interface type
        // 'Number', 'Boolean', or 'String'.
        // If T is an enum type, the apparent type of T is the augmented form of the
        // global interface type 'Number'.
        // If T is an object type, the apparent type of T is the augmented form of T.
        // If T is a type parameter, the apparent type of T is the augmented form
        // of the base constraint(section 3.4.1) of T.
        // Otherwise, the apparent type of T is T itself.
        private getApparentType(type: PullTypeSymbol): PullTypeSymbol {
            if (type.isTypeParameter()) {
                var baseConstraint = (<PullTypeParameterSymbol>type).getBaseConstraint(this.semanticInfoChain);
                if (baseConstraint === this.semanticInfoChain.anyTypeSymbol) {
                    // This is not yet in the spec. If a type parameter's base constraint is any
                    // (implicitly or explicitly), its apparent type is {}.
                    return this.semanticInfoChain.emptyTypeSymbol;
                }
                else {
                    // Don't return. We need to feed the resulting type thru the rest of the method
                    type = baseConstraint;
                }
            }
            if (type.isPrimitive()) {
                if (type === this.semanticInfoChain.numberTypeSymbol) {
                    return this.cachedNumberInterfaceType();
                }
                if (type === this.semanticInfoChain.booleanTypeSymbol) {
                    return this.cachedBooleanInterfaceType();
                }
                if (type === this.semanticInfoChain.stringTypeSymbol) {
                    return this.cachedStringInterfaceType();
                }
                return type;
            }
            if (type.isEnum()) {
                return this.cachedNumberInterfaceType();
            }
            return type;
        }

        private setTypeChecked(ast: ISyntaxElement, context: PullTypeResolutionContext) {
            context.setTypeChecked(ast);
        }

        private canTypeCheckAST(ast: ISyntaxElement, context: PullTypeResolutionContext) {
            return context.canTypeCheckAST(ast);
        }

        private setSymbolForAST(ast: ISyntaxElement, symbol: PullSymbol, context: PullTypeResolutionContext): void {
            if (context && context.inProvisionalResolution()) {
                // Cache provisionally
                context.setSymbolForAST(ast, symbol);
            }
            else {
                // Cache globally
                this.semanticInfoChain.setSymbolForAST(ast, symbol);
            }
        }

        private getSymbolForAST(ast: ISyntaxElement, context: PullTypeResolutionContext): PullSymbol {
            // Check global cache
            var symbol = this.semanticInfoChain.getSymbolForAST(ast);

            if (!symbol) {
                // Check provisional cache
                if (context && context.inProvisionalResolution()) {
                    symbol = context.getSymbolForAST(ast);
                }
            }

            return symbol;
        }

        public getASTForDecl(decl: PullDecl): ISyntaxElement {
            return this.semanticInfoChain.getASTForDecl(decl);
        }

        public getNewErrorTypeSymbol(name: string = null): PullErrorTypeSymbol {
            return new PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, name, this.semanticInfoChain);
        }

        public getEnclosingDecl(decl: PullDecl): PullDecl {
            var declPath = decl.getParentPath();

            if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            }
            else {
                return declPath[declPath.length - 1];
            }
        }

        private getExportedMemberSymbol(symbol: PullSymbol, parent: PullTypeSymbol): PullSymbol {

            if (!(symbol.kind & (PullElementKind.Method | PullElementKind.Property))) {
                var isContainer = (parent.kind & (PullElementKind.Container | PullElementKind.DynamicModule)) !== 0;
                var containerType = !isContainer ? parent.getAssociatedContainerType() : parent;

                if (isContainer && containerType) {
                    if (symbol.anyDeclHasFlag(PullElementFlags.Exported)) {
                        return symbol;
                    }

                    return null;
                }
            }

            return symbol;
        }

        // This is a modification of getMemberSymbol to fall back to Object or Function as necessary
        // November 18th, 2013, Section 3.8.1:
        // The augmented form of an object type T adds to T those members of the global interface type
        // 'Object' that arent hidden by members in T. Furthermore, if T has one or more call or
        // construct signatures, the augmented form of T adds to T the members of the global interface
        // type 'Function' that arent hidden by members in T. 
        // Note: The most convenient way to do this is to have a method on PullTypeSymbol that
        // gives the apparent type. However, this would require synthesizing a new type because
        // almost every type in the system should inherit the properties from Object. It would essentially
        // double the number of type symbols, which would significantly increase memory usage.
        public _getNamedPropertySymbolOfAugmentedType(symbolName: string, parent: PullTypeSymbol): PullSymbol {
            var memberSymbol = this.getNamedPropertySymbol(symbolName, PullElementKind.SomeValue, parent);
            if (memberSymbol) {
                return memberSymbol;
            }

            // Check if the parent has a call/construct signature, and if so, inherit from Function
            if (this.cachedFunctionInterfaceType() && parent.isFunctionType()) {
                memberSymbol = this.cachedFunctionInterfaceType().findMember(symbolName, /*lookInParent*/ true);
                if (memberSymbol) {
                    return memberSymbol;
                }
            }

            // Lastly, check the Object type
            if (this.cachedObjectInterfaceType()) {
                return this.cachedObjectInterfaceType().findMember(symbolName, /*lookInParent*/ true);
            }

            return null;
        }

        private getNamedPropertySymbol(symbolName: string, declSearchKind: PullElementKind, parent: PullTypeSymbol) {
            var member: PullSymbol = null;

            if (declSearchKind & PullElementKind.SomeValue) {
                member = parent.findMember(symbolName, /*lookInParent*/ true);
            }
            else if (declSearchKind & PullElementKind.SomeType) {
                member = parent.findNestedType(symbolName);
            }
            else if (declSearchKind & PullElementKind.SomeContainer) {
                member = parent.findNestedContainer(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var containerType = parent.getAssociatedContainerType();

            if (containerType) {

                // If we were searching over the constructor type, we don't want to also search
                // over the class instance type (we only want to consider static fields)
                if (containerType.isClass()) {
                    return null;
                }

                parent = containerType;

                if (declSearchKind & PullElementKind.SomeValue) {
                    member = parent.findMember(symbolName, /*lookInParent*/ true);
                }
                else if (declSearchKind & PullElementKind.SomeType) {
                    member = parent.findNestedType(symbolName);
                }
                else if (declSearchKind & PullElementKind.SomeContainer) {
                    member = parent.findNestedContainer(symbolName);
                }

                if (member) {
                    return this.getExportedMemberSymbol(member, parent);
                }
            }

            if (parent.kind & PullElementKind.SomeContainer) {
                var typeDeclarations = parent.getDeclarations();
                var childDecls: PullDecl[] = null;

                for (var j = 0; j < typeDeclarations.length; j++) {
                    childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        member = childDecls[0].getSymbol(this.semanticInfoChain);

                        if (!member) {
                            member = childDecls[0].getSignatureSymbol(this.semanticInfoChain);
                        }
                        return this.getExportedMemberSymbol(member, parent);
                    }

                    // If we were looking  for some type or value, we need to look for alias so we can see if it has associated value or type symbol with it
                    if ((declSearchKind & PullElementKind.SomeType) !== 0 || (declSearchKind & PullElementKind.SomeValue) !== 0) {
                        childDecls = typeDeclarations[j].searchChildDecls(symbolName, PullElementKind.TypeAlias);
                        if (childDecls.length && childDecls[0].kind === PullElementKind.TypeAlias) { // this can return container or dynamic module
                            var aliasSymbol = <PullTypeAliasSymbol>this.getExportedMemberSymbol(childDecls[0].getSymbol(this.semanticInfoChain), parent);
                            if (aliasSymbol) {
                                if (!aliasSymbol.isResolved) {
                                    this.resolveDeclaredSymbol(aliasSymbol);
                                }

                                if ((declSearchKind & PullElementKind.SomeType) !== 0) {
                                    // Some type
                                    var typeSymbol = aliasSymbol.getExportAssignedTypeSymbol();
                                    if (typeSymbol) {
                                        return typeSymbol;
                                    }
                                }
                                else {
                                    // Some value
                                    var valueSymbol = aliasSymbol.getExportAssignedValueSymbol();
                                    if (valueSymbol) {
                                        aliasSymbol.setIsUsedAsValue();
                                        return valueSymbol;
                                    }
                                }

                                return aliasSymbol;
                            }
                        }
                    }
                }
            }
        }
        
        // search for an unqualified symbol name within a given decl path
        private getSymbolFromDeclPath(symbolName: string, declPath: PullDecl[], declSearchKind: PullElementKind): PullSymbol {
            var symbol: PullSymbol = null;

            // search backwards through the decl list
            //  - if the decl in question is a function, search its members
            //  - if the decl in question is a module, search the decl then the symbol
            //  - Otherwise, search globally

            var decl: PullDecl = null;
            var childDecls: PullDecl[];
            var declSymbol: PullTypeSymbol = null;
            var declMembers: PullSymbol[];
            var pathDeclKind: PullElementKind;
            var valDecl: PullDecl = null;
            var kind: PullElementKind;
            var instanceSymbol: PullSymbol = null;
            var instanceType: PullTypeSymbol = null;
            var childSymbol: PullSymbol = null;

            // if search kind allows searching for enum members - expand search space to enums
            var allowedContainerDeclKind = PullElementKind.Container | PullElementKind.DynamicModule;
            if (TypeScript.hasFlag(declSearchKind, PullElementKind.EnumMember)) {
                allowedContainerDeclKind |= PullElementKind.Enum;
            }

            var isAcceptableAlias = (symbol: PullSymbol): boolean => {
                if (symbol.isAlias()) {
                    this.resolveDeclaredSymbol(symbol);
                    if (hasFlag(declSearchKind, PullElementKind.SomeContainer)) {
                        if ((<PullTypeAliasSymbol>symbol).assignedContainer() || (<PullTypeAliasSymbol>symbol).getExportAssignedContainerSymbol()) {
                            return true;
                        }
                    }
                    else if (hasFlag(declSearchKind, PullElementKind.SomeType)) {
                        // check if alias points to dynamic module - it should not be returned if type is requested
                        var type = (<PullTypeAliasSymbol>symbol).getExportAssignedTypeSymbol();
                        if (type && type.kind !== PullElementKind.DynamicModule) {
                            return true;
                        }

                        // check if alias points to dynamic module - if should not be returned if type is requested
                        var type = (<PullTypeAliasSymbol>symbol).assignedType();
                        if (type && type.kind !== PullElementKind.DynamicModule) {
                            return true;
                        }
                    }
                    // search for value might exclude EnumMember element from the declSearchKind
                    else if (hasFlag(declSearchKind, PullElementKind.SomeValue & ~PullElementKind.EnumMember)) {
                        // if alias is dereferenced to unresolved module - be conservative and treat it as value
                        if ((<PullTypeAliasSymbol>symbol).assignedType() && (<PullTypeAliasSymbol>symbol).assignedType().isError()) {
                            return true;
                        }
                        else if ((<PullTypeAliasSymbol>symbol).assignedValue() || (<PullTypeAliasSymbol>symbol).getExportAssignedValueSymbol()) {
                            return true;
                        }
                        else {
                            // alias is dereferenced to container with existing instance side - return alias
                            var assignedType = (<PullTypeAliasSymbol>symbol).assignedType();
                            if (assignedType && assignedType.isContainer() && (<PullContainerSymbol>assignedType).getInstanceType()) {
                                return true;
                            }

                            // Spec Nov 18:
                            // 11.2.3 Unlike a non-instantiated internal module (section 10.1), 
                            // an external module containing only interface types and non-instantiated internal modules still has a module instance associated with it, albeit one with no members.
                            var decls = symbol.getDeclarations();
                            var ast = <ImportDeclarationSyntax>decls[0].ast();
                            return ast.moduleReference.kind() === SyntaxKind.ExternalModuleReference;
                        }
                    }
                }

                return false;
            }

            var tryFindAlias = (decl: PullDecl): PullSymbol => {
                var childDecls = decl.searchChildDecls(symbolName, PullElementKind.TypeAlias);

                if (childDecls.length) {
                    var sym = childDecls[0].getSymbol(this.semanticInfoChain);
                    if (isAcceptableAlias(sym)) {
                        return sym;
                    }
                }
                return null;
            }

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                if (decl.flags & PullElementFlags.DeclaredInAWithBlock) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
                
                if (pathDeclKind & allowedContainerDeclKind) {

                    // first check locally
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol(this.semanticInfoChain);
                    }

                    var alias = tryFindAlias(decl);
                    if (alias) {
                        return alias;
                    }

                    if (declSearchKind & PullElementKind.SomeValue) {

                        // search "split" exported members
                        instanceSymbol = (<PullContainerSymbol>decl.getSymbol(this.semanticInfoChain)).getInstanceSymbol();

                        if (instanceSymbol) {
                            instanceType = instanceSymbol.type;

                            childSymbol = this.getNamedPropertySymbol(symbolName, declSearchKind, instanceType);

                            // Make sure we are not picking up a static from a class (it is never in scope)
                            if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(PullElementFlags.Static)) {
                                return childSymbol;
                            }
                        }

                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    // otherwise, check the members
                    declSymbol = decl.getSymbol(this.semanticInfoChain).type;

                    var childSymbol = this.getNamedPropertySymbol(symbolName, declSearchKind, declSymbol);

                    if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.anyDeclHasFlag(PullElementFlags.Static)) {
                        return childSymbol;
                    }
                }
                else if ((declSearchKind & (PullElementKind.SomeType | PullElementKind.SomeContainer)) || !(pathDeclKind & PullElementKind.Class)) {
                    var candidateSymbol: PullSymbol = null;

                    // If the decl is a function expression, we still want to check its children since it may be shadowed by one
                    // of its parameters
                    if (pathDeclKind === PullElementKind.FunctionExpression && symbolName === (<PullFunctionExpressionDecl>decl).getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol(this.semanticInfoChain);
                    }

                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        // if the enclosing decl is a function of some sort, we need to ensure that it's bound
                        // otherwise, the child decl may not be properly bound if it's a parameter (since they're
                        // bound when binding the function symbol)
                        if (decl.kind & PullElementKind.SomeFunction) {
                            decl.ensureSymbolIsBound(this.semanticInfoChain);
                        }
                        return childDecls[0].getSymbol(this.semanticInfoChain);
                    }

                    if (candidateSymbol) {
                        return candidateSymbol;
                    }

                    var alias = tryFindAlias(decl);
                    if (alias) {
                        return alias;
                    }
                }
            }

            // otherwise, search globally
            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);
            if (symbol) {
                return symbol;
            }

            // if element was not found and we were not searching for aliases- try to find globally defined type alias
            if (!hasFlag(declSearchKind, PullElementKind.TypeAlias)) {
                symbol = this.semanticInfoChain.findSymbol([symbolName], PullElementKind.TypeAlias);
                if (symbol && isAcceptableAlias(symbol)) {
                    return symbol;
                }
            }

            return null;
        }

        private getVisibleDeclsFromDeclPath(declPath: PullDecl[], declSearchKind: PullElementKind): PullDecl[] {
            var result: PullDecl[] = [];
            var decl: PullDecl = null;
            var childDecls: PullDecl[];
            var pathDeclKind: PullElementKind;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                var declKind = decl.kind;

                // First add locals
                // Child decls of classes and interfaces are members, and should only be visible as members of 'this'
                if (declKind !== PullElementKind.Class && declKind !== PullElementKind.Interface) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }

                switch (declKind) {
                    case PullElementKind.Container:
                    case PullElementKind.DynamicModule:
                        // Add members from other instances
                        var otherDecls = this.semanticInfoChain.findDeclsFromPath(declPath.slice(0, i + 1), PullElementKind.SomeContainer);
                        for (var j = 0, m = otherDecls.length; j < m; j++) {
                            var otherDecl = otherDecls[j];
                            if (otherDecl === decl) {
                                continue;
                            }

                            var otherDeclChildren = otherDecl.getChildDecls();
                            for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                var otherDeclChild = otherDeclChildren[k];
                                if ((otherDeclChild.flags & PullElementFlags.Exported) && (otherDeclChild.kind & declSearchKind)) {
                                    result.push(otherDeclChild);
                                }
                            }
                        }

                        break;

                    case PullElementKind.Class:
                    case PullElementKind.Interface:
                        // Add generic types prameters
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;

                    case PullElementKind.FunctionExpression:
                        var functionExpressionName = (<PullFunctionExpressionDecl>decl).getFunctionExpressionName();
                        if (functionExpressionName) {
                            result.push(decl);
                        }
                    // intentional fall through.

                    case PullElementKind.Function:
                    case PullElementKind.ConstructorMethod:
                    case PullElementKind.Method:
                        // Add generic types prameters
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;
                }
            }

            // Get the global decls
            var topLevelDecls = this.semanticInfoChain.topLevelDecls();
            for (var i = 0, n = topLevelDecls.length; i < n; i++) {
                var topLevelDecl = topLevelDecls[i];
                if (declPath.length > 0 && topLevelDecl.fileName() === declPath[0].fileName()) {
                    // Current unit has already been processed. skip it.
                    continue;
                }

                if (!topLevelDecl.isExternalModule()) {
                    this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result)
                }
            }

            return result;
        }

        private addFilteredDecls(decls: PullDecl[], declSearchKind: PullElementKind, result: PullDecl[]): void {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.kind & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        }

        public getVisibleDecls(enclosingDecl: PullDecl): PullDecl[] {
            var declPath = enclosingDecl.getParentPath();

            var declSearchKind: PullElementKind = PullElementKind.SomeType | PullElementKind.SomeContainer | PullElementKind.SomeValue;

            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        }

        public getVisibleContextSymbols(enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol[] {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }

            var declSearchKind: PullElementKind = PullElementKind.SomeType | PullElementKind.SomeContainer | PullElementKind.SomeValue;
            var members: PullSymbol[] = contextualTypeSymbol.getAllMembers(declSearchKind, GetAllMembersVisiblity.externallyVisible);

            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }

            return members;
        }

        public getVisibleMembersFromExpression(expression: ISyntaxElement, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol[] {
            var lhs = this.resolveAST(expression, false, context);

            if (isTypesOnlyLocation(expression) && (lhs.kind === PullElementKind.Class || lhs.kind === PullElementKind.Interface || lhs.kind === PullElementKind.Enum)) {
                // No more sub types in these types
                return null;
            }

            var lhsType = lhs.type;
            if (!lhsType) {
                return null;
            }

            this.resolveDeclaredSymbol(lhsType, context);

            if (lhsType.isContainer() && lhsType.isAlias()) {
                lhsType = (<PullTypeAliasSymbol>lhsType).getExportAssignedTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }

            // Figure out if privates are available under the current scope
            var memberVisibilty = GetAllMembersVisiblity.externallyVisible;
            var containerSymbol = lhsType;
            if (containerSymbol.kind === PullElementKind.ConstructorType) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].returnType;
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = enclosingDecl.getParentPath();
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (ArrayUtilities.contains(declPath, declaration)) {
                            memberVisibilty = GetAllMembersVisiblity.internallyVisible;
                            break;
                        }
                    }
                }
            }

            var declSearchKind: PullElementKind = PullElementKind.SomeType | PullElementKind.SomeContainer | PullElementKind.SomeValue;

            var members: PullSymbol[] = [];

            if (lhsType.isContainer()) {
                var exportedAssignedContainerSymbol = (<PullContainerSymbol>lhsType).getExportAssignedContainerSymbol();
                if (exportedAssignedContainerSymbol) {
                    lhsType = exportedAssignedContainerSymbol;
                }
            }

            lhsType = this.getApparentType(lhsType);

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = <PullTypeSymbol>this.resolveDeclaredSymbol(lhsType, context);

                if (potentiallySpecializedType !== lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            members = lhsType.getAllMembers(declSearchKind, memberVisibilty);

            // In order to show all members in type or value positions, query the associated symbol for members 
            // on modules.
            if (lhsType.isContainer()) {
                var associatedInstance = (<PullContainerSymbol>lhsType).getInstanceSymbol();
                if (associatedInstance) {
                    var instanceType = associatedInstance.type;
                    this.resolveDeclaredSymbol(instanceType, context);
                    var instanceMembers = instanceType.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(instanceMembers);
                }

                var exportedContainer = (<PullContainerSymbol>lhsType).getExportAssignedContainerSymbol();
                if (exportedContainer) {
                    var exportedContainerMembers = exportedContainer.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(exportedContainerMembers);
                }
            }
            else if (!lhsType.isConstructor() && !lhsType.isEnum()) {
                var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    var containerType = associatedContainerSymbol.type;
                    this.resolveDeclaredSymbol(containerType, context);
                    var containerMembers = containerType.getAllMembers(declSearchKind, memberVisibilty);
                    members = members.concat(containerMembers);
                }
            }

            // could be a function symbol
            if (lhsType.isFunctionType() && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, GetAllMembersVisiblity.externallyVisible));
            }

            return members;
        }

        private isAnyOrEquivalent(type: PullTypeSymbol) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        }

        private resolveExternalModuleReference(idText: string, currentFileName: string): PullContainerSymbol {
            var originalIdText = idText;
            var symbol: PullContainerSymbol = null;

            if (isRelative(originalIdText)) {
                // Find the module relative to current file
                var path = getRootFilePath(switchToForwardSlashes(currentFileName));
                symbol = this.semanticInfoChain.findExternalModule(path + idText);
            }
            else {
                idText = originalIdText;

                // Search in global context if there exists ambient module
                symbol = this.semanticInfoChain.findAmbientExternalModuleInGlobalContext(quoteStr(originalIdText));

                if (!symbol) {
                    // REVIEW: Technically, we shouldn't have to normalize here - we should normalize in addUnit.
                    // Still, normalizing here alows any language services to be free of assumptions
                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));

                    // Search for external modules compiled (.d.ts or .ts files) starting with current files directory to root directory until we find the module
                    while (symbol === null && path != "") {
                        symbol = this.semanticInfoChain.findExternalModule(path + idText);
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            }
                            else {
                                path = normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }

            return symbol;
        }

        // PULLTODO: VERY IMPORTANT
        // Right now, the assumption is that the declaration's parse tree is still in memory
        // we need to add a cache-in/cache-out mechanism so that we can break the dependency on in-memory ASTs
        public resolveDeclaredSymbol<TSymbol extends PullSymbol>(symbol: TSymbol, context?: PullTypeResolutionContext): TSymbol {
            if (!symbol || symbol.isResolved || symbol.isTypeReference()) {
                return symbol;
            }

            if (!context) {
                context = new PullTypeResolutionContext(this);
            }

            return this.resolveDeclaredSymbolWorker(symbol, context);
        }

        private resolveDeclaredSymbolWorker<TSymbol extends PullSymbol>(symbol: TSymbol, context: PullTypeResolutionContext): TSymbol {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }

            if (symbol.inResolution) {
                if (!symbol.type && !symbol.isType()) {
                    symbol.type = this.semanticInfoChain.anyTypeSymbol;
                }

                return symbol;
            }

            var decls = symbol.getDeclarations();

            // We want to walk and resolve all associated decls, so we can catch
            // cases like function overloads that may be spread across multiple
            // logical declarations
            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];

                var ast = this.semanticInfoChain.getASTForDecl(decl);

                // if it's an object literal member, just return the symbol and wait for
                // the object lit to be resolved
                if (!ast ||
                    (ast.kind() === SyntaxKind.GetAccessor && ast.parent.parent.kind() === SyntaxKind.ObjectLiteralExpression) ||
                    (ast.kind() === SyntaxKind.SetAccessor && ast.parent.parent.kind() === SyntaxKind.ObjectLiteralExpression)) {
                    // We'll return the cached results, and let the decl be corrected on the next invalidation
                    return symbol;
                }

                // There are a few places where an identifier may represent the declaration of 
                // a symbol.  They include:

                // A catch variable.  i.e.:  catch (e) { ...
                if (ast.parent && ast.parent.kind() === SyntaxKind.CatchClause && (<CatchClauseSyntax>ast.parent).identifier === ast) {
                    return symbol;
                }

                // A simple arrow parameter.  i.e.:   a => ...
                if (ast.parent && ast.parent.kind() === SyntaxKind.SimpleArrowFunctionExpression && (<SimpleArrowFunctionExpressionSyntax>ast.parent).identifier === ast) {
                    return symbol;
                }

                // One of the names in a module declaration.  i.e.:  module A.B.C { ...

                // If our decl points at a single name of a module, then just resolve that individual module.
                var enclosingModule = ASTHelpers.getModuleDeclarationFromNameAST(ast);
                var resolvedSymbol: PullSymbol;
                if (enclosingModule) {
                    resolvedSymbol = this.resolveSingleModuleDeclaration(enclosingModule, ast, context);
                }
                else if (ast.kind() === SyntaxKind.SourceUnit && decl.kind === PullElementKind.DynamicModule) {
                    // Otherwise, if we have a decl for the top level external module, then just resolve that
                    // specific module.
                    resolvedSymbol = this.resolveModuleSymbol(<PullContainerSymbol>decl.getSymbol(this.semanticInfoChain), context, /*moduleDeclAST:*/ null, /*moduleNameAST:*/ null, <SourceUnitSyntax>ast);
                }
                else {
                    // This assert is here to catch potential stack overflows. There have been infinite recursions resulting
                    // from one of these decls pointing to a name expression.
                    Debug.assert(ast.kind() !== SyntaxKind.IdentifierName && ast.kind() !== SyntaxKind.MemberAccessExpression);
                    resolvedSymbol = this.resolveAST(ast, /*isContextuallyTyped*/false, context);
                }

                // if the symbol is a parameter property referenced in an out-of-order fashion, it may not have been resolved
                // along with the original property, so we need to "fix" its type here
                if (decl.kind === PullElementKind.Parameter &&
                    !symbol.isResolved &&
                    !symbol.type &&
                    resolvedSymbol &&
                    symbol.anyDeclHasFlag(PullElementFlags.PropertyParameter | PullElementFlags.ConstructorParameter)) {

                    symbol.type = resolvedSymbol.type;
                    symbol.setResolved();
                }
            }

            if (!symbol.isResolved) {
                Debug.assert(!symbol.inResolution);
                // All declarations are resolved there is nothing to do any more 
                symbol.setResolved();
            }

            return symbol;
        }

        private resolveOtherDecl(otherDecl: PullDecl, context: PullTypeResolutionContext) {
            var astForOtherDecl = this.getASTForDecl(otherDecl);
            var moduleDecl = ASTHelpers.getModuleDeclarationFromNameAST(astForOtherDecl);
            if (moduleDecl) {
                this.resolveSingleModuleDeclaration(moduleDecl, astForOtherDecl, context);
            }
            else {
                this.resolveAST(astForOtherDecl, false, context);
            }
        }

        private resolveOtherDeclarations(astName: ISyntaxElement, context: PullTypeResolutionContext) {
            var resolvedDecl = this.semanticInfoChain.getDeclForAST(astName);
            var symbol = resolvedDecl.getSymbol(this.semanticInfoChain);

            var allDecls = symbol.getDeclarations();
            this.inResolvingOtherDeclsWalker.walkOtherPullDecls(resolvedDecl, symbol.getDeclarations(),
                otherDecl => this.resolveOtherDecl(otherDecl, context));
        }

        private resolveSourceUnit(sourceUnit: SourceUnitSyntax, context: PullTypeResolutionContext): PullSymbol {
            // Ensure that any export assignments are resolved before we proceed. 
            var enclosingDecl = this.getEnclosingDeclForAST(sourceUnit);
            var moduleSymbol = enclosingDecl.getSymbol(this.semanticInfoChain);
            this.ensureAllSymbolsAreBound(moduleSymbol);

            this.resolveFirstExportAssignmentStatement(sourceUnit.moduleElements, context);
            this.resolveAST(sourceUnit.moduleElements, /*isContextuallyTyped:*/ false, context);

            if (this.canTypeCheckAST(sourceUnit, context)) {
                this.typeCheckSourceUnit(sourceUnit, context);
            }

            return moduleSymbol;
        }

        private typeCheckSourceUnit(sourceUnit: SourceUnitSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(sourceUnit, context);

            this.resolveAST(sourceUnit.moduleElements, /*isContextuallyTyped:*/ false, context);

            this.typeCheckCallBacks.push(context => this.verifyUniquenessOfImportNamesInSourceUnit(sourceUnit));
        }

        private verifyUniquenessOfImportNamesInSourceUnit(sourceUnit: SourceUnitSyntax) {
            var enclosingDecl = this.semanticInfoChain.getDeclForAST(sourceUnit);

            var doesImportNameExistInOtherFiles = (name: string): boolean => {
                var importSymbol = this.semanticInfoChain.findTopLevelSymbol(name, PullElementKind.TypeAlias, null);
                return importSymbol && importSymbol.isAlias();
            }

            this.checkUniquenessOfImportNames([enclosingDecl], doesImportNameExistInOtherFiles);
        }

        private resolveEnumDeclaration(ast: EnumDeclarationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            var containerSymbol = <PullContainerSymbol>containerDecl.getSymbol(this.semanticInfoChain);

            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;

            var containerDecls = containerSymbol.getDeclarations();

            for (var i = 0; i < containerDecls.length; i++) {

                var childDecls = containerDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                }
            }

            containerSymbol.setResolved();

            this.resolveOtherDeclarations(ast, context);

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckEnumDeclaration(ast, context);
            }

            return containerSymbol;
        }

        private typeCheckEnumDeclaration(ast: EnumDeclarationSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.enumElements, false, context);
            var containerDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(containerDecl, context);

            this.typeCheckCallBacks.push(context => this.checkInitializersInEnumDeclarations(containerDecl, context))

            if (!ASTHelpers.enumIsElided(ast)) {
                this.checkNameForCompilerGeneratedDeclarationCollision(ast, /*isDeclaration*/ true, ast.identifier, context);
            }
        }

        private postTypeCheckEnumDeclaration(ast: EnumDeclarationSyntax, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(ast, /*isDeclaration*/ true, context);
        }

        private checkInitializersInEnumDeclarations(decl: PullDecl, context: PullTypeResolutionContext) {
            var symbol = decl.getSymbol(this.semanticInfoChain);

            // check should be executed just once so run it only for one decl
            var declarations = symbol.getDeclarations();
            if (decl !== declarations[0]) {
                return;
            }

            // SPEC: NOV 18
            // It isnt possible for one enum declaration to continue the automatic numbering sequence of another, 
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value for the first member.            
            var seenEnumDeclWithNoFirstMember = false;
            for (var i = 0; i < declarations.length; ++i) {
                var currentDecl = declarations[i];

                var ast = <EnumDeclarationSyntax>currentDecl.ast();
                if (ast.enumElements.length === 0) {
                    continue;
                }

                var firstVariable = ast.enumElements[0];
                if (!firstVariable.equalsValueClause) {
                    if (!seenEnumDeclWithNoFirstMember) {
                        seenEnumDeclWithNoFirstMember = true;
                    }
                    else {
                        this.semanticInfoChain.addDiagnosticFromAST(firstVariable, DiagnosticCode.In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element);
                    }
                }
            }
        }

        //
        // Resolve a module declaration
        //
        private resolveModuleDeclaration(ast: ModuleDeclarationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var result: PullTypeSymbol;

            if (ast.stringLiteral) {
                result = this.resolveSingleModuleDeclaration(ast, ast.stringLiteral, context);
            }
            else {

                var moduleNames = ASTHelpers.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    result = this.resolveSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckModuleDeclaration(ast, context);
            }

            return result;
        }

        private ensureAllSymbolsAreBound(containerSymbol: PullSymbol): void {
            if (containerSymbol) {
                var containerDecls = containerSymbol.getDeclarations();

                for (var i = 0; i < containerDecls.length; i++) {
                    var childDecls = containerDecls[i].getChildDecls();

                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }
        }

        private resolveModuleSymbol(containerSymbol: PullContainerSymbol, context: PullTypeResolutionContext, moduleDeclAST: ModuleDeclarationSyntax, moduleDeclNameAST: ISyntaxElement, sourceUnitAST: SourceUnitSyntax): PullTypeSymbol {
            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;
            this.ensureAllSymbolsAreBound(containerSymbol);

            var instanceSymbol = containerSymbol.getInstanceSymbol();

            // resolve the instance variable, if neccesary
            if (instanceSymbol) {
                this.resolveDeclaredSymbol(instanceSymbol, context);
            }

            var isLastName = ASTHelpers.isLastNameOfModule(moduleDeclAST, moduleDeclNameAST);
            if (isLastName) {
                this.resolveFirstExportAssignmentStatement(moduleDeclAST.moduleElements, context);
            }
            else if (sourceUnitAST) {
                this.resolveFirstExportAssignmentStatement(sourceUnitAST.moduleElements, context);
            }

            containerSymbol.setResolved();

            if (moduleDeclNameAST) {
                this.resolveOtherDeclarations(moduleDeclNameAST, context);
            }

            return containerSymbol;
        }

        private resolveFirstExportAssignmentStatement(moduleElements: IModuleElementSyntax[], context: PullTypeResolutionContext): void {
            for (var i = 0, n = moduleElements.length; i < n; i++) {
                var moduleElement = moduleElements[i];
                if (moduleElement.kind() === SyntaxKind.ExportAssignment) {
                    this.resolveExportAssignmentStatement(<ExportAssignmentSyntax>moduleElement, context);
                    return;
                }
            }
        }

        private resolveSingleModuleDeclaration(ast: ModuleDeclarationSyntax, astName: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            var containerSymbol = <PullContainerSymbol>containerDecl.getSymbol(this.semanticInfoChain);

            return this.resolveModuleSymbol(containerSymbol, context, ast, astName, /*sourceUnit:*/ null);
        }

        private typeCheckModuleDeclaration(ast: ModuleDeclarationSyntax, context: PullTypeResolutionContext): void {
            if (ast.stringLiteral) {
                this.typeCheckSingleModuleDeclaration(ast, ast.stringLiteral, context);
            }
            else {
                var moduleNames = ASTHelpers.getModuleNames(ast.name);
                for (var i = 0, n = moduleNames.length; i < n; i++) {
                    this.typeCheckSingleModuleDeclaration(ast, moduleNames[i], context);
                }
            }
        }

        private typeCheckSingleModuleDeclaration(ast: ModuleDeclarationSyntax, astName: ISyntaxElement, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            if (ASTHelpers.isLastNameOfModule(ast, astName)) {
                this.resolveAST(ast.moduleElements, false, context);
            }

            var containerDecl = this.semanticInfoChain.getDeclForAST(astName);
            this.validateVariableDeclarationGroups(containerDecl, context);

            if (ast.stringLiteral) {
                if (isRelative(tokenValueText(ast.stringLiteral))) {
                    this.semanticInfoChain.addDiagnosticFromAST(
                        ast.stringLiteral, DiagnosticCode.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                }
            }

            if (!ASTHelpers.moduleIsElided(ast) && !ast.stringLiteral) {
                this.checkNameForCompilerGeneratedDeclarationCollision(astName, /*isDeclaration*/ true, <ISyntaxToken>astName, context);
            }

            this.typeCheckCallBacks.push(context => this.verifyUniquenessOfImportNamesInModule(containerDecl));
        }

        private verifyUniquenessOfImportNamesInModule(decl: PullDecl): void {
            var symbol = decl.getSymbol(this.semanticInfoChain);
            if (!symbol) {
                return;
            }

            var decls = symbol.getDeclarations();
            // this check should be performed once per module.
            // to guarantee this we'll perform check only for one declaration that form the module
            if (decls[0] !== decl) {
                return;
            }

            this.checkUniquenessOfImportNames(decls);
        }

        private checkUniquenessOfImportNames(decls: PullDecl[], doesNameExistOutside?: (name: string) => boolean): void {

            var importDeclarationNames: IIndexable<boolean>;
            // collect all type aliases across all supplied declarations
            for (var i = 0; i < decls.length; ++i) {
                var childDecls = decls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; ++j) {
                    var childDecl = childDecls[j];
                    if (childDecl.kind === PullElementKind.TypeAlias) {
                        importDeclarationNames = importDeclarationNames || createIntrinsicsObject<boolean>();
                        importDeclarationNames[childDecl.name] = true;
                    }
                }
            }

            if (!importDeclarationNames && !doesNameExistOutside) {
                return;
            }

            for (var i = 0; i < decls.length; ++i) {
                // Walk over all variable declaration groups located in 'decls[i]', 
                // pick the first item from the group and test if it name conflicts with the name of any of import declaration.
                // Taking just first item is enough since all variables in group have the same name
                this.scanVariableDeclarationGroups(
                    decls[i],
                    (firstDeclInGroup: PullDecl) => {
                        // Make sure the variable declaration doesn't conflict with an import declaration.
                        var nameConflict = importDeclarationNames && importDeclarationNames[firstDeclInGroup.name];
                        if (!nameConflict) {
                            nameConflict = doesNameExistOutside && doesNameExistOutside(firstDeclInGroup.name);
                            if (nameConflict) {
                                // save result for name == 'firstDeclInGroup.name' so if we'll see it again the result will be picked from the cache instead of invoking 'doesNameExistOutside' callback.
                                importDeclarationNames = importDeclarationNames || createIntrinsicsObject<boolean>();
                                importDeclarationNames[firstDeclInGroup.name] = true;
                            }
                        }

                        if (nameConflict) {
                            this.semanticInfoChain.addDiagnosticFromAST(firstDeclInGroup.ast(),
                                DiagnosticCode.Variable_declaration_cannot_have_the_same_name_as_an_import_declaration);
                        }
                    });
            }
        }

        private scanVariableDeclarationGroups(
            enclosingDecl: PullDecl,
            firstDeclHandler: (firstDecl: PullDecl) => void,
            subsequentDeclHandler?: (subsequentDecl: PullDecl, firstSymbol: PullSymbol) => void): void {

            var declGroups: PullDecl[][] = enclosingDecl.getVariableDeclGroups();

            for (var i = 0; i < declGroups.length; i++) {
                var firstSymbol: PullSymbol = null;
                var enclosingDeclForFirstSymbol: PullSymbol = null;

                if (enclosingDecl.kind === PullElementKind.Script && declGroups[i].length) {
                    var name = declGroups[i][0].name;
                    var candidateSymbol = this.semanticInfoChain.findTopLevelSymbol(name, PullElementKind.Variable, enclosingDecl);
                    if (candidateSymbol) {
                        if (!candidateSymbol.anyDeclHasFlag(PullElementFlags.ImplicitVariable)) {
                            // in case if candidate is declared in lib.d.ts it might not be resolved in IDE scenarios (because of deferred resolution of lib.d.ts)
                            // however we cannot just ignore it since then behavior will be different from command line (where everything is resolved).
                            if (!candidateSymbol.isResolved) {
                                this.resolveDeclaredSymbol(candidateSymbol);
                            }
                            firstSymbol = candidateSymbol;
                        }
                    }
                }

                for (var j = 0; j < declGroups[i].length; j++) {
                    var decl = declGroups[i][j];

                    var name = decl.name;

                    var symbol = decl.getSymbol(this.semanticInfoChain);

                    if (j === 0) {
                        firstDeclHandler(decl);
                        if (!subsequentDeclHandler) {
                            break;
                        }

                        if (!firstSymbol || !firstSymbol.type) {
                            firstSymbol = symbol;
                            continue;
                        }
                    }

                    subsequentDeclHandler(decl, firstSymbol);
                }
            }
        }


        private postTypeCheckModuleDeclaration(ast: ModuleDeclarationSyntax, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(ast, /*isDeclaration*/ true, context);
        }

        private isTypeRefWithoutTypeArgs(term: ISyntaxElement) {
            if (term.kind() === SyntaxKind.IdentifierName) {
                return true;
            }
            else if (term.kind() === SyntaxKind.QualifiedName) {
                var binex = <QualifiedNameSyntax>term;

                if (binex.right.kind() === SyntaxKind.IdentifierName) {
                    return true;
                }
            }

            return false;
        }

        public createInstantiatedType(type: PullTypeSymbol, typeArguments: PullTypeSymbol[]): PullTypeSymbol {

            if (!type.isGeneric()) {
                return type;
            }

            // if the type had previously been instantiated, we want to re-instantiate the type arguments.  Otherwise,
            // we just use the type parameters.  E.g., for
            //      class Foo<T> {
            //          public <U>(p: Foo<U>): void
            //      }
            // For parameter 'p', we'd need to specialize from 'T' to 'U' to 'any', so we'd need to request p's type arguments
            // and not its type parameters
            var typeParameters = type.getTypeArgumentsOrTypeParameters();

            var typeParameterArgumentMap: PullTypeSymbol[] = [];

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterArgumentMap[typeParameters[i].pullSymbolID] = typeArguments[i] || new PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, typeParameters[i].name, this.semanticInfoChain);
            }

            return InstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap);
        }

        //
        // Resolve a reference type (class or interface) type parameters, implements and extends clause, members, call, construct and index signatures
        //
        private resolveReferenceTypeDeclaration(
            classOrInterface: ISyntaxElement,
            name: ISyntaxToken,
            heritageClauses: HeritageClauseSyntax[],
            context: PullTypeResolutionContext): PullSymbol {

            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = <PullTypeSymbol>typeDecl.getSymbol(this.semanticInfoChain);
            var typeDeclIsClass = classOrInterface.kind() === SyntaxKind.ClassDeclaration;
            var hasVisited = this.getSymbolForAST(classOrInterface, context) !== null;

            if ((typeDeclSymbol.isResolved && hasVisited) || (typeDeclSymbol.inResolution && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }

            var wasResolving = typeDeclSymbol.inResolution;
            typeDeclSymbol.startResolving();

            // ensure that all members are bound
            var typeRefDecls = typeDeclSymbol.getDeclarations();

            for (var i = 0; i < typeRefDecls.length; i++) {

                var childDecls = typeRefDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                }
            }

            // Resolve Type Parameters
            if (!typeDeclSymbol.isResolved) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], context);
                }
            }

            var wasInBaseTypeResolution = context.startBaseTypeResolution();

            // if it's a "split" interface type, we'll need to consider constituent extends lists separately
            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }

            // Extends list
            var extendsClause = ASTHelpers.getExtendsHeritageClause(heritageClauses);
            if (extendsClause) {
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < extendsClause.typeNames.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(extendsClause.typeNames[i], context);

                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        this.setSymbolForAST(extendsClause.typeNames[i], parentType, null /* setting it without context so that we record the baseType associated with the members */);

                        // Do not add parentType as a base if it already added, or if it will cause a cycle as it already inherits from typeDeclSymbol
                        if (!typeDeclSymbol.hasBase(parentType) && !parentType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addExtendedType(parentType);

                            var specializations = typeDeclSymbol.getKnownSpecializations();

                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    }
                    else if (parentType && !this.getSymbolForAST(extendsClause.typeNames[i], context)) {
                        this.setSymbolForAST(extendsClause.typeNames[i], parentType, null /* setting it without context so that we record the baseType associated with the members */);
                    }
                }
            }

            var implementsClause = ASTHelpers.getImplementsHeritageClause(heritageClauses);
            if (implementsClause && typeDeclIsClass) {
                var extendsCount = extendsClause ? extendsClause.typeNames.length : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < implementsClause.typeNames.length); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedTypeAST = implementsClause.typeNames[i - extendsCount];
                    var implementedType = this.resolveTypeReference(implementedTypeAST, context);

                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        this.setSymbolForAST(implementsClause.typeNames[i - extendsCount], implementedType, null /* setting it without context so that we record the baseType associated with the members */);

                        // Do not add parentType as a base if it already added, or if it will cause a cycle as it already inherits from typeDeclSymbol
                        if (!typeDeclSymbol.hasBase(implementedType) && !implementedType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    }
                    else if (implementedType && !this.getSymbolForAST(implementsClause.typeNames[i - extendsCount], context)) {
                        this.setSymbolForAST(implementsClause.typeNames[i - extendsCount], implementedType, null /* setting it without context so that we record the baseType associated with the members */);
                    }
                }
            }

            context.doneBaseTypeResolution(wasInBaseTypeResolution);

            if (wasInBaseTypeResolution) {

                // Do not resolve members as yet
                typeDeclSymbol.inResolution = false;

                // Store off and resolve the reference type after we've finished checking the file
                // (This way, we'll still properly resolve the type even if its parent was already resolved during
                // base type resolution, making the type otherwise inaccessible).
                this.typeCheckCallBacks.push(context => {
                    if (classOrInterface.kind() === SyntaxKind.ClassDeclaration) {
                        this.resolveClassDeclaration(<ClassDeclarationSyntax>classOrInterface, context);
                    }
                    else {
                        this.resolveInterfaceDeclaration(<InterfaceDeclarationSyntax>classOrInterface, context);
                    }
                });

                return typeDeclSymbol;
            }

            this.setSymbolForAST(name, typeDeclSymbol, context);
            this.setSymbolForAST(classOrInterface, typeDeclSymbol, context);

            typeDeclSymbol.setResolved();

            return typeDeclSymbol;
        }

        //
        // Resolve a class declaration
        //
        // A class's implements and extends lists are not pre-bound, so they must be bound here
        // Once bound, we can add the parent type's members to the class
        //
        private resolveClassDeclaration(classDeclAST: ClassDeclarationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var classDecl: PullDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = <PullTypeSymbol>classDecl.getSymbol(this.semanticInfoChain);

            if (!classDeclSymbol.isResolved) {
                this.resolveReferenceTypeDeclaration(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, context);

                var constructorMethod = classDeclSymbol.getConstructorMethod();
                var extendedTypes = classDeclSymbol.getExtendedTypes();
                var parentType = extendedTypes.length ? extendedTypes[0] : null;

                if (constructorMethod) {
                    // Need to ensure our constructor type can properly see our parent type's 
                    // constructor type before going and resolving our members.
                    if (parentType) {
                        var parentConstructorSymbol = parentType.getConstructorMethod();

                        // this will only be null if we have upstream errors
                        if (parentConstructorSymbol) {
                            var parentConstructorTypeSymbol = parentConstructorSymbol.type;
                            var constructorTypeSymbol = constructorMethod.type;
                            if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                                constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                            }
                        }
                    }

                    if (!classDeclSymbol.isResolved) {
                        return classDeclSymbol;
                    }
                }

                this.resolveOtherDeclarations(classDeclAST, context);
            }

            if (this.canTypeCheckAST(classDeclAST, context)) {
                this.typeCheckClassDeclaration(classDeclAST, context);
            }

            return classDeclSymbol;
        }
        
        private typeCheckTypeParametersOfTypeDeclaration(classOrInterface: ISyntaxElement, context: PullTypeResolutionContext) {
            var typeParametersList = classOrInterface.kind() == SyntaxKind.ClassDeclaration
             ? (<ClassDeclarationSyntax>classOrInterface).typeParameterList
             : (<InterfaceDeclarationSyntax>classOrInterface).typeParameterList;

            if (typeParametersList) {
                var typeDecl: PullDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);
                var typeDeclSymbol = <PullTypeSymbol>typeDecl.getSymbol(this.semanticInfoChain);

                for (var i = 0; i < typeParametersList.typeParameters.length; i++) {
                    // Resolve the type parameter
                    var typeParameterAST = typeParametersList.typeParameters[i];
                    this.resolveTypeParameterDeclaration(typeParameterAST, context);

                    var typeParameterDecl = this.semanticInfoChain.getDeclForAST(typeParameterAST);
                    var typeParameterSymbol = <PullTypeParameterSymbol>typeParameterDecl.getSymbol(this.semanticInfoChain);

                    this.checkSymbolPrivacy(typeDeclSymbol, typeParameterSymbol, (symbol: PullSymbol) =>
                        this.typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface, typeParameterAST, typeParameterSymbol, symbol, context));
                }
            }
        }

        private typeCheckClassDeclaration(classDeclAST: ClassDeclarationSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(classDeclAST, context);

            var classDecl: PullDecl = this.semanticInfoChain.getDeclForAST(classDeclAST);
            var classDeclSymbol = <PullTypeSymbol>classDecl.getSymbol(this.semanticInfoChain);

            // Add for post typeChecking if we want to verify name collision with _this
            this.checkNameForCompilerGeneratedDeclarationCollision(classDeclAST, /*isDeclaration*/ true, classDeclAST.identifier, context);
            this.resolveAST(classDeclAST.classElements, false, context);

            this.typeCheckTypeParametersOfTypeDeclaration(classDeclAST, context);
            this.typeCheckBases(classDeclAST, classDeclAST.identifier, classDeclAST.heritageClauses, classDeclSymbol, this.getEnclosingDecl(classDecl), context);

            if (!classDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classDeclSymbol, classDecl, context);
            }

            this.checkTypeForDuplicateIndexSignatures(classDeclSymbol);
        }

        private postTypeCheckClassDeclaration(classDeclAST: ClassDeclarationSyntax, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(classDeclAST, /*isDeclaration*/ true, context);
        }

        private resolveTypeSymbolSignatures(typeSymbol: PullTypeSymbol, context: PullTypeResolutionContext): void {
            // Resolve call, construct and index signatures
            var callSignatures = typeSymbol.getCallSignatures();
            for (var i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], context);
            }

            var constructSignatures = typeSymbol.getConstructSignatures();
            for (var i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], context);
            }

            var indexSignatures = typeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], context);
            }
        }

        private resolveInterfaceDeclaration(interfaceDeclAST: InterfaceDeclarationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            this.resolveReferenceTypeDeclaration(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, context);

            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = <PullTypeSymbol>interfaceDecl.getSymbol(this.semanticInfoChain);

            this.resolveTypeSymbolSignatures(interfaceDeclSymbol, context);

            if (interfaceDeclSymbol.isResolved) {
                this.resolveOtherDeclarations(interfaceDeclAST, context);

                if (this.canTypeCheckAST(interfaceDeclAST, context)) {
                    this.typeCheckInterfaceDeclaration(interfaceDeclAST, context);
                }
            }

            return interfaceDeclSymbol;
        }

        private typeCheckInterfaceDeclaration(interfaceDeclAST: InterfaceDeclarationSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(interfaceDeclAST, context);

            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = <PullTypeSymbol>interfaceDecl.getSymbol(this.semanticInfoChain);

            this.resolveAST(interfaceDeclAST.body.typeMembers, false, context);

            this.typeCheckTypeParametersOfTypeDeclaration(interfaceDeclAST, context);
            this.typeCheckBases(interfaceDeclAST, interfaceDeclAST.identifier, interfaceDeclAST.heritageClauses, interfaceDeclSymbol, this.getEnclosingDecl(interfaceDecl), context);

            if (!interfaceDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceDeclSymbol, interfaceDecl, context);
            }

            // Only check for duplicate index signatures once per symbol
            // We check that this interface decl is the last one for this symbol. The reason we don't
            // use the first decl is because in case one decl is in lib.d.ts, the experience is
            // slightly better in the language service because of the order we tend to type check
            // the files in. Lib.d.ts is usually last in the language service, but it contains the
            // first decl. Therefore, picking the last decl will report the error sooner. 
            var allInterfaceDecls = interfaceDeclSymbol.getDeclarations();
            if (interfaceDecl === allInterfaceDecls[allInterfaceDecls.length - 1]) {
                this.checkTypeForDuplicateIndexSignatures(interfaceDeclSymbol);
            }

            if (!this.checkInterfaceDeclForIdenticalTypeParameters(interfaceDeclAST, context)) {
                this.semanticInfoChain.addDiagnosticFromAST(interfaceDeclAST.identifier, DiagnosticCode.All_declarations_of_an_interface_must_have_identical_type_parameters);
            }
        }

        // Spec section 7.2:
        // When a generic interface has multiple declarations, all declarations must have identical type parameter lists,
        // i.e.identical type parameter names with identical constraints in identical order.
        private checkInterfaceDeclForIdenticalTypeParameters(interfaceDeclAST: InterfaceDeclarationSyntax, context: PullTypeResolutionContext) {
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = <PullTypeSymbol>interfaceDecl.getSymbol(this.semanticInfoChain);

            // Only generic symbols need the type parameter verification
            if (!interfaceDeclSymbol.isGeneric()) {
                return true;
            }

            // Verify against the first interface declaration only
            var firstInterfaceDecl = interfaceDeclSymbol.getDeclarations()[0];
            if (firstInterfaceDecl == interfaceDecl) {
                return true;
            }

            var typeParameters = interfaceDecl.getTypeParameters();
            var firstInterfaceDeclTypeParameters = firstInterfaceDecl.getTypeParameters();

            // Type parameter length should match
            if (typeParameters.length != firstInterfaceDeclTypeParameters.length) {
                return false;
            }

            for (var i = 0; i < typeParameters.length; i++) {
                var typeParameter = typeParameters[i];
                var firstInterfaceDeclTypeParameter = firstInterfaceDeclTypeParameters[i];
                // Type parameter names should be identical
                if (typeParameter.name != firstInterfaceDeclTypeParameter.name) {
                    return false;
                }

                var typeParameterSymbol = <PullTypeParameterSymbol>typeParameter.getSymbol(this.semanticInfoChain);
                var typeParameterAST = <TypeParameterSyntax>this.semanticInfoChain.getASTForDecl(typeParameter);
                var firstInterfaceDeclTypeParameterAST = <TypeParameterSyntax>this.semanticInfoChain.getASTForDecl(firstInterfaceDeclTypeParameter);

                // Constraint should be present or absent in both the decls
                if (!!typeParameterAST.constraint != !!firstInterfaceDeclTypeParameterAST.constraint) {
                    return false;
                }

                // If the constraint is present, it should be identical
                if (typeParameterAST.constraint) {
                    var typeParameterConstraint = <PullTypeSymbol>this.resolveAST(typeParameterAST.constraint, /*isContexuallyTyped*/ false, context);
                    if (!this.typesAreIdenticalWithNewEnclosingTypes(typeParameterConstraint, typeParameterSymbol.getConstraint(), context)) {
                        return false;
                    }
                }
            }

            return true;
        }

        // November 18, 2013: Section 3.7.4:
        // An object type can contain at most one string index signature and one numeric index signature.
        private checkTypeForDuplicateIndexSignatures(enclosingTypeSymbol: PullTypeSymbol): void {
            var indexSignatures = enclosingTypeSymbol.getOwnIndexSignatures();
            var firstStringIndexer: PullSignatureSymbol = null;
            var firstNumberIndexer: PullSignatureSymbol = null;
            for (var i = 0; i < indexSignatures.length; i++) {
                var currentIndexer = indexSignatures[i];
                var currentParameterType = currentIndexer.parameters[0].type;
                Debug.assert(currentParameterType);
                if (currentParameterType === this.semanticInfoChain.stringTypeSymbol) {
                    if (firstStringIndexer) {
                        this.semanticInfoChain.addDiagnosticFromAST(currentIndexer.getDeclarations()[0].ast(),
                            DiagnosticCode.Duplicate_string_index_signature, null,
                            [this.semanticInfoChain.locationFromAST(firstStringIndexer.getDeclarations()[0].ast())]);
                        return;
                    }
                    else {
                        firstStringIndexer = currentIndexer;
                    }
                }
                else if (currentParameterType === this.semanticInfoChain.numberTypeSymbol) {
                    if (firstNumberIndexer) {
                        this.semanticInfoChain.addDiagnosticFromAST(currentIndexer.getDeclarations()[0].ast(),
                            DiagnosticCode.Duplicate_number_index_signature, null,
                            [this.semanticInfoChain.locationFromAST(firstNumberIndexer.getDeclarations()[0].ast())]);
                        return;
                    }
                    else {
                        firstNumberIndexer = currentIndexer;
                    }
                }
            }
        }

        private filterSymbol(symbol: PullSymbol, kind: PullElementKind, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            if (symbol) {
                if (symbol.kind & kind) {
                    return symbol;
                }

                if (symbol.isAlias()) {
                    this.resolveDeclaredSymbol(symbol, context);

                    var alias = <PullTypeAliasSymbol>symbol;
                    if (kind & PullElementKind.SomeContainer) {
                        return alias.getExportAssignedContainerSymbol();
                    }
                    else if (kind & PullElementKind.SomeType) {
                        return alias.getExportAssignedTypeSymbol();
                    }
                    else if (kind & PullElementKind.SomeValue) {
                        return alias.getExportAssignedValueSymbol();
                    }
                }
            }
            return null;
        }

        private getMemberSymbolOfKind(symbolName: string, kind: PullElementKind, pullTypeSymbol: PullTypeSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var memberSymbol = this.getNamedPropertySymbol(symbolName, kind, pullTypeSymbol);
            // Verify that the symbol is actually of the given kind
            return {
                symbol: this.filterSymbol(memberSymbol, kind, enclosingDecl, context),
                aliasSymbol: memberSymbol && memberSymbol.isAlias() ? <PullTypeAliasSymbol>memberSymbol : null
            };
        }

        private resolveIdentifierOfInternalModuleReference(importDecl: PullDecl, identifier: ISyntaxToken, moduleSymbol: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext):
            {
                valueSymbol: PullSymbol; typeSymbol: PullTypeSymbol; containerSymbol: PullContainerSymbol; aliasSymbol: PullTypeAliasSymbol;
            } {
            var rhsName = tokenValueText(identifier);
            if (rhsName.length === 0) {
                return null;
            }

            var moduleTypeSymbol = <PullContainerSymbol>moduleSymbol.type;
            var memberSymbol = this.getMemberSymbolOfKind(rhsName, PullElementKind.SomeContainer, moduleTypeSymbol, enclosingDecl, context);
            var containerSymbol = memberSymbol.symbol;
            var valueSymbol: PullSymbol = null;
            var typeSymbol: PullSymbol = null;
            var aliasSymbol: PullTypeAliasSymbol = null;

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & PullElementKind.AcceptableAlias) !== 0;
                aliasSymbol = memberSymbol.aliasSymbol;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind === PullElementKind.TypeAlias) {
                this.resolveDeclaredSymbol(containerSymbol, context);
                var aliasedAssignedValue = (<PullTypeAliasSymbol>containerSymbol).getExportAssignedValueSymbol();
                var aliasedAssignedType = (<PullTypeAliasSymbol>containerSymbol).getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = (<PullTypeAliasSymbol>containerSymbol).getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    aliasSymbol = <PullTypeAliasSymbol>containerSymbol;
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            // check for valid export assignment type (variable, function, class, interface, enum, internal module)
            if (!acceptableAlias) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, DiagnosticCode.Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return null;
            }

            // if we haven't already gotten a value or type from the alias, look for them now
            if (!valueSymbol) {
                if (moduleTypeSymbol.getInstanceSymbol()) {
                    memberSymbol = this.getMemberSymbolOfKind(rhsName, PullElementKind.SomeValue, moduleTypeSymbol.getInstanceSymbol().type, enclosingDecl, context);
                    valueSymbol = memberSymbol.symbol;
                    if (valueSymbol && memberSymbol.aliasSymbol) {
                        aliasSymbol = memberSymbol.aliasSymbol;
                    }
                }
            }

            if (!typeSymbol) {
                memberSymbol = this.getMemberSymbolOfKind(rhsName, PullElementKind.SomeType, moduleTypeSymbol, enclosingDecl, context);
                typeSymbol = memberSymbol.symbol;
                if (typeSymbol && memberSymbol.aliasSymbol) {
                    aliasSymbol = memberSymbol.aliasSymbol;
                }
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                this.semanticInfoChain.addDiagnosticFromAST(identifier, DiagnosticCode.Could_not_find_symbol_0_in_module_1, [rhsName, moduleSymbol.toString()]);
                return null;
            }

            if (!typeSymbol && containerSymbol) {
                typeSymbol = containerSymbol;
            }

            return {
                valueSymbol: valueSymbol,
                typeSymbol: <PullTypeSymbol>typeSymbol,
                containerSymbol: <PullContainerSymbol>containerSymbol,
                aliasSymbol: aliasSymbol
            };
        }

        private resolveModuleReference(importDecl: PullDecl, moduleNameExpr: ISyntaxElement, enclosingDecl: PullDecl, context: PullTypeResolutionContext, declPath: PullDecl[]) {
            Debug.assert(moduleNameExpr.kind() === SyntaxKind.QualifiedName || moduleNameExpr.kind() === SyntaxKind.IdentifierName || moduleNameExpr.kind() === SyntaxKind.StringLiteral, "resolving module reference should always be either name or member reference");

            var moduleSymbol: PullSymbol = null;
            var moduleName: string;

            if (moduleNameExpr.kind() === SyntaxKind.QualifiedName) {
                var dottedNameAST = <QualifiedNameSyntax>moduleNameExpr;

                var moduleContainer = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleContainer) {
                    moduleName = tokenValueText(dottedNameAST.right);
                    // We dont care about setting alias symbol here, because it has to be exported member which would make the import statement to emit anyways
                    moduleSymbol = this.getMemberSymbolOfKind(moduleName, PullElementKind.Container, moduleContainer.type, enclosingDecl, context).symbol;
                    if (!moduleSymbol) {
                        this.semanticInfoChain.addDiagnosticFromAST(dottedNameAST.right, DiagnosticCode.Could_not_find_module_0_in_module_1, [moduleName, moduleContainer.toString()]);
                    }
                }
            }
            else {
                var valueText = moduleNameExpr.kind() === SyntaxKind.IdentifierName ? tokenValueText((<ISyntaxToken>moduleNameExpr)) : tokenValueText((<ISyntaxToken>moduleNameExpr));
                var text = moduleNameExpr.kind() === SyntaxKind.IdentifierName ? (<ISyntaxToken>moduleNameExpr).text() : (<ISyntaxToken>moduleNameExpr).text();

                if (text.length > 0) {
                    var resolvedModuleNameSymbol = this.getSymbolFromDeclPath(valueText, declPath, PullElementKind.Container);
                    moduleSymbol = this.filterSymbol(resolvedModuleNameSymbol, PullElementKind.Container, enclosingDecl, context);
                    if (moduleSymbol) {
                        // Import declaration isn't contextual so set the symbol and diagnostic message irrespective of the context
                        this.semanticInfoChain.setSymbolForAST(moduleNameExpr, moduleSymbol);
                        if (resolvedModuleNameSymbol.isAlias()) {
                            this.semanticInfoChain.setAliasSymbolForAST(moduleNameExpr, <PullTypeAliasSymbol>resolvedModuleNameSymbol);
                            var importDeclSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);
                            importDeclSymbol.addLinkedAliasSymbol(<PullTypeAliasSymbol>resolvedModuleNameSymbol);
                        }
                    }
                    else {
                        this.semanticInfoChain.addDiagnosticFromAST(moduleNameExpr, DiagnosticCode.Unable_to_resolve_module_reference_0, [valueText]);
                    }
                }
            }

            return moduleSymbol;
        }

        private resolveInternalModuleReference(importStatementAST: ImportDeclarationSyntax, context: PullTypeResolutionContext) {
            // ModuleName or ModuleName.Identifier or ModuleName.ModuleName....Identifier
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);

            var moduleReference = importStatementAST.moduleReference;

            var aliasExpr = moduleReference.kind() === SyntaxKind.ExternalModuleReference
                ? (<ExternalModuleReferenceSyntax>moduleReference).stringLiteral
                : (<ModuleNameModuleReferenceSyntax>moduleReference).moduleName;

            var declPath = enclosingDecl.getParentPath();
            var aliasedType: PullTypeSymbol = null;
            var importDeclSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);

            if (aliasExpr.kind() === SyntaxKind.IdentifierName || aliasExpr.kind() === SyntaxKind.StringLiteral) {
                var moduleSymbol = this.resolveModuleReference(importDecl, aliasExpr, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    aliasedType = moduleSymbol.type;
                    this.semanticInfoChain.setAliasSymbolForAST(moduleReference, this.semanticInfoChain.getAliasSymbolForAST(aliasExpr));
                    if (aliasedType.anyDeclHasFlag(PullElementFlags.InitializedModule)) {
                        var moduleName = aliasExpr.kind() === SyntaxKind.IdentifierName ? tokenValueText((<ISyntaxToken>aliasExpr)) : tokenValueText((<ISyntaxToken>aliasExpr));
                        var valueSymbol = this.getSymbolFromDeclPath(moduleName, declPath, PullElementKind.SomeValue);
                        var instanceSymbol = (<PullContainerSymbol>aliasedType).getInstanceSymbol();
                        // If there is module and it is instantiated, value symbol needs to refer to the module instance symbol

                        if (valueSymbol && (instanceSymbol != valueSymbol || valueSymbol.type === aliasedType)) {
                            var text = (<ISyntaxToken>aliasExpr).text();
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(aliasExpr, DiagnosticCode.Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1, [text, moduleSymbol.type.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                        }
                        else {
                            // Set value symbol, type and container setting will be taken care of later using aliasedType                            
                            importDeclSymbol.setAssignedValueSymbol(valueSymbol);
                        }
                    }
                }
                else {
                    aliasedType = this.getNewErrorTypeSymbol();
                }
            }
            else if (aliasExpr.kind() === SyntaxKind.QualifiedName) {
                var dottedNameAST = <QualifiedNameSyntax>aliasExpr;
                var moduleSymbol = this.resolveModuleReference(importDecl, dottedNameAST.left, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    var identifierResolution = this.resolveIdentifierOfInternalModuleReference(importDecl, dottedNameAST.right, moduleSymbol, enclosingDecl, context);
                    if (identifierResolution) {
                        importDeclSymbol.setAssignedValueSymbol(identifierResolution.valueSymbol);
                        importDeclSymbol.setAssignedTypeSymbol(identifierResolution.typeSymbol);
                        importDeclSymbol.setAssignedContainerSymbol(identifierResolution.containerSymbol);
                        this.semanticInfoChain.setAliasSymbolForAST(moduleReference, identifierResolution.aliasSymbol);
                        return null;
                    }
                }
            }

            if (!aliasedType){
                // unresolved alias - set error as assigned type
                importDeclSymbol.setAssignedTypeSymbol(this.getNewErrorTypeSymbol());
            }

            return aliasedType;
        }

        private resolveImportDeclaration(importStatementAST: ImportDeclarationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            // internal or external? (Does it matter?)
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);

            var aliasedType: PullTypeSymbol = null;

            if (importDeclSymbol.isResolved) {
                return importDeclSymbol;
            }

            importDeclSymbol.startResolving();

            // the alias name may be a string literal, in which case we'll need to convert it to a type
            // reference
            if (importStatementAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                // dynamic module name (string literal)
                var modPath = tokenValueText((<ExternalModuleReferenceSyntax>importStatementAST.moduleReference).stringLiteral);
                var declPath = enclosingDecl.getParentPath();

                aliasedType = this.resolveExternalModuleReference(modPath, importDecl.fileName());

                if (!aliasedType) {
                    var path = (<ExternalModuleReferenceSyntax>importStatementAST.moduleReference).stringLiteral.text();
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, DiagnosticCode.Unable_to_resolve_external_module_0, [path]);
                    aliasedType = this.getNewErrorTypeSymbol();

                }
            }
            else {
                aliasedType = this.resolveInternalModuleReference(importStatementAST, context);
            }

            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    this.semanticInfoChain.addDiagnosticFromAST(importStatementAST, DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type);
                    if (!aliasedType.isError()) {
                        aliasedType = this.getNewErrorTypeSymbol();
                    }
                }

                if (aliasedType.isContainer()) {
                    importDeclSymbol.setAssignedContainerSymbol(<PullContainerSymbol>aliasedType);
                }
                importDeclSymbol.setAssignedTypeSymbol(aliasedType);

                // Import declaration isn't contextual so set the symbol and diagnostic message irrespective of the context
                this.setSymbolForAST(importStatementAST.moduleReference, aliasedType, null);
            }

            importDeclSymbol.setResolved();

            this.resolveDeclaredSymbol(importDeclSymbol.assignedValue(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedType(), context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedContainer(), context);
            
            // these checks should be made after 'resolveDeclaredSymbol' calls.since 'resolveDeclaredSymbol' can set 'assignedValue' to aliasedType
            if (aliasedType && importDeclSymbol.anyDeclHasFlag(PullElementFlags.Exported)) {
                importDeclSymbol.setIsUsedInExportedAlias();

                if (aliasedType.isContainer() && (<PullContainerSymbol>aliasedType).getExportAssignedValueSymbol()) {
                    importDeclSymbol.setIsUsedAsValue();
                }
            }


            if (this.canTypeCheckAST(importStatementAST, context)) {
                this.typeCheckImportDeclaration(importStatementAST, context);
            }

            return importDeclSymbol;
        }

        private typeCheckImportDeclaration(importStatementAST: ImportDeclarationSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(importStatementAST, context);

            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);

            if (importStatementAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                if (this.compilationSettings.noResolve()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST,
                        DiagnosticCode.Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set, null));
                }

                var modPath = tokenValueText((<ExternalModuleReferenceSyntax>importStatementAST.moduleReference).stringLiteral);
                if (enclosingDecl.kind === PullElementKind.DynamicModule) {
                    var ast = ASTHelpers.getEnclosingModuleDeclaration(this.getASTForDecl(enclosingDecl));
                    if (ast && ast.kind() === SyntaxKind.ModuleDeclaration) {
                        if (isRelative(modPath)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST,
                                DiagnosticCode.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name));
                        }
                    }
                }
            }

            var checkPrivacy: boolean;
            if (importStatementAST.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var container = containerSymbol ? containerSymbol.getContainer() : null;
                if (container && container.kind === PullElementKind.DynamicModule) {
                    checkPrivacy = true;
                }
            }
            else {
                checkPrivacy = true;
            }

            if (checkPrivacy) {
                // Check if import satisfies type privacy
                var typeSymbol = importDeclSymbol.getExportAssignedTypeSymbol();
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var valueSymbol = importDeclSymbol.getExportAssignedValueSymbol();

                this.checkSymbolPrivacy(importDeclSymbol, containerSymbol, (symbol: PullSymbol) => {
                    var messageCode = DiagnosticCode.Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1;
                    var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null, /*skipTypeParametersInName*/ false, /*useContraintInName*/false, /*skipInternalAliasName*/true)];
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                });

                if (typeSymbol !== containerSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, typeSymbol, (symbol: PullSymbol) => {
                        var messageCode = symbol.isContainer() && !(<PullTypeSymbol>symbol).isEnum() ?
                            DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1 :
                            DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1;

                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null, /*skipTypeParametersInName*/ false, /*useContraintInName*/false, /*skipInternalAliasName*/true)];
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }

                if (valueSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, valueSymbol.type, (symbol: PullSymbol) => {
                        var messageCode = symbol.isContainer() && !(<PullTypeSymbol>symbol).isEnum() ?
                            DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1 :
                            DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null, /*skipTypeParametersInName*/ false, /*useContraintInName*/false, /*skipInternalAliasName*/true)];
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(importStatementAST, messageCode, messageArguments));
                    });
                }
            }

            // Check if there's a name collision with the import's name.  Note: checkNameFor... 
            // will do the check in a post typeCheck callback.  This is critical for import 
            // statements as we need to know how the import is actually used in order for us to 
            // know if there will be a collision or not.  For example, if the import is never used
            // as a value, and is only used as a type, then no collision will occur.
            this.checkNameForCompilerGeneratedDeclarationCollision(importStatementAST, /*isDeclaration:*/ true, importStatementAST.identifier, context);
        }

        private postTypeCheckImportDeclaration(importStatementAST: ImportDeclarationSyntax, context: PullTypeResolutionContext) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importStatementAST);
            var importSymbol = <PullTypeAliasSymbol>importDecl.getSymbol(this.semanticInfoChain);

            var isUsedAsValue = importSymbol.isUsedAsValue();
            var hasAssignedValue = importStatementAST.moduleReference.kind() !== SyntaxKind.ExternalModuleReference && importSymbol.getExportAssignedValueSymbol() !== null;

            if (isUsedAsValue || hasAssignedValue) {
                this.checkThisCaptureVariableCollides(importStatementAST, /*isDeclaration*/ true, context);
            }
        }

        private resolveExportAssignmentStatement(exportAssignmentAST: ExportAssignmentSyntax, context: PullTypeResolutionContext): PullSymbol {
            var id = tokenValueText(exportAssignmentAST.identifier);
            if (id.length === 0) {
                // No point trying to resolve an export assignment without an actual identifier.
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // get the identifier text
            var valueSymbol: PullSymbol = null;
            var typeSymbol: PullSymbol = null;
            var containerSymbol: PullSymbol = null;

            var enclosingDecl = this.getEnclosingDeclForAST(exportAssignmentAST);
            var parentSymbol = enclosingDecl.getSymbol(this.semanticInfoChain);

            if (!parentSymbol.isType() && (<PullTypeSymbol>parentSymbol).isContainer()) {
                // Error
                // Export assignments may only be used at the top-level of external modules
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, DiagnosticCode.Export_assignments_may_only_be_used_at_the_top_level_of_external_modules);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // The Identifier of an export assignment must name a variable, function, class, interface, 
            // enum, or internal module declared at the top level in the external module.
            // So look for the id only from this dynamic module
            var declPath: PullDecl[] = enclosingDecl !== null ? [enclosingDecl] : <PullDecl[]>[];

            containerSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeContainer);

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & PullElementKind.AcceptableAlias) !== 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind === PullElementKind.TypeAlias) {
                this.resolveDeclaredSymbol(containerSymbol, context);

                var aliasSymbol = <PullTypeAliasSymbol>containerSymbol;
                var aliasedAssignedValue = aliasSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = aliasSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = aliasSymbol.getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    aliasSymbol.setTypeUsedExternally();
                    if (valueSymbol) {
                        aliasSymbol.setIsUsedAsValue();
                    }
                    acceptableAlias = true;
                }
            }

            // check for valid export assignment type (variable, function, class, interface, enum, internal module)
            if (!acceptableAlias) {
                // Error
                // Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules
                this.semanticInfoChain.addDiagnosticFromAST(exportAssignmentAST, DiagnosticCode.Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules);
                return this.semanticInfoChain.voidTypeSymbol;
            }

            // if we haven't already gotten a value or type from the alias, look for them now
            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeValue);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                // Error
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(exportAssignmentAST, DiagnosticCode.Could_not_find_symbol_0, [id]));
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (valueSymbol) {
                (<PullContainerSymbol>parentSymbol).setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                (<PullContainerSymbol>parentSymbol).setExportAssignedTypeSymbol(<PullTypeSymbol>typeSymbol);
            }
            if (containerSymbol) {
                (<PullContainerSymbol>parentSymbol).setExportAssignedContainerSymbol(<PullContainerSymbol>containerSymbol);
            }

            this.resolveDeclaredSymbol(valueSymbol, context);
            this.resolveDeclaredSymbol(typeSymbol, context);
            this.resolveDeclaredSymbol(containerSymbol, context);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveAnyFunctionTypeSignature(funcDeclAST: ISyntaxElement, typeParameters: TypeParameterListSyntax, parameterList: ParameterListSyntax, returnTypeAnnotation: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            Debug.assert(functionDecl);

            var funcDeclSymbol = <PullTypeSymbol>functionDecl.getSymbol(this.semanticInfoChain);

            var signature = funcDeclSymbol.kind === PullElementKind.ConstructorType
                ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            // resolve the return type annotation
            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            }

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            // link parameters and resolve their annotations
            if (parameterList) {
                for (var i = 0; i < parameterList.parameters.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(parameterList.parameters[i], signature, functionDecl, context);
                }
            }

            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.setTypeChecked(funcDeclAST, context);
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            }

            return funcDeclSymbol;
        }

        private resolveFunctionTypeSignatureParameter(argDeclAST: ParameterSyntax, signature: PullSignatureSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol(this.semanticInfoChain);

            if (argDeclAST.typeAnnotation) {
                var typeRef = this.resolveTypeReference(ASTHelpers.getType(argDeclAST), context);

                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeRef = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(paramSymbol, typeRef);
            }
            else {
                if (paramSymbol.isVarArg) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol]));
                    }
                    else {
                        context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }

                // if the noImplicitAny flag is set to be true, report an error 
                if (this.compilationSettings.noImplicitAny()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Parameter_0_of_function_type_implicitly_has_an_any_type,
                        [argDeclAST.identifier.text()]));
                }
            }

            if (hasFlag(paramDecl.flags, PullElementFlags.Optional) && argDeclAST.equalsValueClause && isTypesOnlyLocation(argDeclAST)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Default_arguments_are_only_allowed_in_implementation));
            }

            paramSymbol.setResolved();
        }

        private resolveFunctionExpressionParameter(argDeclAST: ISyntaxElement, id: ISyntaxToken, typeExpr: ISyntaxElement, equalsValueClause: EqualsValueClauseSyntax, contextParam: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var paramDecl = this.semanticInfoChain.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol(this.semanticInfoChain);
            var contextualType = contextParam && contextParam.type;
            var isImplicitAny = false;

            if (typeExpr) {
                var typeRef = this.resolveTypeReference(typeExpr, context);

                if (paramSymbol.isVarArg && !typeRef.isArrayNamedTypeReference()) {
                    var diagnostic = context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeRef = this.getNewErrorTypeSymbol();
                }

                // The contextual type now gets overriden by the type annotation
                contextualType = typeRef || contextualType;
            }
            if (contextualType) {
                // November 18, 2013, Section 4.12.2:
                // When a function expression is inferentially typed (section 4.9.3) and a type assigned
                // to a parameter in that expression references type parameters for which inferences are
                // being made, the corresponding inferred type arguments to become fixed and no further
                // candidate inferences are made for them.
                if (context.isInferentiallyTyping()) {
                    contextualType = context.fixAllTypeParametersReferencedByType(contextualType, this);
                }
                context.setTypeInContext(paramSymbol, contextualType);
            }
            else if (paramSymbol.isVarArg) {
                if (this.cachedArrayInterfaceType()) {
                    context.setTypeInContext(paramSymbol, this.createInstantiatedType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol]));
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
                isImplicitAny = true;
            }

            // Resolve the function expression parameter init only if we have contexual type to evaluate the expression in or we are in typeCheck
            var canTypeCheckAST = this.canTypeCheckAST(argDeclAST, context);
            if (equalsValueClause && (canTypeCheckAST || !contextualType)) {
                if (contextualType) {
                    context.propagateContextualType(contextualType);
                }

                var initExprSymbol = this.resolveAST(equalsValueClause, contextualType !== null, context);

                if (contextualType) {
                    context.popAnyContextualType();
                }

                if (!initExprSymbol || !initExprSymbol.type) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Unable_to_resolve_type_of_0, [id.text()]));

                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(paramSymbol.name));
                    }
                }
                else {
                    var initTypeSymbol = this.getInstanceTypeForAssignment(argDeclAST, initExprSymbol.type, context);
                    if (!contextualType) {
                        // Set the type to the inferred initializer type
                        context.setTypeInContext(paramSymbol, initTypeSymbol.widenedType(this, equalsValueClause, context));
                        isImplicitAny = initTypeSymbol !== paramSymbol.type;
                    }
                    else {
                        var comparisonInfo = new TypeComparisonInfo();

                        var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, contextualType, argDeclAST, context, comparisonInfo);

                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(argDeclAST);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol), comparisonInfo.message]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST, DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(enclosingSymbol), contextualType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }

            // If we do not have any type for it, set it to any
            if (!contextualType && !paramSymbol.isVarArg && !initTypeSymbol) {
                context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                isImplicitAny = true;
            }

            // if the noImplicitAny flag is set to be true, report an error
            if (isImplicitAny && this.compilationSettings.noImplicitAny()) {

                // there is a name for function expression then use the function expression name otherwise use "lambda"
                var functionExpressionName = (<PullFunctionExpressionDecl>paramDecl.getParentDecl()).getFunctionExpressionName();
                if (functionExpressionName) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST,
                        DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [id.text(), functionExpressionName]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(argDeclAST,
                        DiagnosticCode.Parameter_0_of_lambda_function_implicitly_has_an_any_type, [id.text()]));
                }
            }

            if (canTypeCheckAST) {
                this.checkNameForCompilerGeneratedDeclarationCollision(argDeclAST, /*isDeclaration*/ true, id, context);
            }

            paramSymbol.setResolved();
        }

        private checkNameForCompilerGeneratedDeclarationCollision(astWithName: ISyntaxElement, isDeclaration: boolean, name: ISyntaxToken, context: PullTypeResolutionContext) {
            var compilerReservedName = getCompilerReservedName(name);
            switch (compilerReservedName) {
                case CompilerReservedName._this:
                     this.postTypeCheckWorkitems.push(astWithName);
                     return;

                case CompilerReservedName._super:
                    this.checkSuperCaptureVariableCollides(astWithName, isDeclaration, context);
                    return;

                case CompilerReservedName.arguments:
                    this.checkArgumentsCollides(astWithName, context);
                    return;

                case CompilerReservedName._i:
                    this.checkIndexOfRestArgumentInitializationCollides(astWithName, isDeclaration, context);
                    return;

                case CompilerReservedName.require:
                case CompilerReservedName.exports:
                    if (isDeclaration) {
                        this.checkExternalModuleRequireExportsCollides(astWithName, name, context);
                    }
                    return;
            }
        }

        private hasRestParameterCodeGen(someFunctionDecl: PullDecl) {
            var enclosingAST = this.getASTForDecl(someFunctionDecl);
            var nodeType = enclosingAST.kind();

            // If the method/function/constructor is non ambient, with code block and has rest parameter it would have the rest parameter code gen
            if (nodeType === SyntaxKind.FunctionDeclaration) {
                var functionDeclaration = <FunctionDeclarationSyntax>enclosingAST;
                return !hasFlag(someFunctionDecl.kind === PullElementKind.Method ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, PullElementFlags.Ambient)
                && functionDeclaration.block
                && lastParameterIsRest(functionDeclaration.callSignature.parameterList);
            }
            else if (nodeType === SyntaxKind.MemberFunctionDeclaration) {
                var memberFunction = <MemberFunctionDeclarationSyntax>enclosingAST;
                return !hasFlag(someFunctionDecl.kind === PullElementKind.Method ? someFunctionDecl.getParentDecl().flags : someFunctionDecl.flags, PullElementFlags.Ambient)
                && memberFunction.block
                && lastParameterIsRest(memberFunction.callSignature.parameterList);
            }
            else if (nodeType === SyntaxKind.ConstructorDeclaration) {
                var constructorDeclaration = <ConstructorDeclarationSyntax>enclosingAST;
                 return !hasFlag(someFunctionDecl.getParentDecl().flags, PullElementFlags.Ambient)
                && constructorDeclaration.block
                && lastParameterIsRest(constructorDeclaration.callSignature.parameterList);
            }
            else if (nodeType === SyntaxKind.ParenthesizedArrowFunctionExpression) {
                var arrowFunctionExpression = <ParenthesizedArrowFunctionExpressionSyntax>enclosingAST;
                return lastParameterIsRest(arrowFunctionExpression.callSignature.parameterList);
            }
            else if (nodeType === SyntaxKind.FunctionExpression) {
                var functionExpression = <FunctionExpressionSyntax>enclosingAST;
                return lastParameterIsRest(functionExpression.callSignature.parameterList);
            }

            return false;
        }

        private checkArgumentsCollides(ast: ISyntaxElement, context: PullTypeResolutionContext) {
            if (ast.kind() === SyntaxKind.Parameter) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                if (hasFlag(enclosingDecl.kind, PullElementKind.SomeFunction)) {
                    if (this.hasRestParameterCodeGen(enclosingDecl)) {
                        // It is error to use the arguments as variable name or parameter name in function with rest parameters
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters));
                    }
                }
            }
        }

        private checkIndexOfRestArgumentInitializationCollides(ast: ISyntaxElement, isDeclaration: boolean, context: PullTypeResolutionContext) {
            if (!isDeclaration || ast.kind() === SyntaxKind.Parameter) {
                var enclosingDecl = this.getEnclosingDeclForAST(ast);
                var declPath = isDeclaration ? [enclosingDecl] : (enclosingDecl ? enclosingDecl.getParentPath() : []);
                var resolvedSymbol: PullSymbol = null;
                var resolvedSymbolContainer: PullTypeSymbol;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    if (!isDeclaration) {
                        // Get the symbol this ast would be resolved to
                        if (!resolvedSymbol) {
                            resolvedSymbol = this.resolveNameExpression(<ISyntaxToken>ast, context);
                            if (resolvedSymbol.isError()) {
                                return;
                            }

                            resolvedSymbolContainer = resolvedSymbol.getContainer();
                        }

                        // If the resolved symbol was declared in this decl, then it would always resolve to this symbol
                        // so stop looking in the decls as it is valid usage of _i
                        if (resolvedSymbolContainer && ArrayUtilities.contains(resolvedSymbolContainer.getDeclarations(), decl)) {
                            break;
                        }
                    }

                    if (hasFlag(decl.kind, PullElementKind.SomeFunction)) {
                        if (this.hasRestParameterCodeGen(decl)) {
                            // It is error to use the _i varible name
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, isDeclaration ?
                                DiagnosticCode.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter :
                                DiagnosticCode.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter));
                        }
                    }
                }
            }
        }

        private checkExternalModuleRequireExportsCollides(ast: ISyntaxElement, name: ISyntaxToken, context: PullTypeResolutionContext) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);

            var enclosingModule = ASTHelpers.getModuleDeclarationFromNameAST(name);
            if (enclosingModule) {
                // If we're actually the name of a module, then we want the enclosing decl for the 
                // module that we're in.
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }

            // If the declaration is in external module
            if (enclosingDecl && enclosingDecl.kind === PullElementKind.DynamicModule) {
                var decl = this.semanticInfoChain.getDeclForAST(ast);
                // This is not ambient declaration, then there would be code gen
                if (!hasFlag(decl.flags, PullElementFlags.Ambient)) { 
                    // It is error to use 'require' or 'exports' as name for the declaration
                    var nameText = tokenValueText(name);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, [nameText, nameText]));
                }
            }
        }

        private resolveObjectTypeTypeReference(objectType: ObjectTypeSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var interfaceDecl = this.semanticInfoChain.getDeclForAST(objectType);
            Debug.assert(interfaceDecl);

            var interfaceSymbol = <PullTypeSymbol>interfaceDecl.getSymbol(this.semanticInfoChain);
            Debug.assert(interfaceSymbol);

            if (objectType.typeMembers) {
                var memberDecl: PullDecl = null;
                var memberSymbol: PullSymbol = null;
                var memberType: PullTypeSymbol = null;
                var typeMembers = objectType.typeMembers;

                for (var i = 0; i < typeMembers.length; i++) {
                    memberDecl = this.semanticInfoChain.getDeclForAST(typeMembers[i]);
                    memberSymbol = (memberDecl.kind & PullElementKind.SomeSignature) ? memberDecl.getSignatureSymbol(this.semanticInfoChain) : memberDecl.getSymbol(this.semanticInfoChain);

                    this.resolveAST(typeMembers[i], false, context);

                    memberType = memberSymbol.type;

                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && (<PullSignatureSymbol>memberSymbol).isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }

            interfaceSymbol.setResolved();

            if (this.canTypeCheckAST(objectType, context)) {
                this.typeCheckObjectTypeTypeReference(objectType, context);
            }

            return interfaceSymbol;
        }

        private typeCheckObjectTypeTypeReference(objectType: ObjectTypeSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(objectType, context);
            var objectTypeDecl = this.semanticInfoChain.getDeclForAST(objectType);
            var objectTypeSymbol = <PullTypeSymbol>objectTypeDecl.getSymbol(this.semanticInfoChain);

            this.typeCheckMembersAgainstIndexer(objectTypeSymbol, objectTypeDecl, context);
            this.checkTypeForDuplicateIndexSignatures(objectTypeSymbol);
        }

        private resolveTypeAnnotation(typeAnnotation: TypeAnnotationSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            return this.resolveTypeReference(typeAnnotation.type, context);
        }

        public resolveTypeReference(typeRef: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            if (typeRef === null) {
                return null;
            }

            Debug.assert(typeRef.kind() !== SyntaxKind.TypeAnnotation);

            var aliasType: PullTypeAliasSymbol = null;
            var type = this.computeTypeReferenceSymbol(typeRef, context);

            if (type.kind === PullElementKind.Container) {
                var container = <PullContainerSymbol>type;
                var instanceSymbol = container.getInstanceSymbol();
                // check if it is actually merged with class
                if (instanceSymbol &&
                    (instanceSymbol.anyDeclHasFlag(PullElementFlags.ClassConstructorVariable) || instanceSymbol.kind === PullElementKind.ConstructorMethod)) {
                    type = instanceSymbol.type.getAssociatedContainerType();
                }
            }

            // Unwrap an alias type to its true type.
            if (type && type.isAlias()) {
                aliasType = <PullTypeAliasSymbol>type;
                type = aliasType.getExportAssignedTypeSymbol();
            }

            if (type && !type.isGeneric()) {
                if (aliasType) {
                    this.semanticInfoChain.setAliasSymbolForAST(typeRef, aliasType);
                }
            }

            if (type && !type.isError()) {
                if ((type.kind & PullElementKind.SomeType) === 0) {
                    // Provide some helper messages for common cases.
                    if (type.kind & PullElementKind.SomeContainer) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef,
                            DiagnosticCode.Type_reference_cannot_refer_to_container_0, [aliasType ? aliasType.toString() : type.toString()]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeRef,
                            DiagnosticCode.Type_reference_must_refer_to_type));
                    }
                }
            }

            if (this.canTypeCheckAST(typeRef, context)) {
                this.setTypeChecked(typeRef, context);
            }

            return type;
        }

        private getArrayType(elementType: PullTypeSymbol) {
            var arraySymbol = elementType.getArrayType();

            // ...But in case we haven't...
            if (!arraySymbol) {

                arraySymbol = this.createInstantiatedType(this.cachedArrayInterfaceType(), [elementType]);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }

                elementType.setArrayType(arraySymbol);
            }

            return arraySymbol;
        }

        private computeTypeReferenceSymbol(term: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            // the type reference can be
            // a name
            // a function
            // an interface
            // a dotted name
            // an array of any of the above
            // a type query

            switch (term.kind()) {
                case SyntaxKind.AnyKeyword: return this.semanticInfoChain.anyTypeSymbol;
                case SyntaxKind.BooleanKeyword: return this.semanticInfoChain.booleanTypeSymbol;
                case SyntaxKind.NumberKeyword: return this.semanticInfoChain.numberTypeSymbol;
                case SyntaxKind.StringKeyword: return this.semanticInfoChain.stringTypeSymbol;
                case SyntaxKind.VoidKeyword: return this.semanticInfoChain.voidTypeSymbol;
            }

            var typeDeclSymbol: PullTypeSymbol = null;

            // a name
            if (term.kind() === SyntaxKind.IdentifierName) {
                typeDeclSymbol = this.resolveTypeNameExpression(<ISyntaxToken>term, context);
            }
            // a function
            else if (term.kind() === SyntaxKind.FunctionType) {
                var functionType = <FunctionTypeSyntax>term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(functionType, functionType.typeParameterList, functionType.parameterList, functionType.type, context);
            }
            else if (term.kind() === SyntaxKind.ConstructorType) {
                var constructorType = <ConstructorTypeSyntax>term;
                typeDeclSymbol = this.resolveAnyFunctionTypeSignature(constructorType, constructorType.typeParameterList, constructorType.parameterList, constructorType.type, context);
            }
            else if (term.kind() === SyntaxKind.ObjectType) {
                typeDeclSymbol = this.resolveObjectTypeTypeReference(<ObjectTypeSyntax>term, context);
            }
            else if (term.kind() === SyntaxKind.GenericType) {
                typeDeclSymbol = this.resolveGenericTypeReference(<GenericTypeSyntax>term, context);
            }
            else if (term.kind() === SyntaxKind.QualifiedName) {
                // find the decl
                typeDeclSymbol = this.resolveQualifiedName(<QualifiedNameSyntax>term, context);
            }
            else if (term.kind() === SyntaxKind.StringLiteral) {
                var stringConstantAST = <ISyntaxToken>term;
                var enclosingDecl = this.getEnclosingDeclForAST(term);
                typeDeclSymbol = new PullStringConstantTypeSymbol(stringConstantAST.text(), this.semanticInfoChain);
                var decl = new PullSynthesizedDecl(stringConstantAST.text(), stringConstantAST.text(),
                    typeDeclSymbol.kind, null, enclosingDecl);
                typeDeclSymbol.addDeclaration(decl);
            }
            else if (term.kind() === SyntaxKind.TypeQuery) {
                var typeQuery = <TypeQuerySyntax>term;

                // TODO: This is a workaround if we encounter a TypeReference ISyntaxElement node. Remove it when we remove the ISyntaxElement.
                var typeQueryTerm = typeQuery.name;
                //if (typeQueryTerm.kind === SyntaxKind.TypeRef) {
                //    typeQueryTerm = (<TypeReference>typeQueryTerm).term;
                //}

                var valueSymbol = this.resolveAST(typeQueryTerm, false, context);

                if (valueSymbol && valueSymbol.isAlias()) {
                    if ((<PullTypeAliasSymbol>valueSymbol).assignedValue()) {
                        valueSymbol = (<PullTypeAliasSymbol>valueSymbol).assignedValue();
                    }
                    else {
                        var containerSymbol = (<PullTypeAliasSymbol>valueSymbol).getExportAssignedContainerSymbol();
                        valueSymbol = (containerSymbol && containerSymbol.isContainer() && !containerSymbol.isEnum()) ? containerSymbol.getInstanceSymbol() : null;
                    }
                }

                // Get the type of the symbol
                if (valueSymbol) {
                    typeDeclSymbol = valueSymbol.type.widenedType(this, typeQueryTerm, context);
                }
                else {
                    typeDeclSymbol = this.getNewErrorTypeSymbol();
                }
            }
            else if (term.kind() === SyntaxKind.ArrayType) {
                var arrayType = <ArrayTypeSyntax>term;
                var underlying = this.resolveTypeReference(arrayType.type, context);
                typeDeclSymbol = this.getArrayType(underlying);
            }
            else {
                throw Errors.invalidOperation("unknown type");
            }

            if (!typeDeclSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, DiagnosticCode.Unable_to_resolve_type));
                return this.getNewErrorTypeSymbol();
            }

            if (typeDeclSymbol.isError()) {
                return typeDeclSymbol;
            }

            if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeDeclSymbol, term, context)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(term, DiagnosticCode.Generic_type_references_must_include_all_type_arguments));
                typeDeclSymbol = this.instantiateTypeToAny(typeDeclSymbol, context);
            }

            return typeDeclSymbol;
        }

        private genericTypeIsUsedWithoutRequiredTypeArguments(typeSymbol: PullTypeSymbol, term: ISyntaxElement, context: PullTypeResolutionContext): boolean {
            if (!typeSymbol) {
                return false;
            }

            if (typeSymbol.isAlias()) {
                return this.genericTypeIsUsedWithoutRequiredTypeArguments((<PullTypeAliasSymbol>typeSymbol).getExportAssignedTypeSymbol(), term, context);
            }

            return typeSymbol.isNamedTypeSymbol() &&
                typeSymbol.isGeneric() &&
                !typeSymbol.isTypeParameter() &&
                (typeSymbol.isResolved || typeSymbol.inResolution) &&
                !typeSymbol.getIsSpecialized() &&
                typeSymbol.getTypeParameters().length &&
                typeSymbol.getTypeArguments() === null &&
                this.isTypeRefWithoutTypeArgs(term);
        }

        private resolveMemberVariableDeclaration(varDecl: MemberVariableDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(
                varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, ASTHelpers.getType(varDecl.variableDeclarator), varDecl.variableDeclarator.equalsValueClause, context);
        }

        private resolvePropertySignature(varDecl: PropertySignatureSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(
                varDecl, Syntax.emptyList<ISyntaxToken>(), varDecl.propertyName, ASTHelpers.getType(varDecl), null, context);
        }

        private resolveVariableDeclarator(varDecl: VariableDeclaratorSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(
                varDecl, ASTHelpers.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, ASTHelpers.getType(varDecl), varDecl.equalsValueClause, context);
        }

        private resolveParameterList(list: ParameterListSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveSeparatedList(list.parameters, context);
        }

        private resolveParameter(parameter: ParameterSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(
                parameter, parameter.modifiers, parameter.identifier, ASTHelpers.getType(parameter), parameter.equalsValueClause, context);
        }

        private getEnumTypeSymbol(enumElement: EnumElementSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var enumDeclaration = <EnumDeclarationSyntax>enumElement.parent.parent;
            var decl = this.semanticInfoChain.getDeclForAST(enumDeclaration);
            var symbol = decl.getSymbol(this.semanticInfoChain);
            this.resolveDeclaredSymbol(symbol, context);

            return <PullTypeSymbol>symbol;
        }

        private resolveEnumElement(enumElement: EnumElementSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveVariableDeclaratorOrParameterOrEnumElement(
                enumElement, Syntax.emptyList<ISyntaxToken>(), enumElement.propertyName, null, enumElement.equalsValueClause, context);
        }

        private typeCheckEnumElement(enumElement: EnumElementSyntax, context: PullTypeResolutionContext): void {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                enumElement, Syntax.emptyList<ISyntaxToken>(), enumElement.propertyName, null, enumElement.equalsValueClause, context);
        }

        private resolveEqualsValueClause(clause: EqualsValueClauseSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(clause, context)) {
                this.setTypeChecked(clause, context);
            }

            return this.resolveAST(clause.value, isContextuallyTyped, context);
        }

        private resolveVariableDeclaratorOrParameterOrEnumElement(
            varDeclOrParameter: ISyntaxElement,
            modifiers: ISyntaxToken[],
            name: ISyntaxToken,
            typeExpr: ISyntaxElement,
            init: EqualsValueClauseSyntax,
            context: PullTypeResolutionContext): PullSymbol {

            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === SyntaxKind.EnumElement;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);

            // if the enclosing decl is a lambda, we may not have bound the parent symbol
            if (enclosingDecl && decl.kind === PullElementKind.Parameter) {
                enclosingDecl.ensureSymbolIsBound(this.semanticInfoChain);
            }

            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol: PullSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            if (declSymbol.isResolved) {
                var declType = declSymbol.type;
                var valDecl = decl.getValueDecl();

                if (valDecl) {
                    var valSymbol = valDecl.getSymbol(this.semanticInfoChain);

                    if (valSymbol && !valSymbol.isResolved) {
                        valSymbol.type = declType;
                        valSymbol.setResolved();
                    }
                }
            }
            else {
                if (declSymbol.inResolution) {
                    // PULLTODO: Error or warning?
                    declSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    declSymbol.setResolved();
                    return declSymbol;
                }

                if (!declSymbol.type || !declSymbol.type.isError()) {
                    declSymbol.startResolving();

                    // Does this have a type expression? If so, that's the type
                    var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(
                        varDeclOrParameter, name, typeExpr, context);

                    // If we're not type checking, and have a type expression, don't bother looking at the initializer expression
                    if (!hasTypeExpr) {
                        this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(
                            varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);
                    }

                    // if we're lacking both a type annotation and an initialization expression, the type is 'any'
                    if (!(hasTypeExpr || init)) {
                        var defaultType: PullTypeSymbol = this.semanticInfoChain.anyTypeSymbol;

                        if (declSymbol.isVarArg && this.cachedArrayInterfaceType()) {
                            defaultType = this.createInstantiatedType(this.cachedArrayInterfaceType(), [defaultType]);
                        }

                        context.setTypeInContext(declSymbol, defaultType);

                        if (declParameterSymbol) {
                            declParameterSymbol.type = defaultType;
                        }
                    }
                    declSymbol.setResolved();

                    if (declParameterSymbol) {
                        declParameterSymbol.setResolved();
                    }
                }
            }

            if (this.canTypeCheckAST(varDeclOrParameter, context)) {
                this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                    varDeclOrParameter, modifiers, name, typeExpr, init, context);
            }

            return declSymbol;
        }

        private resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter: ISyntaxElement, name: ISyntaxToken, typeExpr: ISyntaxElement, context: PullTypeResolutionContext) {
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol: PullSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            if (varDeclOrParameter.kind() === SyntaxKind.EnumElement) {
                var result = this.getEnumTypeSymbol(<EnumElementSyntax>varDeclOrParameter, context);
                declSymbol.type = result;
                return result;
            }

            if (!typeExpr) {
                return null;
            }

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl || enclosingDecl;

            var typeExprSymbol = this.resolveTypeReference(typeExpr, context);

            if (!typeExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));
                declSymbol.type = this.getNewErrorTypeSymbol();

                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            else if (typeExprSymbol.isError()) {
                context.setTypeInContext(declSymbol, typeExprSymbol);
                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, typeExprSymbol);
                }
            }
            else {
                if (typeExprSymbol === this.semanticInfoChain.anyTypeSymbol) {
                    decl.setFlag(PullElementFlags.IsAnnotatedWithAny);
                }

                // PULLREVIEW: If the type annotation is a container type, use the module instance type
                if (typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = (<PullContainerSymbol>typeExprSymbol).getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    }
                    else {
                        typeExprSymbol = typeExprSymbol.type;

                        if (typeExprSymbol.isAlias()) {
                            typeExprSymbol = (<PullTypeAliasSymbol>typeExprSymbol).getExportAssignedTypeSymbol();
                        }

                        if (typeExprSymbol && typeExprSymbol.isContainer() && !typeExprSymbol.isEnum()) {
                            // aliased type could still be 'any' as the result of an error
                            var instanceSymbol = (<PullContainerSymbol>typeExprSymbol).getInstanceSymbol();

                            if (!instanceSymbol || !PullHelpers.symbolIsEnum(instanceSymbol)) {
                                typeExprSymbol = this.getNewErrorTypeSymbol();
                            }
                            else {
                                typeExprSymbol = instanceSymbol.type;
                            }
                        }
                    }
                }
                else if (declSymbol.isVarArg && !(typeExprSymbol.isArrayNamedTypeReference() || typeExprSymbol === this.cachedArrayInterfaceType())) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Rest_parameters_must_be_array_types));
                    typeExprSymbol = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(declSymbol, typeExprSymbol);

                if (declParameterSymbol) {
                    declParameterSymbol.type = typeExprSymbol;
                }

                // We associate the value with the function type here because we couldn't do so at biding
                // but need this information to get correct doc comments
                if (typeExprSymbol.kind === PullElementKind.FunctionType && !typeExprSymbol.getFunctionSymbol()) {
                    typeExprSymbol.setFunctionSymbol(declSymbol);
                }
            }

            return typeExprSymbol;
        }

        private resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter: ISyntaxElement, name: ISyntaxToken, typeExpr: ISyntaxElement, init: EqualsValueClauseSyntax, context: PullTypeResolutionContext, typeExprSymbol: PullTypeSymbol) {
            if (!init) {
                return null;
            }

            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === SyntaxKind.EnumElement;
            if (typeExprSymbol) {
                context.pushNewContextualType(typeExprSymbol);
            }

            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);
            var declParameterSymbol: PullSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol(this.semanticInfoChain) : null;

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl || enclosingDecl;

            var initExprSymbol = this.resolveAST(init, typeExprSymbol !== null, context);

            if (typeExprSymbol) {
                context.popAnyContextualType();
            }

            if (!initExprSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Unable_to_resolve_type_of_0, [name.text()]));

                if (!hasTypeExpr) {
                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol());

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            }
            else {
                var initTypeSymbol = initExprSymbol.type;

                // Don't reset the type if we already have one from the type expression
                if (!hasTypeExpr) {
                    var widenedInitTypeSymbol = initTypeSymbol.widenedType(this, init.value, context);
                    context.setTypeInContext(declSymbol, widenedInitTypeSymbol);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, widenedInitTypeSymbol);
                    }

                    // if the noImplicitAny flag is set to be true, report an error
                    if (this.compilationSettings.noImplicitAny()) {
                        // initializer is resolved to any type from widening variable declaration (i.e var x = null)
                        if ((widenedInitTypeSymbol !== initTypeSymbol) && (widenedInitTypeSymbol === this.semanticInfoChain.anyTypeSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Variable_0_implicitly_has_an_any_type,
                                [name.text()]));
                        }
                    }

                    return widenedInitTypeSymbol;
                }
            }

            return initTypeSymbol;
        }

        private typeCheckPropertySignature(varDecl: PropertySignatureSyntax, context: PullTypeResolutionContext) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                varDecl, Syntax.emptyList<ISyntaxToken>(), varDecl.propertyName, ASTHelpers.getType(varDecl), null, context);
        }

        private typeCheckMemberVariableDeclaration(varDecl: MemberVariableDeclarationSyntax, context: PullTypeResolutionContext) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                varDecl, varDecl.modifiers, varDecl.variableDeclarator.propertyName, ASTHelpers.getType(varDecl), varDecl.variableDeclarator.equalsValueClause, context);
        }

        private typeCheckVariableDeclarator(varDecl: VariableDeclaratorSyntax, context: PullTypeResolutionContext) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                varDecl, ASTHelpers.getVariableDeclaratorModifiers(varDecl), varDecl.propertyName, ASTHelpers.getType(varDecl), varDecl.equalsValueClause, context);
        }

        private typeCheckParameter(parameter: ParameterSyntax, context: PullTypeResolutionContext) {
            this.typeCheckVariableDeclaratorOrParameterOrEnumElement(
                parameter, parameter.modifiers, parameter.identifier, ASTHelpers.getType(parameter), parameter.equalsValueClause, context);
        }

        private typeCheckVariableDeclaratorOrParameterOrEnumElement(varDeclOrParameter: ISyntaxElement, modifiers: ISyntaxToken[], name: ISyntaxToken, typeExpr: ISyntaxElement, init: EqualsValueClauseSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(varDeclOrParameter, context);

            var hasTypeExpr = typeExpr !== null || varDeclOrParameter.kind() === SyntaxKind.EnumElement;
            var enclosingDecl = this.getEnclosingDeclForAST(varDeclOrParameter);
            var decl = this.semanticInfoChain.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol(this.semanticInfoChain);

            var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(
                varDeclOrParameter, name, typeExpr, context);

            // Report errors on init Expr only if typeExpr is present because we wouldnt have resolved the initExpr when just resolving
            var initTypeSymbol = this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(
                varDeclOrParameter, name, typeExpr, init, context, typeExprSymbol);

            // If we're type checking, test the initializer and type annotation for assignment compatibility
            if (hasTypeExpr || init) {
                if (typeExprSymbol && typeExprSymbol.isAlias()) {
                    typeExprSymbol = (<PullTypeAliasSymbol>typeExprSymbol).getExportAssignedTypeSymbol();
                }

                if (typeExprSymbol && typeExprSymbol.kind === PullElementKind.DynamicModule) {
                    var exportedTypeSymbol = (<PullContainerSymbol>typeExprSymbol).getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    }
                    else {
                        var instanceTypeSymbol = (<PullContainerSymbol>typeExprSymbol).getInstanceType();

                        if (!instanceTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [typeExprSymbol.toString()]));
                            typeExprSymbol = null;
                        }
                        else {
                            typeExprSymbol = instanceTypeSymbol;
                        }
                    }
                }

                initTypeSymbol = this.getInstanceTypeForAssignment(
                    varDeclOrParameter, initTypeSymbol, context);

                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();

                    var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, varDeclOrParameter, context, comparisonInfo);

                    if (!isAssignable) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(varDeclOrParameter);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(enclosingSymbol), typeExprSymbol.toString(enclosingSymbol)]));
                        }
                    }
                }
            }
            else if (varDeclOrParameter.kind() !== SyntaxKind.EnumElement && this.compilationSettings.noImplicitAny() && !this.isForInVariableDeclarator(varDeclOrParameter)) {
                // if we're lacking both a type annotation and an initialization expression, the type is 'any'
                // if the noImplicitAny flag is set to be true, report an error
                // Do not report an error if the variable declaration is declared in ForIn statement

                var wrapperDecl = this.getEnclosingDecl(decl);
                wrapperDecl = wrapperDecl || enclosingDecl;

                // error should be reported if
                // - container decl is not ambient
                // OR
                // - container decl is ambient and self decl is not private (is provided)
                var needReportError = (containerDecl: PullDecl, selfDecl?: PullDecl) => {
                    if (!hasFlag(containerDecl.flags, PullElementFlags.Ambient)) {
                        return true;
                    }

                    return selfDecl && !hasFlag(selfDecl.flags, PullElementFlags.Private)
                };

                // check what enclosingDecl the varDecl is in and report an appropriate error message
                // varDecl is a function/constructor/constructor-signature parameter
                if ((wrapperDecl.kind === TypeScript.PullElementKind.Function ||
                    wrapperDecl.kind === TypeScript.PullElementKind.ConstructorMethod ||
                    wrapperDecl.kind === TypeScript.PullElementKind.ConstructSignature)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter,
                        DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                }
                // varDecl is a method paremeter
                else if (wrapperDecl.kind === TypeScript.PullElementKind.Method) {
                    // check if the parent of wrapperDecl is ambient class declaration
                    var parentDecl = wrapperDecl.getParentDecl();
                    // parentDecl is not an ambient declaration; so report an error
                    // OR
                    //parentDecl is an ambient declaration, but the wrapperDecl(method) is a not private; so report an error
                    if (needReportError(parentDecl, wrapperDecl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter,
                            DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.text(), enclosingDecl.name]));
                    }
                }
                // varDecl is a property in object type
                else if (decl.kind === TypeScript.PullElementKind.Property && !declSymbol.getContainer().isNamedTypeSymbol()) {
                    if (needReportError(wrapperDecl, decl)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter,
                            DiagnosticCode.Member_0_of_object_type_implicitly_has_an_any_type, [name.text()]));
                    }
                }
                // varDecl is a variable declaration or class/interface property; Ignore variable in catch block or in the ForIn Statement
                else if (wrapperDecl.kind !== TypeScript.PullElementKind.CatchBlock) {
                    // varDecl is not declared in ambient declaration; so report an error
                    // OR
                    // varDecl is declared in ambient declaration but it is not private; so report an error
                    if (needReportError(wrapperDecl) || !hasModifier(modifiers, PullElementFlags.Private)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter,
                            DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.text()]));
                    }                    
                }
            }

            if (init && varDeclOrParameter.kind() === SyntaxKind.Parameter) {
                var containerSignature = enclosingDecl.getSignatureSymbol(this.semanticInfoChain);
                if (containerSignature && !containerSignature.isDefinition()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(varDeclOrParameter, DiagnosticCode.Default_arguments_are_only_allowed_in_implementation));
                }
            }
            if (declSymbol.kind !== PullElementKind.Parameter &&
                (declSymbol.kind !== PullElementKind.Property || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkSymbolPrivacy(declSymbol, declSymbol.type, (symbol: PullSymbol) =>
                    this.variablePrivacyErrorReporter(varDeclOrParameter, declSymbol, symbol, context));
            }

            if ((declSymbol.kind !== PullElementKind.Property && declSymbol.kind !== PullElementKind.EnumMember) || declSymbol.anyDeclHasFlag(PullElementFlags.PropertyParameter)) {
                // Non property variable with _this name, we need to verify if this would be ok
                this.checkNameForCompilerGeneratedDeclarationCollision(varDeclOrParameter, /*isDeclaration*/ true, name, context);
            }
        }

        private isForInVariableDeclarator(ast: ISyntaxElement): boolean {
            return ast.kind() === SyntaxKind.VariableDeclarator &&
                ast.parent && ast.parent.parent && ast.parent.parent.parent &&
                ast.parent.kind() === SyntaxKind.SeparatedList &&
                ast.parent.parent.kind() === SyntaxKind.VariableDeclaration &&
                ast.parent.parent.parent.kind() === SyntaxKind.ForInStatement &&
                (<ForInStatementSyntax>ast.parent.parent.parent).variableDeclaration === ast.parent.parent;
        }

        private checkSuperCaptureVariableCollides(superAST: ISyntaxElement, isDeclaration: boolean, context: PullTypeResolutionContext) {
            var enclosingDecl = this.getEnclosingDeclForAST(superAST);

            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(superAST, enclosingDecl);

            if (classSymbol && !classSymbol.anyDeclHasFlag(PullElementFlags.Ambient)) {
                if (superAST.kind() === SyntaxKind.Parameter) {
                    var enclosingAST = this.getASTForDecl(enclosingDecl);
                    if (enclosingAST.kind() !== SyntaxKind.ParenthesizedArrowFunctionExpression &&
                        enclosingAST.kind() !== SyntaxKind.SimpleArrowFunctionExpression) {

                        var block = enclosingDecl.kind === PullElementKind.Method ? (<FunctionDeclarationSyntax>enclosingAST).block : (<ConstructorDeclarationSyntax>enclosingAST).block;
                        if (!block) {
                            return; // just a overload signature - no code gen
                        }
                    }
                }

                this.resolveDeclaredSymbol(classSymbol, context);

                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(superAST, isDeclaration
                        ? DiagnosticCode.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference
                        : DiagnosticCode.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference));
                }
            }
        }

        private checkThisCaptureVariableCollides(_thisAST: ISyntaxElement, isDeclaration: boolean, context: PullTypeResolutionContext) {
            if (isDeclaration) {
                var decl = this.semanticInfoChain.getDeclForAST(_thisAST);
                if (hasFlag(decl.flags, PullElementFlags.Ambient)) { // ambient declarations do not generate the code
                    return;
                }
            }

            // Verify if this variable name conflicts with the _this that would be emitted to capture this in any of the enclosing context
            var enclosingDecl = this.getEnclosingDeclForAST(_thisAST);

            var enclosingModule = ASTHelpers.getModuleDeclarationFromNameAST(_thisAST);
            if (enclosingModule) {
                // If we're actually the name of a module, then we want the enclosing decl for the 
                // module that we're in.
                enclosingDecl = this.getEnclosingDeclForAST(enclosingModule);
            }


            var declPath = enclosingDecl.getParentPath();

            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                var declKind = decl.kind;
                if (declKind === PullElementKind.FunctionExpression && hasFlag(decl.flags, PullElementFlags.ArrowFunction)) {
                    continue;
                }

                if (declKind === PullElementKind.Function ||
                    declKind === PullElementKind.Method ||
                    declKind === PullElementKind.ConstructorMethod ||
                    declKind === PullElementKind.GetAccessor ||
                    declKind === PullElementKind.SetAccessor ||
                    declKind === PullElementKind.FunctionExpression ||
                    declKind === PullElementKind.Class ||
                    declKind === PullElementKind.Container ||
                    declKind === PullElementKind.DynamicModule ||
                    declKind === PullElementKind.Script) {
                    if (hasFlag(decl.flags, PullElementFlags.MustCaptureThis)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(_thisAST, isDeclaration
                            ? DiagnosticCode.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference
                            : DiagnosticCode.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference));
                    }
                    break;
                }
            }
        }

        private postTypeCheckVariableDeclaratorOrParameter(varDeclOrParameter: ISyntaxElement, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(varDeclOrParameter, /*isDeclaration:*/ true, context);
        }

        private resolveTypeParameterDeclaration(typeParameterAST: TypeParameterSyntax, context: PullTypeResolutionContext): PullTypeParameterSymbol {
            var typeParameterDecl = this.semanticInfoChain.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = <PullTypeParameterSymbol>typeParameterDecl.getSymbol(this.semanticInfoChain);

            // Always resolve the first type parameter declaration to make sure we have the constraint set from the first decl
            this.resolveFirstTypeParameterDeclaration(typeParameterSymbol, context);

            if (typeParameterSymbol.isResolved && this.canTypeCheckAST(typeParameterAST, context)) {
                this.typeCheckTypeParameterDeclaration(typeParameterAST, context);
            }

            return typeParameterSymbol;
        }

        private resolveFirstTypeParameterDeclaration(typeParameterSymbol: PullTypeParameterSymbol, context: PullTypeResolutionContext) {
            var typeParameterDecl = typeParameterSymbol.getDeclarations()[0];
            var typeParameterAST = <TypeParameterSyntax>this.semanticInfoChain.getASTForDecl(typeParameterDecl);

            // REVIEW: We shouldn't bail if we're specializing
            if (typeParameterSymbol.isResolved || typeParameterSymbol.inResolution) {
                return;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint.type, context);

                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();
        }

        private typeCheckTypeParameterDeclaration(typeParameterAST: TypeParameterSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(typeParameterAST, context);

            var constraint = <PullTypeSymbol>this.resolveAST(typeParameterAST.constraint, /*isContextuallyTyped:*/ false, context);

            if (constraint) {
                // Get all type parameters and create a map that has entries at pullSymbolID for each of the type parameter
                // The value doesnt matter, the entry needs to be present for the wrapsSomeTypeParameter to be able to give the correct answer
                var typeParametersAST = <TypeParameterSyntax[]>typeParameterAST.parent;
                var typeParameters: PullTypeSymbol[] = [];
                for (var i = 0; i < typeParametersAST.length; i++) {
                    var currentTypeParameterAST = typeParametersAST[i];
                    var currentTypeParameterDecl = this.semanticInfoChain.getDeclForAST(currentTypeParameterAST);
                    var currentTypeParameter = <PullTypeParameterSymbol>this.semanticInfoChain.getSymbolForDecl(currentTypeParameterDecl);
                    typeParameters[currentTypeParameter.pullSymbolID] = currentTypeParameter;
                }

                // If constraint wraps any of the type parameter from the type parameters list report error
                if (constraint.wrapsSomeTypeParameter(typeParameters)) {
                    this.semanticInfoChain.addDiagnosticFromAST(typeParameterAST, DiagnosticCode.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);
                }
            }
        }

        private resolveConstraint(constraint: ConstraintSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(constraint, context)) {
                this.setTypeChecked(constraint, context);
            }

            return this.resolveTypeReference(constraint.type, context);
        }

        private resolveFunctionBodyReturnTypes(
            funcDeclAST: ISyntaxElement,
            block: BlockSyntax,
            bodyExpression: ISyntaxElement,
            signature: PullSignatureSymbol,
            useContextualType: boolean,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext) {

            var returnStatementsExpressions: {
                expression: ISyntaxElement; enclosingDecl: PullDecl;
            }[] = [];

            var enclosingDeclStack: PullDecl[] = [enclosingDecl];

            var preFindReturnExpressionTypes = (ast: ISyntaxElement, walker: IAstWalker) => {
                var go = true;

                switch (ast.kind()) {
                    case SyntaxKind.ReturnStatement:
                        var returnStatement: ReturnStatementSyntax = <ReturnStatementSyntax>ast;
                        enclosingDecl.setFlag(PullElementFlags.HasReturnStatement);
                        returnStatementsExpressions.push({ expression: returnStatement.expression, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] });
                        go = false;
                        break;

                    case SyntaxKind.CatchClause:
                    case SyntaxKind.WithStatement:
                        enclosingDeclStack[enclosingDeclStack.length] = this.semanticInfoChain.getDeclForAST(ast);
                        break;

                    default:
                        // don't recurse into a function\object literal decl - we don't want to confuse a nested
                        // return type with the top-level function's return type
                        go = !this.isAnyFunctionExpressionOrDeclaration(ast);
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            };

            var postFindReturnExpressionEnclosingDecls = function (ast: ISyntaxElement, walker: IAstWalker) {
                switch (ast.kind()) {
                    case SyntaxKind.CatchClause:
                    case SyntaxKind.WithStatement:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }

                walker.options.goChildren = true;

                return ast;
            };

            if (block) {
                getAstWalkerFactory().walk(block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);
            }
            else {
                returnStatementsExpressions.push({ expression: bodyExpression, enclosingDecl: enclosingDecl });
                enclosingDecl.setFlag(PullElementFlags.HasReturnStatement);
            }

            if (!returnStatementsExpressions.length) {
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
            }

            else {
                var returnExpressionSymbols: PullTypeSymbol[] = [];
                var returnExpressions: ISyntaxElement[] = [];

                for (var i = 0; i < returnStatementsExpressions.length; i++) {
                    var returnExpression = returnStatementsExpressions[i].expression;
                    if (returnExpression) {
                        var returnType = this.resolveAST(returnExpression, useContextualType, context).type;

                        if (returnType.isError()) {
                            signature.returnType = returnType;
                            return;
                        }
                        else {
                            if (returnExpression.parent.kind() === SyntaxKind.ReturnStatement) {
                                this.setSymbolForAST(returnExpression.parent, returnType, context);
                            }
                        }

                        returnExpressionSymbols.push(returnType);
                        returnExpressions.push(returnExpression);
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                }
                else {
                    // combine return expression types for best common type
                    var collection: IPullTypeCollection = {
                        getLength: () => { return returnExpressionSymbols.length; },
                        getTypeAtIndex: (index: number) => {
                            return returnExpressionSymbols[index].type;
                        }
                    };

                    var bestCommonReturnType = this.findBestCommonType(collection, context, new TypeComparisonInfo());
                    var returnType = bestCommonReturnType;
                    var returnExpression = returnExpressions[returnExpressionSymbols.indexOf(returnType)];

                    var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
                    var functionSymbol = functionDecl.getSymbol(this.semanticInfoChain);

                    if (returnType) {
                        var previousReturnType = returnType;
                        var newReturnType = returnType.widenedType(this, returnExpression, context);
                        signature.returnType = newReturnType;

                        if (!ArrayUtilities.contains(returnExpressionSymbols, bestCommonReturnType)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                                DiagnosticCode.Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions));
                        }

                        // if noImplicitAny flag is set to be true and return statements are not cast expressions, report an error
                        if (this.compilationSettings.noImplicitAny()) {
                            // if the returnType got widen to Any
                            if (previousReturnType !== newReturnType && newReturnType === this.semanticInfoChain.anyTypeSymbol) {
                                var functionName = enclosingDecl.name;
                                if (functionName === "") {
                                    functionName = (<PullFunctionExpressionDecl>enclosingDecl).getFunctionExpressionName();
                                }

                                if (functionName != "") {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                                        DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionName]));
                                }
                                else {
                                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                                        DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                                }
                            }
                        }
                    }

                    // If the accessor is referenced via a recursive chain, we may not have set the accessor's type just yet and we'll
                    // need to do so before setting the 'isGeneric' flag
                    if (!functionSymbol.type && functionSymbol.isAccessor()) {
                        functionSymbol.type = signature.returnType;
                    }
                }
            }
        }

        private typeCheckConstructorDeclaration(funcDeclAST: ConstructorDeclarationSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            // resolve parameter type annotations as necessary
            for (var i = 0; i < funcDeclAST.callSignature.parameterList.parameters.length; i++) {
                this.resolveAST(funcDeclAST.callSignature.parameterList.parameters[i], /*isContextuallyTyped:*/ false, context);
            }

            this.resolveAST(funcDeclAST.block, false, context);

            if (funcDecl.getSignatureSymbol(this.semanticInfoChain) && funcDecl.getSignatureSymbol(this.semanticInfoChain).isDefinition() && this.enclosingClassIsDerived(funcDecl.getParentDecl())) {
                // Constructors for derived classes must contain a call to the class's 'super' constructor
                if (!this.constructorHasSuperCall(funcDeclAST)) {
                    var syntaxTree = TypeScript.syntaxTree(funcDeclAST);
                    context.postDiagnostic(new Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), start(funcDeclAST.constructorKeyword), width(funcDeclAST.constructorKeyword),
                        DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call));
                }
                // The first statement in the body of a constructor must be a super call if both of the following are true:
                //  - The containing class is a derived class.
                //  - The constructor declares parameter properties or the containing class declares instance member variables with initializers.
                else if (this.superCallMustBeFirstStatementInConstructor(funcDecl)) {
                    var firstStatement = this.getFirstStatementOfBlockOrNull(funcDeclAST.block);
                    if (!firstStatement || !this.isSuperInvocationExpressionStatement(firstStatement)) {
                        var syntaxTree = TypeScript.syntaxTree(funcDeclAST);
                        context.postDiagnostic(new Diagnostic(syntaxTree.fileName(), syntaxTree.lineMap(), start(funcDeclAST.constructorKeyword), width(funcDeclAST.constructorKeyword),
                            DiagnosticCode.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties));
                    }
                }
            }

            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(
                funcDeclAST, /*isStatic:*/ false, null, ASTHelpers.parametersFromParameterList(funcDeclAST.callSignature.parameterList), null, funcDeclAST.block, context);

            this.typeCheckCallBacks.push(context => {
                // Function or constructor
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        }

        private constructorHasSuperCall(constructorDecl: ConstructorDeclarationSyntax): boolean {
            // October 1, 2013
            // Constructors of classes with no extends clause may not contain super calls, whereas 
            // constructors of derived classes must contain at least one super call somewhere in 
            // their function body. Super calls are not permitted outside constructors or in local
            // functions inside constructors.
            if (constructorDecl.block) {
                var foundSuperCall = false;
                var pre = (ast: ISyntaxElement, walker: IAstWalker) => {
                    // do not dive in functions - super calls inside them are illegal and should not be considered valid search results
                    if (this.isAnyFunctionExpressionOrDeclaration(ast)) {
                        walker.options.goChildren = false;
                        return;
                    }

                    // If we hit a super invocation, then we're done.  Stop everything we're doing.
                    // Note 1: there is no restriction on there being multiple super calls.
                    // Note 2: The restriction about super calls not being permitted in a local 
                    // function is checked in typeCheckSuperExpression
                    if (this.isSuperInvocationExpression(ast)) {
                        foundSuperCall = true;
                        walker.options.stopWalking = true;
                    }
                }

                getAstWalkerFactory().walk(constructorDecl.block, pre);
                return foundSuperCall;
            }

            return false;
        }

        private typeCheckFunctionExpression(funcDecl: FunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): void {
            this.typeCheckAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList,
                ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList), 
                funcDecl.callSignature.typeAnnotation, funcDecl.block, /*bodyExpression:*/ null, isContextuallyTyped, context);
        }

        private typeCheckCallSignature(funcDecl: CallSignatureSyntax, context: PullTypeResolutionContext): void {
            this.typeCheckAnyFunctionDeclaration(funcDecl, /*isStatic:*/ false,
                null, funcDecl.typeParameterList, funcDecl.parameterList, ASTHelpers.getType(funcDecl), null, context);
        }

        private typeCheckConstructSignature(funcDecl: ConstructSignatureSyntax, context: PullTypeResolutionContext): void {
            this.typeCheckAnyFunctionDeclaration(funcDecl, /*isStatic:*/ false,
                null, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, ASTHelpers.getType(funcDecl), null, context);
        }

        private typeCheckMethodSignature(funcDecl: MethodSignatureSyntax, context: PullTypeResolutionContext): void {
            this.typeCheckAnyFunctionDeclaration(funcDecl, /*isStatic:*/ false,
                funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList,
                ASTHelpers.getType(funcDecl), null, context);
        }

        private typeCheckMemberFunctionDeclaration(funcDecl: MemberFunctionDeclarationSyntax, context: PullTypeResolutionContext): void {
            this.typeCheckAnyFunctionDeclaration(funcDecl, hasModifier(funcDecl.modifiers, PullElementFlags.Static),
                funcDecl.propertyName, funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList,
                ASTHelpers.getType(funcDecl), funcDecl.block, context);
        }

        private containsSingleThrowStatement(block: BlockSyntax): boolean {
            return block !== null && block.statements.length === 1 && block.statements[0].kind() === SyntaxKind.ThrowStatement;
        }

        private typeCheckAnyFunctionDeclaration(
            funcDeclAST: ISyntaxElement,
            isStatic: boolean,
            name: ISyntaxToken,
            typeParameters: TypeParameterListSyntax,
            parameters: ParameterListSyntax,
            returnTypeAnnotation: ISyntaxElement,
            block: BlockSyntax,
            context: PullTypeResolutionContext) {
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            // resolve parameter type annotations as necessary
            this.resolveAST(parameters, /*isContextuallyTyped:*/ false, context);

            this.resolveAST(block, false, context);
                var enclosingDecl = this.getEnclosingDecl(funcDecl);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);
            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(
                funcDeclAST, isStatic, typeParameters, ASTHelpers.parametersFromParameterList(parameters), returnTypeAnnotation, block, context);

            this.checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(funcDecl, returnTypeAnnotation, funcDecl.getSignatureSymbol(this.semanticInfoChain).returnType, block, context);

            if (funcDecl.kind === PullElementKind.Function) {
                this.checkNameForCompilerGeneratedDeclarationCollision(funcDeclAST, /*isDeclaration*/ true, name, context);
            } 

            // Check for implicit any return types on signatures.
            // In cases where a function has a body, the return type can be inferred from the body.
            // In such cases, we do not consider an inferred any type to be implicit.
            if (this.compilationSettings.noImplicitAny() && block === null && returnTypeAnnotation === null ) {
                this.checkAndReportImplicitAnyOnFunctionSignature(funcDeclAST, name, context);
            }

            this.typeCheckCallBacks.push(context => {
                // Function or constructor
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        }

        // Given that we have no type annotation nor body, raise an error if we find it appropriate to do so.
        private checkAndReportImplicitAnyOnFunctionSignature(funcDeclAST: ISyntaxElement, funcDeclASTName: ISyntaxToken, context: PullTypeResolutionContext): void {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            // Don't report an error to the user if the field is a private ambient member.
            // Private fields don't actually need their types exposed, and in generated
            // .d.ts files, they are given no type annotations.
            if (this.isPrivateWithinAmbientDeclaration(funcDecl)) {
                return;
            }

            if (funcDecl.kind === PullElementKind.ConstructSignature) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
            }
            else if (funcDeclASTName !== null) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type,
                    [funcDeclASTName.text()]));
            }
            else {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                    DiagnosticCode.Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
            }
        }
        
        private isPrivateWithinAmbientDeclaration(funcDecl: PullDecl): boolean {
            if (TypeScript.hasFlag(funcDecl.flags, PullElementFlags.Private)) {
                var parentDecl = funcDecl.getParentDecl();

                if (parentDecl !== null) {
                    return TypeScript.hasFlag(parentDecl.flags, PullElementFlags.Ambient);
                }
            
            }

            return false;
        }

        private checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(
            functionDecl: PullDecl,
            returnTypeAnnotation: ISyntaxElement,
            returnTypeSymbol: PullTypeSymbol,
            block: BlockSyntax,
            context: PullTypeResolutionContext): void {
            var hasReturn = hasFlag(functionDecl.flags, PullElementFlags.HasReturnStatement);

            // November 18, 2013
            // An explicitly typed function returning a non-void type must have at least one return 
            // statement somewhere in its body. An exception to this rule is if the function 
            // implementation consists of a single 'throw' statement.
            if (block !== null && returnTypeAnnotation !== null && !hasReturn) {
                var isVoidOrAny = this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol;

                if (!isVoidOrAny && !this.containsSingleThrowStatement(block)) {
                    var funcName = functionDecl.getDisplayName() || getLocalizedText(DiagnosticCode.expression, null);

                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, DiagnosticCode.Function_declared_a_non_void_return_type_but_has_no_return_expression));
                }
            }
        }

        private typeCheckIndexSignature(funcDeclAST: IndexSignatureSyntax, context: PullTypeResolutionContext): void {

            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            // resolve parameter type annotations as necessary
            this.resolveAST(funcDeclAST.parameter, /*isContextuallyTyped:*/ false, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, ASTHelpers.getType(funcDeclAST), context);
            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(
                funcDeclAST, /*isStatic:*/ false, null, ASTHelpers.parametersFromParameter(funcDeclAST.parameter), ASTHelpers.getType(funcDeclAST), null, context);

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            this.typeCheckCallBacks.push(context => {
                var parentSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain).getContainer();
                var allIndexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(parentSymbol, context);
                var stringIndexSignature = allIndexSignatures.stringSignature;
                var numberIndexSignature = allIndexSignatures.numericSignature;
                var isNumericIndexer = numberIndexSignature === signature;

                // Section 3.7.4 (November 18, 2013): 
                // Specifically, in a type with a string index signature of type T, all properties and numeric index signatures must
                // have types that are subtypes of T.
                // Check that the number signature is assignable to the string index signature. To ensure that we only check this once,
                // we make sure that if the two signatures share a container, we only check this when type checking the number signature.
                if (numberIndexSignature && stringIndexSignature &&
                    (isNumericIndexer || stringIndexSignature.getDeclarations()[0].getParentDecl() !== numberIndexSignature.getDeclarations()[0].getParentDecl())) {
                    var comparisonInfo = new TypeComparisonInfo();

                        if (!this.sourceIsAssignableToTarget(numberIndexSignature.returnType, stringIndexSignature.returnType, funcDeclAST, context, comparisonInfo)) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(funcDeclAST);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2,
                                [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1,
                                [numberIndexSignature.returnType.toString(enclosingSymbol), stringIndexSignature.returnType.toString(enclosingSymbol)]));
                        }
                    }
                }

                // Check that property names comply with indexer constraints (either string or numeric)
                var allMembers = parentSymbol.type.getAllMembers(PullElementKind.All, GetAllMembersVisiblity.all);
                for (var i = 0; i < allMembers.length; i++) {
                    var member = allMembers[i];
                    var name = member.name;
                    if (name || (member.kind === PullElementKind.Property && name === "")) {
                        if (!allMembers[i].isResolved) {
                            this.resolveDeclaredSymbol(allMembers[i], context);
                        }
                        // Skip members in the same container, they will be checked during their member type check
                        if (parentSymbol !== allMembers[i].getContainer()) {
                            // Check if the member name kind (number or string), matches the index signature kind. If it does give an error.
                            // If it doesn't we only want to give an error if this is a string signature, and we don't have a numeric signature
                            var isMemberNumeric = PullHelpers.isNameNumeric(name);
                            var indexerKindMatchesMemberNameKind = isNumericIndexer === isMemberNumeric;
                            var onlyStringIndexerIsPresent = !numberIndexSignature;

                            if (indexerKindMatchesMemberNameKind || onlyStringIndexerIsPresent) {
                                var comparisonInfo = new TypeComparisonInfo();
                                if (!this.sourceIsAssignableToTarget(allMembers[i].type, signature.returnType, funcDeclAST, context, comparisonInfo, /*isComparingInstantiatedSignatures*/ false)) {
                                    this.reportErrorThatMemberIsNotSubtypeOfIndexer(allMembers[i], signature, funcDeclAST, context, comparisonInfo);
                                }
                            }
                        }
                    }
                }
            });
        }

        private postTypeCheckFunctionDeclaration(funcDeclAST: FunctionDeclarationSyntax, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(funcDeclAST, /*isDeclaration*/ true, context);
        }

        private resolveReturnTypeAnnotationOfFunctionDeclaration(
            funcDeclAST: ISyntaxElement,
            returnTypeAnnotation: ISyntaxElement,
            context: PullTypeResolutionContext): PullTypeSymbol {

            var returnTypeSymbol: PullTypeSymbol = null;

            // resolve the return type annotation
            if (returnTypeAnnotation) {
                var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

                // use the funcDecl for the enclosing decl, since we want to pick up any type parameters 
                // on the function when resolving the return type
                returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);

                if (!returnTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, DiagnosticCode.Cannot_resolve_return_type_reference));
                }
                else {
                    var isConstructor = funcDeclAST.kind() === SyntaxKind.ConstructorDeclaration || funcDeclAST.kind() === SyntaxKind.ConstructSignature;
                    if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                    }
                }
            }

            return returnTypeSymbol;
        }

        private resolveMemberFunctionDeclaration(funcDecl: MemberFunctionDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveFunctionDeclaration(funcDecl, hasModifier(funcDecl.modifiers, PullElementFlags.Static), funcDecl.propertyName,
                funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, ASTHelpers.getType(funcDecl), funcDecl.block, context);
        }

        private resolveCallSignature(funcDecl: CallSignatureSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveFunctionDeclaration(funcDecl, /*isStatic:*/ false, null,
                funcDecl.typeParameterList, funcDecl.parameterList, ASTHelpers.getType(funcDecl), null, context);
        }

        private resolveConstructSignature(funcDecl: ConstructSignatureSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveFunctionDeclaration(funcDecl, /*isStatic:*/ false, null,
                funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, ASTHelpers.getType(funcDecl), null, context);
        }

        private resolveMethodSignature(funcDecl: MethodSignatureSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveFunctionDeclaration(funcDecl, /*isStatic:*/ false, funcDecl.propertyName,
                funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, ASTHelpers.getType(funcDecl), null, context);
        }

        private resolveAnyFunctionDeclaration(funcDecl: FunctionDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveFunctionDeclaration(funcDecl, hasModifier(funcDecl.modifiers, PullElementFlags.Static), funcDecl.identifier,
                funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList, ASTHelpers.getType(funcDecl), funcDecl.block, context);
        }

        private resolveFunctionExpression(funcDecl: FunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.callSignature.typeParameterList,
                ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList), ASTHelpers.getType(funcDecl), funcDecl.block, /*bodyExpression:*/ null,
                isContextuallyTyped, context);
        }

        private resolveSimpleArrowFunctionExpression(funcDecl: SimpleArrowFunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveAnyFunctionExpression(
                funcDecl, null, ASTHelpers.parametersFromIdentifier(funcDecl.identifier), null, funcDecl.block, funcDecl.expression,
                isContextuallyTyped, context);
        }

        private resolveParenthesizedArrowFunctionExpression(funcDecl: ParenthesizedArrowFunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveAnyFunctionExpression(
                funcDecl, funcDecl.callSignature.typeParameterList, ASTHelpers.parametersFromParameterList(funcDecl.callSignature.parameterList), ASTHelpers.getType(funcDecl),
                funcDecl.block, funcDecl.expression, isContextuallyTyped, context);
        }

        private getEnclosingClassDeclaration(ast: ISyntaxElement): ClassDeclarationSyntax {
            while (ast) {
                if (ast.kind() === SyntaxKind.ClassDeclaration) {
                    return <ClassDeclarationSyntax>ast;
                }

                ast = ast.parent;
            }

            return null;
        }

        private resolveConstructorDeclaration(funcDeclAST: ConstructorDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckConstructorDeclaration(funcDeclAST, context);
                    }
                    return funcSymbol;
                }

                if (!signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);

                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol(this.semanticInfoChain);

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }

                // Save this in case we had set the function type to any because of a recursive reference.
                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                // resolve parameter type annotations as necessary

                var prevInTypeCheck = context.inTypeCheck;

                // TODO: why are we getting ourselves out of typecheck here?
                context.inTypeCheck = false;

                for (var i = 0; i < funcDeclAST.callSignature.parameterList.parameters.length; i++) {
                    // TODO: why are we calling resolveParameter instead of resolveAST.
                    this.resolveParameter(funcDeclAST.callSignature.parameterList.parameters[i], context);
                }

                context.inTypeCheck = prevInTypeCheck;

                if (signature.isGeneric()) {
                    // PULLREVIEW: This is split into a spearate if statement to make debugging slightly easier...
                    if (funcSymbol) {
                        funcSymbol.type.setHasGenericSignature();
                    }
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckConstructorDeclaration(funcDeclAST, context);
            }

            return funcSymbol;
        }

        private resolveIndexMemberDeclaration(ast: IndexMemberDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }

            return this.resolveIndexSignature(ast.indexSignature, context);
        }

        private resolveIndexSignature(funcDeclAST: IndexSignatureSyntax, context: PullTypeResolutionContext): PullSymbol {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckIndexSignature(funcDeclAST, context);
                    }
                    return funcSymbol;
                }

                // Save this in case we had set the function type to any because of a recursive reference.
                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {

                    // try to set the return type, even though we may be lacking in some information
                    if (funcDeclAST.typeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(ASTHelpers.getType(funcDeclAST), context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ASTHelpers.getType(funcDeclAST), DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        }
                        else {
                            signature.returnType = returnTypeSymbol;
                        }
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                // resolve parameter type annotations as necessary

                if (funcDeclAST.parameter) {
                    var prevInTypeCheck = context.inTypeCheck;

                    // TODO: why are we setting inTypeCheck false here?
                    context.inTypeCheck = false;
                    this.resolveParameter(funcDeclAST.parameter, context);
                    context.inTypeCheck = prevInTypeCheck;
                }

                // resolve the return type annotation
                if (funcDeclAST.typeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, ASTHelpers.getType(funcDeclAST), context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }
                else {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckIndexSignature(funcDeclAST, context);
            }

            return funcSymbol;
        }


        private resolveFunctionDeclaration(funcDeclAST: ISyntaxElement, isStatic: boolean, name: ISyntaxToken, typeParameters: TypeParameterListSyntax, parameterList: ParameterListSyntax, returnTypeAnnotation: ISyntaxElement, block: BlockSyntax, context: PullTypeResolutionContext): PullSymbol {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol(this.semanticInfoChain);

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            var isConstructor = funcDeclAST.kind() === SyntaxKind.ConstructSignature;

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckAnyFunctionDeclaration(
                            funcDeclAST, isStatic, name, typeParameters,
                            parameterList, returnTypeAnnotation, block, context);
                    }
                    return funcSymbol;
                }

                if (isConstructor && !signature.inResolution) {
                    var classAST = this.getEnclosingClassDeclaration(funcDeclAST);

                    if (classAST) {
                        var classDecl = this.semanticInfoChain.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol(this.semanticInfoChain);

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }

                // Save this in case we had set the function type to any because of a recursive reference.
                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {

                    // try to set the return type, even though we may be lacking in some information
                    if (returnTypeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                        if (!returnTypeSymbol) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, DiagnosticCode.Cannot_resolve_return_type_reference));
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        }
                        else {
                            signature.returnType = returnTypeSymbol;

                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.Constructors_cannot_have_a_return_type_of_void));
                            }
                        }
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                if (typeParameters) {
                    for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                        this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                    }
                }

                // resolve parameter type annotations as necessary

                if (parameterList) {
                    var prevInTypeCheck = context.inTypeCheck;

                    // TODO: why are we setting inTypeCheck false here?
                    context.inTypeCheck = false;

                    for (var i = 0; i < parameterList.parameters.length; i++) {
                        // TODO: why are are calling resolveParameter directly here?
                        this.resolveParameter(parameterList.parameters[i], context);
                    }

                    context.inTypeCheck = prevInTypeCheck;
                }

                // resolve the return type annotation
                if (returnTypeAnnotation) {
                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }
                // if there's no return-type annotation
                //     - if it's not a definition signature, set the return type to 'any'
                //     - if it's a definition signature, take the best common type of all return expressions
                //     - if it's a constructor, we set the return type link during binding
                else if (funcDecl.kind !== PullElementKind.ConstructSignature) {
                    if (hasFlag(funcDecl.flags, PullElementFlags.Signature)) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                    else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, /*bodyExpression:*/ null, signature, false, funcDecl, context);
                    }
                }
                else {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionDeclaration(
                    funcDeclAST, isStatic, name, typeParameters,
                    parameterList, returnTypeAnnotation, block, context);
            }

            return funcSymbol;
        }

        private resolveGetterReturnTypeAnnotation(
            getterFunctionDeclarationAst: GetAccessorSyntax,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext): PullTypeSymbol {

            if (getterFunctionDeclarationAst && getterFunctionDeclarationAst.typeAnnotation) {
                return this.resolveTypeReference(ASTHelpers.getType(getterFunctionDeclarationAst), context);
            }

            return null;
        }

        private resolveSetterArgumentTypeAnnotation(
            setterFunctionDeclarationAst: SetAccessorSyntax,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext): PullTypeSymbol {

            if (setterFunctionDeclarationAst &&
                setterFunctionDeclarationAst.parameterList &&
                setterFunctionDeclarationAst.parameterList.parameters.length > 0) {

                var parameter = setterFunctionDeclarationAst.parameterList.parameters[0];
                return this.resolveTypeReference(ASTHelpers.getType(parameter), context);
            }

            return null;
        }

        private resolveAccessorDeclaration(funcDeclAst: ISyntaxElement, context: PullTypeResolutionContext): PullSymbol {
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = <PullAccessorSymbol> functionDeclaration.getSymbol(this.semanticInfoChain);

            if (accessorSymbol.inResolution) {
                // TODO: Review, should an error be raised?
                accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                accessorSymbol.setResolved();

                return accessorSymbol;
            }

            if (accessorSymbol.isResolved) {
                if (!accessorSymbol.type) {
                    accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else {
                var getterSymbol = accessorSymbol.getGetter();
                var getterFunctionDeclarationAst = getterSymbol ? <GetAccessorSyntax>getterSymbol.getDeclarations()[0].ast() : null;
                var hasGetter = getterSymbol !== null;

                var setterSymbol = accessorSymbol.getSetter();
                var setterFunctionDeclarationAst = setterSymbol ? <SetAccessorSyntax>setterSymbol.getDeclarations()[0].ast() : null;
                var hasSetter = setterSymbol !== null;

                var getterAnnotatedType = this.resolveGetterReturnTypeAnnotation(
                    getterFunctionDeclarationAst, functionDeclaration, context);
                var getterHasTypeAnnotation = getterAnnotatedType !== null;

                var setterAnnotatedType = this.resolveSetterArgumentTypeAnnotation(
                    setterFunctionDeclarationAst, functionDeclaration, context);
                var setterHasTypeAnnotation = setterAnnotatedType !== null;

                accessorSymbol.startResolving();

                // resolve accessors - resolution order doesn't matter
                if (hasGetter) {
                    getterSymbol =
                    this.resolveGetAccessorDeclaration(
                        getterFunctionDeclarationAst,
                        getterFunctionDeclarationAst.parameterList,
                        ASTHelpers.getType(getterFunctionDeclarationAst),
                        getterFunctionDeclarationAst.block,
                        setterAnnotatedType, context);
                }

                if (hasSetter) {
                    setterSymbol = this.resolveSetAccessorDeclaration(setterFunctionDeclarationAst, setterFunctionDeclarationAst.parameterList, context);
                }

                // enforce spec resolution rules
                if (hasGetter && hasSetter) {
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;
                    var getterSig = getterSymbol.type.getCallSignatures()[0];

                    var setterSuppliedTypeSymbol: PullTypeSymbol = setterHasParameters ? setterParameters[0].type : null;
                    var getterSuppliedTypeSymbol: PullTypeSymbol = getterSig.returnType;

                    // SPEC: October 1, 2013 section 4.5 -
                    //  If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    // -- In this case setter has annotation and getter does not.
                    if (setterHasTypeAnnotation && !getterHasTypeAnnotation) {
                        getterSuppliedTypeSymbol = setterSuppliedTypeSymbol;
                        getterSig.returnType = setterSuppliedTypeSymbol;
                    }
                    // SPEC: October 1, 2013 section 4.5 -
                    //  If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    //  If neither accessor includes a type annotation, the inferred return type of the get accessor becomes the parameter type of the set accessor.
                    // -- In this case getter has annotation and setter does not - or neither do, so use getter.
                    else if ((getterHasTypeAnnotation && !setterHasTypeAnnotation) ||
                        (!getterHasTypeAnnotation && !setterHasTypeAnnotation)) {

                        setterSuppliedTypeSymbol = getterSuppliedTypeSymbol;

                        if (setterHasParameters) {
                            setterParameters[0].type = getterSuppliedTypeSymbol;
                        }
                    }

                    // SPEC: October 1, 2013 section 4.5 -
                    //  If both accessors include type annotations, the specified types must be identical.
                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol, context)) {
                        accessorSymbol.type = this.getNewErrorTypeSymbol();
                    }
                    else {
                        accessorSymbol.type = getterSuppliedTypeSymbol;
                    }
                }
                else if (hasSetter) {
                    // only has setter
                    var setterSig = setterSymbol.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;
                    var setterHasParameters = setterParameters.length > 0;

                    accessorSymbol.type = setterHasParameters ? setterParameters[0].type : this.semanticInfoChain.anyTypeSymbol;
                }
                else {
                    // only has getter 
                    var getterSig = getterSymbol.type.getCallSignatures()[0];
                    accessorSymbol.type = getterSig.returnType;
                }

                accessorSymbol.setResolved();
            }

            // type check if possible
            if (this.canTypeCheckAST(funcDeclAst, context)) {
                this.typeCheckAccessorDeclaration(funcDeclAst, context);
            }

            return accessorSymbol;
        }

        private typeCheckAccessorDeclaration(funcDeclAst: ISyntaxElement, context: PullTypeResolutionContext) {
            this.setTypeChecked(funcDeclAst, context);
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDeclAst);
            var accessorSymbol = <PullAccessorSymbol> functionDeclaration.getSymbol(this.semanticInfoChain);
            var getterSymbol = accessorSymbol.getGetter();
            var setterSymbol = accessorSymbol.getSetter();

            var isGetter = funcDeclAst.kind() === SyntaxKind.GetAccessor;
            if (isGetter) {
                var getterFunctionDeclarationAst = <GetAccessorSyntax>funcDeclAst;
                context.pushNewContextualType(getterSymbol.type);
                this.typeCheckGetAccessorDeclaration(getterFunctionDeclarationAst, context);
                context.popAnyContextualType();
            }
            else {
                var setterFunctionDeclarationAst = <SetAccessorSyntax>funcDeclAst;
                this.typeCheckSetAccessorDeclaration(setterFunctionDeclarationAst, context);
            }
        }

        private resolveGetAccessorDeclaration(funcDeclAST: ISyntaxElement, parameters: ParameterListSyntax, returnTypeAnnotation: ISyntaxElement, block: BlockSyntax, setterAnnotatedType: PullTypeSymbol, context: PullTypeResolutionContext): PullSymbol {
            var funcDecl: PullDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol(this.semanticInfoChain);

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = <PullTypeSymbol>getterSymbol.type;

            var signature: PullSignatureSymbol = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    return getterSymbol;
                }

                if (signature.inResolution) {
                    // PULLTODO: Error or warning?
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    return getterSymbol;
                }

                signature.startResolving();

                // resolve the return type annotation
                if (returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, returnTypeAnnotation, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();

                        hadError = true;
                    }
                    else {
                        signature.returnType = returnTypeSymbol;
                    }
                }

                // if there's no return-type annotation
                //     - if it's a definition signature, set the return type to 'any'
                //     - if it's not a definition sigature, take the best common type of all return expressions
                else {
                    // SPEC: October 1, 2013 section 4.5 -
                    //  If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    // -- Use setterAnnotatedType if available
                    //  If neither accessor includes a type annotation, the inferred return type of the get accessor becomes the parameter type of the set accessor.
                    if (!setterAnnotatedType) {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, /*bodyExpression:*/ null, signature, false, funcDecl, context);
                    }
                    else {
                        signature.returnType = setterAnnotatedType;
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            return getterSymbol;
        }

        private checkIfGetterAndSetterTypeMatch(funcDeclAST: ISyntaxElement, context: PullTypeResolutionContext) {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol(this.semanticInfoChain);
            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            if (getter && setter) {
                var getterAST = <GetAccessorSyntax>getter.getDeclarations()[0].ast();
                var setterAST = <SetAccessorSyntax>setter.getDeclarations()[0].ast();

                // There exists: 
                //     return type annotaion for the getter &&
                //     parameter type annotation for the setter
                if (getterAST.typeAnnotation && PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterAST)) {
                    var setterSig = setter.type.getCallSignatures()[0];
                    var setterParameters = setterSig.parameters;

                    var getter = accessorSymbol.getGetter();
                    var getterSig = getter.type.getCallSignatures()[0];

                    var setterSuppliedTypeSymbol: PullTypeSymbol = setterParameters[0].type;
                    var getterSuppliedTypeSymbol: PullTypeSymbol = getterSig.returnType;
                    // Report errors if type do not match
                    if (!this.typesAreIdentical(setterSuppliedTypeSymbol, getterSuppliedTypeSymbol, context)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST, DiagnosticCode.get_and_set_accessor_must_have_the_same_type));
                    }
                }
            }
        }

        private typeCheckGetAccessorDeclaration(funcDeclAST: GetAccessorSyntax, context: PullTypeResolutionContext) {
            // Accessors are handled only by resolve/typeCheckAccessorDeclaration, 
            // hence the resolve/typeCheckGetAccessorDeclaration is helper and need not set setTypeChecked flag
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol(this.semanticInfoChain);

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, ASTHelpers.getType(funcDeclAST), context);

            this.resolveAST(funcDeclAST.block, /*isContextuallyTyped*/ false, context);

            this.validateVariableDeclarationGroups(funcDecl, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            var hasReturn = (funcDecl.flags & (PullElementFlags.Signature | PullElementFlags.HasReturnStatement)) !== 0;
            var funcNameAST = funcDeclAST.propertyName;

            // If there is no return statement report error: 
            //      signature is doesnt have the return statement flag &&
            //      accessor body has atleast one statement and it isnt throw statement
            if (!hasReturn &&
                !this.containsSingleThrowStatement(funcDeclAST.block)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, DiagnosticCode.Getters_must_return_a_value));
            }

            // Setter with return value is checked in typeCheckReturnExpression

            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                var setterIsPrivate = hasFlag(setterDecl.flags, PullElementFlags.Private);
                var getterIsPrivate = hasModifier(funcDeclAST.modifiers, PullElementFlags.Private);

                if (getterIsPrivate !== setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }

                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            }

            this.checkFunctionTypePrivacy(
                funcDeclAST, hasModifier(funcDeclAST.modifiers, PullElementFlags.Static), /*typeParameters:*/null,
                ASTHelpers.parametersFromParameterList(funcDeclAST.parameterList), ASTHelpers.getType(funcDeclAST), funcDeclAST.block, context);
        }

        static hasSetAccessorParameterTypeAnnotation(setAccessor: SetAccessorSyntax) {
            return setAccessor.parameterList && setAccessor.parameterList.parameters.length > 0 && setAccessor.parameterList.parameters[0].typeAnnotation !== null;
        }

        private resolveSetAccessorDeclaration(funcDeclAST: ISyntaxElement, parameterList: ParameterListSyntax, context: PullTypeResolutionContext): PullSymbol {
            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol(this.semanticInfoChain);

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = <PullTypeSymbol>setterSymbol.type;

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol(this.semanticInfoChain);

            var hadError = false;

            if (signature) {

                if (signature.isResolved) {
                    return setterSymbol;
                    }

                if (signature.inResolution) {
                    // PULLTODO: Error or warning?
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                    signature.setResolved();
                    return setterSymbol;
                    }

                signature.startResolving();

                // resolve parameter type annotations as necessary
                if (parameterList) {
                    for (var i = 0; i < parameterList.parameters.length; i++) {
                        this.resolveParameter(parameterList.parameters[i], context);
                    }
                }

                // SPEC: October 1, 2013 section 4.5 -
                //  A set accessor declaration is processed in the same manner as an ordinary function declaration
                //      with a single parameter and a Void return type. 
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;

                if (!hadError) {
                    signature.setResolved();
                }
            }

            return setterSymbol;
        }

        private typeCheckSetAccessorDeclaration(funcDeclAST: SetAccessorSyntax, context: PullTypeResolutionContext) {
            // Accessors are handled only by resolve/typeCheckAccessorDeclaration, 
            // hence the resolve/typeCheckSetAccessorDeclaration is helper and need not set setTypeChecked flag

            var funcDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol(this.semanticInfoChain);

            if (funcDeclAST.parameterList) {
                for (var i = 0; i < funcDeclAST.parameterList.parameters.length; i++) {
                    this.resolveParameter(funcDeclAST.parameterList.parameters[i], context);
                }
            }

            this.resolveAST(funcDeclAST.block, false, context);

            this.validateVariableDeclarationGroups(funcDecl, context);

            var hasReturn = (funcDecl.flags & (PullElementFlags.Signature | PullElementFlags.HasReturnStatement)) !== 0;

            var getter = accessorSymbol.getGetter();

            var funcNameAST = funcDeclAST.propertyName;

            // Setter with return value is checked in typeCheckReturnExpression

            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                var getterIsPrivate = hasFlag(getterDecl.flags, PullElementFlags.Private);
                var setterIsPrivate = hasModifier(funcDeclAST.modifiers, PullElementFlags.Private);

                if (getterIsPrivate !== setterIsPrivate) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcNameAST, DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility));
                }

                this.checkIfGetterAndSetterTypeMatch(funcDeclAST, context);
            }
            else {
                // There is no getter specified
                // Only report noImplicitAny error message on setter if there is no getter
                // if the noImplicitAny flag is set to be true, report an error
                if (this.compilationSettings.noImplicitAny()) {
                    // if setter has an any type, it must be implicit any
                    var setterFunctionDeclarationAst = <SetAccessorSyntax>funcDeclAST;

                    if (!PullTypeResolver.hasSetAccessorParameterTypeAnnotation(setterFunctionDeclarationAst) && accessorSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                            DiagnosticCode._0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type, [setterFunctionDeclarationAst.propertyName.text()]));
                    }
                }
            }

            this.checkFunctionTypePrivacy(
                funcDeclAST, hasModifier(funcDeclAST.modifiers, PullElementFlags.Static), null,
                ASTHelpers.parametersFromParameterList(funcDeclAST.parameterList), null, funcDeclAST.block, context);
        }

        private resolveList(list: ISyntaxNodeOrToken[], context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);

                // Visit members   
                for (var i = 0, n = list.length; i < n; i++) {
                    this.resolveAST(list[i], /*isContextuallyTyped*/ false, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveSeparatedList(list: ISyntaxNodeOrToken[], context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);

                // Visit members   
                for (var i = 0, n = list.length; i < n; i++) {
                    this.resolveAST(list[i], /*isContextuallyTyped*/ false, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveVoidExpression(ast: VoidExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, /*isContextuallyTyped:*/ false, context);
            }

            // September 17, 2013: The void operator takes an operand of any type and produces the 
            // value undefined.The type of the result is the Undefined type(3.2.6).
            return this.semanticInfoChain.undefinedTypeSymbol;
        }

        private resolveLogicalOperation(ast: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLogicalOperation(ast, context);
            }

            // September 17, 2013: The result is always of the Boolean primitive type.
            return this.semanticInfoChain.booleanTypeSymbol;
        }

        private typeCheckLogicalOperation(binex: BinaryExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(binex, context);

            var leftType = this.resolveAST(binex.left, /*isContextuallyTyped:*/ false, context).type;
            var rightType = this.resolveAST(binex.right, /*isContextuallyTyped:*/ false, context).type;

            // September 17, 2013: 
            // The <, >, <=, >=, ==, !=, ===, and !== operators
            // These operators require one operand type to be identical to or a subtype of the 
            // other operand type. 
            var comparisonInfo = new TypeComparisonInfo();
            if (!this.sourceIsAssignableToTarget(leftType, rightType, binex, context, comparisonInfo) &&
                !this.sourceIsAssignableToTarget(rightType, leftType, binex, context, comparisonInfo)) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(binex);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binex,
                    DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
                    [SyntaxFacts.getText(SyntaxFacts.getOperatorTokenFromBinaryExpression(binex.kind())),
                        leftType.toString(enclosingSymbol), rightType.toString(enclosingSymbol)]));
            }
        }

        private resolveLogicalNotExpression(ast: PrefixUnaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.operand, false, context);
            }

            // September 17, 2013: The ! operator permits its operand to be of any type and 
            // produces a result of the Boolean primitive type.
            return this.semanticInfoChain.booleanTypeSymbol;
        }

        private resolveUnaryArithmeticOperation(ast: PrefixUnaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckUnaryArithmeticOperation(ast, context);
            }

            // September 17, 2013:
            // The ++ and-- operators ... produce a result of the Number primitive type.
            // The +, , and ~ operators ... produce a result of the Number primitive type.
            return this.semanticInfoChain.numberTypeSymbol;
        }

        private resolvePostfixUnaryExpression(ast: PostfixUnaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckPostfixUnaryExpression(ast, context);
            }

            // September 17, 2013:
            // The ++ and-- operators ... produce a result of the Number primitive type.
            // The +, , and ~ operators ... produce a result of the Number primitive type.
            return this.semanticInfoChain.numberTypeSymbol;
        }

        private isAnyOrNumberOrEnum(type: PullTypeSymbol): boolean {
            return this.isAnyOrEquivalent(type) || type === this.semanticInfoChain.numberTypeSymbol || PullHelpers.symbolIsEnum(type);
        }

        private typeCheckUnaryArithmeticOperation(unaryExpression: PrefixUnaryExpressionSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(unaryExpression, context);

            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, /*isContextuallyTyped:*/ false, context);

            // September 17, 2013: The +, , and ~ operators
            // These operators permit their operand to be of any type and produce a result of the 
            // Number primitive type.
            if (nodeType === SyntaxKind.PlusExpression || nodeType == SyntaxKind.NegateExpression || nodeType == SyntaxKind.BitwiseNotExpression) {
                return;
            }

            Debug.assert(
                nodeType === SyntaxKind.PreIncrementExpression ||
                nodeType === SyntaxKind.PreDecrementExpression);

            // September 17, 2013: 4.14.1       The ++ and -- operators
            // These operators, in prefix or postfix form, require their operand to be of type Any,
            // the Number primitive type, or an enum type, and classified as a reference(section 4.1).
            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type));
            }

            // September 17, ... and classified as a reference(section 4.1).
            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        }

        private typeCheckPostfixUnaryExpression(unaryExpression: PostfixUnaryExpressionSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(unaryExpression, context);

            var nodeType = unaryExpression.kind();
            var expression = this.resolveAST(unaryExpression.operand, /*isContextuallyTyped:*/ false, context);

            Debug.assert(
                nodeType === SyntaxKind.PostIncrementExpression ||
                nodeType === SyntaxKind.PostDecrementExpression);

            // September 17, 2013: 4.14.1       The ++ and -- operators
            // These operators, in prefix or postfix form, require their operand to be of type Any,
            // the Number primitive type, or an enum type, and classified as a reference(section 4.1).
            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type));
            }

            // September 17, ... and classified as a reference(section 4.1).
            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(unaryExpression.operand, DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer));
            }
        }

        private resolveBinaryArithmeticExpression(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.typeCheckBinaryArithmeticExpression(binaryExpression, context);
            }

            // September 17, 2013: The result is always of the Number primitive type.
            return this.semanticInfoChain.numberTypeSymbol;
        }

        private typeCheckBinaryArithmeticExpression(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(binaryExpression, context);

            var lhsSymbol = this.resolveAST(binaryExpression.left, /*isContextuallyTyped:*/ false, context);

            var lhsType = lhsSymbol.type;
            var rhsType = this.resolveAST(binaryExpression.right, /*isContextuallyTyped:*/false, context).type;

            // September 17, 2013:
            // If one operand is the null or undefined value, it is treated as having the 
            // type of the other operand.
            if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                lhsType = rhsType;
            }

            if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                rhsType = lhsType;
            }

            // September 17, 2013:
            // 4.15.1   The *, /, %, , <<, >>, >>>, &, ^, and | operators
            // These operators require their operands to be of type Any, the Number primitive type,
            // or an enum type
            var lhsIsFit = this.isAnyOrNumberOrEnum(lhsType);
            var rhsIsFit = this.isAnyOrNumberOrEnum(rhsType);

            if (!rhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }

            if (!lhsIsFit) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type));
            }

            if (lhsIsFit && rhsIsFit) {
                switch (binaryExpression.kind()) {
                    case SyntaxKind.LeftShiftAssignmentExpression:
                    case SyntaxKind.SignedRightShiftAssignmentExpression:
                    case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    case SyntaxKind.SubtractAssignmentExpression:
                    case SyntaxKind.MultiplyAssignmentExpression:
                    case SyntaxKind.DivideAssignmentExpression:
                    case SyntaxKind.ModuloAssignmentExpression:
                    case SyntaxKind.OrAssignmentExpression:
                    case SyntaxKind.AndAssignmentExpression:
                    case SyntaxKind.ExclusiveOrAssignmentExpression:
                        // Check if LHS is a valid target
                        if (!this.isReference(binaryExpression.left, lhsSymbol)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }

                        this.checkAssignability(binaryExpression.left, rhsType, lhsType, context);
                }
            }
        }

        private resolveTypeOfExpression(ast: TypeOfExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, /*isContextuallyTyped*/ false, context);
            }

            // September 17, 2013: The typeof operator takes an operand of any type and produces 
            // a value of the String primitive type
            return this.semanticInfoChain.stringTypeSymbol;
        }

        private resolveThrowStatement(ast: ThrowStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, /*isContextuallyTyped:*/ false, context);
            }

            // All statements have the 'void' type.
            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveDeleteExpression(ast: DeleteExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.expression, false, context);
            }

            // September 17, 2013: The delete operator takes an operand of any type and produces a
            // result of the Boolean primitive type.
            return this.semanticInfoChain.booleanTypeSymbol;
        }

        private resolveInstanceOfExpression(ast: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInstanceOfExpression(ast, context);
            }

            // September 17, 2013: The result is always of the Boolean primitive type.
            return this.semanticInfoChain.booleanTypeSymbol;
        }

        private typeCheckInstanceOfExpression(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(binaryExpression, context);

            // Section 4.15.4:
            // September 17, 2013: The instanceof operator requires the left operand to be of type 
            // Any, an object type, or a type parameter type, and the right operand to be of type 
            // Any or a subtype of the Function interface type. 
            // We are using assignability instead of subtype here, which will be reflected in the
            // new spec.
            var lhsType = this.resolveAST(binaryExpression.left, false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, false, context).type;

            var enclosingSymbol = this.getEnclosingSymbolForAST(binaryExpression);
            var isValidLHS = this.isAnyOrEquivalent(lhsType) || lhsType.isObject() || lhsType.isTypeParameter();
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || this.typeIsAssignableToFunction(rhsType, binaryExpression, context);

            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, DiagnosticCode.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type));
            }
        }

        private resolveCommaExpression(commaExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(commaExpression, context)) {
                this.setTypeChecked(commaExpression, context);

                this.resolveAST(commaExpression.left, /*isContextuallyTyped:*/ false, context);
            }

            // September 17, 2013: The comma operator permits the operands to be of any type and
            // produces a result that is of the same type as the second operand.
            return this.resolveAST(commaExpression.right, /*isContextuallyTyped:*/ false, context).type;
        }

        private resolveInExpression(ast: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInExpression(ast, context);
            }

            // October 11, 2013: 
            // The in operator requires the left operand to be of type Any, the String primitive 
            // type, or the Number primitive type, and the right operand to be of type Any, an 
            // object type, or a type parameter type. 
            //
            // The result is always of the Boolean primitive type.
            return this.semanticInfoChain.booleanTypeSymbol;
        }

        private typeCheckInExpression(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(binaryExpression, context);
            
            // October 11, 2013: 
            // The in operator requires the left operand to be of type Any, the String primitive 
            // type, or the Number primitive type, and the right operand to be of type Any, an 
            // object type, or a type parameter type. 
            var lhsType = this.resolveAST(binaryExpression.left, /*isContextuallyTyped:*/ false, context).type;
            var rhsType = this.resolveAST(binaryExpression.right, /*isContextuallyTyped:*/ false, context).type;

            var isValidLHS =
                this.isAnyOrEquivalent(lhsType.type) ||
                lhsType.type === this.semanticInfoChain.stringTypeSymbol ||
                lhsType.type === this.semanticInfoChain.numberTypeSymbol;

            var isValidRHS = this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter();

            if (!isValidLHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number));
            }

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.right, DiagnosticCode.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }
        }

        private resolveForStatement(ast: ForStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.variableDeclaration, /*isContextuallyTyped:*/ false, context);
                this.resolveAST(ast.initializer, /*isContextuallyTyped:*/ false, context);
                this.resolveAST(ast.condition, /*isContextuallyTyped:*/ false, context);
                this.resolveAST(ast.incrementor, /*isContextuallyTyped:*/ false, context);
                this.resolveAST(ast.statement, /*isContextuallyTyped:*/ false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveForInStatement(forInStatement: ForInStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(forInStatement, context)) {
                this.typeCheckForInStatement(forInStatement, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckForInStatement(forInStatement: ForInStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(forInStatement, context);

            if (forInStatement.variableDeclaration) {
                var declaration = forInStatement.variableDeclaration;

                // The parser will already have reported an error if 0 or more than 1 variable
                // declarators are provided.
                if (declaration.variableDeclarators.length === 1) {
                    var varDecl = declaration.variableDeclarators[0];

                    if (varDecl.typeAnnotation) {
                        // November 18, 2013
                        // VarDecl must be a variable declaration without a type annotation.
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declaration, DiagnosticCode.Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation));
                    }
                }
            }
            else {
                // November 18, 2013
                // In a for-in statement of the form
                // for (Var in Expr) Statement
                // Var must be an expression classified as a reference of type Any or the String primitive type

                var varSym = this.resolveAST(forInStatement.left, /*isContextuallyTyped*/ false, context);
                var isStringOrNumber = varSym.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(varSym.type);

                if (!isStringOrNumber) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(forInStatement.left, DiagnosticCode.Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any));
                }
            }

            // November 18, 2013
            // In a for-in statement of the form
            // for (Var in Expr) Statement [or of the form]
            // for (var VarDecl in Expr) Statement
            // ... Expr must be an expression of type Any, an object type, or a type parameter type.
            var rhsType = this.resolveAST(forInStatement.expression, /*isContextuallyTyped*/ false, context).type;
            var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter());

            if (!isValidRHS) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(forInStatement.expression, DiagnosticCode.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter));
            }

            this.resolveAST(forInStatement.statement, false, context);
        }

        private resolveWhileStatement(ast: WhileStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWhileStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckWhileStatement(ast: WhileStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, /*isContextuallyTyped:*/ false, context);
            this.resolveAST(ast.statement, /*isContextuallyTyped:*/ false, context);
        }

        private resolveDoStatement(ast: DoStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckDoStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckDoStatement(ast: DoStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, /*isContextuallyTyped:*/ false, context);
            this.resolveAST(ast.statement, /*isContextuallyTyped:*/ false, context);
        }

        private resolveIfStatement(ast: IfStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckIfStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckIfStatement(ast: IfStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.condition, /*isContextuallyTyped:*/ false, context);
            this.resolveAST(ast.statement, /*isContextuallyTyped:*/ false, context);
            this.resolveAST(ast.elseClause, /*isContextuallyTyped:*/ false, context);
        }

        private resolveElseClause(ast: ElseClauseSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckElseClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckElseClause(ast: ElseClauseSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.statement, false, context);
        }

        private resolveBlock(ast: BlockSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.statements, /*isContextuallyTyped*/ false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveVariableStatement(ast: VariableStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.variableDeclaration, /*isContextuallyTyped*/ false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveVariableDeclarationList(ast: VariableDeclarationSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.variableDeclarators, false, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private resolveWithStatement(ast: WithStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWithStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckWithStatement(ast: WithStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);
            var withStatement = <WithStatementSyntax>ast;
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(withStatement.condition, DiagnosticCode.All_symbols_within_a_with_block_will_be_resolved_to_any));
        }

        private resolveTryStatement(ast: ISyntaxElement, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckTryStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckTryStatement(ast: ISyntaxElement, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);
            var tryStatement = <TryStatementSyntax>ast;

            this.resolveAST(tryStatement.block, false, context);
            this.resolveAST(tryStatement.catchClause, false, context);
            this.resolveAST(tryStatement.finallyClause, false, context);
        }

        private resolveCatchClause(ast: CatchClauseSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckCatchClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckCatchClause(ast: CatchClauseSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, /*isContextuallyTyped*/ false, context);

            var catchDecl = this.semanticInfoChain.getDeclForAST(ast);
            this.validateVariableDeclarationGroups(catchDecl, context);
        }

        private resolveFinallyClause(ast: FinallyClauseSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckFinallyClause(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckFinallyClause(ast: FinallyClauseSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.block, /*isContextuallyTyped*/ false, context);
        }

        private getEnclosingFunctionDeclaration(ast: ISyntaxElement): PullDecl {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);

            while (enclosingDecl) {
                if (enclosingDecl.kind & PullElementKind.SomeFunction) {
                    return enclosingDecl;
                }

                enclosingDecl = enclosingDecl.getParentDecl();
            }

            return null;
        }

        private resolveReturnExpression(expression: ISyntaxElement, enclosingFunction: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            if (enclosingFunction) {
                enclosingFunction.setFlag(PullElementFlags.HasReturnStatement);
            }

            // push contextual type
            var isContextuallyTyped = false;

            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = ASTHelpers.getType(enclosingDeclAST);
                if (typeAnnotation) {
                    // The containing function has a type annotation, propagate it as the contextual type
                    var returnTypeAnnotationSymbol = this.resolveTypeReference(typeAnnotation, context);
                    if (returnTypeAnnotationSymbol) {
                        isContextuallyTyped = true;
                        context.pushNewContextualType(returnTypeAnnotationSymbol);
                    }
                }
                else {
                    // No type annotation, check if there is a contextual type enforced on the function, and propagate that
                    var currentContextualType = context.getContextualType();
                    if (currentContextualType && currentContextualType.isFunction()) {
                        var contextualSignatures = currentContextualType.kind == PullElementKind.ConstructorType
                            ? currentContextualType.getConstructSignatures()
                            : currentContextualType.getCallSignatures();
                        var currentContextualTypeSignatureSymbol = contextualSignatures[0];

                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                        if (currentContextualTypeReturnTypeSymbol) {
                            isContextuallyTyped = true;
                            context.propagateContextualType(currentContextualTypeReturnTypeSymbol);
                        }
                    }
                }
            }

            var result = this.resolveAST(expression, isContextuallyTyped, context).type;
            if (isContextuallyTyped) {
                context.popAnyContextualType();
            }

            return result;
        }

        private typeCheckReturnExpression(expression: ISyntaxElement, expressionType: PullTypeSymbol, enclosingFunction: PullDecl, context: PullTypeResolutionContext): void {
            // Return type of constructor signature must be assignable to the instance type of the class.
            if (enclosingFunction && enclosingFunction.kind === PullElementKind.ConstructorMethod) {
                var classDecl = enclosingFunction.getParentDecl();
                if (classDecl) {
                    var classSymbol = classDecl.getSymbol(this.semanticInfoChain);
                    this.resolveDeclaredSymbol(classSymbol, context);

                    var comparisonInfo = new TypeComparisonInfo();
                    var isAssignable = this.sourceIsAssignableToTarget(expressionType, classSymbol.type, expression, context, comparisonInfo);
                    if (!isAssignable) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, DiagnosticCode.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class));
                    }
                }
            }

            if (enclosingFunction && enclosingFunction.kind === PullElementKind.SetAccessor) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, DiagnosticCode.Setters_cannot_return_a_value));
            }

            if (enclosingFunction) {
                var enclosingDeclAST = this.getASTForDecl(enclosingFunction);
                var typeAnnotation = ASTHelpers.getType(enclosingDeclAST);
                if (typeAnnotation || enclosingFunction.kind === PullElementKind.GetAccessor) {
                    var signatureSymbol = enclosingFunction.getSignatureSymbol(this.semanticInfoChain);
                    var sigReturnType = signatureSymbol.returnType;

                    if (expressionType && sigReturnType) {
                        var comparisonInfo = new TypeComparisonInfo();
                        var upperBound: PullTypeSymbol = null;

                        this.resolveDeclaredSymbol(expressionType, context);
                        this.resolveDeclaredSymbol(sigReturnType, context);

                        var isAssignable = this.sourceIsAssignableToTarget(expressionType, sigReturnType, expression, context, comparisonInfo);

                        if (!isAssignable) {
                            var enclosingSymbol = this.getEnclosingSymbolForAST(expression);
                            if (comparisonInfo.message) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, DiagnosticCode.Cannot_convert_0_to_1_NL_2, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol), comparisonInfo.message]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(expression, DiagnosticCode.Cannot_convert_0_to_1, [expressionType.toString(enclosingSymbol), sigReturnType.toString(enclosingSymbol)]));
                            }
                        }
                    }
                }
            }
        }

        private resolveReturnStatement(returnAST: ReturnStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            var enclosingFunction = this.getEnclosingFunctionDeclaration(returnAST);
            if (enclosingFunction) {
                enclosingFunction.setFlag(PullElementFlags.HasReturnStatement);
            }

            var returnType = <PullTypeSymbol>this.getSymbolForAST(returnAST, context);
            var canTypeCheckAST = this.canTypeCheckAST(returnAST, context);
            if (!returnType || canTypeCheckAST) {
                var returnExpr = returnAST.expression;

                var resolvedReturnType = returnExpr === null
                    ? this.semanticInfoChain.voidTypeSymbol
                    : this.resolveReturnExpression(returnExpr, enclosingFunction, context);

                if (!returnType) {
                    returnType = resolvedReturnType;
                    this.setSymbolForAST(returnAST, resolvedReturnType, context);
                }

                if (returnExpr && canTypeCheckAST) {
                    this.setTypeChecked(returnExpr, context);
                    this.typeCheckReturnExpression(returnExpr, resolvedReturnType, enclosingFunction, context);
                }
            }

            return returnType;
        }

        private resolveSwitchStatement(ast: SwitchStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSwitchStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckSwitchStatement(ast: SwitchStatementSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(ast, context);

            var expressionType = this.resolveAST(ast.expression, false, context).type;

            for (var i = 0, n = ast.switchClauses.length; i < n; i++) {
                var switchClause = ast.switchClauses[i];
                if (switchClause.kind() === SyntaxKind.CaseSwitchClause) {
                    var caseSwitchClause = <CaseSwitchClauseSyntax>switchClause;

                    var caseClauseExpressionType = this.resolveAST(caseSwitchClause.expression, /*isContextuallyTyped:*/ false, context).type;
                    this.resolveAST(caseSwitchClause.statements, /*isContextuallyTyped:*/ false, context);

                    var comparisonInfo = new TypeComparisonInfo();
                    if (!this.sourceIsAssignableToTarget(expressionType, caseClauseExpressionType, caseSwitchClause.expression, context, comparisonInfo) &&
                        !this.sourceIsAssignableToTarget(caseClauseExpressionType, expressionType, caseSwitchClause.expression, context, comparisonInfo)) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(caseSwitchClause.expression);
                        if (comparisonInfo.message) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression,
                                DiagnosticCode.Cannot_convert_0_to_1_NL_2, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol), comparisonInfo.message]));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(caseSwitchClause.expression,
                                DiagnosticCode.Cannot_convert_0_to_1, [caseClauseExpressionType.toString(enclosingSymbol), expressionType.toString(enclosingSymbol)]));
                        }
                    }
                }
                else {
                    var defaultSwitchClause = <DefaultSwitchClauseSyntax>switchClause;
                    this.resolveAST(defaultSwitchClause.statements, /*isContextuallyTyped:*/ false, context);
                }
            }
        }

        private resolveLabeledStatement(ast: LabeledStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLabeledStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckLabeledStatement(ast: LabeledStatementSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(ast, context);

            // Note that break/continue are treated differently.  ES5 says this about a break statement:
            // A program is considered syntactically incorrect if ...:
            //
            // The program contains a break statement with the optional Identifier, where Identifier 
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **Statement.**
            // 
            // However, it says this about continue statements:
            //
            // The program contains a continue statement with the optional Identifier, where Identifier
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **IterationStatement.**

            // In other words, you can 'break' to any enclosing statement.  But you can only 'continue'
            // to an enclosing *iteration* statement.
            var labelIdentifier = tokenValueText(ast.identifier);

            var breakableLabels = this.getEnclosingLabels(ast, /*breakable:*/ true, /*crossFunctions:*/ false);

            // It is invalid to have a label enclosed in a label of the same name.
            var matchingLabel = ArrayUtilities.firstOrDefault(breakableLabels, s => tokenValueText(s.identifier) === labelIdentifier);
            if (matchingLabel) {
                context.postDiagnostic(this.semanticInfoChain.duplicateIdentifierDiagnosticFromAST(
                    ast.identifier, labelIdentifier, matchingLabel));
            }

            this.resolveAST(ast.statement, /*isContextuallyTyped*/ false, context);
        }

        private labelIsOnContinuableConstruct(statement: ISyntaxElement): boolean {
            switch (statement.kind()) {
                case SyntaxKind.LabeledStatement:
                    // Labels work transitively.  i.e. if you have:
                    //      foo:
                    //      bar:
                    //      while(...)
                    //
                    // Then both 'foo' and 'bar' are in the label set for 'while' and are thus
                    // continuable.
                    return this.labelIsOnContinuableConstruct((<LabeledStatementSyntax>statement).statement);

                case SyntaxKind.WhileStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.DoStatement:
                    return true;

                default:
                    return false;
            }
        }

        private resolveContinueStatement(ast: ContinueStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckContinueStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private isIterationStatement(ast: ISyntaxElement): boolean {
            switch (ast.kind()) {
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.DoStatement:
                    return true;
            }

            return false;
        }

        private isAnyFunctionExpressionOrDeclaration(ast: ISyntaxElement): boolean {
            switch (ast.kind()) {
                case SyntaxKind.SimpleArrowFunctionExpression:
                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MemberFunctionDeclaration:
                case SyntaxKind.FunctionPropertyAssignment:
                case SyntaxKind.ConstructorDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    return true;
            }

            return false;
        }

        private inSwitchStatement(ast: ISyntaxElement): boolean {
            while (ast) {
                if (ast.kind() === SyntaxKind.SwitchStatement) {
                    return true;
                }

                if (this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }

                ast = ast.parent;
            }

            return false;
        }

        private inIterationStatement(ast: ISyntaxElement, crossFunctions: boolean): boolean {
            while (ast) {
                if (this.isIterationStatement(ast)) {
                    return true;
                }

                if (!crossFunctions && this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }

                ast = ast.parent;
            }

            return false;
        }

        private getEnclosingLabels(ast: ISyntaxElement, breakable: boolean, crossFunctions: boolean): LabeledStatementSyntax[] {
            var result: LabeledStatementSyntax[] = [];

            ast = ast.parent;
            while (ast) {
                if (ast.kind() === SyntaxKind.LabeledStatement) {
                    var labeledStatement = <LabeledStatementSyntax>ast;
                    if (breakable) {
                        // Breakable labels can be placed on any construct
                        result.push(labeledStatement);
                    }
                    else {
                        // They're asking for continuable labels.  Continuable labels must be on
                        // a loop construct.
                        if (this.labelIsOnContinuableConstruct(labeledStatement.statement)) {
                            result.push(labeledStatement);
                        }
                    }
                }

                if (!crossFunctions && this.isAnyFunctionExpressionOrDeclaration(ast)) {
                    break;
                }

                ast = ast.parent;
            }

            return result;
        }

        private typeCheckContinueStatement(ast: ContinueStatementSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(ast, context);

            if (!this.inIterationStatement(ast, /*crossFunctions:*/ false)) {
                if (this.inIterationStatement(ast, /*crossFunctions:*/ true)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                        DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                        DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement));
                }
            }
            else if (ast.identifier) {
                var continuableLabels = this.getEnclosingLabels(ast, /*breakable:*/ false, /*crossFunctions:*/ false);

                if (!ArrayUtilities.any(continuableLabels, s => tokenValueText(s.identifier) === tokenValueText(ast.identifier))) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var continuableLabels = this.getEnclosingLabels(ast, /*breakable:*/ false, /*crossFunctions:*/ true);

                    if (ArrayUtilities.any(continuableLabels, s => tokenValueText(s.identifier) === tokenValueText(ast.identifier))) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                            DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                            DiagnosticCode.Jump_target_not_found));
                    }
                }
            }
        }

        private resolveBreakStatement(ast: BreakStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckBreakStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        }

        private typeCheckBreakStatement(ast: BreakStatementSyntax, context: PullTypeResolutionContext): void {
            this.setTypeChecked(ast, context);

            // Note: the order here is important.  If the 'break' has a target, then it can jump to
            // any enclosing laballed statment.  If it has no target, it must be in an iteration or
            // swtich statement.
            if (ast.identifier) {
                var breakableLabels = this.getEnclosingLabels(ast, /*breakable:*/ true, /*crossFunctions:*/ false);

                if (!ArrayUtilities.any(breakableLabels, s => tokenValueText(s.identifier) === tokenValueText(ast.identifier))) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var breakableLabels = this.getEnclosingLabels(ast, /*breakable:*/ true, /*crossFunctions:*/ true);
                    if (ArrayUtilities.any(breakableLabels, s => tokenValueText(s.identifier) === tokenValueText(ast.identifier))) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                            DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                            DiagnosticCode.Jump_target_not_found));
                    }
                }
            }
            else if (!this.inIterationStatement(ast, /*crossFunctions:*/ false) && !this.inSwitchStatement(ast)) {
                if (this.inIterationStatement(ast, /*crossFunctions:*/ true)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                        DiagnosticCode.Jump_target_cannot_cross_function_boundary));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast,
                        DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement));
                }
            }
        }

        // Expression resolution

        public resolveAST(ast: ISyntaxElement, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            if (!ast) {
                return null;
            }

            if (isShared(ast)) {
                return null;
            }

            var symbol = this.getSymbolForAST(ast, context);
            if (symbol && symbol.isResolved) {
                this.typeCheckAST(ast, isContextuallyTyped, context);
                return symbol;
            }

            // We also have to check isTypesOnlyLocation because an identifier representing a type reference
            // is considered an expression at the AST level, yet we only want to resolve it as an expression
            // if it is in an expression position.
            if (isNode(ast) || isToken(ast)) {
                if (SyntaxUtilities.isExpression(ast) && !isTypesOnlyLocation(ast)) {
                    return this.resolveExpressionAST(ast, isContextuallyTyped, context);
                }
            }

            var nodeType = ast.kind();

            switch (nodeType) {
                case SyntaxKind.ArrayType:
                case SyntaxKind.GenericType:
                case SyntaxKind.ObjectType:
                case SyntaxKind.TypeQuery:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.FunctionType:
                    return this.resolveTypeReference(ast, context);

                case SyntaxKind.List:
                    return this.resolveList(<ISyntaxNodeOrToken[]>ast, context);

                case SyntaxKind.SeparatedList:
                    return this.resolveSeparatedList(<ISyntaxNodeOrToken[]>ast, context);

                case SyntaxKind.SourceUnit:
                    return this.resolveSourceUnit(<SourceUnitSyntax>ast, context);

                case SyntaxKind.EnumDeclaration:
                    return this.resolveEnumDeclaration(<EnumDeclarationSyntax>ast, context);

                case SyntaxKind.ModuleDeclaration:
                    return this.resolveModuleDeclaration(<ModuleDeclarationSyntax>ast, context);

                case SyntaxKind.InterfaceDeclaration:
                    return this.resolveInterfaceDeclaration(<InterfaceDeclarationSyntax>ast, context);

                case SyntaxKind.ClassDeclaration:
                    return this.resolveClassDeclaration(<ClassDeclarationSyntax>ast, context);

                case SyntaxKind.VariableDeclaration:
                    return this.resolveVariableDeclarationList(<VariableDeclarationSyntax>ast, context);

                case SyntaxKind.MemberVariableDeclaration:
                    return this.resolveMemberVariableDeclaration(<MemberVariableDeclarationSyntax>ast, context);

                case SyntaxKind.VariableDeclarator:
                    return this.resolveVariableDeclarator(<VariableDeclaratorSyntax>ast, context);

                case SyntaxKind.PropertySignature:
                    return this.resolvePropertySignature(<PropertySignatureSyntax>ast, context);

                case SyntaxKind.ParameterList:
                    return this.resolveParameterList(<ParameterListSyntax>ast, context);

                case SyntaxKind.Parameter:
                    return this.resolveParameter(<ParameterSyntax>ast, context);

                case SyntaxKind.EnumElement:
                    return this.resolveEnumElement(<EnumElementSyntax>ast, context);

                case SyntaxKind.EqualsValueClause:
                    return this.resolveEqualsValueClause(<EqualsValueClauseSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.TypeParameter:
                    return this.resolveTypeParameterDeclaration(<TypeParameterSyntax>ast, context);

                case SyntaxKind.Constraint:
                    return this.resolveConstraint(<ConstraintSyntax>ast, context);

                case SyntaxKind.ImportDeclaration:
                    return this.resolveImportDeclaration(<ImportDeclarationSyntax>ast, context);

                case SyntaxKind.SimplePropertyAssignment:
                    return this.resolveSimplePropertyAssignment(<SimplePropertyAssignmentSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.FunctionPropertyAssignment:
                    return this.resolveFunctionPropertyAssignment(<FunctionPropertyAssignmentSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.IdentifierName:
                    Debug.assert(isTypesOnlyLocation(ast));
                    return this.resolveTypeNameExpression(<ISyntaxToken>ast, context);

                case SyntaxKind.QualifiedName:
                    return this.resolveQualifiedName(<QualifiedNameSyntax>ast, context);

                case SyntaxKind.ConstructorDeclaration:
                    return this.resolveConstructorDeclaration(<ConstructorDeclarationSyntax>ast, context);

                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    return this.resolveAccessorDeclaration(ast, context);

                case SyntaxKind.IndexMemberDeclaration:
                    return this.resolveIndexMemberDeclaration(<IndexMemberDeclarationSyntax>ast, context);

                case SyntaxKind.IndexSignature:
                    return this.resolveIndexSignature(<IndexSignatureSyntax>ast, context);

                case SyntaxKind.MemberFunctionDeclaration:
                    return this.resolveMemberFunctionDeclaration(<MemberFunctionDeclarationSyntax>ast, context);

                case SyntaxKind.CallSignature:
                    return this.resolveCallSignature(<CallSignatureSyntax>ast, context);

                case SyntaxKind.ConstructSignature:
                    return this.resolveConstructSignature(<ConstructSignatureSyntax>ast, context);

                case SyntaxKind.MethodSignature:
                    return this.resolveMethodSignature(<MethodSignatureSyntax>ast, context);

                case SyntaxKind.FunctionDeclaration:
                    return this.resolveAnyFunctionDeclaration(<FunctionDeclarationSyntax>ast, context);

                case SyntaxKind.TypeAnnotation:
                    return this.resolveTypeAnnotation(<TypeAnnotationSyntax>ast, context);

                case SyntaxKind.ExportAssignment:
                    return this.resolveExportAssignmentStatement(<ExportAssignmentSyntax>ast, context);

                case SyntaxKind.ThrowStatement:
                    return this.resolveThrowStatement(<ThrowStatementSyntax>ast, context);

                case SyntaxKind.ExpressionStatement:
                    return this.resolveExpressionStatement(<ExpressionStatementSyntax>ast, context);

                case SyntaxKind.ForStatement:
                    return this.resolveForStatement(<ForStatementSyntax>ast, context);

                case SyntaxKind.ForInStatement:
                    return this.resolveForInStatement(<ForInStatementSyntax>ast, context);

                case SyntaxKind.WhileStatement:
                    return this.resolveWhileStatement(<WhileStatementSyntax>ast, context);

                case SyntaxKind.DoStatement:
                    return this.resolveDoStatement(<DoStatementSyntax>ast, context);

                case SyntaxKind.IfStatement:
                    return this.resolveIfStatement(<IfStatementSyntax>ast, context);

                case SyntaxKind.ElseClause:
                    return this.resolveElseClause(<ElseClauseSyntax>ast, context);

                case SyntaxKind.Block:
                    return this.resolveBlock(<BlockSyntax>ast, context);

                case SyntaxKind.VariableStatement:
                    return this.resolveVariableStatement(<VariableStatementSyntax>ast, context);

                case SyntaxKind.WithStatement:
                    return this.resolveWithStatement(<WithStatementSyntax>ast, context);

                case SyntaxKind.TryStatement:
                    return this.resolveTryStatement(ast, context);

                case SyntaxKind.CatchClause:
                    return this.resolveCatchClause(<CatchClauseSyntax>ast, context);

                case SyntaxKind.FinallyClause:
                    return this.resolveFinallyClause(<FinallyClauseSyntax>ast, context);

                case SyntaxKind.ReturnStatement:
                    return this.resolveReturnStatement(<ReturnStatementSyntax>ast, context);

                case SyntaxKind.SwitchStatement:
                    return this.resolveSwitchStatement(<SwitchStatementSyntax>ast, context);

                case SyntaxKind.ContinueStatement:
                    return this.resolveContinueStatement(<ContinueStatementSyntax>ast, context);

                case SyntaxKind.BreakStatement:
                    return this.resolveBreakStatement(<BreakStatementSyntax>ast, context);

                case SyntaxKind.LabeledStatement:
                    return this.resolveLabeledStatement(<LabeledStatementSyntax>ast, context);
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        private resolveExpressionAST(ast: ISyntaxElement, isContextuallyOrInferentiallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            var expressionSymbol = this.resolveExpressionWorker(ast, isContextuallyOrInferentiallyTyped, context);

            // November 18, 2013, Section 4.12.2:
            // If e is an expression of a function type that contains exactly one generic call signature
            // and no other members, and T is a function type with exactly one non-generic call signature
            // and no other members, then any inferences made for type parameters referenced by the
            // parameters of T's call signature are fixed and, if e's call signature can successfully be
            // instantiated in the context of T's call signature(section 3.8.5), e's type is changed to
            // a function type with that instantiated signature.
            if (isContextuallyOrInferentiallyTyped && context.isInferentiallyTyping()) {
                return this.alterPotentialGenericFunctionTypeToInstantiatedFunctionTypeForTypeArgumentInference(expressionSymbol, context);
            }
            else {
                return expressionSymbol;
            }
        }

        private resolveExpressionWorker(ast: ISyntaxElement, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            switch (ast.kind()) {
                case SyntaxKind.ObjectLiteralExpression:
                    return this.resolveObjectLiteralExpression(<ObjectLiteralExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.IdentifierName:
                    // We already know we are in an expression, so there is no need
                    // to decide between resolveNameExpression and resolveTypeNameExpression
                    return this.resolveNameExpression(<ISyntaxToken>ast, context);

                case SyntaxKind.MemberAccessExpression:
                    return this.resolveMemberAccessExpression(<MemberAccessExpressionSyntax>ast, context);

                case SyntaxKind.FunctionExpression:
                    return this.resolveFunctionExpression(<FunctionExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.SimpleArrowFunctionExpression:
                    return this.resolveSimpleArrowFunctionExpression(<SimpleArrowFunctionExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    return this.resolveParenthesizedArrowFunctionExpression(<ParenthesizedArrowFunctionExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.ArrayLiteralExpression:
                    return this.resolveArrayLiteralExpression(<ArrayLiteralExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.ThisKeyword:
                    return this.resolveThisExpression(<ISyntaxToken>ast, context);

                case SyntaxKind.SuperKeyword:
                    return this.resolveSuperExpression(<ISyntaxToken>ast, context);

                case SyntaxKind.InvocationExpression:
                    return this.resolveInvocationExpression(<InvocationExpressionSyntax>ast, context);

                case SyntaxKind.ObjectCreationExpression:
                    return this.resolveObjectCreationExpression(<ObjectCreationExpressionSyntax>ast, context);

                case SyntaxKind.CastExpression:
                    return this.resolveCastExpression(<CastExpressionSyntax>ast, context);

                // primitives
                case SyntaxKind.NumericLiteral:
                    return this.semanticInfoChain.numberTypeSymbol;

                case SyntaxKind.StringLiteral:
                    return this.semanticInfoChain.stringTypeSymbol;

                case SyntaxKind.NullKeyword:
                    return this.semanticInfoChain.nullTypeSymbol;

                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                    return this.semanticInfoChain.booleanTypeSymbol;

                case SyntaxKind.VoidExpression:
                    return this.resolveVoidExpression(<VoidExpressionSyntax>ast, context);

                // assignment
                case SyntaxKind.AssignmentExpression:
                    return this.resolveAssignmentExpression(<BinaryExpressionSyntax>ast, context);

                // boolean operations
                case SyntaxKind.LogicalNotExpression:
                    return this.resolveLogicalNotExpression(<PrefixUnaryExpressionSyntax>ast, context);

                case SyntaxKind.NotEqualsWithTypeConversionExpression:
                case SyntaxKind.EqualsWithTypeConversionExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                    return this.resolveLogicalOperation(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.AddExpression:
                case SyntaxKind.AddAssignmentExpression:
                    return this.resolveBinaryAdditionOperation(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                    return this.resolveUnaryArithmeticOperation(<PrefixUnaryExpressionSyntax>ast, context);

                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                    return this.resolvePostfixUnaryExpression(<PostfixUnaryExpressionSyntax>ast, context);

                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.SignedRightShiftExpression:
                case SyntaxKind.UnsignedRightShiftExpression:
                case SyntaxKind.BitwiseExclusiveOrExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.SignedRightShiftAssignmentExpression:
                case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                    return this.resolveBinaryArithmeticExpression(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.ElementAccessExpression:
                    return this.resolveElementAccessExpression(<ElementAccessExpressionSyntax>ast, context);

                case SyntaxKind.LogicalOrExpression:
                    return this.resolveLogicalOrExpression(<BinaryExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.LogicalAndExpression:
                    return this.resolveLogicalAndExpression(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.TypeOfExpression:
                    return this.resolveTypeOfExpression(<TypeOfExpressionSyntax>ast, context);

                case SyntaxKind.DeleteExpression:
                    return this.resolveDeleteExpression(<DeleteExpressionSyntax>ast, context);

                case SyntaxKind.ConditionalExpression:
                    return this.resolveConditionalExpression(<ConditionalExpressionSyntax>ast, isContextuallyTyped, context);

                case SyntaxKind.RegularExpressionLiteral:
                    return this.resolveRegularExpressionLiteral();

                case SyntaxKind.ParenthesizedExpression:
                    return this.resolveParenthesizedExpression(<ParenthesizedExpressionSyntax>ast, context);

                case SyntaxKind.InstanceOfExpression:
                    return this.resolveInstanceOfExpression(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.CommaExpression:
                    return this.resolveCommaExpression(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.InExpression:
                    return this.resolveInExpression(<BinaryExpressionSyntax>ast, context);

                case SyntaxKind.OmittedExpression:
                    return this.semanticInfoChain.undefinedTypeSymbol;
            }

            Debug.fail("resolveExpressionASTWorker: Missing expression kind: " + SyntaxKind[ast.kind()]);
        }

        private typeCheckAST(ast: ISyntaxElement, isContextuallyTyped: boolean, context: PullTypeResolutionContext): void {
            if (!this.canTypeCheckAST(ast, context)) {
                return;
            }

            var nodeType = ast.kind();
            switch (nodeType) {
                case SyntaxKind.SourceUnit:
                    this.typeCheckSourceUnit(<SourceUnitSyntax>ast, context);
                    return;

                case SyntaxKind.EnumDeclaration:
                    this.typeCheckEnumDeclaration(<EnumDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.ModuleDeclaration:
                    this.typeCheckModuleDeclaration(<ModuleDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.InterfaceDeclaration:
                    this.typeCheckInterfaceDeclaration(<InterfaceDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.ClassDeclaration:
                    this.typeCheckClassDeclaration(<ClassDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.EnumElement:
                    this.typeCheckEnumElement(<EnumElementSyntax>ast, context);
                    return;

                case SyntaxKind.MemberVariableDeclaration:
                    this.typeCheckMemberVariableDeclaration(<MemberVariableDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.VariableDeclarator:
                    this.typeCheckVariableDeclarator(<VariableDeclaratorSyntax>ast, context);
                    return;

                case SyntaxKind.PropertySignature:
                    this.typeCheckPropertySignature(<PropertySignatureSyntax>ast, context);
                    return;

                case SyntaxKind.Parameter:
                    this.typeCheckParameter(<ParameterSyntax>ast, context);
                    return;

                case SyntaxKind.ImportDeclaration:
                    this.typeCheckImportDeclaration(<ImportDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.ObjectLiteralExpression:
                    this.resolveObjectLiteralExpression(<ObjectLiteralExpressionSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.FunctionPropertyAssignment:
                    this.typeCheckFunctionPropertyAssignment(<FunctionPropertyAssignmentSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.IdentifierName:
                    if (isTypesOnlyLocation(ast)) {
                        this.resolveTypeNameExpression(<ISyntaxToken>ast, context);
                    }
                    else {
                        this.resolveNameExpression(<ISyntaxToken>ast, context);
                    }
                    return;

                case SyntaxKind.MemberAccessExpression:
                    this.resolveMemberAccessExpression(<MemberAccessExpressionSyntax>ast, context);
                    return;

                case SyntaxKind.QualifiedName:
                    this.resolveQualifiedName(<QualifiedNameSyntax>ast, context);
                    return;

                case SyntaxKind.FunctionExpression:
                    this.typeCheckFunctionExpression(<FunctionExpressionSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.ConstructorDeclaration:
                    this.typeCheckConstructorDeclaration(<ConstructorDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    this.typeCheckAccessorDeclaration(ast, context);
                    return;

                case SyntaxKind.MemberFunctionDeclaration:
                    this.typeCheckMemberFunctionDeclaration(<MemberFunctionDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.MethodSignature:
                    this.typeCheckMethodSignature(<MethodSignatureSyntax>ast, context);
                    return;

                case SyntaxKind.IndexSignature:
                    this.typeCheckIndexSignature(<IndexSignatureSyntax>ast, context);
                    break;
                
                case SyntaxKind.CallSignature:
                    this.typeCheckCallSignature(<CallSignatureSyntax>ast, context);
                    return;

                case SyntaxKind.ConstructSignature:
                    this.typeCheckConstructSignature(<ConstructSignatureSyntax>ast, context);
                    return;

                case SyntaxKind.FunctionDeclaration:
                    {
                        var funcDecl = <FunctionDeclarationSyntax>ast;
                        this.typeCheckAnyFunctionDeclaration(
                            funcDecl, hasModifier(funcDecl.modifiers, PullElementFlags.Static), funcDecl.identifier,
                            funcDecl.callSignature.typeParameterList, funcDecl.callSignature.parameterList,
                            ASTHelpers.getType(funcDecl), funcDecl.block, context);
                        return;
                    }

                case SyntaxKind.SimpleArrowFunctionExpression:
                    this.typeCheckSimpleArrowFunctionExpression(<SimpleArrowFunctionExpressionSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.ParenthesizedArrowFunctionExpression:
                    this.typeCheckParenthesizedArrowFunctionExpression(<ParenthesizedArrowFunctionExpressionSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.ArrayLiteralExpression:
                    this.resolveArrayLiteralExpression(<ArrayLiteralExpressionSyntax>ast, isContextuallyTyped, context);
                    return;

                case SyntaxKind.InvocationExpression:
                    this.typeCheckInvocationExpression(<InvocationExpressionSyntax>ast, context);
                    return;

                case SyntaxKind.ObjectCreationExpression:
                    this.typeCheckObjectCreationExpression(<ObjectCreationExpressionSyntax>ast, context);
                    return;

                case SyntaxKind.ReturnStatement:
                    // Since we want to resolve the return expression to traverse parents, resolve will take care of typeChecking
                    this.resolveReturnStatement(<ReturnStatementSyntax>ast, context);
                    return;

                default:
                    Debug.assert(false, "Failure nodeType: " + TypeScript.SyntaxKind[ast.kind()] + ". Implement typeCheck when symbol is set for the ast as part of resolution.");
            }
        }

        private processPostTypeCheckWorkItems(context: PullTypeResolutionContext) {
            while (this.postTypeCheckWorkitems.length) {
                var ast = this.postTypeCheckWorkitems.pop();
                this.postTypeCheck(ast, context);
            }
        }

        private postTypeCheck(ast: ISyntaxElement, context: PullTypeResolutionContext) {
            var nodeType = ast.kind();

            switch (nodeType) {
                case SyntaxKind.Parameter:
                case SyntaxKind.VariableDeclarator:
                    this.postTypeCheckVariableDeclaratorOrParameter(ast, context);
                    return;

                case SyntaxKind.ClassDeclaration:
                    this.postTypeCheckClassDeclaration(<ClassDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.FunctionDeclaration:
                    this.postTypeCheckFunctionDeclaration(<FunctionDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.ModuleDeclaration:
                    this.postTypeCheckModuleDeclaration(<ModuleDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.EnumDeclaration:
                    this.postTypeCheckEnumDeclaration(<EnumDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.ImportDeclaration:
                    this.postTypeCheckImportDeclaration(<ImportDeclarationSyntax>ast, context);
                    return;

                case SyntaxKind.IdentifierName:
                    this.postTypeCheckNameExpression(<ISyntaxToken>ast, context);
                    return;

                default:
                    Debug.assert(false, "Implement postTypeCheck clause to handle the postTypeCheck work, nodeType: " + TypeScript.SyntaxKind[ast.kind()]);
            }
        }

        private resolveRegularExpressionLiteral(): PullTypeSymbol {
            if (this.cachedRegExpInterfaceType()) {
                return this.cachedRegExpInterfaceType();
            }
            else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        }

        private postTypeCheckNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext) {
            this.checkThisCaptureVariableCollides(nameAST, /*isDeclaration*/ false, context);
        }

        private typeCheckNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext) {
            this.setTypeChecked(nameAST, context);
            this.checkNameForCompilerGeneratedDeclarationCollision(nameAST, /*isDeclaration*/ false, nameAST, context);
        }

        private resolveNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext): PullSymbol {
            var nameSymbol = this.getSymbolForAST(nameAST, context);
            var foundCached = nameSymbol !== null;

            if (!foundCached || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.typeCheckNameExpression(nameAST, context);
                }
                nameSymbol = this.computeNameExpression(nameAST, context);
            }

            this.resolveDeclaredSymbol(nameSymbol, context);

            // We don't want to capture an intermediate 'any' from a recursive resolution
            if (nameSymbol &&
                (nameSymbol.type !== this.semanticInfoChain.anyTypeSymbol ||
                nameSymbol.anyDeclHasFlag(PullElementFlags.IsAnnotatedWithAny | PullElementFlags.Exported))/*&& !nameSymbol.inResolution*/) {
                this.setSymbolForAST(nameAST, nameSymbol, context);
            }

            return nameSymbol;
        }

        private isInEnumDecl(decl: PullDecl) : boolean {
            if (decl.kind & PullElementKind.Enum) {
                return true;
            }

            var declPath = decl.getParentPath();
            // enum cannot contain these kinds of declarations, if one is met - exit with false
            var disallowedKinds = PullElementKind.SomeContainer | PullElementKind.SomeType;
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];

                if (decl.kind & PullElementKind.Enum) {
                    return true;
                }

                if (decl.kind & disallowedKinds) {
                    return false;
                }
            }
            return false;
        }

        private getSomeInnermostFunctionScopeDecl(declPath: PullDecl[]) {
            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                if (decl.kind & PullElementKind.SomeFunction) {
                    return decl;
                }
            }

            return null;
        }

        private isFromFunctionScope(nameSymbol: PullSymbol, functionScopeDecl: PullDecl) {
            // If there exists any declaration that is from same functionScopeDecl, nameSymbol is from functionScope
            return ArrayUtilities.any(nameSymbol.getDeclarations(), (nameSymbolDecl) =>
                this.getSomeInnermostFunctionScopeDecl(nameSymbolDecl.getParentPath()) === functionScopeDecl);
        }

        private findConstructorDeclOfEnclosingType(decl: PullDecl): PullDecl {
            var current = decl;
            while (current) {
                if (hasFlag(current.kind, PullElementKind.Property)) {
                    var parentDecl = current.getParentDecl();
                    if (hasFlag(parentDecl.kind, PullElementKind.Class)) {
                        return ArrayUtilities.lastOrDefault(parentDecl.getChildDecls(), decl => hasFlag(decl.kind, PullElementKind.ConstructorMethod));
                    }
                }

                if (hasFlag(current.kind, PullElementKind.SomeContainer)) {
                    return null;
                }

                current = current.getParentDecl();
            }
            return null;
        }

        private checkNameAsPartOfInitializerExpressionForInstanceMemberVariable(nameAST: ISyntaxToken,
            nameSymbol: PullSymbol, context: PullTypeResolutionContext): boolean {
            var id = tokenValueText(nameAST);
            if (id.length === 0) {
                return false;
            }

            // SPEC: Nov 18, 2013
            // Initializer expressions for instance member variables are evaluated in the scope of the class constructor body 
            // but are not permitted to reference parameters or local variables of the constructor.
            // This effectively means that entities from outer scopes by the same name as a constructor parameter or local variable are inaccessible 
            // in initializer expressions for instance member variables.
            var memberVariableDeclarationAST = ASTHelpers.getEnclosingMemberVariableDeclaration(nameAST);
            if (memberVariableDeclarationAST) {

                var memberVariableDecl = this.semanticInfoChain.getDeclForAST(memberVariableDeclarationAST);
                if (!hasFlag(memberVariableDecl.flags, PullElementFlags.Static)) {
                    var constructorDecl = this.findConstructorDeclOfEnclosingType(memberVariableDecl);

                    if (constructorDecl) {
                        var childDecls = constructorDecl.searchChildDecls(id, PullElementKind.SomeValue);
                        if (childDecls.length) {
                            // Check if symbol is from scope that is outer to constructor's outer scope
                            if (PullHelpers.isSymbolDeclaredInScopeChain(nameSymbol, constructorDecl.getSymbol(this.semanticInfoChain).getContainer())) {
                                var memberVariableSymbol = memberVariableDecl.getSymbol(this.semanticInfoChain);
                                // Currently name was resolved to something from outerscope of the class
                                // But constructor contains same parameter name, and hence this member initializer
                                // when moved into constructor function in generated js would resolve to the constructor 
                                // parameter but thats not what user intended. Report error
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST,
                                    DiagnosticCode.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
                                    [memberVariableSymbol.getScopedName(constructorDecl.getSymbol(this.semanticInfoChain)), nameAST.text()]));
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        private computeNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext): PullSymbol {
            var id = tokenValueText(nameAST);
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            
            var nameSymbol: PullSymbol = null;
            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);//, /*skipNonScopeDecls:*/ false);

            // if enclosing decl is property check if it has valueDecl that corresponds to parameter
            if (hasFlag(enclosingDecl.flags, PullElementFlags.PropertyParameter)) {
                var valueDecl = enclosingDecl.getValueDecl();
                if (valueDecl && hasFlag(valueDecl.kind, PullElementKind.Parameter)) {
                    enclosingDecl = valueDecl;
                }
            }

            // First check if this is the name child of a declaration. If it is, no need to search for a name in scope since this is not a reference.
            var isDeclarationASTOrDeclarationNameAST = ASTHelpers.isDeclarationASTOrDeclarationNameAST(nameAST);
            if (isDeclarationASTOrDeclarationNameAST) {
                nameSymbol = this.semanticInfoChain.getDeclForAST(nameAST.parent).getSymbol(this.semanticInfoChain);
            }

            var declPath = enclosingDecl.getParentPath();

            if (!nameSymbol) {
                var searchKind = PullElementKind.SomeValue;

                // disallow accessing enum members with no qualification except the case when enclosing decl is enum
                if (!this.isInEnumDecl(enclosingDecl)) {
                    searchKind = searchKind & ~(PullElementKind.EnumMember);
                }

                var nameSymbol = this.getSymbolFromDeclPath(id, declPath, searchKind);
            }

            // arguments is resolved to local variable in the function or the arguments list that runtime passes and never to any other symbol
            if (id === "arguments") {
                var functionScopeDecl = this.getSomeInnermostFunctionScopeDecl(declPath);
                if (functionScopeDecl) {
                    // if there wasnt nameSymbol Or the nameSymbol isnt from the functionScope we are looking in
                    // resolve this to arguments of type IArguments
                    if (!nameSymbol || !this.isFromFunctionScope(nameSymbol, functionScopeDecl)) {
                        nameSymbol = this.cachedFunctionArgumentsSymbol();
                        this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), context);
                    }
                }
            }

            var aliasSymbol: PullTypeAliasSymbol = null;
            if (nameSymbol && nameSymbol.isAlias() && !isDeclarationASTOrDeclarationNameAST) {
                aliasSymbol = <PullTypeAliasSymbol>nameSymbol;
                if (!this.inTypeQuery(nameAST)) {
                    aliasSymbol.setIsUsedAsValue();
                }

                this.resolveDeclaredSymbol(nameSymbol, context);

                this.resolveDeclaredSymbol(aliasSymbol.assignedValue(), context);
                this.resolveDeclaredSymbol(aliasSymbol.assignedContainer(), context);

                nameSymbol = aliasSymbol.getExportAssignedValueSymbol();
                if (!nameSymbol) {
                    aliasSymbol = null;
                }
            }

            if (!nameSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, DiagnosticCode.Could_not_find_symbol_0, [nameAST.text()]));
                return this.getNewErrorTypeSymbol(id);
            }
            else if (this.checkNameAsPartOfInitializerExpressionForInstanceMemberVariable(nameAST, nameSymbol, context)) {
                return this.getNewErrorTypeSymbol(id);
            }

            // October 11, 2013:
            // Initializer expressions are evaluated in the scope of the function body but are not 
            // permitted to reference local variables and are only permitted to access parameters 
            // that are declared to the left of the parameter they initialize.

            // If we've referenced a parameter of a function, make sure that we're either inside 
            // the function, or if we're in a parameter initializer, that the parameter 
            // initializer is to the left of this reference.

            var nameDeclaration = nameSymbol.getDeclarations()[0];
            var nameParentDecl = nameDeclaration.getParentDecl();
            if (nameParentDecl &&
                (nameParentDecl.kind & PullElementKind.SomeFunction) &&
                (nameParentDecl.flags & PullElementFlags.HasDefaultArgs)) {
                // Get the ISyntaxElement and look it up in the parameter index context to find which parameter we are in
                var enclosingFunctionAST = this.semanticInfoChain.getASTForDecl(nameParentDecl);
                var currentParameterIndex = this.getCurrentParameterIndexForFunction(nameAST, enclosingFunctionAST);

                var parameterList = ASTHelpers.getParameterList(enclosingFunctionAST);
                // Short circuit if we are located in the function body, since all child decls of the function are accessible there
                if (currentParameterIndex >= 0) {
                    // Search the enclosing function AST for a parameter with the right name, but stop once we hit our current context
                    var matchingParameter: ParameterSyntax;
                    if (parameterList) {
                        for (var i = 0; i <= currentParameterIndex; i++) {
                            var candidateParameter = parameterList.parameters[i];
                            if (candidateParameter && tokenValueText(candidateParameter.identifier) === id) {
                                matchingParameter = candidateParameter;
                                break;
                            }
                        }
                    }

                    if (!matchingParameter) {
                        // We didn't find a matching parameter to the left, so error
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST,
                            DiagnosticCode.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it,
                            [parameterList.parameters[currentParameterIndex].identifier.text(), nameAST.text()]));
                        return this.getNewErrorTypeSymbol(id);
                    }
                    else if (matchingParameter === ASTHelpers.getEnclosingParameterForInitializer(nameAST)) {
                        // we've found matching parameter but it references itself from the initializer
                        // per spec Nov 18: 
                        // Initializer expressions ..and are only permitted to access parameters that are declared to the left of the parameter they initialize
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST,
                            DiagnosticCode.Parameter_0_cannot_be_referenced_in_its_initializer,
                            [parameterList.parameters[currentParameterIndex].identifier.text()]));
                        return this.getNewErrorTypeSymbol(id);

                    }
                }
            }

            if (aliasSymbol) {
                this.semanticInfoChain.setAliasSymbolForAST(nameAST, aliasSymbol);
            }

            return nameSymbol;
        }

        // Returns the parameter index in the specified function declaration where ast is contained
        // within.  Returns -1 if ast is not contained within a parameter initializer in the 
        // provided function declaration.
        private getCurrentParameterIndexForFunction(parameter: ISyntaxElement, funcDecl: ISyntaxElement): number {
            var parameterList = ASTHelpers.getParameterList(funcDecl);
            if (parameterList) {
                while (parameter && parameter.parent) {
                    if (parameter.parent.parent === parameterList) {
                        // We were contained in the parameter list.  Return which parameter index 
                        // we were at.
                        return Syntax.nonSeparatorIndexOf(parameterList.parameters, <ISyntaxNodeOrToken>parameter);
                    }

                    parameter = parameter.parent;
                }
            }

            // ast was not found within the parameter list of this function.
            return -1;
        }

        private resolveMemberAccessExpression(dottedNameAST: MemberAccessExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveDottedNameExpression(
                dottedNameAST, dottedNameAST.expression, dottedNameAST.name, context);
        }

        private resolveDottedNameExpression(
            dottedNameAST: ISyntaxElement,
            expression: ISyntaxElement,
            name: ISyntaxToken,
            context: PullTypeResolutionContext): PullSymbol {

            var symbol = this.getSymbolForAST(dottedNameAST, context);
            var foundCached = symbol !== null;

            if (!foundCached || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheckDottedNameAST = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheckDottedNameAST) {
                    this.setTypeChecked(dottedNameAST, context);
                }

                symbol = this.computeDottedNameExpression(
                    expression, name, context, canTypeCheckDottedNameAST);
            }

            this.resolveDeclaredSymbol(symbol, context);

            if (symbol &&
                (symbol.type !== this.semanticInfoChain.anyTypeSymbol ||
                symbol.anyDeclHasFlag(PullElementFlags.IsAnnotatedWithAny | PullElementFlags.Exported))/*&& !symbol.inResolution*/) {
                this.setSymbolForAST(dottedNameAST, symbol, context);
                this.setSymbolForAST(name, symbol, context);
            }

            return symbol;
        }

        private computeDottedNameExpression(expression: ISyntaxElement, name: ISyntaxToken, context: PullTypeResolutionContext, checkSuperPrivateAndStaticAccess: boolean): PullSymbol {
            var rhsName = tokenValueText(name);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // assemble the dotted name path
            var lhs = this.resolveAST(expression, /*isContextuallyTyped*/false, context);
            return this.computeDottedNameExpressionFromLHS(lhs, expression, name, context, checkSuperPrivateAndStaticAccess);
        }

        private computeDottedNameExpressionFromLHS(lhs: PullSymbol, expression: ISyntaxElement, name: ISyntaxToken, context: PullTypeResolutionContext, checkSuperPrivateAndStaticAccess: boolean): PullSymbol {
            // This can be case if incomplete qualified name
            var rhsName = tokenValueText(name);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var lhsType = lhs.type;

            if (lhs.isAlias()) {
                var lhsAlias = <PullTypeAliasSymbol>lhs;
                if (!this.inTypeQuery(expression)) {
                    lhsAlias.setIsUsedAsValue();
                }
                lhsType = lhsAlias.getExportAssignedTypeSymbol();
            }

            // this can happen if a var is set to a type alias and the var is used in a dotted name.
            // i.e. 
            //    import myAlias = require('someModule');
            //    var myAliasVar = myAlias
            //    myAliasVar.someModulesMember();
            // without this we would not be able to resolve someModules Members 
            if (lhsType.isAlias()) {
                lhsType = (<PullTypeAliasSymbol>lhsType).getExportAssignedTypeSymbol();
            }

            if (!lhsType) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [name.text()]));
                return this.getNewErrorTypeSymbol();
            }

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = <PullTypeSymbol>this.resolveDeclaredSymbol(lhsType, context);

                if (potentiallySpecializedType !== lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (lhsType.isContainer() && !lhsType.isAlias() && !lhsType.isEnum()) {
                // we're searching in the value space, so we should try to use the
                // instance value type
                var instanceSymbol = (<PullContainerSymbol>lhsType).getInstanceSymbol();

                if (instanceSymbol) {
                    lhsType = instanceSymbol.type;
                }
            }

            var originalLhsTypeForErrorReporting = lhsType;

            lhsType = this.getApparentType(lhsType).widenedType(this, expression, context);

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            // November 18, 2013, Section 4.10:
            // If Name denotes a property member in the apparent type of ObjExpr, the property access
            // is of the type of that property.
            // Note that here we are assuming the apparent type is already accounted for up to
            // augmentation. So we just check the augmented type.
            var nameSymbol = this._getNamedPropertySymbolOfAugmentedType(rhsName, lhsType);

            if (!nameSymbol) {
                // could be a function symbol
                if (lhsType.kind === PullElementKind.DynamicModule) {
                    var container = <PullContainerSymbol>lhsType;
                    var associatedInstance = container.getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;

                        nameSymbol = this.getNamedPropertySymbol(rhsName, PullElementKind.SomeValue, instanceType);
                    }
                }
                // could be a module instance
                else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getNamedPropertySymbol(rhsName, PullElementKind.SomeValue, associatedType);
                    }
                }

                if (!nameSymbol) {
                    var enclosingDecl = this.getEnclosingDeclForAST(expression);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [name.text(), originalLhsTypeForErrorReporting.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                    return this.getNewErrorTypeSymbol(rhsName);
                }
            }

            if (checkSuperPrivateAndStaticAccess) {
                this.checkForSuperMemberAccess(expression, name, nameSymbol, context) ||
                this.checkForPrivateMemberAccess(name, lhsType, nameSymbol, context);
             }

            return nameSymbol;
        }

        private resolveTypeNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext): PullTypeSymbol {
            var typeNameSymbol = <PullTypeSymbol>this.getSymbolForAST(nameAST, context);

            // TODO(cyrusn): We really shouldn't be checking "isType" here.  However, we currently
            // have a bug where some part of the system calls resolveNameExpression on this node
            // and we cache the wrong thing.  We need to add appropriate checks to ensure that
            // resolveNameExpression is never called on a node that we should be calling 
            // resolveTypeNameExpression (and vice versa).
            if (!typeNameSymbol || !typeNameSymbol.isType() || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.setTypeChecked(nameAST, context);
                }
                typeNameSymbol = this.computeTypeNameExpression(nameAST, context);
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }

            this.resolveDeclaredSymbol(typeNameSymbol, context);

            return typeNameSymbol;
        }

        private computeTypeNameExpression(nameAST: ISyntaxToken, context: PullTypeResolutionContext): PullTypeSymbol {
            var id = tokenValueText(nameAST);
            if (id.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var enclosingDecl = this.getEnclosingDeclForAST(nameAST);

            var declPath = enclosingDecl.getParentPath();

            // If we're resolving a dotted type name, every dotted name but the last will be a container type, so we'll search those
            // first if need be, and then fall back to type names.  Otherwise, look for a type first, since we are probably looking for
            // a type reference (the exception being an alias or export assignment)
            var onLeftOfDot = this.isLeftSideOfQualifiedName(nameAST);

            var kindToCheckFirst = onLeftOfDot ? PullElementKind.SomeContainer : PullElementKind.SomeType;
            var kindToCheckSecond = onLeftOfDot ? PullElementKind.SomeType : PullElementKind.SomeContainer;

            var typeNameSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);

            if (!typeNameSymbol) {
                typeNameSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
            }

            if (!typeNameSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, DiagnosticCode.Could_not_find_symbol_0, [nameAST.text()]));
                return this.getNewErrorTypeSymbol(id);
            }

            var typeNameSymbolAlias: PullTypeAliasSymbol = null;
            if (typeNameSymbol.isAlias()) {
                typeNameSymbolAlias = <PullTypeAliasSymbol>typeNameSymbol;
                this.resolveDeclaredSymbol(typeNameSymbol, context);

                var aliasedType = typeNameSymbolAlias.getExportAssignedTypeSymbol();

                this.resolveDeclaredSymbol(aliasedType, context);
            }

            if (typeNameSymbol.isTypeParameter()) {
                if (PullTypeResolver.isInStaticMemberContext(enclosingDecl)) {
                    var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();

                    if (parentDecl.kind === PullElementKind.Class) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(nameAST, DiagnosticCode.Static_members_cannot_reference_class_type_parameters));
                        return this.getNewErrorTypeSymbol();
                    }
                }
            }

            if (!typeNameSymbol.isGeneric() && (typeNameSymbol.isClass() || typeNameSymbol.isInterface())) {
                typeNameSymbol = TypeReferenceSymbol.createTypeReference(typeNameSymbol);
            }

            return typeNameSymbol;
        }

        public static isInStaticMemberContext(decl: PullDecl): boolean {
            while (decl) {                
                // check if decl correspond to static member of some sort
                if (hasFlag(decl.kind, PullElementKind.SomeFunction | PullElementKind.Property) && hasFlag(decl.flags, PullElementFlags.Static)) {
                    return true;
                }

                // no container can exist in static context - exit early
                if (hasFlag(decl.kind, PullElementKind.SomeContainer)) {
                    return false;
                }

                decl = decl.getParentDecl();
            }

            return false;
        }

        private isLeftSideOfQualifiedName(ast: ISyntaxElement): boolean {
            return ast && ast.parent && ast.parent.kind() === SyntaxKind.QualifiedName && (<QualifiedNameSyntax>ast.parent).left === ast;
        }

        private resolveGenericTypeReference(genericTypeAST: GenericTypeSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, context).type;

            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }

            if (!genericTypeSymbol.inResolution && !genericTypeSymbol.isResolved) {
                this.resolveDeclaredSymbol(genericTypeSymbol, context);
            }

            if (genericTypeSymbol.isAlias()) {
                if (this.inClassExtendsHeritageClause(genericTypeAST) &&
                    !this.inTypeArgumentList(genericTypeAST)) {
                    (<PullTypeAliasSymbol>genericTypeSymbol).setIsUsedAsValue();
                }
                genericTypeSymbol = (<PullTypeAliasSymbol>genericTypeSymbol).getExportAssignedTypeSymbol();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();
            if (typeParameters.length === 0) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, DiagnosticCode.Type_0_does_not_have_type_parameters, [genericTypeSymbol.toString()]));
                return this.getNewErrorTypeSymbol();
            }

            // specialize the type arguments
            var typeArgs: PullTypeSymbol[] = [];

            if (genericTypeAST.typeArgumentList && genericTypeAST.typeArgumentList.typeArguments.length) {
                for (var i = 0; i < genericTypeAST.typeArgumentList.typeArguments.length; i++) {
                    typeArgs[i] = this.resolveTypeReference(genericTypeAST.typeArgumentList.typeArguments[i], context);

                    if (typeArgs[i].isError()) {
                        typeArgs[i] = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }

            if (typeArgs.length && typeArgs.length !== typeParameters.length) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length]));
                return this.getNewErrorTypeSymbol();
            }

            // if the generic type symbol is not resolved, we need to ensure that all of its members are bound before specializing
            if (!genericTypeSymbol.isResolved) {
                var typeDecls = genericTypeSymbol.getDeclarations();
                var childDecls: PullDecl[] = null;

                for (var i = 0; i < typeDecls.length; i++) {
                    childDecls = typeDecls[i].getChildDecls();

                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound(this.semanticInfoChain);
                    }
                }
            }

            var specializedSymbol = this.createInstantiatedType(genericTypeSymbol, typeArgs);

            // check constraints, if appropriate
            var upperBound: PullTypeSymbol = null;

            // Get the instantiated versions of the type parameters (in case their constraints were generic)
            typeParameters = specializedSymbol.getTypeParameters();

            var typeConstraintSubstitutionMap: PullTypeSymbol[] = [];
            
            var instantiatedSubstitutionMap = specializedSymbol.getTypeParameterSubstitutionMap();


            // To defend against forward references amongst constraints, first enter each type
            // parameter into the substitution map, set to itself
            for (var i = 0; i < typeParameters.length; i++) {
                typeConstraintSubstitutionMap[typeParameters[i].pullSymbolID] = typeParameters[i];
            }

            for (var id in instantiatedSubstitutionMap) {
                typeConstraintSubstitutionMap[id] = instantiatedSubstitutionMap[id];
            }

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                var typeArg = typeArgs[iArg];
                var typeParameter = typeParameters[iArg];
                var typeConstraint = typeParameter.getConstraint();

                typeConstraintSubstitutionMap[typeParameter.pullSymbolID] = typeArg;

                // test specialization type for assignment compatibility with the constraint
                if (typeConstraint) {

                    if (typeConstraint.isTypeParameter()) {

                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] === typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    }
                    else if (typeConstraint.isGeneric()) {
                        typeConstraint = this.instantiateType(typeConstraint, typeConstraintSubstitutionMap);
                    }

                    if (typeArg.isTypeParameter()) {
                        upperBound = (<PullTypeParameterSymbol>typeArg).getConstraint();

                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }

                    // handle cases where the type argument is a wrapped name type, that's being recursively resolved
                    if (typeArg.inResolution || (typeArg.isTypeReference() && (<TypeReferenceSymbol>typeArg).referencedTypeSymbol.inResolution)) {
                        return specializedSymbol;
                    }

                    if (context.canTypeCheckAST(genericTypeAST)) {
                        this.typeCheckCallBacks.push(context => {
                            // Section 3.4.2 (November 18, 2013): 
                            // A type argument satisfies a type parameter constraint if the type argument is assignable
                            // to(section 3.8.4) the constraint type once type arguments are substituted for type parameters.
                            if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, genericTypeAST, context)) {
                                var enclosingSymbol = this.getEnclosingSymbolForAST(genericTypeAST);
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(genericTypeAST, DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [typeArg.toString(enclosingSymbol, /*useConstraintInName*/ true), typeConstraint.toString(enclosingSymbol, /*useConstraintInName*/ true), typeParameter.toString(enclosingSymbol, /*useConstraintInName*/ true)]));
                            }
                        });
                    }
                }
            }

            return specializedSymbol;
        }

        private resolveQualifiedName(dottedNameAST: QualifiedNameSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            if (this.inTypeQuery(dottedNameAST)) {
                // If we're in a type query, then treat the qualified name as a normal dotted
                // name expression.
                return this.resolveDottedNameExpression(
                    dottedNameAST, dottedNameAST.left, dottedNameAST.right, context).type;
            }

            var symbol = <PullTypeSymbol>this.getSymbolForAST(dottedNameAST, context);
            if (!symbol || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheck = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheck) {
                    this.setTypeChecked(dottedNameAST, context);
                }

                symbol = this.computeQualifiedName(dottedNameAST, context);
                this.setSymbolForAST(dottedNameAST, symbol, context);
            }

            this.resolveDeclaredSymbol(symbol, context);

            return symbol;
        }

        private isLastNameOfQualifiedModuleNameModuleReference(ast: ISyntaxElement): boolean {
            // SPEC: November 18, 2013 section 10.3 -
            // Don't walk up any other qualified names because the spec says only the last entity name can be a non-module
            // i.e. Only Module.Module.Module.var and not Module.Type.var or Module.var.member
            return ast.kind() === SyntaxKind.IdentifierName &&
                ast.parent && ast.parent.kind() === SyntaxKind.QualifiedName &&
                (<QualifiedNameSyntax>ast.parent).right === ast &&
                ast.parent.parent && ast.parent.parent.kind() === SyntaxKind.ModuleNameModuleReference;
        }

        private computeQualifiedName(dottedNameAST: QualifiedNameSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var rhsName = tokenValueText(dottedNameAST.right);
            if (rhsName.length === 0) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // assemble the dotted name path
            var enclosingDecl = this.getEnclosingDeclForAST(dottedNameAST);
            var lhs = this.resolveAST(dottedNameAST.left, /*isContextuallyTyped*/ false, context);

            var lhsType = lhs.isAlias() ? (<PullTypeAliasSymbol>lhs).getExportAssignedContainerSymbol() : lhs.type;

            if (this.inClassExtendsHeritageClause(dottedNameAST) &&
                !this.inTypeArgumentList(dottedNameAST)) {
                if (lhs.isAlias()) {
                    (<PullTypeAliasSymbol>lhs).setIsUsedAsValue();
                }
            }

            if (!lhsType) {
                return this.getNewErrorTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            // now for the name...
            var onLeftOfDot = this.isLeftSideOfQualifiedName(dottedNameAST);
            var isNameOfModule = dottedNameAST.parent.kind() === SyntaxKind.ModuleDeclaration && (<ModuleDeclarationSyntax>dottedNameAST.parent).name === dottedNameAST;

            var memberKind = (onLeftOfDot || isNameOfModule) ? PullElementKind.SomeContainer : PullElementKind.SomeType;

            var childTypeSymbol = <PullTypeSymbol>this.getNamedPropertySymbol(rhsName, memberKind, lhsType);

            // SPEC: November 18, 2013 section 10.3 -
            //  - An EntityName consisting of more than one identifier is resolved as 
            //     a ModuleName followed by an identifier that names one or more exported entities in the given module.
            //     The resulting local alias has all the meanings and classifications of the referenced entity or entities. 
            //     (As many as three distinct meanings are possible for an entity name  namespace, type, and member.)
            if (!childTypeSymbol && !isNameOfModule && this.isLastNameOfQualifiedModuleNameModuleReference(dottedNameAST.right))
            {
                childTypeSymbol = <PullTypeSymbol>this.getNamedPropertySymbol(rhsName, PullElementKind.SomeValue, lhsType);
            }

            // if the lhs exports a container type, but not a type, we should check the container type
            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = (<PullContainerSymbol>lhsType).getExportAssignedContainerSymbol();

                if (exportedContainer) {
                    childTypeSymbol = <PullTypeSymbol>this.getNamedPropertySymbol(rhsName, memberKind, exportedContainer);
                }
            }

            // If the name is expressed as a dotted name within the parent type,
            // then it will be considered a contained member, so back up to the nearest
            // enclosing symbol and look there
            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;

                while (parentDecl) {
                    if (parentDecl.kind & PullElementKind.SomeContainer) {
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol(this.semanticInfoChain).type;

                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = <PullTypeSymbol>this.getNamedPropertySymbol(rhsName, memberKind, lhsType);//lhsType.findContainedMember(rhsName);
                    }
                }
            }

            if (!childTypeSymbol) {
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(dottedNameAST.right, DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [dottedNameAST.right.text(), lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                return this.getNewErrorTypeSymbol(rhsName);
            }

            return childTypeSymbol;
        }

        private shouldContextuallyTypeAnyFunctionExpression(
            functionExpressionAST: ISyntaxElement,
            typeParameters: TypeParameterListSyntax,
            parameters: IParameters,
            returnTypeAnnotation: ISyntaxElement,
            context: PullTypeResolutionContext): boolean {

            // September 21, 2013: If e is a FunctionExpression or ArrowFunctionExpression with no type parameters and no parameter
            // or return type annotations, and T is a function type with exactly one non - generic call signature, then any
            // inferences made for type parameters referenced by the parameters of Ts call signature are fixed(section 4.12.2)
            // and e is processed with the contextual type T, as described in section 4.9.3.

            // No type parameters
            if (typeParameters && typeParameters.typeParameters.length > 0) {
                return false;
            }

            // No return type annotation
            if (returnTypeAnnotation) {
                return false;
            }

            // No parameter type annotations
            if (parameters) {
                for (var i = 0, n = parameters.length; i < n; i++) {
                    if (parameters.typeAt(i)) {
                        return false
                    }
                }
            }

            var contextualFunctionTypeSymbol = context.getContextualType();

            // Exactly one non-generic call signature (note that this means it must have exactly one call signature,
            // AND that call signature must be non-generic)
            if (contextualFunctionTypeSymbol) {
                this.resolveDeclaredSymbol(contextualFunctionTypeSymbol, context);
                var callSignatures = contextualFunctionTypeSymbol.getCallSignatures();
                var exactlyOneCallSignature = callSignatures && callSignatures.length === 1;
                if (!exactlyOneCallSignature) {
                    return false;
                }

                var callSignatureIsGeneric = callSignatures[0].getTypeParameters().length > 0;
                return !callSignatureIsGeneric;
                    }

            return false;
                }

        private resolveAnyFunctionExpression(
            funcDeclAST: ISyntaxNodeOrToken,
            typeParameters: TypeParameterListSyntax,
            parameters: IParameters,
            returnTypeAnnotation: ISyntaxNodeOrToken,
            block: BlockSyntax,
            bodyExpression: ISyntaxNodeOrToken,
            isContextuallyTyped: boolean,
            context: PullTypeResolutionContext): PullSymbol {

            var funcDeclSymbol: PullSymbol = null;
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            Debug.assert(functionDecl);

            if (functionDecl && functionDecl.hasSymbol(this.semanticInfoChain)) {
                funcDeclSymbol = functionDecl.getSymbol(this.semanticInfoChain);
                if (funcDeclSymbol.isResolved || funcDeclSymbol.inResolution) {
                    return funcDeclSymbol;
                }
            }

            funcDeclSymbol = <PullTypeSymbol>functionDecl.getSymbol(this.semanticInfoChain);
            Debug.assert(funcDeclSymbol);

            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            funcDeclSymbol.startResolving();

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            var assigningFunctionSignature: PullSignatureSymbol = null;
            if (isContextuallyTyped &&
                this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {

                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }

            // link parameters and resolve their annotations
            this.resolveAnyFunctionExpressionParameters(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, isContextuallyTyped, context);

            // resolve the return type annotation
            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, context);
            }
            else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.returnType;

                    if (returnType) {
                        context.propagateContextualType(returnType);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, bodyExpression, signature, true, functionDecl, context);
                        context.popAnyContextualType();
                    }
                    else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        // if noimplictiany flag is set to be true, report an error
                        if (this.compilationSettings.noImplicitAny()) {
                            var functionExpressionName = (<PullFunctionExpressionDecl>functionDecl).getFunctionExpressionName();

                            // If there is a function name for the funciton expression, report an error with that name
                            if (functionExpressionName != "") {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                                    DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionExpressionName]));
                            }
                            else {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDeclAST,
                                    DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type));
                            }
                        }
                    }
                }
                else {
                    this.resolveFunctionBodyReturnTypes(
                        funcDeclAST, block, bodyExpression, signature, false, functionDecl, context);
                }
            }
            // reset the type to the one we already had, 
            // this makes sure if we had short - circuited the type of this symbol to any, we would get back to the function type
            context.setTypeInContext(funcDeclSymbol, funcDeclType);
            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression, isContextuallyTyped, context);
            }

            return funcDeclSymbol;
        }

        private resolveAnyFunctionExpressionParameters(funcDeclAST: ISyntaxElement, typeParameters: TypeParameterListSyntax, parameters: IParameters, returnTypeAnnotation: ISyntaxElement, isContextuallyTyped: boolean, context: PullTypeResolutionContext): void {
            if (!parameters) {
                return;
            }

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var contextParams: PullSymbol[] = [];

            var assigningFunctionSignature: PullSignatureSymbol = null;
            if (isContextuallyTyped &&
                this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {

                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }

            if (assigningFunctionSignature) {
                contextParams = assigningFunctionSignature.parameters;
            }

            // Push the function onto the parameter index stack
            var contextualParametersCount = contextParams.length;
            for (var i = 0, n = parameters.length; i < n; i++) {
                // Function has a variable argument list, and this paramter is the last

                var actualParameterIsVarArgParameter = (i === (n - 1)) && parameters.lastParameterIsRest();
                var correspondingContextualParameter: PullSymbol = null;
                var contextualParameterType: PullTypeSymbol = null;

                // Find the matching contextual paramter
                if (i < contextualParametersCount) {
                    correspondingContextualParameter = contextParams[i];
                }
                else if (contextualParametersCount && contextParams[contextualParametersCount - 1].isVarArg) {
                    correspondingContextualParameter = contextParams[contextualParametersCount - 1];
                }

                // Find the contextual type from the paramter
                if (correspondingContextualParameter) {
                    if (correspondingContextualParameter.isVarArg === actualParameterIsVarArgParameter) {
                        contextualParameterType = correspondingContextualParameter.type;
                    }
                    else if (correspondingContextualParameter.isVarArg) {
                        contextualParameterType = correspondingContextualParameter.type.getElementType();
                    }
                }

                // use the function decl as the enclosing decl, so as to properly resolve type parameters
                this.resolveFunctionExpressionParameter(parameters.astAt(i), parameters.identifierAt(i),
                    parameters.typeAt(i), parameters.initializerAt(i), contextualParameterType, functionDecl, context);
            }
        }

        private typeCheckSimpleArrowFunctionExpression(arrowFunction: SimpleArrowFunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): void {
            return this.typeCheckAnyFunctionExpression(
                arrowFunction, /*typeParameters:*/ null, ASTHelpers.parametersFromIdentifier(arrowFunction.identifier),
                /*returnTypeAnnotation:*/ null, arrowFunction.block, arrowFunction.expression, isContextuallyTyped, context);
        }

        private typeCheckParenthesizedArrowFunctionExpression(
            arrowFunction: ParenthesizedArrowFunctionExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): void {

            return this.typeCheckAnyFunctionExpression(
                arrowFunction, arrowFunction.callSignature.typeParameterList,
                ASTHelpers.parametersFromParameterList(arrowFunction.callSignature.parameterList),
                ASTHelpers.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, isContextuallyTyped, context);
        }

        private typeCheckAnyFunctionExpression(
            funcDeclAST: ISyntaxNodeOrToken,
            typeParameters: TypeParameterListSyntax,
            parameters: IParameters,
            returnTypeAnnotation: ISyntaxNodeOrToken,
            block: BlockSyntax,
            bodyExpression: ISyntaxNodeOrToken,
            isContextuallyTyped: boolean,
            context: PullTypeResolutionContext) {

            this.setTypeChecked(funcDeclAST, context);

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);

            var funcDeclSymbol = <PullTypeSymbol>functionDecl.getSymbol(this.semanticInfoChain);
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            var returnTypeSymbol = signature.returnType;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.typeParameters[i], context);
                }
            }

            this.resolveAnyFunctionExpressionParameters(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, isContextuallyTyped, context);

            // Make sure there is no contextual type on the stack when resolving the block
            context.pushNewContextualType(null);
            if (block) {
                this.resolveAST(block, /*isContextuallyTyped:*/ false, context);
            }
            else {
                var bodyExpressionType = this.resolveReturnExpression(bodyExpression, functionDecl, context);
                this.typeCheckReturnExpression(bodyExpression, bodyExpressionType, functionDecl, context);
            }

            context.popAnyContextualType();

            this.checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(functionDecl, returnTypeAnnotation, returnTypeSymbol, block, context);

            this.validateVariableDeclarationGroups(functionDecl, context);

            this.typeCheckCallBacks.push(context => {
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            });
        }

        private resolveThisExpression(thisExpression: ISyntaxToken, context: PullTypeResolutionContext): PullSymbol {
            var enclosingDecl = this.getEnclosingDeclForAST(thisExpression);
            var thisTypeSymbol = this.getContextualClassSymbolForEnclosingDecl(thisExpression, enclosingDecl) || this.semanticInfoChain.anyTypeSymbol;

            if (this.canTypeCheckAST(thisExpression, context)) {
                this.typeCheckThisExpression(thisExpression, context, enclosingDecl);
            }

            return thisTypeSymbol;
        }

        private inTypeArgumentList(ast: ISyntaxElement): boolean {
            var previous: ISyntaxElement = null;
            var current = ast;
            
            while (current) {
                switch (current.kind()) {
                    case SyntaxKind.GenericType:
                        var genericType = <GenericTypeSyntax>current;
                        if (genericType.typeArgumentList === previous) {
                            return true;
                        }
                        break;

                    case SyntaxKind.ArgumentList:
                        var argumentList = <ArgumentListSyntax>current;
                        return argumentList.typeArgumentList === previous;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        }

        private inClassExtendsHeritageClause(ast: ISyntaxElement): boolean {
            while (ast) {
                switch (ast.kind()) {
                    case SyntaxKind.ExtendsHeritageClause:
                        var heritageClause = <HeritageClauseSyntax>ast;

                        // Heritage clause is parented by the heritage clause list.  Which is 
                        // parented by either a class or an interface.  So check the grandparent.
                        return heritageClause.parent.parent.kind() === SyntaxKind.ClassDeclaration;

                    case SyntaxKind.ConstructorDeclaration:
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ModuleDeclaration:
                        return false;
                }

                ast = ast.parent;
            }

            return false;
        }

        private inTypeQuery(ast: ISyntaxElement) {
            while (ast) {
                switch (ast.kind()) {
                    case SyntaxKind.TypeQuery:
                        return true;
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.InvocationExpression:
                    case SyntaxKind.ConstructorDeclaration:
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ModuleDeclaration:
                        return false;
                }

                ast = ast.parent;
            }

            return false;
        }

        private inArgumentListOfSuperInvocation(ast: ISyntaxElement): boolean {
            var previous: ISyntaxElement = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case SyntaxKind.InvocationExpression:
                        var invocationExpression = <InvocationExpressionSyntax>current;
                        if (previous === invocationExpression.argumentList &&
                            invocationExpression.expression.kind() === SyntaxKind.SuperKeyword) {
                                return true;
                        }
                        break;
                    
                    case SyntaxKind.ConstructorDeclaration:
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ModuleDeclaration:
                        return false;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        }

        private inConstructorParameterList(ast: ISyntaxElement): boolean {
            var previous: ISyntaxElement = null;
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case SyntaxKind.CallSignature:
                        var callSignature = <CallSignatureSyntax>current;
                        if (previous === callSignature.parameterList && callSignature.parent.kind() === SyntaxKind.ConstructorDeclaration) {
                            return true;
                        }

                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ModuleDeclaration:
                        return false;
                }

                previous = current;
                current = current.parent;
            }

            return false;
        }
        private isFunctionAccessorOrNonArrowFunctionExpression(decl: PullDecl): boolean {

            if (decl.kind === PullElementKind.GetAccessor || decl.kind === PullElementKind.SetAccessor) {
                return true;
            }

            return this.isFunctionOrNonArrowFunctionExpression(decl);
        }

        private isFunctionOrNonArrowFunctionExpression(decl: PullDecl): boolean {
            if (decl.kind === PullElementKind.Function) {
                return true;
            }
            else if (decl.kind === PullElementKind.FunctionExpression && !hasFlag(decl.flags, PullElementFlags.ArrowFunction)) {
                return true;
            }

            return false;
        }

        private typeCheckThisExpression(thisExpression: ISyntaxToken, context: PullTypeResolutionContext, enclosingDecl: PullDecl): void {
            this.checkForThisCaptureInArrowFunction(thisExpression);

            if (this.inConstructorParameterList(thisExpression)) {
                // October 11, 2013
                // Similar to functions, only the constructor implementation (and not 
                // constructor overloads) can specify default value expressions for optional
                // parameters.It is a compile - time error for such default value expressions
                //  to reference this. 
                //
                // Note: this applies for constructor parameters and constructor parameter 
                // properties.
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, DiagnosticCode.this_cannot_be_referenced_in_constructor_arguments));
                return;
            }

            // October 11, 2013
            // The type of this in an expression depends on the location in which the reference 
            // takes place:
            //      In a constructor, member function, member accessor, or member variable 
            //      initializer, this is of the class instance type of the containing class.
            //
            //      In a static function or static accessor, the type of this is the constructor 
            //      function type of the containing class.
            //
            //      In a function declaration or a standard function expression, this is of type Any.
            //
            //      In the global module, this is of type Any.
            //
            // In all other contexts it is a compile - time error to reference this.

            for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                if (this.isFunctionAccessorOrNonArrowFunctionExpression(currentDecl)) {
                    // 'this' is always ok in a function.  It just has the 'any' type.
                    return;
                }
                else if (currentDecl.kind === PullElementKind.Container || currentDecl.kind === PullElementKind.DynamicModule) {
                    if (currentDecl.getParentDecl() === null) {
                        // Legal in the global module.
                        return;
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, DiagnosticCode.this_cannot_be_referenced_within_module_bodies));
                        return;
                    }
                }
                else if (currentDecl.kind === PullElementKind.Enum)
                {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, DiagnosticCode.this_cannot_be_referenced_in_current_location));
                    return;
                }
                else if (currentDecl.kind === PullElementKind.ConstructorMethod) {
                    // October 11, 2013
                    // The first statement in the body of a constructor must be a super call if 
                    // both of the following are true:
                    //      The containing class is a derived class.
                    //      The constructor declares parameter properties or the containing class 
                    //      declares instance member variables with initializers.
                    // In such a required super call, it is a compile - time error for argument
                    // expressions to reference this.
                    if (this.inArgumentListOfSuperInvocation(thisExpression) &&
                        this.superCallMustBeFirstStatementInConstructor(currentDecl)) {

                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, DiagnosticCode.this_cannot_be_referenced_in_current_location));
                    }

                    // Otherwise, it's ok to access 'this' in a constructor.
                    return;
                }
                else if (currentDecl.kind === PullElementKind.Class) {
                    if (this.inStaticMemberVariableDeclaration(thisExpression)) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(thisExpression, DiagnosticCode.this_cannot_be_referenced_in_static_initializers_in_a_class_body));
                    }

                    // Legal use of 'this'.  
                    return;
                }
            }
        }

        private getContextualClassSymbolForEnclosingDecl(ast: ISyntaxElement, enclosingDecl: PullDecl): PullTypeSymbol {
            var declPath = enclosingDecl.getParentPath();

            // work back up the decl path, until you can find a class
            if (declPath.length) {
                var isStaticContext = false;

                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declFlags & PullElementFlags.Static) {
                        isStaticContext = true;
                    }
                    else if (declKind === PullElementKind.FunctionExpression && !hasFlag(declFlags, PullElementFlags.ArrowFunction)) {
                        return null;
                    }
                    else if (declKind === PullElementKind.Function) {
                        return null;
                    }
                    else if (declKind === PullElementKind.Class) {
                        if (this.inStaticMemberVariableDeclaration(ast)) {
                            return this.getNewErrorTypeSymbol();
                        }
                        else {
                            var classSymbol = <PullTypeSymbol>decl.getSymbol(this.semanticInfoChain);
                            if (isStaticContext) {
                                var constructorSymbol = classSymbol.getConstructorMethod();
                                return constructorSymbol.type;
                            }
                            else {
                                return classSymbol;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private inStaticMemberVariableDeclaration(ast: ISyntaxElement): boolean {
            while (ast) {
                if (ast.kind() === SyntaxKind.MemberVariableDeclaration && hasModifier((<MemberVariableDeclarationSyntax>ast).modifiers, PullElementFlags.Static)) {
                    return true;
                }

                ast = ast.parent;
            }

            return false;
        }

        private resolveSuperExpression(ast: ISyntaxToken, context: PullTypeResolutionContext): PullSymbol {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            var superType: PullTypeSymbol = this.semanticInfoChain.anyTypeSymbol;

            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(ast, enclosingDecl);

            if (classSymbol) {
                this.resolveDeclaredSymbol(classSymbol, context);

                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    superType = parents[0];
                }
            }

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSuperExpression(ast, context, enclosingDecl);
            }

            return superType;
        }

        private typeCheckSuperExpression(ast: ISyntaxElement, context: PullTypeResolutionContext, enclosingDecl: PullDecl) {
            this.setTypeChecked(ast, context);

            this.checkForThisCaptureInArrowFunction(ast);

            var isSuperCall = ast.parent.kind() === SyntaxKind.InvocationExpression;
            var isSuperPropertyAccess = ast.parent.kind() === SyntaxKind.MemberAccessExpression;
            Debug.assert(isSuperCall || isSuperPropertyAccess);

            if (isSuperPropertyAccess) {
                // October 11, 2013
                // Super property accesses are permitted as follows:
                //      In a constructor, instance member function, or instance member accessor of a 
                //      derived class, a super property access must specify a public instance member
                //      function of the base class.
                //
                //      In a static member function or static member accessor of a derived class, a 
                //      super property access must specify a public static member function of the base
                //      class.

                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (this.isFunctionOrNonArrowFunctionExpression(currentDecl)) {
                        // TODO: quote relevant spec section once it is in place.
                        // you can only access 'super' in places where 'this' is strongly typed 
                        // and of a derived class type
                        break;
                    }
                    else if (currentDecl.kind === PullElementKind.Class) {
                        // We're in some class member.  That's good.

                        if (!this.enclosingClassIsDerived(currentDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes));
                            return;
                        }
                        else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        }
                        else if (this.inStaticMemberVariableDeclaration(ast)) {
                            break;
                        }

                        // We've checked the bad cases, at this point we're good.
                        return;
                    }
                }
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class));
                return;
            }
            else {
                // October 11, 2013
                // Constructors of classes with no extends clause may not contain super calls, 
                // whereas constructors of derived classes must contain at least one super call 
                // somewhere in their function body. Super calls are not permitted outside 
                // constructors or in local functions inside constructors.
                // 
                // The first statement in the body of a constructor must be a super call if both 
                // of the following are true:
                //      The containing class is a derived class.
                //      The constructor declares parameter properties or the containing class 
                //      declares instance member variables with initializers.
                for (var currentDecl = enclosingDecl; currentDecl !== null; currentDecl = currentDecl.getParentDecl()) {
                    if (currentDecl.kind === PullElementKind.ConstructorMethod) {
                        // We were in a constructor.  That's good.
                        var classDecl = currentDecl.getParentDecl();

                        if (!this.enclosingClassIsDerived(classDecl)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes));
                            return;
                        }
                        else if (this.inConstructorParameterList(ast)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments));
                            return;
                        }

                        // Nothing wrong with how we were referenced.  Note: the check if we're the
                        // first statement in the constructor happens in typeCheckConstructorDeclaration.
                        return;
                    }
                    else if (this.isAnyFunctionExpressionOrDeclaration(currentDecl.ast())) {
                        break;
                    }
                }

                // SPEC NOV 18: Super calls are not permitted outside constructors or in local functions inside constructors.
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors));

            }
        }

        private resolveSimplePropertyAssignment(propertyAssignment: SimplePropertyAssignmentSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveAST(propertyAssignment.expression, isContextuallyTyped, context);
        }

        private resolveFunctionPropertyAssignment(funcProp: FunctionPropertyAssignmentSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            return this.resolveAnyFunctionExpression(
                funcProp, funcProp.callSignature.typeParameterList, ASTHelpers.parametersFromParameterList(funcProp.callSignature.parameterList),
                ASTHelpers.getType(funcProp), funcProp.block, /*bodyExpression:*/ null, isContextuallyTyped, context);
        }

        private typeCheckFunctionPropertyAssignment(funcProp: FunctionPropertyAssignmentSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext) {
            this.typeCheckAnyFunctionExpression(funcProp, funcProp.callSignature.typeParameterList,
                ASTHelpers.parametersFromParameterList(funcProp.callSignature.parameterList),
                ASTHelpers.getType(funcProp), funcProp.block, /*bodyExpression:*/ null, isContextuallyTyped, context);
        }

        public resolveObjectLiteralExpression(expressionAST: ObjectLiteralExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext, additionalResults?: PullAdditionalObjectLiteralResolutionData): PullSymbol {
            var symbol = this.getSymbolForAST(expressionAST, context);
            var hasResolvedSymbol = symbol && symbol.isResolved;

            if (!hasResolvedSymbol || additionalResults || this.canTypeCheckAST(expressionAST, context)) {
                if (this.canTypeCheckAST(expressionAST, context)) {
                    this.setTypeChecked(expressionAST, context);
                }
                symbol = this.computeObjectLiteralExpression(expressionAST, isContextuallyTyped, context, additionalResults);
                this.setSymbolForAST(expressionAST, symbol, context);
            }

            return symbol;
        }

        private bindObjectLiteralMembers(
                objectLiteralDeclaration: PullDecl,
                objectLiteralTypeSymbol: PullTypeSymbol,
                objectLiteralMembers: IPropertyAssignmentSyntax[],
                isUsingExistingSymbol: boolean,
                pullTypeContext: PullTypeResolutionContext): PullSymbol[]{

            var boundMemberSymbols: PullSymbol[] = [];
            var memberSymbol: PullSymbol;
            for (var i = 0, len = objectLiteralMembers.length; i < len; i++) {
                var propertyAssignment = objectLiteralMembers[i];

                var id = this.getPropertyAssignmentName(propertyAssignment);
                var assignmentText = getPropertyAssignmentNameTextFromIdentifier(id);

                var isAccessor = propertyAssignment.kind() === SyntaxKind.GetAccessor || propertyAssignment.kind() === SyntaxKind.SetAccessor;
                var decl = this.semanticInfoChain.getDeclForAST(propertyAssignment);
                Debug.assert(decl);

                if (propertyAssignment.kind() === SyntaxKind.SimplePropertyAssignment) {
                    if (!isUsingExistingSymbol) {
                        memberSymbol = new PullSymbol(assignmentText.memberName, PullElementKind.Property, this.semanticInfoChain);
                        memberSymbol.addDeclaration(decl);
                        decl.setSymbol(memberSymbol, this.semanticInfoChain);
                    }
                    else {
                        memberSymbol = decl.getSymbol(this.semanticInfoChain);
                    }
                }
                else if (propertyAssignment.kind() === SyntaxKind.FunctionPropertyAssignment) {
                    memberSymbol = decl.getSymbol(this.semanticInfoChain);
                }
                else {
                    Debug.assert(isAccessor);
                    memberSymbol = decl.getSymbol(this.semanticInfoChain);
                }

                if (!isUsingExistingSymbol && !isAccessor) {
                    // Make sure this was not defined before
                    var existingMember = objectLiteralTypeSymbol.findMember(memberSymbol.name, /*lookInParent*/ true);
                    if (existingMember) {
                        pullTypeContext.postDiagnostic(this.semanticInfoChain.duplicateIdentifierDiagnosticFromAST(propertyAssignment, assignmentText.actualText,
                            existingMember.getDeclarations()[0].ast()));
                    }

                    objectLiteralTypeSymbol.addMember(memberSymbol);
                }

                boundMemberSymbols.push(memberSymbol);
            }

            return boundMemberSymbols;
        }

        private resolveObjectLiteralMembers(
                objectLiteralDeclaration: PullDecl,
                objectLiteralTypeSymbol: PullTypeSymbol,
                objectLiteralContextualType: PullTypeSymbol,
                objectLiteralMembers: IPropertyAssignmentSyntax[],
                stringIndexerSignature: PullSignatureSymbol,
                numericIndexerSignature: PullSignatureSymbol,
                allMemberTypes: PullTypeSymbol[],
                allNumericMemberTypes: PullTypeSymbol[],
                boundMemberSymbols: PullSymbol[],
                isUsingExistingSymbol: boolean,
                pullTypeContext: PullTypeResolutionContext,
                additionalResults?: PullAdditionalObjectLiteralResolutionData) {

            for (var i = 0, len = objectLiteralMembers.length; i < len; i++) {
                var propertyAssignment = objectLiteralMembers[i];
                
                var acceptedContextualType = false;
                var assigningSymbol: PullSymbol = null;

                var id = this.getPropertyAssignmentName(propertyAssignment);
                var memberSymbol = boundMemberSymbols[i];
                var contextualMemberType: PullTypeSymbol = null;

                if (objectLiteralContextualType) {
                    assigningSymbol = this.getNamedPropertySymbol(memberSymbol.name, PullElementKind.SomeValue, objectLiteralContextualType);

                    // Consider index signatures as potential contextual types
                    if (!assigningSymbol) {
                        if (numericIndexerSignature && PullHelpers.isNameNumeric(memberSymbol.name)) {
                            assigningSymbol = numericIndexerSignature;
                        }
                        else if (stringIndexerSignature) {
                            assigningSymbol = stringIndexerSignature;
                        }
                    }

                    if (assigningSymbol) {
                        this.resolveDeclaredSymbol(assigningSymbol, pullTypeContext);

                        contextualMemberType = assigningSymbol.kind === PullElementKind.IndexSignature ? (<PullSignatureSymbol>assigningSymbol).returnType : assigningSymbol.type;
                        pullTypeContext.propagateContextualType(contextualMemberType);

                        acceptedContextualType = true;

                        if (additionalResults) {
                            additionalResults.membersContextTypeSymbols[i] = contextualMemberType;
                        }
                    }
                }

                var memberSymbolType = this.resolveAST(propertyAssignment, contextualMemberType !== null, pullTypeContext).type;

                if (memberSymbolType) {
                    if (memberSymbolType.isGeneric()) {
                        objectLiteralTypeSymbol.setHasGenericMember();
                    }

                    // Add the member to the appropriate member type lists to compute the type of the synthesized index signatures
                    if (stringIndexerSignature) {
                        allMemberTypes.push(memberSymbolType);
                    }
                    if (numericIndexerSignature && PullHelpers.isNameNumeric(memberSymbol.name)) {
                        allNumericMemberTypes.push(memberSymbolType);
                    }
                }

                if (acceptedContextualType) {
                    pullTypeContext.popAnyContextualType();
                }

                var isAccessor = propertyAssignment.kind() === SyntaxKind.SetAccessor || propertyAssignment.kind() === SyntaxKind.GetAccessor;
                if (!memberSymbol.isResolved) {
                    if (isAccessor) {
                        this.setSymbolForAST(id, memberSymbolType, pullTypeContext);
                    }
                    else {
                        pullTypeContext.setTypeInContext(memberSymbol, memberSymbolType);
                        memberSymbol.setResolved();

                        this.setSymbolForAST(id, memberSymbol, pullTypeContext);
                    }
                }
            }
        }

        // if there's no type annotation on the assigning ISyntaxElement, we need to create a type from each binary expression
        // in the object literal
        private computeObjectLiteralExpression(
            objectLitAST: ObjectLiteralExpressionSyntax,
            isContextuallyTyped: boolean,
            context: PullTypeResolutionContext,
            additionalResults?: PullAdditionalObjectLiteralResolutionData): PullSymbol {
            // PULLTODO: Create a decl for the object literal

            // walk the members of the object literal,
            // create fields for each based on the value assigned in

            var objectLitDecl = this.semanticInfoChain.getDeclForAST(objectLitAST);
            Debug.assert(objectLitDecl);

            var typeSymbol = <PullTypeSymbol>this.getSymbolForAST(objectLitAST, context);
            var isUsingExistingSymbol = !!typeSymbol;

            if (!typeSymbol) {
                // TODO: why don't se just use the normal symbol binder for this?
                typeSymbol = new PullTypeSymbol("", PullElementKind.ObjectLiteral, this.semanticInfoChain);
                typeSymbol.addDeclaration(objectLitDecl);
                this.setSymbolForAST(objectLitAST, typeSymbol, context);
                objectLitDecl.setSymbol(typeSymbol, this.semanticInfoChain);
            }

            var propertyAssignments = objectLitAST.propertyAssignments;
            var contextualType: PullTypeSymbol = null;

            if (isContextuallyTyped) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, context);
            }

            var stringIndexerSignature: PullSignatureSymbol = null;
            var numericIndexerSignature: PullSignatureSymbol = null;
            var allMemberTypes: PullTypeSymbol[] = null;
            var allNumericMemberTypes: PullTypeSymbol[] = null;
             
            // Get the index signatures for contextual typing
            if (contextualType) {
                var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(contextualType, context);

                stringIndexerSignature = indexSignatures.stringSignature;
                numericIndexerSignature = indexSignatures.numericSignature;

                // Start collecting the types of all the members so we can stamp the object
                // literal with the proper index signatures
                // October 16, 2013: Section 4.12.2: Where a contextual type would be included
                // in a candidate set for a best common type(such as when inferentially typing
                // an object or array literal), an inferential type is not.
                var inInferentialTyping = context.isInferentiallyTyping();
                if (stringIndexerSignature) {
                    allMemberTypes = inInferentialTyping ? [] : [stringIndexerSignature.returnType];
                }

                if (numericIndexerSignature) {
                    allNumericMemberTypes = inInferentialTyping ? [] : [numericIndexerSignature.returnType];
                }
            }

            if (propertyAssignments) {

                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }

                // first bind decls and symbols
                var boundMemberSymbols = this.bindObjectLiteralMembers(
                    objectLitDecl, typeSymbol, propertyAssignments, isUsingExistingSymbol, context);

                // now perform member symbol resolution
                this.resolveObjectLiteralMembers(
                    objectLitDecl,
                    typeSymbol,
                    contextualType,
                    propertyAssignments,
                    stringIndexerSignature,
                    numericIndexerSignature,
                    allMemberTypes,
                    allNumericMemberTypes,
                    boundMemberSymbols,
                    isUsingExistingSymbol,
                    context,
                    additionalResults);

                if (!isUsingExistingSymbol) {
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allMemberTypes, stringIndexerSignature, context);
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allNumericMemberTypes, numericIndexerSignature, context);
                }
            }

            typeSymbol.setResolved();
            return typeSymbol;
        }

        private getPropertyAssignmentName(propertyAssignment: ISyntaxElement): ISyntaxElement {
            if (propertyAssignment.kind() === SyntaxKind.SimplePropertyAssignment) {
                return (<SimplePropertyAssignmentSyntax>propertyAssignment).propertyName;
            }
            else if (propertyAssignment.kind() === SyntaxKind.FunctionPropertyAssignment) {
                return (<FunctionPropertyAssignmentSyntax>propertyAssignment).propertyName;
            }
            else if (propertyAssignment.kind() === SyntaxKind.GetAccessor) {
                return (<GetAccessorSyntax>propertyAssignment).propertyName;
            }
            else if (propertyAssignment.kind() === SyntaxKind.SetAccessor) {
                return (<SetAccessorSyntax>propertyAssignment).propertyName;
            }
            else {
                Debug.assert(false);
            }
        }

        private stampObjectLiteralWithIndexSignature(objectLiteralSymbol: PullTypeSymbol, indexerTypeCandidates: PullTypeSymbol[],
            contextualIndexSignature: PullSignatureSymbol, context: PullTypeResolutionContext): void {
            if (contextualIndexSignature) {
                var typeCollection: IPullTypeCollection = {
                    getLength: () => indexerTypeCandidates.length,
                    getTypeAtIndex: (index: number) => indexerTypeCandidates[index]
                };
                var decl = objectLiteralSymbol.getDeclarations()[0];
                var indexerReturnType = this.findBestCommonType(typeCollection, context).widenedType(this, /*ast*/ null, context);
                if (indexerReturnType === contextualIndexSignature.returnType) {
                    objectLiteralSymbol.addIndexSignature(contextualIndexSignature);
                }
                else {
                    // Create an index signature
                    this.semanticInfoChain.addSyntheticIndexSignature(decl, objectLiteralSymbol, this.getASTForDecl(decl),
                        contextualIndexSignature.parameters[0].name, /*indexParamType*/ contextualIndexSignature.parameters[0].type, /*returnType*/ indexerReturnType);
                }
            }
        }

        private resolveArrayLiteralExpression(arrayLit: ArrayLiteralExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            var symbol = this.getSymbolForAST(arrayLit, context);
            if (!symbol || this.canTypeCheckAST(arrayLit, context)) {
                if (this.canTypeCheckAST(arrayLit, context)) {
                    this.setTypeChecked(arrayLit, context);
                }
                symbol = this.computeArrayLiteralExpressionSymbol(arrayLit, isContextuallyTyped, context);
                this.setSymbolForAST(arrayLit, symbol, context);
            }

            return symbol;
        }

        private computeArrayLiteralExpressionSymbol(arrayLit: ArrayLiteralExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            var elements = arrayLit.expressions;
            var elementType: PullTypeSymbol = null;
            var elementTypes: PullTypeSymbol[] = [];
            var comparisonInfo = new TypeComparisonInfo();
            var contextualElementType: PullTypeSymbol = null;
            comparisonInfo.onlyCaptureFirstError = true;

            // if the target type is an array type, extract the element type
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);

                if (contextualType) {
                    // Get the number indexer if it exists
                    var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(contextualType, context);
                    if (indexSignatures.numericSignature) {
                        contextualElementType = indexSignatures.numericSignature.returnType;
                    }
                }
            }

            // Resolve element types
            if (elements) {
                if (contextualElementType) {
                    context.propagateContextualType(contextualElementType);
                }

                for (var i = 0, n = elements.length; i < n; i++) {
                    elementTypes.push(this.resolveAST(elements[i], contextualElementType !== null, context).type);
                }

                if (contextualElementType) {
                    context.popAnyContextualType();
                }
            }

            // If there is no contextual type to apply attempt to find the best common type
            if (elementTypes.length) {
                elementType = elementTypes[0];
            }
            var collection: IPullTypeCollection;
            // October 16, 2013: Section 4.12.2: Where a contextual type would be included
            // in a candidate set for a best common type(such as when inferentially typing
            // an object or array literal), an inferential type is not.
            if (contextualElementType && !context.isInferentiallyTyping()) {
                if (!elementType) { // we have an empty array
                    elementType = contextualElementType;
                }
                // Add the contextual type to the collection as one of the types to be considered for best common type
                collection = {
                    getLength: () => { return elements.length + 1; },
                    getTypeAtIndex: (index: number) => { return index === 0 ? contextualElementType : elementTypes[index - 1]; }
                };
            }
            else {
                collection = {
                    getLength: () => { return elements.length; },
                    getTypeAtIndex: (index: number) => { return elementTypes[index]; }
                };
            }

            elementType = elementType ? this.findBestCommonType(collection, context, comparisonInfo) : elementType;

            if (!elementType) {
                elementType = this.semanticInfoChain.undefinedTypeSymbol;
            }

            return this.getArrayType(elementType);
        }

        private resolveElementAccessExpression(callEx: ElementAccessExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            var symbolAndDiagnostic = this.computeElementAccessExpressionSymbolAndDiagnostic(callEx, context);

            if (this.canTypeCheckAST(callEx, context)) {
                this.typeCheckElementAccessExpression(callEx, context, symbolAndDiagnostic);
            }

            return symbolAndDiagnostic.symbol;
        }

        private typeCheckElementAccessExpression(callEx: ElementAccessExpressionSyntax, context: PullTypeResolutionContext, symbolAndDiagnostic: { symbol: PullSymbol; diagnostic?: Diagnostic }): void {
            this.setTypeChecked(callEx, context);
            context.postDiagnostic(symbolAndDiagnostic.diagnostic);
        }

        private computeElementAccessExpressionSymbolAndDiagnostic(callEx: ElementAccessExpressionSyntax, context: PullTypeResolutionContext): { symbol: PullSymbol; diagnostic?: Diagnostic } {
            // resolve the target
            var targetSymbol = this.resolveAST(callEx.expression, /*isContextuallyTyped:*/ false, context);
            var indexType = this.resolveAST(callEx.argumentExpression, /*isContextuallyTyped:*/ false, context).type;

            var targetTypeSymbol = targetSymbol.type;

            targetTypeSymbol = this.getApparentType(targetTypeSymbol);

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return { symbol: targetTypeSymbol }
            }

            var elementType = targetTypeSymbol.getElementType();

            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || PullHelpers.symbolIsEnum(indexType);

            if (elementType && isNumberIndex) {
                return { symbol: elementType };
            }

            // if the index expression is a string literal or a numberic literal and the object expression has
            // a property with that name,  the property access is the type of that property
            if (callEx.argumentExpression.kind() === SyntaxKind.StringLiteral || callEx.argumentExpression.kind() === SyntaxKind.NumericLiteral) {
                var memberName = callEx.argumentExpression.kind() === SyntaxKind.StringLiteral
                    ? stripStartAndEndQuotes((<ISyntaxToken>callEx.argumentExpression).text())
                    : tokenValueText((<ISyntaxToken>callEx.argumentExpression));

                // November 18, 2013, Section 4.10:
                // If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type
                // has a property with the name given by that literal(converted to its string representation
                // in the case of a numeric literal), the property access is of the type of that property.
                // Note that here we are assuming the apparent type is already accounted for up to
                // augmentation. So we just check the augmented type.
                var member = this._getNamedPropertySymbolOfAugmentedType(memberName, targetTypeSymbol);

                if (member) {
                    this.resolveDeclaredSymbol(member, context);

                    return { symbol: member.type };
                }
            }

            var signatures = this.getBothKindsOfIndexSignaturesIncludingAugmentedType(targetTypeSymbol, context);

            var stringSignature = signatures.stringSignature;
            var numberSignature = signatures.numericSignature;

            // otherwise, if the object expression has a numeric index signature and the index expression is
            // of type Any, the Number primitive type or an enum type, the property access is of the type of that index
            // signature
            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                return { symbol: numberSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            }
            // otherwise, if the object expression has a string index signature and the index expression is
            // of type Any, the String or Number primitive type or an enum type, the property access of the type of
            // that index signature
            else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                return { symbol: stringSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            }
            // otherwise, if indexExpr is of type Any, the String or Number primitive type or an enum type,
            // the property access is of type Any
            else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                if (this.compilationSettings.noImplicitAny()) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(callEx.argumentExpression, DiagnosticCode.Index_signature_of_object_type_implicitly_has_an_any_type));
                }
                return { symbol: this.semanticInfoChain.anyTypeSymbol };
            }
            // otherwise, the property acess is invalid and a compile-time error occurs
            else {
                return {
                    symbol: this.getNewErrorTypeSymbol(),
                    diagnostic: this.semanticInfoChain.diagnosticFromAST(callEx, DiagnosticCode.Value_of_type_0_is_not_indexable_by_type_1, [targetTypeSymbol.toString(), indexType.toString()])
                }
            }
        }

        private getBothKindsOfIndexSignaturesIncludingAugmentedType(enclosingType: PullTypeSymbol, context: PullTypeResolutionContext): IndexSignatureInfo {
            return this._getBothKindsOfIndexSignatures(enclosingType, context, /*includeAugmentedType*/ true);
        }

        private getBothKindsOfIndexSignaturesExcludingAugmentedType(enclosingType: PullTypeSymbol, context: PullTypeResolutionContext): IndexSignatureInfo {
            return this._getBothKindsOfIndexSignatures(enclosingType, context, /*includeAugmentedType*/ false);
        }

        public _getBothKindsOfIndexSignatures(enclosingType: PullTypeSymbol, context: PullTypeResolutionContext, includeAugmentedType: boolean): IndexSignatureInfo {
            var signatures = includeAugmentedType
                ? enclosingType.getIndexSignaturesOfAugmentedType(this, this.cachedFunctionInterfaceType(), this.cachedObjectInterfaceType())
                : enclosingType.getIndexSignatures();

            var stringSignature: PullSignatureSymbol = null;
            var numberSignature: PullSignatureSymbol = null;
            var signature: PullSignatureSymbol = null;
            var paramSymbols: PullSymbol[];
            var paramType: PullTypeSymbol;

            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }

                signature = signatures[i];
                if (!signature.isResolved) {
                    this.resolveDeclaredSymbol(signature, context);
                }

                paramSymbols = signature.parameters;

                if (paramSymbols.length) {
                    paramType = paramSymbols[0].type;

                    if (!stringSignature && paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signature;
                        continue;
                    }
                    else if (!numberSignature && paramType === this.semanticInfoChain.numberTypeSymbol) {
                        numberSignature = signature;
                        continue;
                    }
                }
            }

            return {
                numericSignature: numberSignature,
                stringSignature: stringSignature
            };
        }

        // This method can be called to get unhidden (not shadowed by a signature in derived class)
        // signatures from a set of base class signatures. Can be used for signatures of any kind.
        // October 16, 2013: Section 7.1:
        // A call signature declaration hides a base type call signature that is identical when
        // return types are ignored.
        // A construct signature declaration hides a base type construct signature that is
        // identical when return types are ignored.
        // A string index signature declaration hides a base type string index signature.
        // A numeric index signature declaration hides a base type numeric index signature.
        public _addUnhiddenSignaturesFromBaseType(
            derivedTypeSignatures: PullSignatureSymbol[],
            baseTypeSignatures: PullSignatureSymbol[],
            signaturesBeingAggregated: PullSignatureSymbol[]) {
            // If there are no derived type signatures, none of the base signatures will be hidden.
            if (!derivedTypeSignatures) {
                signaturesBeingAggregated.push.apply(signaturesBeingAggregated, baseTypeSignatures);
                return;
            }

            var context = new PullTypeResolutionContext(this);
            for (var i = 0; i < baseTypeSignatures.length; i++) {
                var baseSignature = baseTypeSignatures[i];
                // If it is different from every signature in the derived type (modulo
                // return types, add it to the list)
                var signatureIsHidden = ArrayUtilities.any(derivedTypeSignatures, sig =>
                    this.signaturesAreIdenticalWithNewEnclosingTypes(baseSignature, sig, context, /*includingReturnType*/ false));

                if (!signatureIsHidden) {
                    signaturesBeingAggregated.push(baseSignature);
                }
            }
        }

        private resolveBinaryAdditionOperation(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            var lhsExpression = this.resolveAST(binaryExpression.left, /*isContextuallyTyped*/ false, context);
            var lhsType = lhsExpression.type;
            var rhsType = this.resolveAST(binaryExpression.right, /*isContextuallyTyped*/ false, context).type;

            // November 18, 2013
            // 4.15.2 The + operator 
            // The binary + operator requires both operands to be of the Number primitive type or an enum type, or at least one of the operands to be of type Any or the String primitive type. 
            // Operands of an enum type are treated as having the primitive type Number.
            // If one operand is the null or undefined value, it is treated as having the type of the other operand. 
            if (PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            }

            var isLhsTypeNullOrUndefined = lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol;
            var isRhsTypeNullOrUndefined = rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol;

            if (isLhsTypeNullOrUndefined) {
                if (isRhsTypeNullOrUndefined) {
                    lhsType = rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
                else {
                    lhsType = rhsType;
                }
            }
            else if (isRhsTypeNullOrUndefined) {
                rhsType = lhsType;
            }

            var exprType: PullTypeSymbol = null;

            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            }
            else if (this.isAnyOrEquivalent(lhsType) || this.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }
            else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);

                if (exprType) {
                    if (binaryExpression.kind() === SyntaxKind.AddAssignmentExpression) {
                        // Check if LHS is a valid target
                        if (!this.isReference(binaryExpression.left, lhsExpression)) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                        }

                        this.checkAssignability(binaryExpression.left, exprType, lhsType, context);
                    }
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.Invalid_expression_types_not_known_to_support_the_addition_operator));
                }
            }

            if (!exprType) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }

            return exprType;
        }

        private bestCommonTypeOfTwoTypes(type1: PullTypeSymbol, type2: PullTypeSymbol, context: PullTypeResolutionContext): PullTypeSymbol {
            return this.findBestCommonType({
                getLength() {
                    return 2;
                },
                getTypeAtIndex(index: number) {
                    switch (index) {
                        case 0: return type1;
                        case 1: return type2;
                    }
                }
            }, context);
        }

        private bestCommonTypeOfThreeTypes(type1: PullTypeSymbol, type2: PullTypeSymbol, type3: PullTypeSymbol, context: PullTypeResolutionContext): PullTypeSymbol {
            return this.findBestCommonType({
                getLength() {
                    return 3;
                },
                getTypeAtIndex(index: number) {
                    switch (index) {
                        case 0: return type1;
                        case 1: return type2;
                        case 2: return type3;
                    }
                }
            }, context);
        }

        private resolveLogicalOrExpression(binex: BinaryExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            // October 11, 2013:  
            // The || operator permits the operands to be of any type.
            if (this.canTypeCheckAST(binex, context)) {
                // So there's no type checking we actually have to do.
                this.setTypeChecked(binex, context);
            }

            if (isContextuallyTyped) {
                // If the || expression is contextually typed(section 4.19), the operands are 
                // contextually typed by the same type and the result is of the best common type 
                // (section 3.10) of the contextual type and the two operand types.

                var contextualType = context.getContextualType();
                var leftType = this.resolveAST(binex.left, isContextuallyTyped, context).type;
                var rightType = this.resolveAST(binex.right, isContextuallyTyped, context).type;

                return context.isInferentiallyTyping() ?
                    this.bestCommonTypeOfTwoTypes(leftType, rightType, context):
                    this.bestCommonTypeOfThreeTypes(contextualType, leftType, rightType, context);
            }
            else {
                // If the || expression is not contextually typed, the right operand is contextually 
                // typed by the type of the left operand and the result is of the best common type of 
                // the two operand types.
                var leftType = this.resolveAST(binex.left, /*isContextuallyTyped:*/ false, context).type;

                context.pushNewContextualType(leftType);
                var rightType = this.resolveAST(binex.right, /*isContextuallyTyped:*/ true, context).type;
                context.popAnyContextualType();

                return this.bestCommonTypeOfTwoTypes(leftType, rightType, context);
            }
        }

        private resolveLogicalAndExpression(binex: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(binex, context)) {
                this.setTypeChecked(binex, context);

                this.resolveAST(binex.left, /*isContextuallyTyped:*/ false, context);
            }

            // September 17, 2013: The && operator permits the operands to be of any type and 
            // produces a result of the same type as the second operand.
            return this.resolveAST(binex.right, /*isContextuallyTyped:*/ false, context).type;
        }

        private computeTypeOfConditionalExpression(leftType: PullTypeSymbol, rightType: PullTypeSymbol, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullTypeSymbol {
            if (isContextuallyTyped && !context.isInferentiallyTyping()) {
                // October 11, 2013
                // If the conditional expression is contextually typed (section 4.19), Expr1 and Expr2 
                // are contextually typed by the same type and the result is of the best common type 
                // (section 3.10) of the contextual type and the types of Expr1 and Expr2. 
                var contextualType = context.getContextualType();
                return this.bestCommonTypeOfThreeTypes(contextualType, leftType, rightType, context);
            }
            else {
                // October 11, 2013
                // If the conditional expression is not contextually typed, the result is of the 
                // best common type of the types of Expr1 and Expr2. 
                return this.bestCommonTypeOfTwoTypes(leftType, rightType, context);
            }
        }

        private resolveConditionalExpression(trinex: ConditionalExpressionSyntax, isContextuallyTyped: boolean, context: PullTypeResolutionContext): PullSymbol {
            // October 11, 2013
            // If the conditional expression is contextually typed (section 4.19), Expr1 and Expr2 
            // are contextually typed by the same type and the result is of the best common type
            // (section 3.10) of the contextual type and the types of Expr1 and Expr2.  An error 
            // occurs if the best common type is not identical to at least one of the three 
            // candidate types.
            var leftType = this.resolveAST(trinex.whenTrue, isContextuallyTyped, context).type;
            var rightType = this.resolveAST(trinex.whenFalse, isContextuallyTyped, context).type;

            var expressionType = this.computeTypeOfConditionalExpression(leftType, rightType, isContextuallyTyped, context);

            var conditionalTypesAreValid = this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context);

            if (this.canTypeCheckAST(trinex, context)) {
                this.setTypeChecked(trinex, context);
                this.resolveAST(trinex.condition, /*isContextuallyTyped:*/ false, context);

                if (!this.conditionExpressionTypesAreValid(leftType, rightType, expressionType, isContextuallyTyped, context)) {
                    if (isContextuallyTyped) {
                        var contextualType = context.getContextualType();
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex,
                            DiagnosticCode.Type_of_conditional_0_must_be_identical_to_1_2_or_3,
                            [expressionType.toString(), leftType.toString(), rightType.toString(), contextualType.toString()]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(trinex,
                            DiagnosticCode.Type_of_conditional_0_must_be_identical_to_1_or_2,
                            [expressionType.toString(), leftType.toString(), rightType.toString()]));
                    }
                }
            }

            // If the conditional is not valid, then return an error symbol.  That way we won't 
            // report further errors higher up the stack.
            if (!conditionalTypesAreValid) {
                return this.getNewErrorTypeSymbol();
            }

            return expressionType;
        }

        private conditionExpressionTypesAreValid(leftType: PullTypeSymbol, rightType: PullTypeSymbol, expressionType: PullTypeSymbol, isContextuallyTyped: boolean, context: PullTypeResolutionContext): boolean {
            if (isContextuallyTyped) {
                var contextualType = context.getContextualType();
                if (this.typesAreIdentical(expressionType, leftType, context) ||
                    this.typesAreIdentical(expressionType, rightType, context) ||
                    this.typesAreIdentical(expressionType, contextualType, context)) {

                    return true;
                }
            }
            else {
                if (this.typesAreIdentical(expressionType, leftType, context) ||
                    this.typesAreIdentical(expressionType, rightType, context)) {

                    return true;
                }
            }

            return false;
        }

        private resolveParenthesizedExpression(ast: ParenthesizedExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
            }

            // September 17, 2013: A parenthesized expression (Expression) has the same type and 
            // classification as the Expression itself
            return this.resolveAST(ast.expression, /*isContextuallyTyped*/ false, context);
        }

        private resolveExpressionStatement(ast: ExpressionStatementSyntax, context: PullTypeResolutionContext): PullSymbol {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);

                this.resolveAST(ast.expression, /*isContextuallyTyped:*/ false, context);
            }

            // All statements have the 'void' type.
            return this.semanticInfoChain.voidTypeSymbol;
        }

        public resolveInvocationExpression(callEx: InvocationExpressionSyntax, context: PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): PullSymbol {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeInvocationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                if (symbol !== this.semanticInfoChain.anyTypeSymbol) {
                    this.setSymbolForAST(callEx, symbol, context);
                }
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            }
            else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckInvocationExpression(callEx, context);
                }

                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData !== additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }

            return symbol;
        }

        private typeCheckInvocationExpression(callEx: InvocationExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(callEx, context);
            var targetSymbol = this.resolveAST(callEx.expression, /*isContextuallyTyped:*/ false, context);

            if (callEx.argumentList.arguments) {
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);

                var len = callEx.argumentList.arguments.length;
                for (var i = 0; i < len; i++) {
                    // Ensure call resolution data contains additional information. 
                    // Actual parameters context type symbols will be undefined if the call target resolves to any or error types.
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            // Post errors when resolving overload
            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        }

        private computeInvocationExpressionSymbol(callEx: InvocationExpressionSyntax, context: PullTypeResolutionContext, additionalResults: PullAdditionalCallResolutionData): PullSymbol {
            // resolve the target
            var targetSymbol = this.resolveAST(callEx.expression, /*isContextuallyTyped:*/ false, context);
            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var targetTypeSymbol = targetSymbol.type;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                // Note: targetType is either any or an error.

                // resolve any arguments.
                this.resolveAST(callEx.argumentList.arguments, /*isContextuallyTyped:*/ false, context);

                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                    // Can't invoke 'any' generically.
                    if (targetTypeSymbol === this.semanticInfoChain.anyTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Untyped_function_calls_may_not_accept_type_arguments),
                            additionalResults, context);
                        return this.getNewErrorTypeSymbol();
                    }

                    // Note: if we get here, targetType is an error type.  In that case we don't
                    // want to report *another* error since the user will have already gotten 
                    // the first error about the target not resolving properly.
                }

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var isSuperCall = false;

            if (callEx.expression.kind() === SyntaxKind.SuperKeyword) {

                isSuperCall = true;

                if (targetTypeSymbol.isClass()) {
                    targetSymbol = targetTypeSymbol.getConstructorMethod();
                    this.resolveDeclaredSymbol(targetSymbol, context);
                    targetTypeSymbol = targetSymbol.type;
                }
                else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Calls_to_super_are_only_valid_inside_a_class),
                        additionalResults, context);
                    this.resolveAST(callEx.argumentList.arguments, /*isContextuallyTyped:*/ false, context);
                    // POST diagnostics
                    return this.getNewErrorTypeSymbol();
                }
            }

            var signatures = isSuperCall ? targetTypeSymbol.getConstructSignatures() : targetTypeSymbol.getCallSignatures();

            if (!signatures.length && (targetTypeSymbol.kind === PullElementKind.ConstructorType)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, [targetTypeSymbol.toString()]),
                    additionalResults, context);
            }

            var explicitTypeArgs: PullTypeSymbol[] = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint: boolean;
            var constraintDiagnostic: Diagnostic = null;
            var typeArgumentCountDiagnostic: Diagnostic = null;
            var diagnostics: Diagnostic[] = [];

            // resolve the type arguments, specializing if necessary
            if (callEx.argumentList.typeArgumentList) {

                // specialize the type arguments
                explicitTypeArgs = [];

                if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                    for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.length; i++) {
                        explicitTypeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments[i], context);
                    }
                }
            }
            
            var triedToInferTypeArgs: boolean = false;

            // next, walk the available signatures
            // if any are generic, and we don't have type arguments, try to infer
            // otherwise, try to specialize to the type arguments above

            var resolvedSignatures: PullSignatureSymbol[] = [];
            var inferredOrExplicitTypeArgs: PullTypeSymbol[];
            var specializedSignature: PullSignatureSymbol;
            var typeParameters: PullTypeParameterSymbol[];
            var typeConstraint: PullTypeSymbol = null;
            var beforeResolutionSignatures = signatures;
            var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterSubstitutionMap();

            for (var i = 0; i < signatures.length; i++) {
                typeParameters = signatures[i].getTypeParameters();
                couldNotAssignToConstraint = false;

                if (signatures[i].isGeneric() && typeParameters.length) {
                    // If it is a constructor call, the type arguments are that of the return Type that is the super type
                    if (isSuperCall && targetTypeSymbol.isGeneric() && !callEx.argumentList.typeArgumentList) {
                        explicitTypeArgs = signatures[i].returnType.getTypeArguments();
                    }

                    if (explicitTypeArgs) {
                        // October 16, 2013: Section 4.12.2
                        // A generic signature is a candidate in a function call with type arguments
                        // arguments when:
                        // The signature has the same number of type parameters as were supplied in
                        // the type argument list
                        // ...
                        if (explicitTypeArgs.length === typeParameters.length) {
                            inferredOrExplicitTypeArgs = explicitTypeArgs;
                        }
                        else {
                            typeArgumentCountDiagnostic = typeArgumentCountDiagnostic ||
                            this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead,
                                [typeParameters.length, explicitTypeArgs.length]);
                            continue;
                        }
                    }
                    else {
                        Debug.assert(callEx.argumentList);
                        var typeArgumentInferenceContext = new InvocationTypeArgumentInferenceContext(this, context, signatures[i], callEx.argumentList);
                        inferredOrExplicitTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);
                        triedToInferTypeArgs = true;
                    }

                    // if we could infer Args, or we have type arguments, then attempt to specialize the signature
                    Debug.assert(inferredOrExplicitTypeArgs && inferredOrExplicitTypeArgs.length == typeParameters.length);
                    // When specializing the constraints, seed the replacement map with any substitutions already specified by
                    // the target function's type
                    var mutableTypeReplacementMap = new PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(targetTypeReplacementMap ? targetTypeReplacementMap : []);
                    PullInstantiationHelpers.updateMutableTypeParameterSubstitutionMap(typeParameters, inferredOrExplicitTypeArgs, mutableTypeReplacementMap);
                    var typeReplacementMap = mutableTypeReplacementMap.typeParameterSubstitutionMap;

                    if (explicitTypeArgs) {
                        for (var j = 0; j < typeParameters.length; j++) {
                            typeConstraint = typeParameters[j].getConstraint();

                            // test specialization type for assignment compatibility with the constraint
                            if (typeConstraint) {
                                if (typeConstraint.isGeneric()) {
                                    typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                }

                                // Section 3.4.2 (November 18, 2013): 
                                // A type argument satisfies a type parameter constraint if the type argument is assignable
                                // to(section 3.8.4) the constraint type once type arguments are substituted for type parameters.
                                if (!this.sourceIsAssignableToTarget(inferredOrExplicitTypeArgs[j], typeConstraint, targetAST, context, /*comparisonInfo:*/ null, /*isComparingInstantiatedSignatures:*/ true)) {
                                    var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                    constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredOrExplicitTypeArgs[j].toString(enclosingSymbol, /*useConstraintInName*/ true), typeConstraint.toString(enclosingSymbol, /*useConstraintInName*/ true), typeParameters[j].toString(enclosingSymbol, /*useConstraintInName*/ true)]);
                                    couldNotAssignToConstraint = true;
                                }

                                if (couldNotAssignToConstraint) {
                                    break;
                                }
                            }
                        }
                    }

                    if (couldNotAssignToConstraint) {
                        continue;
                    }

                    specializedSignature = this.instantiateSignature(signatures[i], typeReplacementMap);

                    if (specializedSignature) {
                        resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                    }
                }
                else {
                    if (!(callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length)) {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
            }

            if (signatures.length && !resolvedSignatures.length) {
                couldNotFindGenericOverload = true;
            }

            signatures = resolvedSignatures;

            var errorCondition: PullSymbol = null;
            if (!signatures.length) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;

                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                this.resolveAST(callEx.argumentList.arguments, /*isContextuallyTyped:*/ false, context);

                // if there are no call signatures, but the target is assignable to 'Function', return 'any'
                if (!couldNotFindGenericOverload) {
                    // if there are no call signatures, but the target is assignable to 'Function', return 'any'
                    if (this.cachedFunctionInterfaceType() && this.sourceIsAssignableToTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), targetAST, context)) {
                        if (callEx.argumentList.typeArgumentList) {
                            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments),
                                additionalResults, context);
                        }
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature),
                        additionalResults, context);
                }
                else if (constraintDiagnostic) {
                    this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                }
                else if (typeArgumentCountDiagnostic) {
                    this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                }
                else {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx, DiagnosticCode.Could_not_select_overload_for_call_expression),
                        additionalResults, context);
                }

                return this.getNewErrorTypeSymbol();
            }

            var signature = this.resolveOverloads(callEx, signatures, callEx.argumentList.typeArgumentList !== null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;

            if (!signature) {
                for (var i = 0; i < diagnostics.length; i++) {
                    this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                }

                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Could_not_select_overload_for_call_expression),
                    additionalResults, context);

                // Remember the error state
                // POST diagnostics
                errorCondition = this.getNewErrorTypeSymbol();

                if (!signatures.length) {
                    return errorCondition;
                }

                // Attempt to recover from the error condition
                // First, pick the first signature as the candidate signature
                signature = signatures[0];
            }

            var rootSignature = <PullSignatureSymbol>signature.getRootSymbol();
            if (!rootSignature.isGeneric() && callEx.argumentList.typeArgumentList) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments),
                    additionalResults, context);
            }
            else if (rootSignature.isGeneric() && callEx.argumentList.typeArgumentList && rootSignature.getTypeParameters() && (callEx.argumentList.typeArgumentList.typeArguments.length !== rootSignature.getTypeParameters().length)) {
                this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [rootSignature.getTypeParameters().length, callEx.argumentList.typeArgumentList.typeArguments.length]),
                    additionalResults, context);
            }

            var returnType = isSuperCall ? this.semanticInfoChain.voidTypeSymbol : signature.returnType;

            // contextually type arguments
            var actualParametersContextTypeSymbols: PullTypeSymbol[] = [];
            if (callEx.argumentList.arguments) {
                var len = callEx.argumentList.arguments.length;
                var params = signature.parameters;
                var contextualType: PullTypeSymbol = null;
                var signatureDecl = signature.getDeclarations()[0];

                for (var i = 0; i < len; i++) {
                    // account for varargs
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                            this.resolveDeclaredSymbol(params[i], context);
                            contextualType = params[i].type;
                        }
                        else if (signature.hasVarArgs) {
                            contextualType = params[params.length - 1].type;
                            if (contextualType.isArrayNamedTypeReference()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }

                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            // Store any additional resolution results if needed before we return
            additionalResults.targetSymbol = targetSymbol;
            if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures[0];
            }
            else {
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
            }
            additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

            if (errorCondition) {
                return errorCondition;
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            return returnType;
        }

        public resolveObjectCreationExpression(callEx: ObjectCreationExpressionSyntax, context: PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): PullSymbol {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeObjectCreationExpressionSymbol(callEx, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                this.setSymbolForAST(callEx, symbol, context);
                this.semanticInfoChain.setCallResolutionDataForAST(callEx, additionalResults);
            }
            else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckObjectCreationExpression(callEx, context);
                }

                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData !== additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                }
            }

            return symbol;
        }

        private typeCheckObjectCreationExpression(callEx: ObjectCreationExpressionSyntax, context: PullTypeResolutionContext) {
            this.setTypeChecked(callEx, context);
            this.resolveAST(callEx.expression, /*isContextuallyTyped:*/ false, context);
            var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
            if (callEx.argumentList) {
                var callResolutionData = this.semanticInfoChain.getCallResolutionDataForAST(callEx);
                var len = callEx.argumentList.arguments.length;

                for (var i = 0; i < len; i++) {
                    // Ensure call resolution data contains additional information. 
                    // Actual parameters context type symbols will be undefined if the call target resolves to any or error types.
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols ? callResolutionData.actualParametersContextTypeSymbols[i] : null;
                    if (contextualType) {
                        context.pushNewContextualType(contextualType);
                    }

                    this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                    if (contextualType) {
                        context.popAnyContextualType();
                        contextualType = null;
                    }
                }
            }

            // Post errors when resolving overload
            for (var i = 0; i < callResolutionData.diagnosticsFromOverloadResolution.length; i++) {
                context.postDiagnostic(callResolutionData.diagnosticsFromOverloadResolution[i]);
            }
        }

        private postOverloadResolutionDiagnostics(diagnostic: Diagnostic, additionalResults: PullAdditionalCallResolutionData, context: PullTypeResolutionContext) {
            if (!context.inProvisionalResolution()) {
                additionalResults.diagnosticsFromOverloadResolution.push(diagnostic);
            }
            context.postDiagnostic(diagnostic);
        }

        private computeObjectCreationExpressionSymbol(callEx: ObjectCreationExpressionSyntax, context: PullTypeResolutionContext, additionalResults: PullAdditionalCallResolutionData): PullSymbol {
            var returnType: PullTypeSymbol = null;

            // resolve the target
            var targetSymbol = this.resolveAST(callEx.expression, /*isContextuallyTyped:*/ false, context);
            var targetTypeSymbol = targetSymbol.isType() ? <PullTypeSymbol>targetSymbol : targetSymbol.type;

            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var explicitTypeArgs: PullTypeSymbol[] = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint: boolean;
            var constraintDiagnostic: Diagnostic = null;
            var typeArgumentCountDiagnostic: Diagnostic = null;
            var diagnostics: Diagnostic[] = [];

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                // resolve any arguments
                if (callEx.argumentList) {
                    this.resolveAST(callEx.argumentList.arguments, /*isContextuallyTyped:*/ false, context);
                }

                return targetTypeSymbol;
            }

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;

                // if noImplicitAny flag is set to be true, report an error
                if (this.compilationSettings.noImplicitAny()) {
                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(callEx,
                        DiagnosticCode.new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type),
                        additionalResults, context);
                }
            }

            if (constructSignatures.length) {
                // resolve the type arguments, specializing if necessary
                if (callEx.argumentList && callEx.argumentList.typeArgumentList) {
                    // specialize the type arguments
                    explicitTypeArgs = [];

                    if (callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length) {
                        for (var i = 0; i < callEx.argumentList.typeArgumentList.typeArguments.length; i++) {
                            explicitTypeArgs[i] = this.resolveTypeReference(callEx.argumentList.typeArgumentList.typeArguments[i], context);
                        }
                    }
                }

                // next, walk the available signatures
                // if any are generic, and we don't have type arguments, try to infer
                // otherwise, try to specialize to the type arguments above
                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures: PullSignatureSymbol[] = [];
                    var inferredOrExplicitTypeArgs: PullTypeSymbol[];
                    var specializedSignature: PullSignatureSymbol;
                    var typeParameters: PullTypeParameterSymbol[];
                    var typeConstraint: PullTypeSymbol = null;
                    var triedToInferTypeArgs: boolean;
                    var targetTypeReplacementMap = targetTypeSymbol.getTypeParameterSubstitutionMap();

                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;

                        if (constructSignatures[i].isGeneric()) {
                            typeParameters = constructSignatures[i].getTypeParameters();

                            if (explicitTypeArgs) {
                                // October 16, 2013: Section 4.12.2
                                // A generic signature is a candidate in a function call with type arguments
                                // arguments when:
                                // The signature has the same number of type parameters as were supplied in
                                // the type argument list
                                // ...
                                if (explicitTypeArgs.length === typeParameters.length) {
                                    inferredOrExplicitTypeArgs = explicitTypeArgs;
                                }
                                else {
                                    typeArgumentCountDiagnostic = typeArgumentCountDiagnostic ||
                                    this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead,
                                        [typeParameters.length, explicitTypeArgs.length]);
                                    continue;
                                }
                            }
                            else if (callEx.argumentList) {
                                var typeArgumentInferenceContext = new InvocationTypeArgumentInferenceContext(this, context, constructSignatures[i], callEx.argumentList);
                                inferredOrExplicitTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);
                                triedToInferTypeArgs = true;
                            }
                            else {
                                // Pretend to infer the constraints. This is useful for the following case:
                                // class C<T extends number, U> { }
                                // var c = new C; // c should have type C<number, {}>, just like calling it with new C()
                                inferredOrExplicitTypeArgs = ArrayUtilities.select(typeParameters, typeParameter => typeParameter.getDefaultConstraint(this.semanticInfoChain));
                            }

                            // if we could infer Args, or we have type arguments, then attempt to specialize the signature
                            Debug.assert(inferredOrExplicitTypeArgs && inferredOrExplicitTypeArgs.length == typeParameters.length);

                            // When specializing the constraints, seed the replacement map with any substitutions already specified by
                            // the target function's type
                            var mutableTypeReplacementMap = new PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(targetTypeReplacementMap ? targetTypeReplacementMap : []);
                            PullInstantiationHelpers.updateMutableTypeParameterSubstitutionMap(typeParameters, inferredOrExplicitTypeArgs, mutableTypeReplacementMap);
                            var typeReplacementMap = mutableTypeReplacementMap.typeParameterSubstitutionMap;

                            if (explicitTypeArgs) {
                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeConstraint = typeParameters[j].getConstraint();

                                    // test specialization type for assignment compatibility with the constraint
                                    if (typeConstraint) {
                                        if (typeConstraint.isGeneric()) {
                                            typeConstraint = this.instantiateType(typeConstraint, typeReplacementMap);
                                        }

                                        // Section 3.4.2 (November 18, 2013): 
                                        // A type argument satisfies a type parameter constraint if the type argument is assignable
                                        // to(section 3.8.4) the constraint type once type arguments are substituted for type parameters.
                                        if (!this.sourceIsAssignableToTarget(inferredOrExplicitTypeArgs[j], typeConstraint, targetAST, context, null, /*isComparingInstantiatedSignatures:*/ true)) {
                                            var enclosingSymbol = this.getEnclosingSymbolForAST(targetAST);
                                            constraintDiagnostic = this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredOrExplicitTypeArgs[j].toString(enclosingSymbol, /*useConstraintInName*/ true), typeConstraint.toString(enclosingSymbol, /*useConstraintInName*/ true), typeParameters[j].toString(enclosingSymbol, /*useConstraintInName*/ true)]);
                                            couldNotAssignToConstraint = true;
                                        }

                                        if (couldNotAssignToConstraint) {
                                            break;
                                        }

                                    }
                                }
                            }

                            if (couldNotAssignToConstraint) {
                                continue;
                            }

                            specializedSignature = this.instantiateSignature(constructSignatures[i], typeReplacementMap);

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                        else {
                            if (!(callEx.argumentList && callEx.argumentList.typeArgumentList && callEx.argumentList.typeArgumentList.typeArguments.length)) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                            }
                        }
                    }

                    // PULLTODO: Try to avoid copying here...
                    constructSignatures = resolvedSignatures;
                }

                var signature = this.resolveOverloads(callEx, constructSignatures, callEx.argumentList && callEx.argumentList.typeArgumentList !== null, context, diagnostics);

                // Store any additional resolution results if needed before we return
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = [];

                if (!constructSignatures.length) {

                    if (constraintDiagnostic) {
                        this.postOverloadResolutionDiagnostics(constraintDiagnostic, additionalResults, context);
                    }
                    else if (typeArgumentCountDiagnostic) {
                        this.postOverloadResolutionDiagnostics(typeArgumentCountDiagnostic, additionalResults, context);
                    }

                    return this.getNewErrorTypeSymbol();
                }

                var errorCondition: PullSymbol = null;

                // if we haven't been able to choose an overload, default to the first one
                if (!signature) {

                    for (var i = 0; i < diagnostics.length; i++) {
                        this.postOverloadResolutionDiagnostics(diagnostics[i], additionalResults, context);
                    }

                    this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Could_not_select_overload_for_new_expression),
                        additionalResults, context);

                    // Remember the error
                    errorCondition = this.getNewErrorTypeSymbol();

                    if (!constructSignatures.length) {
                        // POST diagnostics
                        return errorCondition;
                    }

                    // First, pick the first signature as the candidate signature
                    signature = constructSignatures[0];
                }

                returnType = signature.returnType;

                // if it's a default constructor, and we have a type argument, we need to specialize
                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (explicitTypeArgs && explicitTypeArgs.length) {
                        returnType = this.createInstantiatedType(returnType, explicitTypeArgs);
                    }
                    else {
                        returnType = this.instantiateTypeToAny(returnType, context);
                    }
                }

                if (usedCallSignaturesInstead) {
                    if (returnType !== this.semanticInfoChain.voidTypeSymbol) {
                        this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Call_signatures_used_in_a_new_expression_must_have_a_void_return_type),
                            additionalResults, context);
                        // POST diagnostics
                        return this.getNewErrorTypeSymbol();
                    }
                    else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (!returnType) {
                    returnType = signature.returnType;

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                // contextually type arguments
                var actualParametersContextTypeSymbols: PullTypeSymbol[] = [];
                if (callEx.argumentList && callEx.argumentList.arguments) {
                    var len = callEx.argumentList.arguments.length;
                    var params = signature.parameters;
                    var contextualType: PullTypeSymbol = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (var i = 0; i < len; i++) {

                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                                this.resolveDeclaredSymbol(params[i], context);
                                contextualType = params[i].type;
                            }
                            else if (signature.hasVarArgs) {
                                contextualType = params[params.length - 1].type;
                                if (contextualType.isArrayNamedTypeReference()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }

                        if (contextualType) {
                            context.pushNewContextualType(contextualType);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }

                        this.resolveAST(callEx.argumentList.arguments[i], contextualType !== null, context);

                        if (contextualType) {
                            context.popAnyContextualType();
                            contextualType = null;
                        }
                    }
                }

                // Store any additional resolution results if needed before we return
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                if (errorCondition) {
                    // POST diagnostics
                    return errorCondition;
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType
            }
            else if (callEx.argumentList) {
                this.resolveAST(callEx.argumentList.arguments, /*isContextuallyTyped:*/ false, context);
            }

            this.postOverloadResolutionDiagnostics(this.semanticInfoChain.diagnosticFromAST(targetAST, DiagnosticCode.Invalid_new_expression),
                additionalResults, context);

            // POST diagnostics
            return this.getNewErrorTypeSymbol();
        }

        // Here, we are instantiating signatureAToInstantiate in the context of contextSignatureB.
        // The A and B reference section 3.8.5 of the spec:
        // A is instantiated in the context of B. If A is a non-generic signature, the result of
        // this process is simply A. Otherwise, type arguments for A are inferred from B producing
        // an instantiation of A that can be related to B
        // The shouldFixContextualSignatureParameterTypes flag should be set to true when inferences
        // are being made for type parameters of the contextual signature (like for inferential
        // typing in section 4.12.2). It should be set to false for relation checking (sections
        // 3.8.3 & 3.8.4).
        private instantiateSignatureInContext(
            signatureAToInstantiate: PullSignatureSymbol,
            contextualSignatureB: PullSignatureSymbol,
            context: PullTypeResolutionContext,
            shouldFixContextualSignatureParameterTypes: boolean): PullSignatureSymbol {
            var typeReplacementMap: PullTypeSymbol[] = [];
            var inferredTypeArgs: PullTypeSymbol[];
            var specializedSignature: PullSignatureSymbol;
            var typeParameters: PullTypeParameterSymbol[] = signatureAToInstantiate.getTypeParameters();
            var typeConstraint: PullTypeSymbol = null;

            var typeArgumentInferenceContext = new ContextualSignatureInstantiationTypeArgumentInferenceContext(this, context, signatureAToInstantiate, contextualSignatureB, shouldFixContextualSignatureParameterTypes);
            inferredTypeArgs = this.inferArgumentTypesForSignature(typeArgumentInferenceContext, new TypeComparisonInfo(), context);

            var functionTypeA = signatureAToInstantiate.functionType;
            var functionTypeB = contextualSignatureB.functionType;
            var enclosingTypeParameterMap: TypeSubstitutionMap;

            if (functionTypeA) {
                enclosingTypeParameterMap = functionTypeA.getTypeParameterSubstitutionMap();

                for (var id in enclosingTypeParameterMap) {
                    typeReplacementMap[id] = enclosingTypeParameterMap[id];
                }
            }

            if (functionTypeB) {
                enclosingTypeParameterMap = functionTypeB.getTypeParameterSubstitutionMap();

                for (var id in enclosingTypeParameterMap) {
                    typeReplacementMap[id] = enclosingTypeParameterMap[id];
                }
            }

            PullInstantiationHelpers.updateTypeParameterSubstitutionMap(typeParameters, inferredTypeArgs, typeReplacementMap);

            return this.instantiateSignature(signatureAToInstantiate, typeReplacementMap);
        }

        private resolveCastExpression(assertionExpression: CastExpressionSyntax, context: PullTypeResolutionContext): PullTypeSymbol {
            var typeAssertionType = this.resolveTypeReference(assertionExpression.type, context).type;

            if (this.canTypeCheckAST(assertionExpression, context)) {
                this.typeCheckCastExpression(assertionExpression, context, typeAssertionType);
            }

            // October 11, 2013: 
            // In a type assertion expression of the form < T > e, e is contextually typed (section 
            // 4.19) by T and the resulting type of e is required to be assignable to or from T, or
            // otherwise a compile - time error occurs.
            //
            // The type of the result is T.
            return typeAssertionType;
        }

        private typeCheckCastExpression(assertionExpression: CastExpressionSyntax, context: PullTypeResolutionContext, typeAssertionType: PullTypeSymbol): void {
            this.setTypeChecked(assertionExpression, context);

            // October 11, 2013: 
            // In a type assertion expression of the form < T > e, e is contextually typed (section 
            // 4.19) by T and the resulting type of e is required to be assignable to or from T, or
            // otherwise a compile - time error occurs.
            //
            // The type of the result is T.

            context.pushNewContextualType(typeAssertionType);
            var exprType = this.resolveAST(assertionExpression.expression, /*isContextuallyTyped:*/ true, context).type;
            context.popAnyContextualType();

            // TODO: why are we resolving these symbols here?
            this.resolveDeclaredSymbol(typeAssertionType, context);
            this.resolveDeclaredSymbol(exprType, context);

            var comparisonInfo = new TypeComparisonInfo();

            // Be careful to check exprType assignable to typeAssertionType first. Only widen if
            // this direction is not assignable to avoid extra implicit any errors that widening
            // would cause.
            var isAssignable = this.sourceIsAssignableToTarget(exprType, typeAssertionType, assertionExpression, context, comparisonInfo);

            if (!isAssignable) {
                var widenedExprType = exprType.widenedType(this, assertionExpression.expression, context);
                isAssignable = this.sourceIsAssignableToTarget(typeAssertionType, widenedExprType, assertionExpression, context, comparisonInfo);
            }

            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(assertionExpression);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, DiagnosticCode.Cannot_convert_0_to_1_NL_2, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(assertionExpression, DiagnosticCode.Cannot_convert_0_to_1, [exprType.toString(enclosingSymbol), typeAssertionType.toString(enclosingSymbol)]));
                }
            }
        }

        private resolveAssignmentExpression(binaryExpression: BinaryExpressionSyntax, context: PullTypeResolutionContext): PullSymbol {
            // September 17, 2013: An assignment of the form
            //
            //      VarExpr = ValueExpr
            //
            // requires VarExpr to be classified as a reference(section 4.1).ValueExpr is 
            // contextually typed(section 4.19) by the type of VarExpr, and the type of ValueExpr 
            // must be assignable to(section 3.8.4) the type of VarExpr, or otherwise a compile - 
            // time error occurs.The result is a value with the type of ValueExpr.

            var leftExpr = this.resolveAST(binaryExpression.left, /*isContextuallyTyped:*/ false, context);
            var leftType = leftExpr.type;

            context.pushNewContextualType(leftType);
            var rightType = this.resolveAST(binaryExpression.right, true, context).type;
            context.popAnyContextualType();

            rightType = this.getInstanceTypeForAssignment(binaryExpression.left, rightType, context);

            // Check if LHS is a valid target
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);

                if (!this.isReference(binaryExpression.left, leftExpr)) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(binaryExpression.left, DiagnosticCode.Invalid_left_hand_side_of_assignment_expression));
                }
                else {
                    this.checkAssignability(binaryExpression.left, rightType, leftExpr.type, context);
                }
            }

            return rightType;
        }

        private getInstanceTypeForAssignment(lhs: ISyntaxElement, type: PullTypeSymbol, context: PullTypeResolutionContext): PullTypeSymbol {
            var typeToReturn = type;
            if (typeToReturn && typeToReturn.isAlias()) {
                typeToReturn = (<PullTypeAliasSymbol>typeToReturn).getExportAssignedTypeSymbol();
            }

            if (typeToReturn && typeToReturn.isContainer() && !typeToReturn.isEnum()) {
                var instanceTypeSymbol = (<PullContainerSymbol>typeToReturn).getInstanceType();

                if (!instanceTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(lhs, DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [type.toString()]));
                    typeToReturn = null;
                }
                else {
                    typeToReturn = instanceTypeSymbol;
                }
            }

            return typeToReturn;
        }

        public widenType(type: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            if (type === this.semanticInfoChain.undefinedTypeSymbol ||
                type === this.semanticInfoChain.nullTypeSymbol ||
                type.isError()) {

                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (type.isArrayNamedTypeReference()) {
                return this.widenArrayType(type, ast, context);
            }
            else if (type.kind === PullElementKind.ObjectLiteral) {
                return this.widenObjectLiteralType(type, ast, context);
            }

            return type;
        }

        private widenArrayType(type: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            // Call into the symbol to get the widened type so we pick up the cached version if there is one
            var elementType = type.getElementType().widenedType(this, /*ast*/ ast, context);

            if (this.compilationSettings.noImplicitAny() && ast) {
                // If we widened from non-'any' type to 'any', then report error.
                if (elementType === this.semanticInfoChain.anyTypeSymbol && type.getElementType() !== this.semanticInfoChain.anyTypeSymbol) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening));
                }
            }

            return this.getArrayType(elementType);
        }

        private widenObjectLiteralType(type: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext): PullTypeSymbol {
            if (!this.needsToWidenObjectLiteralType(type, ast, context)) {
                return type;
            }

            // The name here should be "", and the kind should be ObjectLiteral
            Debug.assert(type.name === "");
            var newObjectTypeSymbol = new PullTypeSymbol(type.name, type.kind, this.semanticInfoChain);
            var declsOfObjectType = type.getDeclarations();
            Debug.assert(declsOfObjectType.length === 1);
            newObjectTypeSymbol.addDeclaration(declsOfObjectType[0]);
            var members = type.getMembers();

            for (var i = 0; i < members.length; i++) {
                var memberType = members[i].type;
                // Call into the symbol to get the widened type so we pick up the cached version if there is one
                var widenedMemberType = members[i].type.widenedType(this, ast, context);
                var newMember = new PullSymbol(members[i].name, members[i].kind, this.semanticInfoChain);

                // Since this is an object literal, we only care about one decl for this member.
                // It has more than one decl in an error case where there was a duplicate member
                // declaration. For example:
                // var obj = { a: 3, a: 4 };
                // This will have two decls for "a", but an error is already given in computeObjectLiteralExpression.
                var declsOfMember = members[i].getDeclarations();
                //Debug.assert(declsOfMember.length === 1);
                //Debug.assert(members[i].isResolved);
                newMember.addDeclaration(declsOfMember[0]);
                newMember.type = widenedMemberType;
                newObjectTypeSymbol.addMember(newMember);
                newMember.setResolved();

                if (this.compilationSettings.noImplicitAny() &&
                    ast &&
                    widenedMemberType === this.semanticInfoChain.anyTypeSymbol
                    && memberType !== this.semanticInfoChain.anyTypeSymbol) {
                    // Property was widened from non-any to any
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Object_literal_s_property_0_implicitly_has_an_any_type_from_widening, [members[i].name]));
                }
            }

            var indexers = type.getIndexSignatures();
            for (var i = 0; i < indexers.length; i++) {
                var newIndexer = new PullSignatureSymbol(PullElementKind.IndexSignature, this.semanticInfoChain);
                var parameter = indexers[i].parameters[0];
                var newParameter = new PullSymbol(parameter.name, parameter.kind, this.semanticInfoChain);
                newParameter.type = parameter.type;
                newIndexer.addParameter(newParameter);
                newIndexer.returnType = indexers[i].returnType;
                newObjectTypeSymbol.addIndexSignature(newIndexer);
            }

            return newObjectTypeSymbol;
        }

        private needsToWidenObjectLiteralType(type: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext): boolean {
            var members = type.getMembers();
            for (var i = 0; i < members.length; i++) {
                var memberType = members[i].type;
                if (memberType !== memberType.widenedType(this, ast, context)) {
                    return true;
                }
            }

            return false;
        }

        public findBestCommonType(collection: IPullTypeCollection, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            var len = collection.getLength();

            for (var i = 0; i < len; i++) {
                var candidateType = collection.getTypeAtIndex(i);
                if (this.typeIsBestCommonTypeCandidate(candidateType, collection, context)) {
                    return candidateType;
                }
            }

            // October 16, 2013: It is possible that no such [common] type exists, in which case
            // the best common type is an empty object type.
            return this.semanticInfoChain.emptyTypeSymbol;
        }

        private typeIsBestCommonTypeCandidate(candidateType: PullTypeSymbol, collection: IPullTypeCollection, context: PullTypeResolutionContext): boolean {
            for (var i = 0; i < collection.getLength(); i++) {
                var otherType = collection.getTypeAtIndex(i);
                if (candidateType === otherType) {
                    continue;
                }

                if (!this.sourceIsSubtypeOfTarget(otherType, candidateType, /*ast*/ null, context)) {
                    return false;
                }
            }

            return true;
        }

        // Type Identity

        private typesAreIdenticalInEnclosingTypes(t1: PullTypeSymbol, t2: PullTypeSymbol, context: PullTypeResolutionContext) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);

            if (t1 === t2) {
                return true;
            }

            if (t1 && t2) {
                // Section 3.8.7 - Recursive Types
                //  When comparing two types S and T for identity(section 3.8.2), subtype(section 3.8.3), and assignability(section 3.8.4) relationships, 
                //  if either type originates in an infinitely expanding type reference, S and T are not compared by the rules in the preceding sections.Instead, for the relationship to be considered true,
                //  -   S and T must both be type references to the same named type, and
                //  -   the relationship in question must be true for each corresponding pair of type arguments in the type argument lists of S and T.

                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    return this.infinitelyExpandingTypesAreIdentical(t1, t2, context);
                }
            }

            return this.typesAreIdentical(t1, t2, context);
        }

        private typesAreIdenticalWithNewEnclosingTypes(t1: PullTypeSymbol, t2: PullTypeSymbol, context: PullTypeResolutionContext) {
            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            var areTypesIdentical = this.typesAreIdentical(t1, t2, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areTypesIdentical;
        }

        public typesAreIdentical(t1: PullTypeSymbol, t2: PullTypeSymbol, context: PullTypeResolutionContext) {
            t1 = this.getSymbolForRelationshipCheck(t1);
            t2 = this.getSymbolForRelationshipCheck(t2);

            // This clause will cover both primitive types (since the type objects are shared),
            // as well as shared brands
            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            // identity check for enums is 't1 === t2'
            // if it returns false and one of elements is enum - they are not identical
            if (hasFlag(t1.kind, PullElementKind.Enum) || hasFlag(t2.kind, PullElementKind.Enum)) {
                return false;
            }

            if (t1.isPrimitive() && (<PullPrimitiveTypeSymbol>t1).isStringConstant() && t2.isPrimitive() && (<PullPrimitiveTypeSymbol>t2).isStringConstant()) {
                // Both are string constants
                return TypeScript.stripStartAndEndQuotes(t1.name) === TypeScript.stripStartAndEndQuotes(t2.name);
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isError() && t2.isError()) {
                return true;
            }

            var isIdentical = this.identicalCache.valueAt(t1.pullSymbolID, t2.pullSymbolID);
            if (isIdentical != undefined) {
                return isIdentical;
            }

            if (t1.isTypeParameter() !== t2.isTypeParameter()) {
                return false;
            }
            else if (t1.isTypeParameter()) {

                // We compare parent declarations instead of container symbols because type parameter symbols are shared
                // accross overload groups
                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();

                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                }
                else {
                    return false;
                }
            }

            if (t1.isPrimitive() !== t2.isPrimitive()) {
                return false;
            }

            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, true);
            var statesWhenStartedWalkingTypes = context.startWalkingTypes(t1, t2);
            isIdentical = this.typesAreIdenticalWorker(t1, t2, context);
            context.endWalkingTypes(statesWhenStartedWalkingTypes);
            this.identicalCache.setValueAt(t1.pullSymbolID, t2.pullSymbolID, isIdentical);

            return isIdentical;
        }

        private typesAreIdenticalWorker(t1: PullTypeSymbol, t2: PullTypeSymbol, context: PullTypeResolutionContext) {
            if (t1.getIsSpecialized() && t2.getIsSpecialized()) {
                // If types are specialized from same root symbol, comparing type arguments should be enough
                if (TypeScript.PullHelpers.getRootType(t1) === TypeScript.PullHelpers.getRootType(t2)
                    && PullHelpers.getRootType(t1).isNamedTypeSymbol()) {
                    var t1TypeArguments = t1.getTypeArguments();
                    var t2TypeArguments = t2.getTypeArguments();

                    if (t1TypeArguments && t2TypeArguments) {
                        for (var i = 0; i < t1TypeArguments.length; i++) {
                            // The type arguments are not enclosed in current enclosing contexts
                            if (!this.typesAreIdenticalWithNewEnclosingTypes(t1TypeArguments[i], t2TypeArguments[i], context)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }

            // properties are identical in name, optionality, and type
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all);
                var t2Members = t2.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all);

                if (t1Members.length !== t2Members.length) {
                    return false;
                }

                var t1MemberSymbol: PullSymbol = null;
                var t2MemberSymbol: PullSymbol = null;

                var t1MemberType: PullTypeSymbol = null;
                var t2MemberType: PullTypeSymbol = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    // Spec section 3.8.2:
                    // Two members are considered identical when
                    // they are public properties with identical names, optionality, and types,
                    // they are private properties originating in the same declaration and having identical types
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getNamedPropertySymbol(t1MemberSymbol.name, PullElementKind.SomeValue, t2);
                    
                    if (!this.propertiesAreIdentical(t1MemberSymbol, t2MemberSymbol, context)) {
                        return false;
                    }
                }
            }
            else if (t1.hasMembers() || t2.hasMembers()) {
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs, context)) {
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs, context)) {
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs, context)) {
                return false;
            }

            return true;
        }

        private propertiesAreIdentical(propertySymbol1: PullSymbol, propertySymbol2: PullSymbol, context: PullTypeResolutionContext): boolean {
            // Spec section 3.8.2:
            // Two members are considered identical when
            // they are public properties with identical names, optionality, and types,
            // they are private properties originating in the same declaration and having identical types
            if (!propertySymbol2 || (propertySymbol1.isOptional !== propertySymbol2.isOptional)) {
                return false;
            }

            var t1MemberSymbolIsPrivate = propertySymbol1.anyDeclHasFlag(PullElementFlags.Private);
            var t2MemberSymbolIsPrivate = propertySymbol2.anyDeclHasFlag(PullElementFlags.Private);

            // if visibility doesn't match, the types don't match
            if (t1MemberSymbolIsPrivate !== t2MemberSymbolIsPrivate) {
                return false;
            }
            // if both are private members, test to ensure that they share a declaration
            else if (t2MemberSymbolIsPrivate && t1MemberSymbolIsPrivate) {
                var t1MemberSymbolDecl = propertySymbol1.getDeclarations()[0];
                var sourceDecl = propertySymbol2.getDeclarations()[0];
                if (t1MemberSymbolDecl !== sourceDecl) {
                    return false;
                }
            }

            var t1MemberType = propertySymbol1.type;
            var t2MemberType = propertySymbol2.type;

            context.walkMemberTypes(propertySymbol1.name);
            var areMemberTypesIdentical = this.typesAreIdenticalInEnclosingTypes(t1MemberType, t2MemberType, context);
            context.postWalkMemberTypes();
            return areMemberTypesIdentical;
        }

        private propertiesAreIdenticalWithNewEnclosingTypes(
            type1: PullTypeSymbol,
            type2: PullTypeSymbol,
            property1: PullSymbol,
            property2: PullSymbol,
            context: PullTypeResolutionContext): boolean {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(type1, type2);
            var arePropertiesIdentical = this.propertiesAreIdentical(property1, property2, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return arePropertiesIdentical;
        }

        private signatureGroupsAreIdentical(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[],
            context: PullTypeResolutionContext) {

            // covers the null case
            if (sg1 === sg2) {
                return true;
            }

            // covers the mixed-null case
            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length !== sg2.length) {
                return false;
            }

            // Signatures must be in the same order for the signature groups to be identical.
            // The spec does not say this yet. It is vague about this comparison:
            // November 18th, 2013: Section 3.8.2:
            // Two members are considered identical when:
            // ...
            //    they are identical call signatures,
            //    they are identical construct signatures, or
            //    they are index signatures of identical kind with identical types.
            for (var i = 0; i < sg1.length; i++) {
                context.walkSignatures(sg1[i].kind, i);
                var areSignaturesIdentical = this.signaturesAreIdentical(sg1[i], sg2[i], context, /*includeReturnTypes*/ true);
                context.postWalkSignatures();
                if (!areSignaturesIdentical) {
                    return false;
                }
            }

            return true;
        }

        private constraintsAreIdentical(tp1: PullTypeParameterSymbol[], tp2: PullTypeParameterSymbol[],
            context: PullTypeResolutionContext) {
            Debug.assert(tp1 && tp2);
            if (tp1.length !== tp2.length) {
                return false;
            }

            for (var i = 0; i < tp1.length; i++) {
                // Verify the pairwise identity of the constraints
                context.walkTypeParameterConstraints(i);
                var areConstraintsIdentical = this.typesAreIdentical(tp1[i].getConstraint(), tp2[i].getConstraint(), context);
                context.postWalkTypeParameterConstraints();
                if (!areConstraintsIdentical) {
                    return false;
                }
            }

            return true;
        }

        private setTypeParameterIdentity(tp1: PullTypeParameterSymbol[], tp2: PullTypeParameterSymbol[], val: boolean) {
            if (tp1 && tp2 && tp1.length === tp2.length) {
                for (var i = 0; i < tp1.length; i++) {
                    this.identicalCache.setValueAt(tp1[i].pullSymbolID, tp2[i].pullSymbolID, val);
                }
            }
        }

        public signaturesAreIdenticalWithNewEnclosingTypes(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext,
            includingReturnType = true) {

            // If signatures are identitical is called directally we need to get the enclosingType and 
            // current symbol correctly
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            var areSignaturesIdentical = this.signaturesAreIdentical(s1, s2, context, includingReturnType);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSignaturesIdentical;
        }

        private signaturesAreIdentical(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext,
            includingReturnType = true) {
            if (s1 === s2) {
                return true;
            }

            var signaturesIdentical = this.identicalCache.valueAt(s1.pullSymbolID, s2.pullSymbolID);
            if (signaturesIdentical || // If signatures are identical they are identical whether we check return type or not
                (signaturesIdentical != undefined && includingReturnType)) { // If we are checking signature with return type, we can use cached false value
                return signaturesIdentical;
            }

            var oldValue = signaturesIdentical;
            this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, true);

            signaturesIdentical = this.signaturesAreIdenticalWorker(s1, s2, context, includingReturnType);

            if (includingReturnType) {
                // Can cache the result
                this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, signaturesIdentical);
            }
            else {
                // Not checking return type, revert the result
                this.identicalCache.setValueAt(s1.pullSymbolID, s2.pullSymbolID, oldValue);
            }

            return signaturesIdentical;
        }

        public signaturesAreIdenticalWorker(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext,
            includingReturnType = true) {
            if (s1.hasVarArgs !== s2.hasVarArgs) {
                return false;
            }

            if (s1.nonOptionalParamCount !== s2.nonOptionalParamCount) {
                return false;
            }

            if (s1.parameters.length !== s2.parameters.length) {
                return false;
            }

            // The spec says to assume type parameters are pairwise identical in order to compare
            // the signatures. We skip that here because we are about to instantiate the signatures
            // to any to avoid a generative recursion when comparing generic signatures.
            return this.signatureConstraints_Parameters_AndReturnTypesAreIdenticalAfterInstantiationToAny(s1, s2, context, includingReturnType);
        }

        private signatureConstraints_Parameters_AndReturnTypesAreIdenticalAfterInstantiationToAny(s1: PullSignatureSymbol, s2: PullSignatureSymbol,
            context: PullTypeResolutionContext, includingReturnType?: boolean) {
            if (!this.constraintsAreIdentical(s1.getTypeParameters(), s2.getTypeParameters(), context)) {
                return false;
            }

            // This is not in the spec yet, but we need to instantiate signatures to any before
            // comparing them to avoid a generative recursion. Considering them pairwise
            // identical is not enough to achieve this. Consider the following example:
            //
            // interface IPromise<T> {
            //     then<U>(callback: (x: T) => IPromise<U>): IPromise<U>;
            // }
            // interface Promise<T> {
            //     then<U>(callback: (x: T) => Promise<U>): Promise<U>;
            // }
            // var x: IPromise<string>;
            // var x: Promise<string>;
            //
            // Comparing IPromise<U> and Promise<U> would lead to an infinite expansion, since
            // each instantiation introduces a new U. Therefore, the U must be erased to any.
            s1 = this.instantiateSignatureToAny(s1);
            s2 = this.instantiateSignatureToAny(s2);

            if (includingReturnType) {
                PullHelpers.resolveDeclaredSymbolToUseType(s1);
                PullHelpers.resolveDeclaredSymbolToUseType(s2);
                context.walkReturnTypes();
                var areReturnTypesIdentical = this.typesAreIdenticalInEnclosingTypes(s1.returnType, s2.returnType, context);
                context.postWalkReturnTypes();
                if (!areReturnTypesIdentical) {
                    return false;
                }
            }

            var s1Params = s1.parameters;
            var s2Params = s2.parameters;

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                PullHelpers.resolveDeclaredSymbolToUseType(s1Params[iParam]);
                PullHelpers.resolveDeclaredSymbolToUseType(s2Params[iParam]);
                context.walkParameterTypes(iParam);
                var areParameterTypesIdentical = this.typesAreIdenticalInEnclosingTypes(s1Params[iParam].type, s2Params[iParam].type, context);
                context.postWalkParameterTypes();

                if (!areParameterTypesIdentical) {
                    return false;
                }
            }

            return true;
        }

        public signatureReturnTypesAreIdentical(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext) {
            // Set the cache pairwise identity of type parameters, so if parameters refer to them, they would be treated as identical
            var s1TypeParameters = s1.getTypeParameters();
            var s2TypeParameters = s2.getTypeParameters();
            this.setTypeParameterIdentity(s1TypeParameters, s2TypeParameters, true);

            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            context.walkReturnTypes();
            var returnTypeIsIdentical = this.typesAreIdenticalInEnclosingTypes(s1.returnType, s2.returnType, context);
            // context.postWalkReturnTypes(); - this is not needed because we are restoring the old walkers
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            
            // Reset the cahce with pairwise identity of type parameters
            this.setTypeParameterIdentity(s1TypeParameters, s2TypeParameters, undefined);

            return returnTypeIsIdentical;
        }

        // Assignment Compatibility and Subtyping

        private symbolsShareDeclaration(symbol1: PullSymbol, symbol2: PullSymbol) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();

            if (decls1.length && decls2.length) {
                return decls1[0] === decls2[0];
            }

            return false;
        }

        private sourceIsSubtypeOfTarget(source: PullTypeSymbol, target: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean): boolean {
            return this.sourceIsRelatableToTarget(source, target, /*assignableTo*/false, this.subtypeCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        }

        private sourceMembersAreAssignableToTargetMembers(source: PullTypeSymbol, target: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceMembersAreAssignableToTargetMembers = this.sourceMembersAreRelatableToTargetMembers(source, target,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceMembersAreAssignableToTargetMembers;
        }

        private sourcePropertyIsAssignableToTargetProperty(source: PullTypeSymbol, target: PullTypeSymbol,
            sourceProp: PullSymbol, targetProp: PullSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean) {

            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var isSourcePropertyIsAssignableToTargetProperty = this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSourcePropertyIsAssignableToTargetProperty;
        }

        private sourceCallSignaturesAreAssignableToTargetCallSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo,
            isComparingInstantiatedSignatures?: boolean) {
            
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceCallSignaturesAssignableToTargetCallSignatures = this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceCallSignaturesAssignableToTargetCallSignatures;
        }

        private sourceConstructSignaturesAreAssignableToTargetConstructSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean) {

            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceConstructSignaturesAssignableToTargetConstructSignatures = this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceConstructSignaturesAssignableToTargetConstructSignatures;
        }

        private sourceIndexSignaturesAreAssignableToTargetIndexSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(source, target);
            var areSourceIndexSignaturesAssignableToTargetIndexSignatures = this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return areSourceIndexSignaturesAssignableToTargetIndexSignatures;
        }

        private typeIsAssignableToFunction(source: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext): boolean {
            // Note that object types containing one or more call or construct signatures are 
            // automatically assignable to Function, provided they do not hide properties of
            // Function, giving them incompatible types. This is a result of the apparent type
            // rules in section 3.1.
            if (source.isFunctionType()) {
                return true;
            }

            return this.cachedFunctionInterfaceType() &&
                this.sourceIsAssignableToTarget(source, this.cachedFunctionInterfaceType(), ast, context);
        }

        private signatureIsAssignableToTarget(s1: PullSignatureSymbol, s2: PullSignatureSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean) {
            var enclosingTypeWalkerStates = context.setEnclosingTypeForSymbols(s1, s2);
            var isSignatureIsAssignableToTarget = this.signatureIsRelatableToTarget(s1, s2,
                /*assignableTo*/true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSignatureIsAssignableToTarget;
        }

        private sourceIsAssignableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean): boolean {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        }

        private sourceIsAssignableToTargetWithNewEnclosingTypes(source: PullTypeSymbol, target: PullTypeSymbol, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo, isComparingInstantiatedSignatures?: boolean): boolean {
            return this.sourceIsRelatableToTargetWithNewEnclosingTypes(source, target, true, this.assignableCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        }

        private getSymbolForRelationshipCheck(symbol: PullTypeSymbol) {
            if (symbol && symbol.isTypeReference()) {
                return (<TypeReferenceSymbol>symbol).getReferencedTypeSymbol();
            }

            return symbol;
        }

        private sourceIsRelatableToTargetInEnclosingTypes(source: PullTypeSymbol, target: PullTypeSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {

            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);

            if (source === target) {
                return true;
            }

            if (source && target) {
                // Section 3.8.7 - Recursive Types
                //  When comparing two types S and T for identity(section 3.8.2), subtype(section 3.8.3), and assignability(section 3.8.4) relationships, 
                //  if either type originates in an infinitely expanding type reference, S and T are not compared by the rules in the preceding sections.Instead, for the relationship to be considered true,
                //  -   S and T must both be type references to the same named type, and
                //  -   the relationship in question must be true for each corresponding pair of type arguments in the type argument lists of S and T.

                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    return this.infinitelyExpandingSourceTypeIsRelatableToTargetType(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                }
            }

            return this.sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
        }

        private sourceIsRelatableToTargetWithNewEnclosingTypes(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {
            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            var isSourceRelatable = this.sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, ast,
                context, comparisonInfo, isComparingInstantiatedSignatures);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
            return isSourceRelatable;
        }

        private sourceIsRelatableToTargetInCache(source: PullSymbol, target: PullSymbol, comparisonCache: IBitMatrix, comparisonInfo: TypeComparisonInfo) {
            var isRelatable = comparisonCache.valueAt(source.pullSymbolID, target.pullSymbolID);
            // If the source is relatable, return immediately
            if (isRelatable) {
                return { isRelatable: isRelatable };
            }

            // if comparison info is not asked, we can return cached false value, 
            // otherwise we need to redo the check to fill in the comparison info
            if (isRelatable != undefined && !comparisonInfo) {
                return { isRelatable: isRelatable };
            }

            return null;
        }

        private sourceIsRelatableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {
            source = this.getSymbolForRelationshipCheck(source);
            target = this.getSymbolForRelationshipCheck(target);

            if (source === target) {
                return true;
            }

            // An error has already been reported in this case
            if (!(source && target)) {
                return true;
            }

            // Note, for subtype the apparent type rules are different for type parameters. This
            // is not yet reflected in the spec.
            var sourceApparentType: PullTypeSymbol = this.getApparentType(source);

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(source, target, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && (<PullPrimitiveTypeSymbol>target).isStringConstant()) {
                return comparisonInfo &&
                    comparisonInfo.stringConstantVal &&
                    (comparisonInfo.stringConstantVal.kind() === SyntaxKind.StringLiteral) &&
                    (stripStartAndEndQuotes((<ISyntaxToken>comparisonInfo.stringConstantVal).text()) === stripStartAndEndQuotes(target.name));
            }

            // this is one difference between subtyping and assignment compatibility
            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }
            }
            else {
                // This is one difference between assignment compatibility and subtyping
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }
            }

            if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && (<PullPrimitiveTypeSymbol>source).isStringConstant()) {
                return true;
            }

            if (source.isPrimitive() && (<PullPrimitiveTypeSymbol>source).isStringConstant() && target.isPrimitive() && (<PullPrimitiveTypeSymbol>target).isStringConstant()) {
                // Both are string constants
                return TypeScript.stripStartAndEndQuotes(source.name) === TypeScript.stripStartAndEndQuotes(target.name);
            }

            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target !== this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            if (target === this.semanticInfoChain.voidTypeSymbol) {
                if (source === this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }

                return false;
            }
            else if (source === this.semanticInfoChain.voidTypeSymbol) {
                if (target === this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }

                return false;
            }

            if (target === this.semanticInfoChain.numberTypeSymbol && PullHelpers.symbolIsEnum(source)) {
                return true;
            }

            if (source === this.semanticInfoChain.numberTypeSymbol && PullHelpers.symbolIsEnum(target)) {
                return assignableTo;
            }

            if (PullHelpers.symbolIsEnum(target) && PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }

            if ((source.kind & PullElementKind.Enum) || (target.kind & PullElementKind.Enum)) {
                return false;
            }

            // Note: this code isn't necessary, but is helpful for error reporting purposes.  
            // Instead of reporting something like:
            //
            // Cannot convert 'A[]' to 'B[]':
            //  Types of property 'pop' of types 'A[]' and 'B[]' are incompatible:
            //    Call signatures of types '() => A' and '() => B' are incompatible:
            //      Type 'A' is missing property 'C' from type 'B'.
            //
            // We instead report:
            // Cannot convert 'A[]' to 'B[]':
            //   Type 'A' is missing property 'C' from type 'B'.

            if (source.getIsSpecialized() && target.getIsSpecialized()) {
                if (PullHelpers.getRootType(source) === PullHelpers.getRootType(target)
                    && PullHelpers.getRootType(source).isNamedTypeSymbol()) {

                    var sourceTypeArguments = source.getTypeArguments();
                    var targetTypeArguments = target.getTypeArguments();

                    if (sourceTypeArguments && targetTypeArguments) {
                        comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);

                        for (var i = 0; i < sourceTypeArguments.length; i++) {
                            if (!this.sourceIsRelatableToTargetWithNewEnclosingTypes(sourceTypeArguments[i],
                                targetTypeArguments[i], assignableTo, comparisonCache, ast, context,
                                /*comparisonInfo*/ null, isComparingInstantiatedSignatures)) {
                                break;
                            }
                        }

                        if (i === sourceTypeArguments.length) {
                            return true;
                        }
                        else {
                            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, undefined);
                            // don't return from here - if we've failed, keep checking (this will allow contravariant checks against generic methods to properly pass or fail)
                        }
                    }
                }
            }

            if (target.isTypeParameter()) {
                if (source.isTypeParameter()) {
                    // SPEC Nov 18
                    // S is assignable to a type T, and T is assignable from S, if ...
                    // S and T are type parameters, and S is directly or indirectly constrained to T.
                    if (!(<PullTypeParameterSymbol>source).getConstraint()) {
                        // if the source is another type parameter (with no constraints), they can only be assignable if they share
                        // a declaration
                        return this.typesAreIdentical(target, source, context)
                    }
                    else {
                        return this.isSourceTypeParameterConstrainedToTargetTypeParameter(<PullTypeParameterSymbol>source, <PullTypeParameterSymbol>target);
                    }
                }
                else {
                    // if the source is not another type parameter, and we're specializing at a constraint site, we consider the
                    // target to be a subtype of its constraint
                    if (isComparingInstantiatedSignatures) {
                        target = (<PullTypeParameterSymbol>target).getBaseConstraint(this.semanticInfoChain);
                    }
                    else {
                        return this.typesAreIdentical(target, sourceApparentType, context);
                    }
                }
            }

            // this check ensures that we only operate on object types from this point forward,
            // since the checks involving primitives occurred above
            if (sourceApparentType.isPrimitive() || target.isPrimitive()) {
                // we already know that they're not the same, and that neither is 'any'
                return false;
            }

            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, true);

            var symbolsWhenStartedWalkingTypes = context.startWalkingTypes(sourceApparentType, target);
            var isRelatable = this.sourceIsRelatableToTargetWorker(sourceApparentType, target, assignableTo,
                comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            context.endWalkingTypes(symbolsWhenStartedWalkingTypes);

            comparisonCache.setValueAt(source.pullSymbolID, target.pullSymbolID, isRelatable);
            return isRelatable;
        }

        private isSourceTypeParameterConstrainedToTargetTypeParameter(source: PullTypeParameterSymbol, target: PullTypeParameterSymbol): boolean {
            var current: PullTypeSymbol = source;
            while (current && current.isTypeParameter()) {
                if (current === target) {
                    return true;
                }

                current = (<PullTypeParameterSymbol>current).getConstraint();
            }
            return false;
        }

        private sourceIsRelatableToTargetWorker(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {
            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                return false;
            }

            return true;
        }

        private sourceMembersAreRelatableToTargetMembers(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: boolean,
            comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {
            var targetProps = target.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all);

            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {

                var targetProp = targetProps[itargetProp];
                // November 18, 2013, Sections 3.8.3 + 3.8.4
                // ..., where S' denotes the apparent type (section 3.8.1) of S
                // Note that by this point, we should already have the apparent type of 'source',
                // not including augmentation, so the only thing left to do is augment the type as
                // we look for the property.
                var sourceProp = this._getNamedPropertySymbolOfAugmentedType(targetProp.name, source);

                this.resolveDeclaredSymbol(targetProp, context);

                var targetPropType = targetProp.type;

                if (!sourceProp) {
                    if (!(targetProp.isOptional)) {
                        if (comparisonInfo) { // only surface the first error
                            var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                            comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Type_0_is_missing_property_1_from_type_2,
                                [source.toString(enclosingSymbol), targetProp.getScopedNameEx().toString(), target.toString(enclosingSymbol)]));
                        }
                        return false;
                    }
                    continue;
                }

                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo,
                    comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures)) {
                    return false;
                }
            }

            return true;
        }

        private infinitelyExpandingSourceTypeIsRelatableToTargetType(
            sourceType: PullTypeSymbol,
            targetType: PullTypeSymbol,
            assignableTo: boolean,
            comparisonCache: IBitMatrix,
            ast: ISyntaxElement,
            context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo,
            isComparingInstantiatedSignatures: boolean): boolean {

            // Section 3.8.7 - Recursive Types
            //  When comparing two types S and T for identity(section 3.8.2), subtype(section 3.8.3), and 
            //  assignability(section 3.8.4) relationships, 
            //  if either type originates in an infinitely expanding type reference, S and T are not compared
            //  by the rules in the preceding sections.Instead, for the relationship to be considered true,
            //  -       S and T must both be type references to the same named type, and
            //  -       the relationship in question must be true for each corresponding pair of type arguments in
            //      the type argument lists of S and T.

            var widenedTargetType = targetType.widenedType(this, /*ast*/ null, context);
            var widenedSourceType = sourceType.widenedType(this, /*ast*/ null, context);

            // Check if the type is not any/null or undefined
            if ((widenedSourceType !== this.semanticInfoChain.anyTypeSymbol) &&
                (widenedTargetType !== this.semanticInfoChain.anyTypeSymbol)) {

                var sourceTypeNamedTypeReference = PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = PullHelpers.getRootType(targetType);

                //  -   S and T must both be type references to the same named type, and
                if (sourceTypeNamedTypeReference !== targetTypeNamedTypeReference) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type,
                            [sourceType.getScopedNameEx(enclosingSymbol).toString(), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }

                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();

                // Verify if all type arguments can relate
                if (!sourceTypeArguments && !targetTypeArguments) {
                    // Both interface have 0 type arguments, so they relate
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }

                // If the number of type arguments mismatch (because of incomplete list - types are incompatible
                if (!(sourceTypeArguments && targetTypeArguments) ||
                    sourceTypeArguments.length !== targetTypeArguments.length) {
                    comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments,
                            [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]));
                    }
                    return false;
                }

                var comparisonInfoTypeArgumentsCheck: TypeComparisonInfo = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoTypeArgumentsCheck = new TypeComparisonInfo(comparisonInfo);
                }
                var isRelatable = true;
                for (var i = 0; i < sourceTypeArguments.length && isRelatable; i++) {
                    //  -       the relationship in question must be true for each corresponding pair of type arguments
                    //      in the type argument lists of S and T.
                    context.walkTypeArgument(i);

                    if (!this.sourceIsRelatableToTargetInEnclosingTypes(sourceTypeArguments[i], targetTypeArguments[i], assignableTo, comparisonCache, ast, context, comparisonInfoTypeArgumentsCheck, isComparingInstantiatedSignatures)) {
                        isRelatable = false;
                        if (comparisonInfo) {
                            var message: string;
                            var enclosingSymbol = this.getEnclosingSymbolForAST(ast);

                            if (comparisonInfoTypeArgumentsCheck && comparisonInfoTypeArgumentsCheck.message) {
                                message = getDiagnosticMessage(DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2,
                                    [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol), comparisonInfoTypeArgumentsCheck.message]);
                            }
                            else {
                                message = getDiagnosticMessage(DiagnosticCode.Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments,
                                    [sourceType.toString(enclosingSymbol), targetType.toString(enclosingSymbol)]);
                            }
                            comparisonInfo.addMessage(message);
                        }

                    }

                    context.postWalkTypeArgument();
                }
            }

            comparisonCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, isRelatable);
            return isRelatable;
        }

        private infinitelyExpandingTypesAreIdentical(sourceType: PullTypeSymbol, targetType: PullTypeSymbol,
            context: PullTypeResolutionContext): boolean {

            // Section 3.8.7 - Recursive Types
            //  When comparing two types S and T for identity(section 3.8.2), subtype(section 3.8.3), and 
            //  assignability(section 3.8.4) relationships, 
            //  if either type originates in an infinitely expanding type reference, S and T are not compared
            //  by the rules in the preceding sections.Instead, for the relationship to be considered true,
            //  -       S and T must both be type references to the same named type, and
            //  -       the relationship in question must be true for each corresponding pair of type arguments in
            //      the type argument lists of S and T.

            var widenedTargetType = targetType.widenedType(this, /*ast*/ null, /*context*/ null);
            var widenedSourceType = sourceType.widenedType(this, /*ast*/ null, /*context*/ null);

            // Check if the type is not any/null or undefined
            if ((widenedSourceType !== this.semanticInfoChain.anyTypeSymbol) &&
                (widenedTargetType !== this.semanticInfoChain.anyTypeSymbol)) {

                //  -   S and T must both be type references to the same named type, and
                var sourceTypeNamedTypeReference = PullHelpers.getRootType(sourceType);
                var targetTypeNamedTypeReference = PullHelpers.getRootType(targetType);
                if (sourceTypeNamedTypeReference !== targetTypeNamedTypeReference) {
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }

                //  -   the relationship in question must be true for each corresponding pair of type arguments in
                //      the type argument lists of S and T.
                var sourceTypeArguments = sourceType.getTypeArguments();
                var targetTypeArguments = targetType.getTypeArguments();

                if (!sourceTypeArguments && !targetTypeArguments) {
                    // Both types do not refere to any type arguments so they are identical
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
                    return true;
                }

                if (!(sourceTypeArguments && targetTypeArguments) ||
                    sourceTypeArguments.length !== targetTypeArguments.length) {
                    // Mismatch in type arguments length - may be missing type arguments - it is error 
                    this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                    return false;
                }

                for (var i = 0; i < sourceTypeArguments.length; i++) {
                    // Each pair of type argument needs to be identical for the type to be identical
                    context.walkTypeArgument(i)
                    var areIdentical = this.typesAreIdenticalInEnclosingTypes(sourceTypeArguments[i], targetTypeArguments[i], context);
                    context.postWalkTypeArgument();

                    if (!areIdentical) {
                        this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, false);
                        return false;
                    }
                }
            }

            this.identicalCache.setValueAt(sourceType.pullSymbolID, targetType.pullSymbolID, true);
            return true;
        }

        private sourcePropertyIsRelatableToTargetProperty(source: PullTypeSymbol, target: PullTypeSymbol,
            sourceProp: PullSymbol, targetProp: PullSymbol, assignableTo: boolean, comparisonCache: IBitMatrix,
            ast: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo,
            isComparingInstantiatedSignatures: boolean): boolean {

            var sourceAndTargetAreConstructors = source.isConstructor() && target.isConstructor();

            // source\target are not always equivalent to getContainer(). 
            // i.e.in cases of inheritance chains source will be derived type and getContainer() will yield some type from the middle of hierarchy
            var getNames = (takeTypesFromPropertyContainers: boolean) => {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                var sourceType = takeTypesFromPropertyContainers ? sourceProp.getContainer() : source;
                var targetType = takeTypesFromPropertyContainers ? targetProp.getContainer() : target;
                if (sourceAndTargetAreConstructors) {
                    sourceType = sourceType.getAssociatedContainerType();
                    targetType = targetType.getAssociatedContainerType();
                }
                return {
                    propertyName: targetProp.getScopedNameEx().toString(),
                    sourceTypeName: sourceType.toString(enclosingSymbol),
                    targetTypeName: targetType.toString(enclosingSymbol)
                }
            };

            var targetPropIsPrivate = targetProp.anyDeclHasFlag(PullElementFlags.Private);
            var sourcePropIsPrivate = sourceProp.anyDeclHasFlag(PullElementFlags.Private);

            // if visibility doesn't match, the types don't match
            if (targetPropIsPrivate !== sourcePropIsPrivate) {
                if (comparisonInfo) { // only surface the first error
                    var names = getNames(/*takeTypesFromPropertyContainers*/ true);
                    var code: string;
                    if (targetPropIsPrivate) {
                        // Overshadowing property in source that is already defined as private in target
                        code = sourceAndTargetAreConstructors
                            ? DiagnosticCode.Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2
                            : DiagnosticCode.Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2;
                    }
                    else {
                        // Public property of target is private in source
                        code =
                            sourceAndTargetAreConstructors
                            ? DiagnosticCode.Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2
                            : DiagnosticCode.Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2
                    }
                    comparisonInfo.addMessage(getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName]));
                }
                return false;
            }
            // if both are private members, test to ensure that they share a declaration
            else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];

                if (targetDecl !== sourceDecl) {
                    if (comparisonInfo) {
                        var names = getNames(/*takeTypesFromPropertyContainers*/ true);
                        // Both types define property with same name as private
                        var code = sourceAndTargetAreConstructors
                            ? DiagnosticCode.Types_0_and_1_define_static_property_2_as_private
                            : DiagnosticCode.Types_0_and_1_define_property_2_as_private;
                        comparisonInfo.addMessage(getDiagnosticMessage(code, [names.sourceTypeName, names.targetTypeName, names.propertyName]));
                    }

                    return false;
                }
            }

            // If the target property is required, and the source property is optional, they are not compatible
            if (sourceProp.isOptional && !targetProp.isOptional) {
                if (comparisonInfo) {
                    var names = getNames(/*takeTypesFromPropertyContainers*/ true);
                    comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2,
                        [names.propertyName, names.sourceTypeName, names.targetTypeName]));
                }
                return false;
            }

            this.resolveDeclaredSymbol(sourceProp, context);

            var sourcePropType = sourceProp.type;
            var targetPropType = targetProp.type;

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(sourcePropType, targetPropType, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            var comparisonInfoPropertyTypeCheck: TypeComparisonInfo = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeComparisonInfo(comparisonInfo);
            }

            context.walkMemberTypes(targetProp.name);
            var isSourcePropertyRelatableToTargetProperty = this.sourceIsRelatableToTargetInEnclosingTypes(sourcePropType,
                targetPropType, assignableTo, comparisonCache, ast, context, comparisonInfoPropertyTypeCheck,
                isComparingInstantiatedSignatures);
            context.postWalkMemberTypes();

            // Update error message correctly
            if (!isSourcePropertyRelatableToTargetProperty && comparisonInfo) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                var message: string;
                var names = getNames(/*takeTypesFromPropertyContainers*/ false);
                if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                    var code = sourceAndTargetAreConstructors
                        ? DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3
                        : DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3;
                    message = getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName, comparisonInfoPropertyTypeCheck.message]);
                }
                else {
                    var code =
                        sourceAndTargetAreConstructors
                        ? DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible
                        : DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible;
                    message = getDiagnosticMessage(code, [names.propertyName, names.sourceTypeName, names.targetTypeName]);
                }
                comparisonInfo.addMessage(message);
            }

            return isSourcePropertyRelatableToTargetProperty;
        }

        private sourceCallSignaturesAreRelatableToTargetCallSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {

            var targetCallSigs = target.getCallSignatures();

            // check signature groups
            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck: TypeComparisonInfo = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(source, target, sourceCallSigs, targetCallSigs,
                    assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var message: string;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = getDiagnosticMessage(DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible_NL_2,
                                    [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            }
                            else {
                                message = getDiagnosticMessage(DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible,
                                    [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        }
                        else {
                            var hasSig = targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetCallSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = getDiagnosticMessage(DiagnosticCode.Type_0_requires_a_call_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        }

        private sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {

            // check signature groups
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck: TypeComparisonInfo = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(source, target, sourceConstructSigs, targetConstructSigs,
                    assignableTo, comparisonCache, ast, context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures)) {
                    if (comparisonInfo) {
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        var message: string;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = getDiagnosticMessage(DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible_NL_2,
                                    [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                            }
                            else {
                                message = getDiagnosticMessage(DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible,
                                    [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                            }
                        }
                        else {
                            var hasSig = targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            var lacksSig = !targetConstructSigs.length ? target.toString(enclosingSymbol) : source.toString(enclosingSymbol);
                            message = getDiagnosticMessage(DiagnosticCode.Type_0_requires_a_construct_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        }

        private sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source: PullTypeSymbol, target: PullTypeSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean): boolean {

            var targetIndexSigs = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(target, context);
            var targetStringSig = targetIndexSigs.stringSignature;
            var targetNumberSig = targetIndexSigs.numericSignature;

            if (targetStringSig || targetNumberSig) {
                var sourceIndexSigs = this.getBothKindsOfIndexSignaturesIncludingAugmentedType(source, context);
                var enclosingTypeIndexSigs = context.getBothKindOfIndexSignatures(/*includeAugmentedType1*/ true, /*includeAugmentedType2*/ false);
                var sourceStringSig = sourceIndexSigs.stringSignature;
                var sourceNumberSig = sourceIndexSigs.numericSignature;

                var comparable = true;
                var comparisonInfoSignatuesTypeCheck: TypeComparisonInfo = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                if (targetStringSig) {
                    // Spec section 3.8.3       Subtypes and Supertypes
                    // S is a subtype of a type T, and T is a supertype of S, if one of the following is true, 
                    // where S denotes the apparent type(section 3.8.1) of S:
                    //      - M is a string index signature of type U and 
                    //        S contains a string index signature of a type that is assignable to U.

                    // Spec section 3.8.4       Assignment Compatibility
                    // S is assignable to a type T, and T is assignable from S, if one of the following is true, 
                    // where S denotes the apparent type(section 3.8.1) of S:
                    //      - M is a string index signature of type U and 
                    //        S contains a string index signature of a type that is assignable to U.
                    if (sourceStringSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, /*useStringIndexSignature1*/ true, /*useStringIndexSignature2*/ true);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceStringSig.returnType,
                            targetStringSig.returnType, assignableTo, comparisonCache, ast,
                            context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    }
                    else {
                        comparable = false;
                    }
                }

                if (comparable && targetNumberSig) {
                    // Spec section 3.8.3       Subtypes and Supertypes
                    // S is a subtype of a type T, and T is a supertype of S, if one of the following is true, 
                    // where S denotes the apparent type(section 3.8.1) of S:
                    //      - M is a numeric index signature of type U and 
                    //        S contains a string or numeric index signature of a type that is a subtype of U.

                    // Spec section 3.8.4       Assignment Compatibility
                    // S is assignable to a type T, and T is assignable from S, if one of the following is true, 
                    // where S denotes the apparent type(section 3.8.1) of S:
                    //      - M is a numeric index signature of type U and
                    //        S contains a string or numeric index signature of a type that is assignable to U.
                    if (sourceNumberSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, /*useStringIndexSignature1*/ false, /*useStringIndexSignature2*/ false);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceNumberSig.returnType,
                            targetNumberSig.returnType, assignableTo, comparisonCache, ast,
                            context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    }
                    else if (sourceStringSig) {
                        context.walkIndexSignatureReturnTypes(enclosingTypeIndexSigs, /*useStringIndexSignature1*/ true, /*useStringIndexSignature2*/ false);
                        comparable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceStringSig.returnType,
                            targetNumberSig.returnType, assignableTo, comparisonCache, ast,
                            context, comparisonInfoSignatuesTypeCheck, isComparingInstantiatedSignatures);
                        context.postWalkIndexSignatureReturnTypes();
                    }
                    else {
                        comparable = false;
                    }
                }

                if (!comparable) {
                    if (comparisonInfo) {
                        var message: string;
                        var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = getDiagnosticMessage(DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible_NL_2,
                                [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfoSignatuesTypeCheck.message]);
                        }
                        else {
                            message = getDiagnosticMessage(DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible,
                                [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]);
                        }
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        }

        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info
        private signatureGroupIsRelatableToTarget(source: PullTypeSymbol, target: PullTypeSymbol,
            sourceSG: PullSignatureSymbol[], targetSG: PullSignatureSymbol[],
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var foundMatch = false;

            var targetExcludeDefinition = targetSG.length > 1;
            var sourceExcludeDefinition = sourceSG.length > 1;
            var sigsCompared = 0;
            var comparisonInfoSignatuesTypeCheck: TypeComparisonInfo = null;
            if (comparisonInfo) {
                comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo, /*useSameIndent*/ true);
                comparisonInfoSignatuesTypeCheck.message = comparisonInfo.message;
            }
            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                var mSig = targetSG[iMSig];

                if (mSig.isStringConstantOverloadSignature() || (targetExcludeDefinition && mSig.isDefinition())) {
                    continue;
                }

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    var nSig = sourceSG[iNSig];

                    if (nSig.isStringConstantOverloadSignature() || (sourceExcludeDefinition && nSig.isDefinition())) {
                        continue;
                    }

                    context.walkSignatures(nSig.kind, iNSig, iMSig);
                    var isSignatureRelatableToTarget = this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, ast, context,
                        sigsCompared == 0 ? comparisonInfoSignatuesTypeCheck : null, isComparingInstantiatedSignatures);
                    context.postWalkSignatures();
                    
                    sigsCompared++;

                    if (isSignatureRelatableToTarget) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }

                // Give information about check fail only if we are comparing one signature.
                // This helps in perf (without comparisonInfo we can even use checks that were determined to be false)
                // Yet we can give useful info if we are comparing two types with one signature
                if (comparisonInfo && sigsCompared == 1) {
                    comparisonInfo.message = comparisonInfoSignatuesTypeCheck.message;
                }

                return false;
            }

            return true;
        }

        private signatureIsRelatableToTarget(sourceSig: PullSignatureSymbol, targetSig: PullSignatureSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean) {
            var isRelatableInfo = this.sourceIsRelatableToTargetInCache(sourceSig, targetSig, comparisonCache, comparisonInfo);
            if (isRelatableInfo) {
                return isRelatableInfo.isRelatable;
            }

            comparisonCache.setValueAt(sourceSig.pullSymbolID, targetSig.pullSymbolID, true);
            var isRelatable = this.signatureIsRelatableToTargetWorker(sourceSig, targetSig, assignableTo, comparisonCache,
                ast, context, comparisonInfo, isComparingInstantiatedSignatures);
            comparisonCache.setValueAt(sourceSig.pullSymbolID, targetSig.pullSymbolID, isRelatable);
            return isRelatable;
        }

        private signatureIsRelatableToTargetWorker(sourceSig: PullSignatureSymbol, targetSig: PullSignatureSymbol,
            assignableTo: boolean, comparisonCache: IBitMatrix, ast: ISyntaxElement, context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo, isComparingInstantiatedSignatures: boolean) {

            var sourceParameters = sourceSig.parameters;
            var targetParameters = targetSig.parameters;

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetNonOptionalParamCount = targetSig.nonOptionalParamCount;
            var sourceNonOptionalParamCount = sourceSig.nonOptionalParamCount;

            if (!targetSig.hasVarArgs && sourceNonOptionalParamCount > targetParameters.length) {
                if (comparisonInfo) {
                    comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Call_signature_expects_0_or_fewer_parameters, [targetParameters.length]));
                }
                return false;
            }

            // If signatures are relatable if sourceSig and targetSig are identical
            if (this.signaturesAreIdentical(sourceSig, targetSig, context)) {
                return true;
            }

            // From the January 23 version of the spec, following the design change:
            // Section 3.8.3 + 3.8.4: M is a non-specialized call or construct signature and S'
            // contains a call or construct signature N where, when M and N are instantiated using
            // type Any as the type argument for all type parameters declared by M and N (if any)
            targetSig = this.instantiateSignatureToAny(targetSig);
            sourceSig = this.instantiateSignatureToAny(sourceSig);

            var sourceReturnType = sourceSig.returnType;
            var targetReturnType = targetSig.returnType;

            if (targetReturnType !== this.semanticInfoChain.voidTypeSymbol) {
                context.walkReturnTypes();
                var returnTypesAreRelatable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceReturnType,
                    targetReturnType, assignableTo, comparisonCache, ast, context, comparisonInfo,
                    isComparingInstantiatedSignatures);
                context.postWalkReturnTypes();
                if (!returnTypesAreRelatable) {
                    return false;
                }
            }

            return targetSig.forAllCorrespondingParameterTypesInThisAndOtherSignature(sourceSig, (targetParamType, sourceParamType, iParam) => {
                context.walkParameterTypes(iParam);
                var areParametersRelatable = this.sourceIsRelatableToTargetInEnclosingTypes(sourceParamType, targetParamType,
                    assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                if (!areParametersRelatable) {
                    // Switch type1 and type2 enclosing types since we are doing reverse check 
                    context.swapEnclosingTypeWalkers();
                    areParametersRelatable = this.sourceIsRelatableToTargetInEnclosingTypes(targetParamType, sourceParamType,
                        assignableTo, comparisonCache, ast, context, comparisonInfo, isComparingInstantiatedSignatures);
                    context.swapEnclosingTypeWalkers();
                }
                context.postWalkParameterTypes();

                return areParametersRelatable;
            });
        }

        // Overload resolution

        private resolveOverloads(
            application: IExpressionWithArgumentListSyntax,
            group: PullSignatureSymbol[],
            haveTypeArgumentsAtCallSite: boolean,
            context: PullTypeResolutionContext,
            diagnostics: Diagnostic[]): PullSignatureSymbol {
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args = application.argumentList ? application.argumentList.arguments : null;

            var initialCandidates = ArrayUtilities.where(group, signature => {
                // Filter out definition if overloads are available
                if (hasOverloads && signature.isDefinition()) {
                    return false;
                }
                // Filter out nongeneric signatures if type arguments are supplied
                var rootSignature = <PullSignatureSymbol>signature.getRootSymbol();
                if (haveTypeArgumentsAtCallSite && !rootSignature.isGeneric()) {
                    return false;
                }

                // Filter out overloads with the wrong arity
                return this.overloadHasCorrectArity(signature, args);
            });

            // Now that we have trimmed initial candidates, find which ones are applicable per spec
            //    section 4.12.1
            // October 11, 2013: If the list of candidate signatures is empty, the function call is
            //    an error.
            // Otherwise, if the candidate list contains one or more signatures for which the type
            //    of each argument expression is a subtype of each corresponding parameter type, 
            //    the return type of the first of those signatures becomes the return type of the
            //    function call.
            // Otherwise, the return type of the first signature in the candidate list becomes
            //    the return type of the function call.

            var firstAssignableButNotSupertypeSignature: PullSignatureSymbol = null;
            var firstAssignableWithProvisionalErrorsSignature: PullSignatureSymbol = null;

            for (var i = 0; i < initialCandidates.length; i++) {
                var applicability = this.overloadIsApplicable(initialCandidates[i], args, context, comparisonInfo);
                if (applicability === OverloadApplicabilityStatus.Subtype) {
                    return initialCandidates[i];
                }
                else if (applicability === OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors &&
                    !firstAssignableButNotSupertypeSignature) {
                    firstAssignableButNotSupertypeSignature = initialCandidates[i];
                }
                else if (applicability === OverloadApplicabilityStatus.AssignableButWithProvisionalErrors &&
                    !firstAssignableWithProvisionalErrorsSignature) {
                    firstAssignableWithProvisionalErrorsSignature = initialCandidates[i];
                }
            }

            // Choose the best signature we have (between assignable candidates and ones with provisional errors)
            // In particular, do not error when we have one that fits but with provisional errors
            if (firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature) {
                return firstAssignableButNotSupertypeSignature || firstAssignableWithProvisionalErrorsSignature;
            }
            else {
                var target: ISyntaxElement = this.getCallTargetErrorSpanAST(application);
                if (comparisonInfo.message) {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target,
                        DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0, [comparisonInfo.message]));
                }
                else {
                    diagnostics.push(this.semanticInfoChain.diagnosticFromAST(target,
                        DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null));
                }
            }

            return null;
        }

        private getCallTargetErrorSpanAST(callEx: IExpressionWithArgumentListSyntax): ISyntaxElement {
            if (callEx.expression.kind() === SyntaxKind.MemberAccessExpression) {
                var memberAccessExpression = <MemberAccessExpressionSyntax>callEx.expression;
                if (memberAccessExpression.name.fullWidth() > 0) {
                    return memberAccessExpression.name;
                }
            }

            return callEx.expression;
        }

        private overloadHasCorrectArity(signature: PullSignatureSymbol, args: IExpressionSyntax[]): boolean {
            if (args == null) {
                return signature.nonOptionalParamCount === 0;
            }

            // First, figure out how many arguments there are. This is usually args.length, but if we have trailing separators,
            // we need to pretend we have one more "phantom" argument that the user is currently typing. This is useful for signature help.
            // Example: foo(1, 2, 
            // should have 3 arguments
            var numberOfArgs = (args.length && args.length === args.separatorCount())
                ? args.separatorCount() + 1
                : args.length;
            if (numberOfArgs < signature.nonOptionalParamCount) {
                return false;
            }
            if (!signature.hasVarArgs && numberOfArgs > signature.parameters.length) {
                return false;
            }

            return true;
        }

        private overloadIsApplicable(signature: PullSignatureSymbol, args: IExpressionSyntax[], context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {
            // Already checked for arity, so it's automatically applicable if there are no args
            if (args === null) {
                return OverloadApplicabilityStatus.Subtype;
            }

            var isInVarArg = false;
            var parameters = signature.parameters;
            var paramType: PullTypeSymbol = null;

            // Start by assuming that the argument types are all subtypes of the corresponding parameter types
            // Indeed this is the case for a call with no arguments.
            var overloadApplicability = OverloadApplicabilityStatus.Subtype;

            for (var i = 0; i < args.length; i++) {
                if (!isInVarArg) {
                    this.resolveDeclaredSymbol(parameters[i], context);

                    if (parameters[i].isVarArg) {
                        // If the vararg has no element type, it is malformed, so just use the any symbol (we will have errored when resolving the signature).
                        paramType = parameters[i].type.getElementType() || this.getNewErrorTypeSymbol(parameters[i].type.getName());
                        isInVarArg = true;
                    }
                    else {
                        paramType = parameters[i].type;
                    }
                }

                // We aggregate the statuses across arguments by taking the less flattering of the two statuses.
                // In the case where we get a completely unassignable argument, we can short circuit and just throw out the signature.
                var statusOfCurrentArgument = this.overloadIsApplicableForArgument(paramType, args[i], i, context, comparisonInfo);

                if (statusOfCurrentArgument === OverloadApplicabilityStatus.NotAssignable) {
                    return OverloadApplicabilityStatus.NotAssignable;
                }
                else if (statusOfCurrentArgument === OverloadApplicabilityStatus.AssignableButWithProvisionalErrors) {
                    overloadApplicability = OverloadApplicabilityStatus.AssignableButWithProvisionalErrors;
                }
                else if (overloadApplicability !== OverloadApplicabilityStatus.AssignableButWithProvisionalErrors &&
                    statusOfCurrentArgument === OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors) {
                    overloadApplicability = OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
                }
                // else we have nothing to downgrade - just stick with what we have
            }

            return overloadApplicability;
        }

        private overloadIsApplicableForArgument(paramType: PullTypeSymbol, arg: ISyntaxNodeOrToken, argIndex: number, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {
            if (paramType.isAny()) {
                return OverloadApplicabilityStatus.Subtype;
            }
            else if (paramType.isError()) {
                // This is for the case where the parameter type itself was malformed. We will treat this like a provisional error because
                // we will get an error for this in the overload defition group, and we want to avoid choosing this overload if possible.
                return OverloadApplicabilityStatus.AssignableButWithProvisionalErrors;
            }
            else if (arg.kind() === SyntaxKind.SimpleArrowFunctionExpression) {
                var simpleArrowFunction = <SimpleArrowFunctionExpressionSyntax>arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType,
                    arg, null, ASTHelpers.parametersFromIdentifier(simpleArrowFunction.identifier), null, simpleArrowFunction.block, simpleArrowFunction.expression,
                    argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === SyntaxKind.ParenthesizedArrowFunctionExpression) {
                var arrowFunction = <ParenthesizedArrowFunctionExpressionSyntax>arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType,
                    arg, arrowFunction.callSignature.typeParameterList, ASTHelpers.parametersFromParameterList(arrowFunction.callSignature.parameterList),
                    ASTHelpers.getType(arrowFunction), arrowFunction.block, arrowFunction.expression, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === SyntaxKind.FunctionExpression) {
                var functionExpression = <FunctionExpressionSyntax>arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType,
                    arg, functionExpression.callSignature.typeParameterList, ASTHelpers.parametersFromParameterList(functionExpression.callSignature.parameterList),
                    ASTHelpers.getType(functionExpression), functionExpression.block, /*bodyExpression:*/ null, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === SyntaxKind.ObjectLiteralExpression) {
                return this.overloadIsApplicableForObjectLiteralArgument(paramType, <ObjectLiteralExpressionSyntax>arg, argIndex, context, comparisonInfo);
            }
            else if (arg.kind() === SyntaxKind.ArrayLiteralExpression) {
                return this.overloadIsApplicableForArrayLiteralArgument(paramType, <ArrayLiteralExpressionSyntax>arg, argIndex, context, comparisonInfo);
            }
            else {
                return this.overloadIsApplicableForOtherArgument(paramType, arg, argIndex, context, comparisonInfo);
            }
        }

        private overloadIsApplicableForAnyFunctionExpressionArgument(
            paramType: PullTypeSymbol,
            arg: ISyntaxNodeOrToken,
            typeParameters: TypeParameterListSyntax,
            parameters: IParameters,
            returnTypeAnnotation: ISyntaxNodeOrToken,
            block: BlockSyntax,
            bodyExpression: ISyntaxNodeOrToken,
            argIndex: number,
            context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {

            if (this.cachedFunctionInterfaceType() && paramType === this.cachedFunctionInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }

            context.pushProvisionalType(paramType);

            var argSym = this.resolveAnyFunctionExpression(arg, typeParameters, parameters, returnTypeAnnotation, block, bodyExpression,
            /*isContextuallyTyped*/ true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        }

        private overloadIsApplicableForObjectLiteralArgument(
            paramType: PullTypeSymbol,
            arg: ObjectLiteralExpressionSyntax,
            argIndex: number,
            context: PullTypeResolutionContext,
            comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {

            // attempt to contextually type the object literal
            if (this.cachedObjectInterfaceType() && paramType === this.cachedObjectInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }

            context.pushProvisionalType(paramType);
            var argSym = this.resolveObjectLiteralExpression(arg, /*isContextuallyTyped*/ true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        }

        private overloadIsApplicableForArrayLiteralArgument(paramType: PullTypeSymbol, arg: ArrayLiteralExpressionSyntax, argIndex: number, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {
            // attempt to contextually type the array literal
            if (paramType === this.cachedArrayInterfaceType()) {
                return OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }

            context.pushProvisionalType(paramType);
            var argSym = this.resolveArrayLiteralExpression(arg, /*isContextuallyTyped*/ true, context);

            var applicabilityStatus = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);

            context.popAnyContextualType();

            return applicabilityStatus;
        }

        private overloadIsApplicableForOtherArgument(paramType: PullTypeSymbol, arg: ISyntaxElement, argIndex: number, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): OverloadApplicabilityStatus {
            // No need to contextually type or mark as provisional
            var argSym = this.resolveAST(arg, /*isContextuallyTyped*/ false, context);

            // If it is an alias, get its type
            if (argSym.type.isAlias()) {
                var aliasSym = <PullTypeAliasSymbol>argSym.type;
                argSym = aliasSym.getExportAssignedTypeSymbol();
            }

            // Just in case the argument is a string literal, and are checking overload on const, we set this stringConstantVal
            // (sourceIsAssignableToTarget will internally check if the argument is actually a string)
            comparisonInfo.stringConstantVal = arg;
            return this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, arg, context);
        }

        // The inner method that decides if an overload is applicable. It can return any of 4 applicability statuses
        // Spec October 11, 2013: Section 4.12.1: for each argument expression e and its corresponding parameter P, 
        // when e is contextually typed(section 4.19) by the type of P, no errors ensue and the type of e is assignable
        // to (section 3.8.4) the type of P.
        // Note this also tracks whether the argument type is a subtype of the parameter type
        private overloadIsApplicableForArgumentHelper(paramType: PullTypeSymbol,
            argSym: PullSymbol,
            argumentIndex: number,
            comparisonInfo: TypeComparisonInfo,
            arg: ISyntaxElement,
            context: PullTypeResolutionContext): OverloadApplicabilityStatus {
            // Make a temporary comparison info to catch an error in case the parameter is not a supertype (we don't want to report such errors)
            var tempComparisonInfo = new TypeComparisonInfo();
            tempComparisonInfo.stringConstantVal = comparisonInfo.stringConstantVal;
            if (!context.hasProvisionalErrors() && this.sourceIsSubtypeOfTarget(argSym.type, paramType, arg, context, tempComparisonInfo)) {
                return OverloadApplicabilityStatus.Subtype;
            }

            // Now check for normal assignability using the original comparison info (or use the temporary one if the original one already has an error).
            if (this.sourceIsAssignableToTarget(argSym.type, paramType, arg, context, comparisonInfo.message ? tempComparisonInfo : comparisonInfo)) {
                return context.hasProvisionalErrors()
                    ? OverloadApplicabilityStatus.AssignableButWithProvisionalErrors
                    : OverloadApplicabilityStatus.AssignableWithNoProvisionalErrors;
            }

            if (!comparisonInfo.message) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(arg);
                comparisonInfo.addMessage(getDiagnosticMessage(DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2,
                    [paramType.toString(enclosingSymbol), (argumentIndex + 1), argSym.getTypeName(enclosingSymbol)]));
            }

            return OverloadApplicabilityStatus.NotAssignable;
        }

        private inferArgumentTypesForSignature(argContext: TypeArgumentInferenceContext, comparisonInfo: TypeComparisonInfo, context: PullTypeResolutionContext): PullTypeSymbol[] {
            var inferenceResultTypes = argContext.inferTypeArguments();
            var typeParameters = argContext.signatureBeingInferred.getTypeParameters();
            Debug.assert(typeParameters.length == inferenceResultTypes.length);

            // Fall back to constraints if constraints are not satisfied
            var typeReplacementMapForConstraints: TypeSubstitutionMap = null;
            for (var i = 0; i < inferenceResultTypes.length; i++) {
                if (typeParameters[i].getConstraint()) {
                    typeReplacementMapForConstraints = typeReplacementMapForConstraints || PullInstantiationHelpers.createTypeParameterSubstitutionMap(typeParameters, inferenceResultTypes);
                    var associatedConstraint = this.instantiateType(typeParameters[i].getConstraint(), typeReplacementMapForConstraints);
                    if (!this.sourceIsAssignableToTargetWithNewEnclosingTypes(inferenceResultTypes[i], associatedConstraint, /*ast*/ null, context, /*comparisonInfo*/ null, /*isComparingInstantiatedSignatures*/ false)) {
                        inferenceResultTypes[i] = associatedConstraint;
                    }
                }
            }

            //  Do not let local type parameters escape at call sites
            //  Because we're comparing for equality between two signatures (where one is instantiated
            //  against the type parameters of the other), we want to know * exactly * what the
            //  instantiation would be give the set of type parameters.In the case where the two
            //  signatures are otherwise equal, we don't want to sub in '{ }' for any of the type parameters,
            //  since that would short - circuit the equality check.The substitution is only desirable at call sites,
            //  where type parameters can leak out of scope, but during contextual instantiation
            //  the type parameters * should * be considered in scope

            // We know that if we are inferring at a call expression we are not doing
            // contextual signature instantiation
            if (argContext.isInvocationInferenceContext()) {
                // Need to know if the type parameters are in scope. If not, they are not legal inference
                // candidates unless we are in contextual signature instantiation
                var invocationContext = <InvocationTypeArgumentInferenceContext>argContext;
                if (!this.typeParametersAreInScopeAtArgumentList(typeParameters, invocationContext.argumentList)) {
                    for (var i = 0; i < inferenceResultTypes.length; i++) {
                        // Check if the inferred type wraps any one of the type parameters
                        if (inferenceResultTypes[i].wrapsSomeTypeParameter(argContext.candidateCache)) {
                            inferenceResultTypes[i] = this.semanticInfoChain.anyTypeSymbol;
                        }
                    }
                }
            }

            return inferenceResultTypes;
        }

        private typeParametersAreInScopeAtArgumentList(typeParameters: PullTypeParameterSymbol[], args: ArgumentListSyntax): boolean {
            // If the parent path from the current enclosing decl contains the type parameters'
            // parent decl, then the type parameters must be in scope
            var enclosingDecl = this.getEnclosingDeclForAST(args);
            var typeParameterParentDecl = typeParameters[0].getDeclarations()[0].getParentDecl();
            return enclosingDecl.getParentPath().indexOf(typeParameterParentDecl) > -1;
        }

        private relateTypeToTypeParametersInEnclosingType(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext) {
            if (expressionType && parameterType) {
                if (context.oneOfClassificationsIsInfinitelyExpanding()) {
                    this.relateInifinitelyExpandingTypeToTypeParameters(expressionType, parameterType, argContext, context);
                    return;
                }
            }
            this.relateTypeToTypeParameters(expressionType, parameterType, argContext, context);
        }
        
        public relateTypeToTypeParametersWithNewEnclosingTypes(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext): void {

            var enclosingTypeWalkerStates = context.resetEnclosingTypeWalkerStates();
            this.relateTypeToTypeParameters(expressionType, parameterType, argContext, context);
            context.setEnclosingTypeWalkerStates(enclosingTypeWalkerStates);
        }

        public relateTypeToTypeParameters(expressionType: PullTypeSymbol,
            parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext,
            context: PullTypeResolutionContext): void {

            if (!expressionType || !parameterType) {
                return;
            }

            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (parameterType.isTypeParameter()) {
                var typeParameter = <PullTypeParameterSymbol>parameterType;
                argContext.addCandidateForInference(typeParameter, expressionType);
                return;
            }

            // This is an optimization. Essentially the only way we can make an inference by diving
            // into a type is if our type parameters T occur inside that type. Because we don't have
            // nested named types, this can only occur if the type is anonymous, or if it is generic
            // and T is a type argument to that type.
            if (parameterType.isNamedTypeSymbol() && !parameterType.isGeneric() && !parameterType.getTypeArguments()) {
                return;
            }

            // As an optimization, if both types are generic and the same type, relate their type arguments
            if (PullInstantiationHelpers.twoTypesAreInstantiationsOfSameNamedGenericType(expressionType, parameterType)) {
                this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, argContext, context);
            }
            else {
                // Relate structurally
                var symbolsWhenStartedWalkingTypes = context.startWalkingTypes(expressionType, parameterType);
                this.relateObjectTypeToTypeParameters(expressionType, parameterType, argContext, context);
                context.endWalkingTypes(symbolsWhenStartedWalkingTypes);
            }
        }

        private relateTypeArgumentsOfTypeToTypeParameters(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext) {
            var parameterSideTypeArguments: PullTypeSymbol[] = parameterType.getTypeArguments();
            var argumentSideTypeArguments: PullTypeSymbol[] = expressionType.getTypeArguments();

            Debug.assert(parameterSideTypeArguments && argumentSideTypeArguments && parameterSideTypeArguments.length === argumentSideTypeArguments.length);
            for (var i = 0; i < parameterSideTypeArguments.length; i++) {
                this.relateTypeToTypeParametersWithNewEnclosingTypes(argumentSideTypeArguments[i], parameterSideTypeArguments[i], argContext, context);
            }
        }

        private relateInifinitelyExpandingTypeToTypeParameters(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext): void {
            if (!expressionType || !parameterType) {
                return;
            }
            // Section 3.8.7 - Recursive Types
            // Likewise, when making type inferences(section 3.8.6) from a type S to a type T, 
            // if either type originates in an infinitely expanding type reference, then
            //     if S and T are type references to the same named type, inferences are made from each type argument in S to each type argument in T,
            //     otherwise, no inferences are made.
            var expressionTypeNamedTypeReference = PullHelpers.getRootType(expressionType);
            var parameterTypeNamedTypeReference = PullHelpers.getRootType(parameterType);
            if (expressionTypeNamedTypeReference !== parameterTypeNamedTypeReference) {
                return;
            }

            var expressionTypeTypeArguments = expressionType.getTypeArguments();
            var parameterTypeArguments = parameterType.getTypeArguments();

            if (expressionTypeTypeArguments && parameterTypeArguments && expressionTypeTypeArguments.length === parameterTypeArguments.length) {
                for (var i = 0; i < expressionTypeTypeArguments.length; i++) {
                    this.relateTypeArgumentsOfTypeToTypeParameters(expressionType, parameterType, argContext, context);
                }
            }
        }

        private relateFunctionSignatureToTypeParameters(expressionSignature: PullSignatureSymbol,
            parameterSignature: PullSignatureSymbol,
            argContext: TypeArgumentInferenceContext,
            context: PullTypeResolutionContext): void {

            var expressionReturnType = expressionSignature.returnType;
            var parameterReturnType = parameterSignature.returnType;

            parameterSignature.forAllCorrespondingParameterTypesInThisAndOtherSignature(expressionSignature, (parameterSignatureParameterType, expressionSignatureParameterType, i) => {
                context.walkParameterTypes(i);
                this.relateTypeToTypeParametersInEnclosingType(expressionSignatureParameterType, parameterSignatureParameterType,
                    argContext, context);
                context.postWalkParameterTypes();
                return true; // Keep going
            });

            context.walkReturnTypes();
            this.relateTypeToTypeParametersInEnclosingType(expressionReturnType, parameterReturnType,
                argContext, context);
            context.postWalkReturnTypes();
        }

        private relateObjectTypeToTypeParameters(objectType: PullTypeSymbol,
            parameterType: PullTypeSymbol,
            argContext: TypeArgumentInferenceContext,
            context: PullTypeResolutionContext): void {

            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures: PullSignatureSymbol[];

            var objectMember: PullSymbol;
            var objectSignatures: PullSignatureSymbol[];


            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            // - If M is a property and S contains a property N with the same name as M, inferences are made from the type of N to the type of M.
            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getNamedPropertySymbol(parameterTypeMembers[i].name, PullElementKind.SomeValue, objectType);
                if (objectMember) {
                    // TODO: resolveDeclaredSymbol shouldn't be necessary here, but full fix requires changing underlying
                    // symbols to resolve themselves, which should be done at a later time.
                    this.resolveDeclaredSymbol(objectMember);
                    this.resolveDeclaredSymbol(parameterTypeMembers[i]);
                    context.walkMemberTypes(parameterTypeMembers[i].name);
                    this.relateTypeToTypeParametersInEnclosingType(objectMember.type, parameterTypeMembers[i].type,
                        argContext, context);
                    context.postWalkMemberTypes();
                }
            }

            // If M is a call signature then for each call signature N in S, if the number of non-optional
            // parameters in N is greater than or equal to that of M, N is instantiated with each of its
            // type parameter constraints as type arguments (if any) and inferences are made from parameter
            // types in N to parameter types in the same position in M, and from the return type of N to the
            // return type of M.
            this.relateSignatureGroupToTypeParameters(objectType.getCallSignatures(), parameterType.getCallSignatures(), PullElementKind.CallSignature, argContext, context);

            // If M is a construct signature then for each construct signature N in S, if the number of non-optional
            // parameters in N is greater than or equal to that of M, N is instantiated with each of its
            // type parameter constraints as type arguments (if any) and inferences are made from parameter
            // types in N to parameter types in the same position in M, and from the return type of N to the
            // return type of M.
            this.relateSignatureGroupToTypeParameters(objectType.getConstructSignatures(), parameterType.getConstructSignatures(), PullElementKind.ConstructSignature, argContext, context);

            var parameterIndexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(parameterType, context);
            var objectIndexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(objectType, context);
            var indexSigInfo = context.getBothKindOfIndexSignatures(/*includingAugmentedType1*/false, /*includingAugmentedType1*/false);

            // - If M is a string index signature and S contains a string index signature N, inferences are made from the type of N to the type of M.
            // - If M is a numeric index signature and S contains a numeric index signature N, inferences are made from the type of N to the type of M.
            if (parameterIndexSignatures.stringSignature && objectIndexSignatures.stringSignature) {
                context.walkIndexSignatureReturnTypes(indexSigInfo, /*useStringIndexSignature1*/ true, /*useStringIndexSignature2*/ true, /*onlySignature*/ true);
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.stringSignature, parameterIndexSignatures.stringSignature, argContext, context);
                context.postWalkIndexSignatureReturnTypes(/*onlySignature*/ true);
            }
            if (parameterIndexSignatures.numericSignature && objectIndexSignatures.numericSignature) {
                context.walkIndexSignatureReturnTypes(indexSigInfo, /*useStringIndexSignature1*/ false, /*useStringIndexSignature2*/ false, /*onlySignature*/ true);
                this.relateFunctionSignatureToTypeParameters(objectIndexSignatures.numericSignature, parameterIndexSignatures.numericSignature, argContext, context);
                context.postWalkIndexSignatureReturnTypes(/*onlySignature*/ true);
            }
        }

        // If M is a call/construct signature then for each call/construct signature N in S, if the number of non-optional
        // parameters in N is greater than or equal to that of M, N is instantiated with each of its
        // type parameter constraints as type arguments (if any) and inferences are made from parameter
        // types in N to parameter types in the same position in M, and from the return type of N to the
        // return type of M.
        private relateSignatureGroupToTypeParameters(
            argumentSignatures: PullSignatureSymbol[],
            parameterSignatures: PullSignatureSymbol[],
            signatureKind: PullElementKind, // Call or construct
            argContext: TypeArgumentInferenceContext,
            context: PullTypeResolutionContext): void {
            for (var i = 0; i < parameterSignatures.length; i++) { 
                var paramSignature = parameterSignatures[i];
                if (argumentSignatures.length > 0) {
                    paramSignature = this.instantiateSignatureToAny(paramSignature);
                }
                for (var j = 0; j < argumentSignatures.length; j++) {
                    var argumentSignature = argumentSignatures[j];
                    if (argumentSignature.nonOptionalParamCount > paramSignature.nonOptionalParamCount) {
                        continue;
                    }

                    argumentSignature = this.instantiateSignatureToAny(argumentSignature);

                    // In relateTypeToTypeParameters, the argument type (expressionType) is passed in first
                    // (before the parameter type), so the correct order here is j, i
                    context.walkSignatures(signatureKind, j, i);
                    this.relateFunctionSignatureToTypeParameters(argumentSignature, paramSignature, argContext, context); 
                    context.postWalkSignatures();
                }
            }
        }

        // November 18, 2013, Section 4.12.2:
        // If e is an expression of a function type that contains exactly one generic call signature
        // and no other members, and T is a function type with exactly one non-generic call signature
        // and no other members, then any inferences made for type parameters referenced by the
        // parameters of T's call signature are fixed and, if e's call signature can successfully be
        // instantiated in the context of T's call signature(section 3.8.5), e's type is changed to
        // a function type with that instantiated signature.
        private alterPotentialGenericFunctionTypeToInstantiatedFunctionTypeForTypeArgumentInference(expressionSymbol: PullSymbol, context: PullTypeResolutionContext): PullSymbol {
            // In this case getContextualType will give us the inferential type
            var inferentialType = context.getContextualType();
            Debug.assert(inferentialType);
            var expressionType = expressionSymbol.type;
            if (this.isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(expressionType, /*callSignatureShouldBeGeneric*/ true) &&
                this.isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(inferentialType, /*callSignatureShouldBeGeneric*/ false)) {
                // Here we overwrite contextualType because we will want to use the version of the type
                // that was instantiated with the fixed type parameters from the argument inference
                // context
                var genericExpressionSignature = expressionType.getCallSignatures()[0];
                var contextualSignature = inferentialType.getCallSignatures()[0];

                // Contextual signature instantiation will return null if the instantiation is unsuccessful
                // We pass true so that the parameters of the contextual signature will be fixed per the spec.
                var instantiatedSignature = this.instantiateSignatureInContext(genericExpressionSignature, contextualSignature, context, /*shouldFixContextualSignatureParameterTypes*/ true);
                if (instantiatedSignature === null) {
                    return expressionSymbol;
                }

                // Create new type with just the given call signature
                var newType = new PullTypeSymbol("", PullElementKind.FunctionType, this.semanticInfoChain);
                newType.appendCallSignature(instantiatedSignature);
                return newType;
            }

            return expressionSymbol;
        }

        private isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(type: PullTypeSymbol, callSignatureShouldBeGeneric: boolean): boolean {
            Debug.assert(type);
            if (type.getCallSignatures().length !== 1) {
                return false;
            }

            var callSignatureIsGeneric = type.getCallSignatures()[0].isGeneric();
            if (callSignatureIsGeneric !== callSignatureShouldBeGeneric) {
                return false;
            }

            var typeHasOtherMembers =
                type.getConstructSignatures().length ||
                type.getIndexSignatures().length ||
                type.getAllMembers(PullElementKind.SomeValue, GetAllMembersVisiblity.all).length;
            if (typeHasOtherMembers) {
                return false;
            }

            return true;
        }

        public instantiateTypeToAny(typeToSpecialize: PullTypeSymbol, context: PullTypeResolutionContext): PullTypeSymbol {

            var typeParameters = typeToSpecialize.getTypeParameters();

            if (!typeParameters.length) {
                return typeToSpecialize;
            }

            var typeArguments: PullTypeSymbol[] = null;

            if (!this._cachedAnyTypeArgs) {
                this._cachedAnyTypeArgs = [
                    [this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol]
                ];
            }

            if (typeParameters.length < this._cachedAnyTypeArgs.length) {
                typeArguments = this._cachedAnyTypeArgs[typeParameters.length - 1];
            }
            else {
                // REVIEW: might want to cache these arg lists
                typeArguments = [];

                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var type = this.createInstantiatedType(typeToSpecialize, typeArguments);

            return type;
        }

        public instantiateSignatureToAny(signature: PullSignatureSymbol) {
            if (!signature.isGeneric()) {
                return signature;
            }

            var typeParameters = signature.getTypeParameters();
            if (!this._cachedAnyTypeArgs) {
                this._cachedAnyTypeArgs = [
                    [this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol],
                    [this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol, this.semanticInfoChain.anyTypeSymbol]
                ];
            }

            if (typeParameters.length < this._cachedAnyTypeArgs.length) {
                var typeArguments = this._cachedAnyTypeArgs[typeParameters.length - 1];
            }
            else {
                // REVIEW: might want to cache these arg lists
                var typeArguments: PullTypeSymbol[] = [];

                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var typeParameterArgumentMap = PullInstantiationHelpers.createTypeParameterSubstitutionMap(typeParameters, typeArguments);
            return this.instantiateSignature(signature, typeParameterArgumentMap);
        }

        public static globalTypeCheckPhase = 0;

        // type check infrastructure
        public static typeCheck(compilationSettings: ImmutableCompilationSettings, semanticInfoChain: SemanticInfoChain, document: Document): void {
            var sourceUnit = document.sourceUnit();

            var resolver = semanticInfoChain.getResolver();
            var context = new PullTypeResolutionContext(resolver, /*inTypeCheck*/ true, TypeScript.syntaxTree(sourceUnit).fileName());

            if (resolver.canTypeCheckAST(sourceUnit, context)) {
                resolver.resolveAST(sourceUnit, /*isContextuallyTyped:*/ false, context);
                resolver.validateVariableDeclarationGroups(semanticInfoChain.getDeclForAST(sourceUnit), context);

                while (resolver.typeCheckCallBacks.length) {
                    var callBack = resolver.typeCheckCallBacks.pop();
                    callBack(context);
                }

                resolver.processPostTypeCheckWorkItems(context);
            }
        }

        private validateVariableDeclarationGroups(enclosingDecl: PullDecl, context: PullTypeResolutionContext) {            
            this.scanVariableDeclarationGroups(
                enclosingDecl,
                (_: PullDecl) => { },
                (subsequentDecl: PullDecl, firstSymbol: PullSymbol) => {
                    // do not report 'must have same type' error for parameters - it makes no sense for them
                    // having 'duplicate name' error that can be raised during parameter binding is enough
                    if (hasFlag(subsequentDecl.kind, PullElementKind.Parameter) || hasFlag(subsequentDecl.flags, PullElementFlags.PropertyParameter)) {
                        return;
                    }

                    var boundDeclAST = this.semanticInfoChain.getASTForDecl(subsequentDecl);

                    var symbol = subsequentDecl.getSymbol(this.semanticInfoChain);
                    var symbolType = symbol.type;
                    var firstSymbolType = firstSymbol.type;

                    if (symbolType && firstSymbolType && symbolType !== firstSymbolType && !this.typesAreIdentical(symbolType, firstSymbolType, context)) {
                        context.postDiagnostic(
                            this.semanticInfoChain.diagnosticFromAST(
                                boundDeclAST,
                                DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, [symbol.getScopedName(), firstSymbolType.toString(firstSymbol), symbolType.toString(symbol)]));
                    }
                });
        }

        private typeCheckFunctionOverloads(
            funcDecl: ISyntaxElement,
            context: PullTypeResolutionContext,
            signature?: PullSignatureSymbol,
            allSignatures?: PullSignatureSymbol[]) {

            if (!signature) {
                var functionSignatureInfo = PullHelpers.getSignatureForFuncDecl(this.semanticInfoChain.getDeclForAST(funcDecl), this.semanticInfoChain);
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = this.semanticInfoChain.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol(this.semanticInfoChain);

            // Find the definition signature for this signature group
            var definitionSignature: PullSignatureSymbol = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }

            // Verify assignment compatibility or in case of constantOverload signature, if its subtype of atleast one signature
            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    // Report error - definition signature cannot specify constant type
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, DiagnosticCode.Overload_signature_implementation_cannot_use_specialized_type));
                }
                else {
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }

                        if (!allSignatures[i].isResolved) {
                            this.resolveDeclaredSymbol(allSignatures[i], context);
                        }

                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }

                        if (this.signatureIsAssignableToTarget(signature, allSignatures[i], /*ast*/ null, context)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }

                    if (!foundSubtypeSignature) {
                        // Could not find the overload signature subtype
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, DiagnosticCode.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature));
                    }
                }
            }
            else if (definitionSignature && definitionSignature !== signature) {
                var comparisonInfo = new TypeComparisonInfo();

                if (!definitionSignature.isResolved) {
                    this.resolveDeclaredSymbol(definitionSignature, context);
                }

                if (!this.signatureIsAssignableToTarget(definitionSignature, signature, funcDecl, context, comparisonInfo)) {
                    // definition signature is not assignable to functionSignature then its incorrect overload signature
                    if (comparisonInfo.message) {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition_NL_0, [comparisonInfo.message]));
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition));
                    }
                }
            }

            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }

            if (funcDecl.kind() !== SyntaxKind.ConstructorDeclaration && functionDeclaration.kind !== PullElementKind.ConstructSignature && signatureForVisibilityCheck && signature !== signatureForVisibilityCheck) {
                var errorCode: string;
                // verify it satisfies all the properties of first signature
                if (signatureForVisibilityCheck.anyDeclHasFlag(PullElementFlags.Private) !== signature.anyDeclHasFlag(PullElementFlags.Private)) {
                    errorCode = DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(PullElementFlags.Exported) !== signature.anyDeclHasFlag(PullElementFlags.Exported)) {
                    errorCode = DiagnosticCode.Overload_signatures_must_all_be_exported_or_not_exported;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(PullElementFlags.Ambient) !== signature.anyDeclHasFlag(PullElementFlags.Ambient)) {
                    errorCode = DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                }
                else if (signatureForVisibilityCheck.anyDeclHasFlag(PullElementFlags.Optional) !== signature.anyDeclHasFlag(PullElementFlags.Optional)) {
                    errorCode = DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }

                if (errorCode) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(funcDecl, errorCode));
                }
            }
        }

        // Privacy checking

        private checkSymbolPrivacy(declSymbol: PullSymbol, symbol: PullSymbol, privacyErrorReporter: (symbol: PullSymbol) => void) {
            if (!symbol || symbol.kind === PullElementKind.Primitive) {
                return;
            }

            if (symbol.isType()) {
                var typeSymbol = <PullTypeSymbol>symbol;
                var isNamedType = typeSymbol.isNamedTypeSymbol();

                if (typeSymbol.isArrayNamedTypeReference()) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getElementType(), privacyErrorReporter);
                    return;
                }

                if (!isNamedType) {
                    var typeOfSymbol = typeSymbol.getTypeOfSymbol();
                    if (typeOfSymbol) {
                        this.checkSymbolPrivacy(declSymbol, typeOfSymbol, privacyErrorReporter);
                        return;
                    }
                }

                if (typeSymbol.inSymbolPrivacyCheck) {
                    return;
                }

                typeSymbol.inSymbolPrivacyCheck = true;

                var typars = typeSymbol.getTypeArgumentsOrTypeParameters();
                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, typars[i], privacyErrorReporter);
                    }
                }

                if (!isNamedType) {
                    var members = typeSymbol.getMembers();
                    for (var i = 0; i < members.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, members[i].type, privacyErrorReporter);
                    }

                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), privacyErrorReporter);
                }
                else if (typeSymbol.kind === PullElementKind.TypeParameter) {
                    this.checkSymbolPrivacy(declSymbol, (<PullTypeParameterSymbol>typeSymbol).getConstraint(), privacyErrorReporter);
                }

                typeSymbol.inSymbolPrivacyCheck = false;

                if (!isNamedType) {
                    return;
                }
            }

            // Check flags for the symbol itself
            if (declSymbol.isExternallyVisible()) {
                // Check if type symbol is externally visible
                var symbolIsVisible = symbol.isExternallyVisible();
                // If Visible check if the type is part of dynamic module
                if (symbolIsVisible && symbol.kind !== PullElementKind.TypeParameter) {
                    var symbolPath = symbol.pathToRoot();
                    var declSymbolPath = declSymbol.pathToRoot();
                    // Symbols are from different dynamic modules
                    if (symbolPath[symbolPath.length - 1].kind === PullElementKind.DynamicModule &&
                        declSymbolPath[declSymbolPath.length - 1].kind === PullElementKind.DynamicModule &&
                        declSymbolPath[declSymbolPath.length - 1] !== symbolPath[symbolPath.length - 1]) {
                        // Declaration symbol is from different modules
                        // Type may not be visible without import statement
                        symbolIsVisible = false;
                        var declSymbolScope = declSymbolPath[declSymbolPath.length - 1];
                        for (var i = symbolPath.length - 1; i >= 0; i--) {
                            var aliasSymbols = symbolPath[i].getExternalAliasedSymbols(declSymbolScope);
                            if (aliasSymbols) {
                                // Visible type.
                                symbolIsVisible = true;
                                aliasSymbols[0].setTypeUsedExternally();
                                break;
                            }
                        }
                        symbol = symbolPath[symbolPath.length - 1];
                    }
                }
                else if (symbol.kind === PullElementKind.TypeAlias) {
                    var aliasSymbol = <PullTypeAliasSymbol>symbol;
                    symbolIsVisible = true;
                    aliasSymbol.setTypeUsedExternally();
                }

                if (!symbolIsVisible) {
                    // declaration is visible from outside but the type isnt - Report error
                    privacyErrorReporter(symbol);
                }
            }
        }

        private checkTypePrivacyOfSignatures(declSymbol: PullSymbol, signatures: PullSignatureSymbol[], privacyErrorReporter: (symbol: PullSymbol) => void) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length > 1 && signature.isDefinition()) {
                    continue;
                }

                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkSymbolPrivacy(declSymbol, typeParams[j], privacyErrorReporter);
                }

                var params = signature.parameters;
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].type;
                    this.checkSymbolPrivacy(declSymbol, paramType, privacyErrorReporter);
                }

                var returnType = signature.returnType;
                this.checkSymbolPrivacy(declSymbol, returnType, privacyErrorReporter);
            }
        }

        private typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface: ISyntaxElement, typeParameterAST: TypeParameterSyntax, typeParameter: PullTypeParameterSymbol, symbol: PullSymbol, context: PullTypeResolutionContext) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
            var messageCode: string;

            var typeParameters = classOrInterface.kind() === SyntaxKind.ClassDeclaration
                ? (<ClassDeclarationSyntax>classOrInterface).typeParameterList
                : (<InterfaceDeclarationSyntax>classOrInterface).typeParameterList;

            var typeSymbol = <PullTypeSymbol>symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === SyntaxKind.ClassDeclaration) {
                    // Class
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_class_is_using_inaccessible_module_1;
                }
                else {
                    // Interface
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1;
                }
            }
            else {
                if (classOrInterface.kind() === SyntaxKind.ClassDeclaration) {
                    // Class
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_class_has_or_is_using_private_type_1;
                }
                else {
                    // Interface
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [typeParameter.getScopedName(enclosingSymbol, /*skipTypeParametersInName*/ false, true /*useConstraintInName*/), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArguments));
        }

        private baseListPrivacyErrorReporter(classOrInterface: ISyntaxElement, declSymbol: PullTypeSymbol, baseAst: ISyntaxElement, isExtendedType: boolean, symbol: PullSymbol, context: PullTypeResolutionContext) {
            var decl = this.semanticInfoChain.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
            var messageCode: string;

            var typeSymbol = <PullTypeSymbol>symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.kind() === SyntaxKind.ClassDeclaration) {
                    // Class
                    if (isExtendedType) {
                        messageCode = DiagnosticCode.Exported_class_0_extends_class_from_inaccessible_module_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Exported_class_0_implements_interface_from_inaccessible_module_1;
                    }
                }
                else {
                    // Interface
                    messageCode = DiagnosticCode.Exported_interface_0_extends_interface_from_inaccessible_module_1;
                }
            }
            else {
                if (classOrInterface.kind() === SyntaxKind.ClassDeclaration) {
                    // Class
                    if (isExtendedType) {
                        messageCode = DiagnosticCode.Exported_class_0_extends_private_class_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Exported_class_0_implements_private_interface_1;
                    }
                }
                else {
                    // Interface
                    messageCode = DiagnosticCode.Exported_interface_0_extends_private_interface_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseAst, messageCode, messageArguments));
        }

        private variablePrivacyErrorReporter(declAST: ISyntaxElement, declSymbol: PullSymbol, symbol: PullSymbol, context: PullTypeResolutionContext) {
            var typeSymbol = <PullTypeSymbol>symbol;
            var enclosingDecl = this.getEnclosingDecl(declSymbol.getDeclarations()[0]);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isProperty = declSymbol.kind === PullElementKind.Property;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.kind === PullElementKind.Class || declParent.kind === PullElementKind.ConstructorMethod)) {
                isPropertyOfClass = true;
            }

            var messageCode: string;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declSymbol.anyDeclHasFlag(PullElementFlags.Static)) {
                    messageCode = DiagnosticCode.Public_static_property_0_of_exported_class_is_using_inaccessible_module_1;
                }
                else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = DiagnosticCode.Public_property_0_of_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Property_0_of_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else {
                    messageCode = DiagnosticCode.Exported_variable_0_is_using_inaccessible_module_1;
                }
            }
            else {
                if (declSymbol.anyDeclHasFlag(PullElementFlags.Static)) {
                    messageCode = DiagnosticCode.Public_static_property_0_of_exported_class_has_or_is_using_private_type_1;
                }
                else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = DiagnosticCode.Public_property_0_of_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Property_0_of_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else {
                    messageCode = DiagnosticCode.Exported_variable_0_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
        }

        private checkFunctionTypePrivacy(
            funcDeclAST: ISyntaxElement,
            isStatic: boolean,
            typeParameters: TypeParameterListSyntax,
            parameters: IParameters,
            returnTypeAnnotation: ISyntaxElement,
            block: BlockSyntax,
            context: PullTypeResolutionContext) {

            if (funcDeclAST.kind() === SyntaxKind.FunctionExpression ||
                funcDeclAST.kind() === SyntaxKind.FunctionPropertyAssignment ||
                (funcDeclAST.kind() === SyntaxKind.GetAccessor && funcDeclAST.parent.parent.kind() === SyntaxKind.ObjectLiteralExpression) ||
                (funcDeclAST.kind() === SyntaxKind.SetAccessor && funcDeclAST.parent.parent.kind() === SyntaxKind.ObjectLiteralExpression)) {
                return;
            }

            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol(this.semanticInfoChain);;
            var functionSignature: PullSignatureSymbol;

            var isGetter = funcDeclAST.kind() === SyntaxKind.GetAccessor;
            var isSetter = funcDeclAST.kind() === SyntaxKind.SetAccessor;
            var isIndexSignature = functionDecl.kind === PullElementKind.IndexSignature;

            if (isGetter || isSetter) {
                var accessorSymbol = <PullAccessorSymbol> functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).type.getCallSignatures()[0];
            }
            else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol(this.semanticInfoChain);
                    if (functionSymbol && functionSymbol.isType() && !(<PullTypeSymbol>functionSymbol).isNamedTypeSymbol()) {
                        // Call Signature from the non named type
                        return;
                    }
                }
                else if (functionSymbol.kind === PullElementKind.Method &&
                         !isStatic &&
                         !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    // method of the unnmaed type
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol(this.semanticInfoChain);
            }

            // TypeParameters
            if (typeParameters && !isGetter && !isSetter && !isIndexSignature && funcDeclAST.kind() !== SyntaxKind.ConstructorDeclaration) {
                for (var i = 0; i < typeParameters.typeParameters.length; i++) {
                    var typeParameterAST = typeParameters.typeParameters[i];
                    var typeParameter = this.resolveTypeParameterDeclaration(typeParameterAST, context);
                    this.checkSymbolPrivacy(functionSymbol, typeParameter, (symbol: PullSymbol) =>
                        this.functionTypeArgumentArgumentTypePrivacyErrorReporter(
                            funcDeclAST, isStatic, typeParameterAST, typeParameter, symbol, context));
                }
            }

            // Check function parameters
            if (!isGetter && !isIndexSignature) {
                var funcParams = functionSignature.parameters;
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkSymbolPrivacy(functionSymbol, funcParams[i].type, (symbol: PullSymbol) =>
                        this.functionArgumentTypePrivacyErrorReporter(
                            funcDeclAST, isStatic, parameters, i, funcParams[i], symbol, context));
                }
            }

            // Check return type
            if (!isSetter) {
                this.checkSymbolPrivacy(functionSymbol, functionSignature.returnType, (symbol: PullSymbol) =>
                    this.functionReturnTypePrivacyErrorReporter(
                        funcDeclAST, isStatic, returnTypeAnnotation, block, functionSignature.returnType, symbol, context));
            }
        }

        private functionTypeArgumentArgumentTypePrivacyErrorReporter(
            declAST: ISyntaxElement,
            isStatic: boolean,
            typeParameterAST: TypeParameterSyntax,
            typeParameter: PullTypeSymbol,
            symbol: PullSymbol,
            context: PullTypeResolutionContext) {

            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isMethod = decl.kind === PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }

            var typeSymbol = <PullTypeSymbol>symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode: string;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else {
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            }
            else {
                if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else {
                    messageCode = DiagnosticCode.TypeParameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var messageArgs = [typeParameter.getScopedName(enclosingSymbol, /*skipTypeParametersInName*/ false, true /*usedConstraintInName*/), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(typeParameterAST, messageCode, messageArgs));
            }
        }

        private functionArgumentTypePrivacyErrorReporter(
            declAST: ISyntaxElement,
            isStatic: boolean,
            parameters: IParameters,
            argIndex: number,
            paramSymbol: PullSymbol,
            symbol: PullSymbol,
            context: PullTypeResolutionContext) {

            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;

            var isGetter = declAST.kind() === SyntaxKind.GetAccessor;
            var isSetter = declAST.kind() === SyntaxKind.SetAccessor;
            var isMethod = decl.kind === PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }

            var typeSymbol = <PullTypeSymbol>symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode: string;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.kind() === SyntaxKind.ConstructorDeclaration) {
                    messageCode = DiagnosticCode.Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1;
                }
                else if (isSetter) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                }
                else if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                }
                else if (!isGetter) {
                    messageCode = DiagnosticCode.Parameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            }
            else {
                if (declAST.kind() === SyntaxKind.ConstructorDeclaration) {
                    messageCode = DiagnosticCode.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1;
                }
                else if (isSetter) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                }
                else if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    }
                    else {
                        messageCode = DiagnosticCode.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                }
                else if (!isGetter && decl.kind !== PullElementKind.IndexSignature) {
                    messageCode = DiagnosticCode.Parameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var parameter = parameters.astAt(argIndex);

                var messageArgs = [paramSymbol.getScopedName(enclosingSymbol), typeSymbolName];
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(parameter, messageCode, messageArgs));
            }
        }

        private functionReturnTypePrivacyErrorReporter(
            declAST: ISyntaxElement,
            isStatic: boolean,
            returnTypeAnnotation: ISyntaxElement,
            block: BlockSyntax,
            funcReturnType: PullTypeSymbol,
            symbol: PullSymbol,
            context: PullTypeResolutionContext) {

            var decl = this.semanticInfoChain.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);

            var isGetter = declAST.kind() === SyntaxKind.GetAccessor;
            var isSetter = declAST.kind() === SyntaxKind.SetAccessor;
            var isMethod = decl.kind === PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === PullElementKind.Class || isStatic)) {
                isMethodOfClass = true;
            }

            var messageCode: string = null;
            var typeSymbol = <PullTypeSymbol>symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (isGetter) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else {
                        messageCode = DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                }
                else if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (decl.kind === PullElementKind.IndexSignature) {
                    messageCode = DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0;
                    }
                    else {
                        messageCode = DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0;
                    }
                }
                else if (!isSetter && declAST.kind() !== SyntaxKind.ConstructorDeclaration) {
                    messageCode = DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module_0;
                }
            }
            else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else {
                        messageCode = DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                }
                else if (decl.kind === PullElementKind.ConstructSignature) {
                    messageCode = DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (decl.kind === PullElementKind.CallSignature) {
                    messageCode = DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (decl.kind === PullElementKind.IndexSignature) {
                    messageCode = DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0;
                }
                else if (isMethod) {
                    if (isStatic) {
                        messageCode = DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else if (isMethodOfClass) {
                        messageCode = DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0;
                    }
                    else {
                        messageCode = DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0;
                    }
                }
                else if (!isSetter && declAST.kind() !== SyntaxKind.ConstructorDeclaration) {
                    messageCode = DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type_0;
                }
            }

            if (messageCode) {
                var messageArguments = [typeSymbolName];
                var reportOnFuncDecl = false;

                if (returnTypeAnnotation) {
                    // NOTE: we don't want to report this diagnostics.  They'll already have been 
                    // reported when we first hit the return statement.
                    var returnExpressionSymbol = this.resolveTypeReference(returnTypeAnnotation, context);
                    
                    if (PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                        // Error coming from return annotation
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnTypeAnnotation, messageCode, messageArguments));
                    }
                }

                if (block) {
                    var reportErrorOnReturnExpressions = (ast: ISyntaxElement, walker: IAstWalker) => {
                        var go = true;
                        if (this.isAnyFunctionExpressionOrDeclaration(ast)) {
                            // don't recurse into a function decl - we don't want to confuse a nested
                            // return type with the top-level function's return type
                            go = false;
                        }
                        else if (ast.kind() === SyntaxKind.ReturnStatement) {

                            var returnStatement: ReturnStatementSyntax = <ReturnStatementSyntax>ast;
                            var returnExpressionSymbol = this.resolveAST(returnStatement.expression, false, context).type;
                            // Check if return statement's type matches the one that we concluded
                            if (PullHelpers.typeSymbolsAreIdentical(returnExpressionSymbol, funcReturnType)) {
                                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(returnStatement, messageCode, messageArguments));
                            }
                            else {
                                reportOnFuncDecl = true;
                            }
                            go = false;
                        }

                        walker.options.goChildren = go;
                        return ast;
                    };

                    getAstWalkerFactory().walk(block, reportErrorOnReturnExpressions);
                }

                if (reportOnFuncDecl) {
                    // Show on function decl
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(declAST, messageCode, messageArguments));
                }
            }
        }

        private enclosingClassIsDerived(classDecl: PullDecl): boolean {
            Debug.assert(classDecl.kind === PullElementKind.Class);

            var classSymbol = <PullTypeSymbol>classDecl.getSymbol(this.semanticInfoChain);
            return classSymbol.getExtendedTypes().length > 0;
        }

        private isSuperInvocationExpression(ast: ISyntaxElement): boolean {
            if (ast.kind() === SyntaxKind.InvocationExpression) {
                var invocationExpression = <InvocationExpressionSyntax>ast;
                if (invocationExpression.expression.kind() === SyntaxKind.SuperKeyword) {
                    return true;
                }
            }

            return false;
        }

        private isSuperInvocationExpressionStatement(node: ISyntaxElement): boolean {
            if (node && node.kind() === SyntaxKind.ExpressionStatement) {
                var expressionStatement = <ExpressionStatementSyntax>node;
                if (this.isSuperInvocationExpression(expressionStatement.expression)) {
                    return true;
                }
            }
            return false;
        }

        private getFirstStatementOfBlockOrNull(block: BlockSyntax): ISyntaxElement {
            if (block && block.statements && block.statements.length > 0) {
                return block.statements[0];
            }

            return null;
        }

        private superCallMustBeFirstStatementInConstructor(constructorDecl: PullDecl): boolean {
            Debug.assert(constructorDecl.kind === PullElementKind.ConstructorMethod);

            /*
            The first statement in the body of a constructor must be a super call if both of the following are true:
                   The containing class is a derived class.
                   The constructor declares parameter properties or the containing class declares instance member variables with initializers.
            In such a required super call, it is a compile-time error for argument expressions to reference this.
            */
            if (constructorDecl) {
                var enclosingClass = constructorDecl.getParentDecl();

                var classSymbol = <PullTypeSymbol>enclosingClass.getSymbol(this.semanticInfoChain);
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }

                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];

                    if (member.kind === PullElementKind.Property) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.kind() === SyntaxKind.Parameter) {
                                return true;
                            }

                            if (ast.kind() === SyntaxKind.MemberVariableDeclaration) {
                                var variableDeclarator = <MemberVariableDeclarationSyntax>ast;
                                if (variableDeclarator.variableDeclarator.equalsValueClause) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        private checkForThisCaptureInArrowFunction(expression: ISyntaxElement): void {
            var enclosingDecl = this.getEnclosingDeclForAST(expression);

            var declPath = enclosingDecl.getParentPath();

            // work back up the decl path, until you can find a class
            // PULLTODO: Obviously not completely correct, but this sufficiently unblocks testing of the pull model
            if (declPath.length) {
                var inArrowFunction = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declKind === PullElementKind.FunctionExpression &&
                        hasFlag(declFlags, PullElementFlags.ArrowFunction)) {

                        inArrowFunction = true;
                        continue;
                    }

                    if (inArrowFunction) {
                        if (declKind === PullElementKind.Function ||
                            declKind === PullElementKind.Method ||
                            declKind === PullElementKind.ConstructorMethod ||
                            declKind === PullElementKind.GetAccessor ||
                            declKind === PullElementKind.SetAccessor ||
                            declKind === PullElementKind.FunctionExpression ||
                            declKind === PullElementKind.Class ||
                            declKind === PullElementKind.Container ||
                            declKind === PullElementKind.DynamicModule ||
                            declKind === PullElementKind.Script) {

                            decl.setFlags(decl.flags | PullElementFlags.MustCaptureThis);

                            // If we're accessing 'this' in a class, then the class constructor 
                            // needs to be marked as capturing 'this'.
                            if (declKind === PullElementKind.Class) {
                                var constructorSymbol = (<PullTypeSymbol> decl.getSymbol(this.semanticInfoChain)).getConstructorMethod();
                                var constructorDecls = constructorSymbol.getDeclarations();
                                for (var i = 0; i < constructorDecls.length; i++) {
                                    constructorDecls[i].flags = constructorDecls[i].flags | PullElementFlags.MustCaptureThis;
                                }
                            }
                            break;
                        }
                    }
                    else if (declKind === PullElementKind.Function || declKind === PullElementKind.FunctionExpression) {
                        break;
                    }
                }
            }
        }

        private typeCheckMembersAgainstIndexer(containerType: PullTypeSymbol, containerTypeDecl: PullDecl, context: PullTypeResolutionContext) {
            // Check all the members defined in this symbol's declarations (no base classes)
            var indexSignatures = this.getBothKindsOfIndexSignaturesExcludingAugmentedType(containerType, context);
            var stringSignature = indexSignatures.stringSignature;
            var numberSignature = indexSignatures.numericSignature;

            if (stringSignature || numberSignature) {
                var members = containerTypeDecl.getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    // Make sure the member is actually contained by the containerType, and not its associated constructor type
                    var member = members[i];
                    if ((member.name || (member.kind === PullElementKind.Property && member.name === "")) &&
                        member.kind !== PullElementKind.ConstructorMethod &&
                        !hasFlag(member.flags, PullElementFlags.Static)) {

                        // Decide whether to check against the number or string signature
                        var memberSymbol = member.getSymbol(this.semanticInfoChain);
                        var relevantSignature = this.determineRelevantIndexerForMember(memberSymbol, numberSignature, stringSignature);
                        if (relevantSignature) {
                            var comparisonInfo = new TypeComparisonInfo();
                            if (!this.sourceIsAssignableToTarget(memberSymbol.type, relevantSignature.returnType, member.ast(), context, comparisonInfo)) {
                                this.reportErrorThatMemberIsNotSubtypeOfIndexer(memberSymbol, relevantSignature, member.ast(), context, comparisonInfo);
                            }
                        }
                    }
                }
            }
        }

        private determineRelevantIndexerForMember(member: PullSymbol, numberIndexSignature: PullSignatureSymbol, stringIndexSignature: PullSignatureSymbol): PullSignatureSymbol {
            if (numberIndexSignature && PullHelpers.isNameNumeric(member.name)) {
                return numberIndexSignature;
            }
            else if (stringIndexSignature) {
                return stringIndexSignature;
            }

            return null;
        }

        private reportErrorThatMemberIsNotSubtypeOfIndexer(member: PullSymbol, indexSignature: PullSignatureSymbol, astForError: ISyntaxElement, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): void {
            var enclosingSymbol = this.getEnclosingSymbolForAST(astForError);

            if (indexSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, DiagnosticCode.All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1,
                        [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, DiagnosticCode.All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0,
                        [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            }
            else {
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, DiagnosticCode.All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1,
                        [indexSignature.returnType.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(astForError, DiagnosticCode.All_named_properties_must_be_assignable_to_string_indexer_type_0,
                        [indexSignature.returnType.toString(enclosingSymbol)]));
                }
            }
        }

        private typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol: PullTypeSymbol, extendedType: PullTypeSymbol, typeMember: PullSymbol, extendedTypeMember: PullSymbol, enclosingDecl: PullDecl, comparisonInfo: TypeComparisonInfo) {

            if (!typeSymbol.isClass()) {
                return true;
            }

            var typeMemberKind = typeMember.kind;
            var extendedMemberKind = extendedTypeMember.kind;

            if (typeMemberKind === extendedMemberKind) {
                return true;
            }

            var errorCode: string;
            if (typeMemberKind === PullElementKind.Property) {
                if (typeMember.isAccessor()) {
                    errorCode = DiagnosticCode.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
                else {
                    errorCode = DiagnosticCode.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
            }
            else if (typeMemberKind === PullElementKind.Method) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                }
                else {
                    errorCode = DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                }
            }

            var message = getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        }

        private typeCheckIfTypeExtendsType(
            classOrInterface: ISyntaxElement,
            name: ISyntaxToken,
            typeSymbol: PullTypeSymbol,
            extendedType: PullTypeSymbol,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext) {

            var typeMembers = typeSymbol.getMembers();

                var comparisonInfo = new TypeComparisonInfo();
                var foundError = false;
                var foundError1 = false;
                var foundError2 = false;

            // Check members
            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].name;
                var extendedTypeProp = extendedType.findMember(propName, /*lookInParent*/ true);
                if (extendedTypeProp) {
                    this.resolveDeclaredSymbol(extendedTypeProp, context);
                    foundError1 = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, enclosingDecl, comparisonInfo);

                    if (!foundError1) {
                        foundError2 = !this.sourcePropertyIsAssignableToTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, classOrInterface, context, comparisonInfo);
                    }

                    if (foundError1 || foundError2) {
                        foundError = true;
                        break;
                    }
                }
            }

            // Check call signatures
            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.sourceCallSignaturesAreAssignableToTargetCallSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            // Check construct signatures
            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.sourceConstructSignaturesAreAssignableToTargetConstructSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            // Check index signatures
            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.sourceIndexSignaturesAreAssignableToTargetIndexSignatures(typeSymbol, extendedType, classOrInterface, context, comparisonInfo);
            }

            if (!foundError && typeSymbol.isClass()) {
                // If there is base class verify the constructor type is subtype of base class
                var typeConstructorType = typeSymbol.getConstructorMethod().type;
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = extendedType.getConstructorMethod().type;
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);

                    // Verify that all the overriden members of the constructor type are compatible
                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].name;
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName, /*lookInParent*/ true);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved) {
                                this.resolveDeclaredSymbol(extendedConstructorTypeProp, context);
                            }

                            if (!this.sourcePropertyIsAssignableToTargetProperty(typeConstructorType, extendedConstructorType, typeConstructorTypeMembers[i], extendedConstructorTypeProp, classOrInterface, context, comparisonInfo)) {
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (foundError) {
                var errorCode: string;
                if (typeSymbol.isClass()) {
                    errorCode = DiagnosticCode.Class_0_cannot_extend_class_1_NL_2;
                }
                else {
                    if (extendedType.isClass()) {
                        errorCode = DiagnosticCode.Interface_0_cannot_extend_class_1_NL_2;
                    }
                    else {
                        errorCode = DiagnosticCode.Interface_0_cannot_extend_interface_1_NL_2;
                    }
                }

                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message]));
            }
        }

        private typeCheckIfClassImplementsType(
            classDecl: ClassDeclarationSyntax,
            classSymbol: PullTypeSymbol,
            implementedType: PullTypeSymbol,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext) {

            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.sourceMembersAreAssignableToTargetMembers(classSymbol, implementedType, classDecl, context, comparisonInfo);
            if (!foundError) {
                foundError = !this.sourceCallSignaturesAreAssignableToTargetCallSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                if (!foundError) {
                    foundError = !this.sourceConstructSignaturesAreAssignableToTargetConstructSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.sourceIndexSignaturesAreAssignableToTargetIndexSignatures(classSymbol, implementedType, classDecl, context, comparisonInfo);
                    }
                }
            }

            // Report error
            if (foundError) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(classDecl);
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(classDecl.identifier,
                    DiagnosticCode.Class_0_declares_interface_1_but_does_not_implement_it_NL_2,
                    [classSymbol.getScopedName(enclosingSymbol), implementedType.getScopedName(enclosingSymbol), comparisonInfo.message]));
            }
        }

        private computeValueSymbolFromAST(valueDeclAST: ISyntaxElement, context: PullTypeResolutionContext): {
            symbol: PullSymbol;
            alias: PullTypeAliasSymbol;
        } {

            // Disable type check because we do not want to report errors about missing symbols when resolving the
            // expression as the value expression
            var prevInTypeCheck = context.inTypeCheck;
            context.inTypeCheck = false;
            
            var typeSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);

            if (valueDeclAST.kind() == SyntaxKind.IdentifierName) {
                var valueSymbol = this.computeNameExpression(<ISyntaxToken>valueDeclAST, context);
            }
            else {
                Debug.assert(valueDeclAST.kind() == SyntaxKind.QualifiedName);
                var qualifiedName = <QualifiedNameSyntax>valueDeclAST;
                // Compute lhs so we can compute dotted expression of the lhs. 
                // We cant directly resolve this expression because otherwise we would end up using cached value of lhs
                // and that might not be the right one when resolving this expression as value expression
                var lhs = this.computeValueSymbolFromAST(qualifiedName.left, context);
                var valueSymbol = this.computeDottedNameExpressionFromLHS(lhs.symbol, qualifiedName.left, qualifiedName.right, context, /*checkSuperPrivateAndStaticAccess*/ false);
            }
            var valueSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(valueDeclAST);

            // Reset the alias value 
            this.semanticInfoChain.setAliasSymbolForAST(valueDeclAST, typeSymbolAlias);
            context.inTypeCheck = prevInTypeCheck;

            return { symbol: valueSymbol, alias: valueSymbolAlias };
        }

        private hasClassTypeSymbolConflictAsValue(
            baseDeclAST: ISyntaxElement,
            typeSymbol: PullTypeSymbol,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext) {

            var typeSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(baseDeclAST);

            var valueDeclAST = baseDeclAST.kind() == SyntaxKind.GenericType ? (<GenericTypeSyntax>baseDeclAST).name : baseDeclAST;
            var valueSymbolInfo = this.computeValueSymbolFromAST(valueDeclAST, context);
            var valueSymbol = valueSymbolInfo.symbol;
            var valueSymbolAlias = valueSymbolInfo.alias;
            
            // If aliases are same
            if (typeSymbolAlias && valueSymbolAlias) {
                return typeSymbolAlias !== valueSymbolAlias;
            }

            // Verify if value refers to same class;
            if (!valueSymbol.anyDeclHasFlag(PullElementFlags.ClassConstructorVariable)) {
                return true;
            }

            var associatedContainerType = valueSymbol.type ? valueSymbol.type.getAssociatedContainerType() : null;

            if (associatedContainerType) {
                // We may have specialized the typeSymbol to any for error recovery, as in the following example:
                // class A<T> { }
                // class B extends A { }
                // Since A was not given type arguments (which is an error), we may have specialized it to any, in which case A<any> != A<T>.
                // So we need to compare associatedContainerType to the rootSymbol (the unspecialized version) of typeSymbol
                return associatedContainerType !== typeSymbol.getRootSymbol();
            }

            return true;
        }

        private typeCheckBase(
            classOrInterface: ISyntaxElement,
            name: ISyntaxToken,
            typeSymbol: PullTypeSymbol,
            baseDeclAST: ISyntaxElement,
            isExtendedType: boolean,
            enclosingDecl: PullDecl,
            context: PullTypeResolutionContext) {

            var typeDecl = this.semanticInfoChain.getDeclForAST(classOrInterface);

            var baseType = this.resolveTypeReference(baseDeclAST, context).type;

            if (!baseType) {
                return;
            }

            var typeDeclIsClass = typeSymbol.isClass();

            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                // Report error about invalid base kind
                if (!baseType.isError()) {
                    if (isExtendedType) {
                        if (typeDeclIsClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, DiagnosticCode.A_class_may_only_extend_another_class));
                        }
                        else {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, DiagnosticCode.An_interface_may_only_extend_another_class_or_interface));
                        }
                    }
                    else {
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST, DiagnosticCode.A_class_may_only_implement_another_class_or_interface));
                    }
                }
                return;
            }
            else if (typeDeclIsClass && isExtendedType) {
                // Verify if the class extends another class verify the value position resolves to the same type expression
                if (this.hasClassTypeSymbolConflictAsValue(baseDeclAST, baseType, enclosingDecl, context)) {
                    // Report error
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(baseDeclAST,
                        DiagnosticCode.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1,
                        [ASTHelpers.getNameOfIdenfierOrQualifiedName(baseDeclAST.kind() == SyntaxKind.GenericType ? (<GenericTypeSyntax>baseDeclAST).name : baseDeclAST), baseType.toString(enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null)]));
                }
            }

            // Check if its a recursive extend/implement type
            if (baseType.hasBase(typeSymbol)) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();
                // Report error
                context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name,
                    typeDeclIsClass ? DiagnosticCode.Class_0_is_recursively_referenced_as_a_base_type_of_itself : DiagnosticCode.Interface_0_is_recursively_referenced_as_a_base_type_of_itself, [typeSymbol.getScopedName()]));
                return;
            }

            if (isExtendedType) {
                // Verify all own overriding members are subtype
                this.typeCheckCallBacks.push(context => this.typeCheckIfTypeExtendsType(classOrInterface, name, typeSymbol, baseType, enclosingDecl, context));
            }
            else {
                Debug.assert(classOrInterface.kind() === SyntaxKind.ClassDeclaration);
                // If class implementes interface or class, verify all the public members are implemented
                this.typeCheckCallBacks.push(context => this.typeCheckIfClassImplementsType(<ClassDeclarationSyntax>classOrInterface, typeSymbol, baseType, enclosingDecl, context));
            }

            // Privacy error:
            this.checkSymbolPrivacy(typeSymbol, baseType, (errorSymbol: PullSymbol) =>
                this.baseListPrivacyErrorReporter(classOrInterface, typeSymbol, baseDeclAST, isExtendedType, errorSymbol, context));
        }

        private typeCheckBases(classOrInterface: ISyntaxElement, name: ISyntaxToken, heritageClauses: HeritageClauseSyntax[], typeSymbol: PullTypeSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var extendsClause = ASTHelpers.getExtendsHeritageClause(heritageClauses);
            var implementsClause = ASTHelpers.getImplementsHeritageClause(heritageClauses);
            if (!extendsClause && !implementsClause) {
                return;
            }

            if (extendsClause) {
                for (var i = 0; i < extendsClause.typeNames.length; i++) {
                    this.typeCheckBase(classOrInterface, name, typeSymbol, extendsClause.typeNames[i], /*isExtendedType:*/ true, enclosingDecl, context);
                }
            }

            if (typeSymbol.isClass()) {
                if (implementsClause) {
                    for (var i = 0; i < implementsClause.typeNames.length; i++) {
                        this.typeCheckBase(classOrInterface, name, typeSymbol, implementsClause.typeNames[i], /*isExtendedType:*/false, enclosingDecl, context);
                    }
                }
            }
            else if (extendsClause && !typeSymbol.hasBaseTypeConflict() && typeSymbol.getExtendedTypes().length > 1) {
                // October 16, 2013: Section 7.1:
                // Inherited properties with the same name must be identical (section 3.8.2).

                // If it is an interface it can extend multiple base types. We need to check for clashes
                // between inherited properties with the same name, per the spec. Note that we only do this
                // once per symbol, not once per declaration. We use the first declaration that has an
                // extends clause. Here is an example:
                // interface A {
                //    m: string;
                // }
                // interface B {
                //    m: number;
                // }
                // interface C extends A {}
                // interface C extends B {}
                // Here, we only report the error on the first C, because it is the first declaration
                // that has an extends clause. Since an interface cannot have an implements clause
                // (by the grammar) we only have to check that it has a heritage clause.
                var firstInterfaceASTWithExtendsClause = ArrayUtilities.firstOrDefault(typeSymbol.getDeclarations(), decl => 
                    (<InterfaceDeclarationSyntax>decl.ast()).heritageClauses !== null).ast();
                if (classOrInterface === firstInterfaceASTWithExtendsClause) {
                    // Checking type compatibility between bases requires knowing the types of all
                    // base type members. Therefore, we have to delay this operation until all
                    // resolution has taken place. Doing the check immediately may cause a recursive
                    // resolution that results in a rogue "any".
                    this.typeCheckCallBacks.push(context => {
                        this.checkTypeCompatibilityBetweenBases((<InterfaceDeclarationSyntax>classOrInterface).identifier, typeSymbol, context);
                    });
                }
            }
        }

        private checkTypeCompatibilityBetweenBases(
            name: ISyntaxToken,
            typeSymbol: PullTypeSymbol,
            context: PullTypeResolutionContext): void {

            // The membersBag will map each member name to its type and which base type we got it from
            var derivedIndexSignatures = typeSymbol.getOwnIndexSignatures();

            var inheritedMembersMap = createIntrinsicsObject<MemberWithBaseOrigin>();
            var inheritedIndexSignatures = new InheritedIndexSignatureInfo();

            var typeHasOwnNumberIndexer = false;
            var typeHasOwnStringIndexer = false;
            // Determine if this type has any index signatures of its own
            if (typeSymbol.hasOwnIndexSignatures()) {
                var ownIndexSignatures = typeSymbol.getOwnIndexSignatures();
                for (var i = 0; i < ownIndexSignatures.length; i++) {
                    if (ownIndexSignatures[i].parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                        typeHasOwnNumberIndexer = true;
                    }
                    else {
                        typeHasOwnStringIndexer = true;
                    }
                }
            }
            var baseTypes = typeSymbol.getExtendedTypes();
            for (var i = 0; i < baseTypes.length; i++) {
                // Check the member identity and the index signature identity between this base
                // and bases checked so far. Only report the first error.
                if (this.checkNamedPropertyIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedMembersMap, context) ||
                    this.checkIndexSignatureIdentityBetweenBases(name, typeSymbol, baseTypes[i], inheritedIndexSignatures, typeHasOwnNumberIndexer, typeHasOwnStringIndexer, context)) {
                    return;
                }
            }

            // Check that number indexer is a subtype of the string indexer. If that check succeeds,
            // check all the inherited members against the relevant signature
            if (this.checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature(name, typeSymbol, inheritedIndexSignatures, context)) {
                return;
            }

            this.checkInheritedMembersAgainstInheritedIndexSignatures(name, typeSymbol, inheritedIndexSignatures, inheritedMembersMap, context);
        }

        // This method returns true if there was an error given, and false if there was no error.
        // The boolean value is used by the caller for short circuiting.
        private checkNamedPropertyIdentityBetweenBases(
            interfaceName: ISyntaxToken,
            interfaceSymbol: PullTypeSymbol,
            baseTypeSymbol: PullTypeSymbol,
            inheritedMembersMap: IIndexable<MemberWithBaseOrigin>,
            context: PullTypeResolutionContext): boolean {
            
            // October 16, 2013: Section 7.1:
            // Inherited properties with the same name must be identical (section 3.8.2).
            var baseMembers = baseTypeSymbol.getAllMembers(PullElementKind.Property | PullElementKind.Method, GetAllMembersVisiblity.all);
            for (var i = 0; i < baseMembers.length; i++) {
                var member = baseMembers[i];
                var memberName = member.name;
                // Skip the member if it is shadowed in the derived type
                if (interfaceSymbol.findMember(memberName, /*lookInParent*/ false)) {
                    continue;
                }

                this.resolveDeclaredSymbol(member, context);

                // Error if there is already a member in the bag with that name, and it is not identical
                if (inheritedMembersMap[memberName]) {
                    var prevMember = inheritedMembersMap[memberName];
                    if (prevMember.baseOrigin !== baseTypeSymbol &&
                        !this.propertiesAreIdenticalWithNewEnclosingTypes(baseTypeSymbol, prevMember.baseOrigin, member, prevMember.memberSymbol, context)) {
                        var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Named_properties_0_of_types_1_and_2_are_not_identical,
                            [memberName, prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName,
                            DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                            [interfaceSymbol.getDisplayName(), prevMember.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                        return true; // Only report first offense
                    }
                }
                else {
                    inheritedMembersMap[memberName] = new MemberWithBaseOrigin(member, baseTypeSymbol);
                }
            }

            return false;
        }

        // This method returns true if there was an error given, and false if there was no error.
        // The boolean value is used by the caller for short circuiting.
        private checkIndexSignatureIdentityBetweenBases(
            interfaceName: ISyntaxToken,
            interfaceSymbol: PullTypeSymbol,
            baseTypeSymbol: PullTypeSymbol,
            allInheritedSignatures: InheritedIndexSignatureInfo,
            derivedTypeHasOwnNumberSignature: boolean,
            derivedTypeHasOwnStringSignature: boolean,
            context: PullTypeResolutionContext): boolean {

            if (derivedTypeHasOwnNumberSignature && derivedTypeHasOwnStringSignature) {
                return false;
            }

            // October 16, 2013:
            // Section 3.7.4:
            // An object type can contain at most one string index signature and one numeric index signature.
            var indexSignaturesFromThisBaseType = baseTypeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignaturesFromThisBaseType.length; i++) {
                var currentInheritedSignature = indexSignaturesFromThisBaseType[i];

                var parameterTypeIsString = currentInheritedSignature.parameters[0].type === this.semanticInfoChain.stringTypeSymbol;
                var parameterTypeIsNumber = currentInheritedSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol;

                // Skip the signature if it is shadowed in the derived type
                if (parameterTypeIsString && derivedTypeHasOwnStringSignature ||
                    parameterTypeIsNumber && derivedTypeHasOwnNumberSignature) {
                    continue;
                }

                // Now error if there is already an inherited signature of the same kind as this one
                if (parameterTypeIsString) {
                    if (allInheritedSignatures.stringSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol &&
                            !this.typesAreIdentical(allInheritedSignatures.stringSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType, context)) {
                            var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Types_of_string_indexer_of_types_0_and_1_are_not_identical,
                                [allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName,
                                DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                                [interfaceSymbol.getDisplayName(), allInheritedSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true; // Only report first offense
                        }
                    }
                    else {
                        allInheritedSignatures.stringSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                }
                else if (parameterTypeIsNumber) {
                    if (allInheritedSignatures.numberSignatureWithBaseOrigin) {
                        if (allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin !== baseTypeSymbol &&
                            !this.typesAreIdentical(allInheritedSignatures.numberSignatureWithBaseOrigin.signature.returnType, currentInheritedSignature.returnType, context)) {
                            var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Types_of_number_indexer_of_types_0_and_1_are_not_identical,
                                [allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName()]);
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName,
                                DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                                [interfaceSymbol.getDisplayName(), allInheritedSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(), baseTypeSymbol.getScopedName(), innerDiagnostic]));
                            return true;
                        }
                    }
                    else {
                        allInheritedSignatures.numberSignatureWithBaseOrigin = new SignatureWithBaseOrigin(currentInheritedSignature, baseTypeSymbol);
                    }
                }
            }

            return false;
        }

        // This method returns true if there was an error given, and false if there was no error.
        // The boolean value is used by the caller for short circuiting.
        private checkInheritedMembersAgainstInheritedIndexSignatures(
            interfaceName: ISyntaxToken,
            interfaceSymbol: PullTypeSymbol,
            inheritedIndexSignatures: InheritedIndexSignatureInfo,
            inheritedMembers: IIndexable<MemberWithBaseOrigin>,
            context: PullTypeResolutionContext): boolean {
            if (!inheritedIndexSignatures.stringSignatureWithBaseOrigin && !inheritedIndexSignatures.numberSignatureWithBaseOrigin) {
                return false;
            }

            // Now check that each named member is a subtype of its corresponding index signature type
            // October 16, 2013: Section 7.1:
            // All properties of the interface must satisfy the constraints implied by the index
            // signatures of the interface as specified in section 3.7.4.
            var comparisonInfo = new TypeComparisonInfo();
            var stringSignature = inheritedIndexSignatures.stringSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature;
            var numberSignature = inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature;
            for (var memberName in inheritedMembers) {
                var memberWithBaseOrigin = inheritedMembers[memberName];
                if (!memberWithBaseOrigin) {
                    continue;
                }

                var relevantSignature = this.determineRelevantIndexerForMember(memberWithBaseOrigin.memberSymbol, numberSignature, stringSignature);
                if (!relevantSignature) {
                    continue;
                }

                var relevantSignatureIsNumberSignature = relevantSignature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol;
                var signatureBaseOrigin = relevantSignatureIsNumberSignature ? inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin :
                    inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin;

                if (signatureBaseOrigin === memberWithBaseOrigin.baseOrigin) {
                    continue;
                }

                var memberIsSubtype = this.sourceIsAssignableToTarget(memberWithBaseOrigin.memberSymbol.type, relevantSignature.returnType, interfaceName, context, comparisonInfo);

                if (!memberIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    if (relevantSignatureIsNumberSignature) {
                        var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3,
                            [memberName, memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);

                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                            [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    }
                    else {
                        var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3,
                            [memberName, memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);

                        context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName, DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                            [interfaceSymbol.getDisplayName(enclosingSymbol), memberWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    }
                    return true;
                }
            }

            return false;
        }


        // This function assumes that we have neither a derived string indexer nor a derived
        // number indexer
        private checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature(
            interfaceName: ISyntaxToken,
            interfaceSymbol: PullTypeSymbol,
            inheritedIndexSignatures: InheritedIndexSignatureInfo,
            context: PullTypeResolutionContext): boolean {
            if (inheritedIndexSignatures.numberSignatureWithBaseOrigin && inheritedIndexSignatures.stringSignatureWithBaseOrigin) {
                // If they originate in the same base, a separate error would have been reported
                if (inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin === inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin) {
                    return false;
                }

                var comparisonInfo = new TypeComparisonInfo();
                var signatureIsSubtype = this.sourceIsAssignableToTarget(
                    inheritedIndexSignatures.numberSignatureWithBaseOrigin.signature.returnType,
                    inheritedIndexSignatures.stringSignatureWithBaseOrigin.signature.returnType, interfaceName, context, comparisonInfo);

                if (!signatureIsSubtype) {
                    var enclosingSymbol = this.getEnclosingSymbolForAST(interfaceName);
                    var innerDiagnostic = getDiagnosticMessage(DiagnosticCode.Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2,
                        [inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol),
                            inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), comparisonInfo.message]);
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(interfaceName,
                        DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3,
                        [interfaceSymbol.getDisplayName(enclosingSymbol), inheritedIndexSignatures.numberSignatureWithBaseOrigin.baseOrigin.getScopedName(),
                            inheritedIndexSignatures.stringSignatureWithBaseOrigin.baseOrigin.getScopedName(enclosingSymbol), innerDiagnostic]));
                    return true;
                }
            }

            return false;
        }

        private checkAssignability(ast: ISyntaxElement, source: PullTypeSymbol, target: PullTypeSymbol, context: PullTypeResolutionContext): void {
            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(source, target, ast, context, comparisonInfo);

            if (!isAssignable) {
                var enclosingSymbol = this.getEnclosingSymbolForAST(ast);
                if (comparisonInfo.message) {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Cannot_convert_0_to_1_NL_2, [source.toString(enclosingSymbol), target.toString(enclosingSymbol), comparisonInfo.message]));
                }
                else {
                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(ast, DiagnosticCode.Cannot_convert_0_to_1, [source.toString(enclosingSymbol), target.toString(enclosingSymbol)]));
                }
            }
        }

        private isReference(ast: ISyntaxElement, astSymbol: PullSymbol): boolean {
            // November 18, 2013
            // References are the subset of expressions that are permitted as the target of an 
            // assignment.Specifically, references are combinations of identifiers(section 4.3),
            // parentheses(section 4.7), and property accesses(section 4.10).All other expression
            //  constructs described in this chapter are classified as values.

            if (ast.kind() === SyntaxKind.ParenthesizedExpression) {
                // A parenthesized LHS is valid if the expression it wraps is valid.
                return this.isReference((<ParenthesizedExpressionSyntax>ast).expression, astSymbol);
            }

            if (ast.kind() !== SyntaxKind.IdentifierName && ast.kind() !== SyntaxKind.MemberAccessExpression && ast.kind() !== SyntaxKind.ElementAccessExpression) {
                return false;
            }

            // November 18, 2013
            // An identifier expression that references a variable or parameter is classified as a reference. 
            // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).
            if (ast.kind() === SyntaxKind.IdentifierName) {
                if (astSymbol.kind === PullElementKind.Variable && astSymbol.anyDeclHasFlag(PullElementFlags.Enum)) {
                    return false;
                }

                if (astSymbol.kind === PullElementKind.Variable && astSymbol.anyDeclHasFlag(PullElementFlags.SomeInitializedModule)) {
                    return false;
                }

                if (astSymbol.kind === PullElementKind.ConstructorMethod || astSymbol.kind === PullElementKind.Function) {
                    return false;
                }
            }

            // Disallow assignment to an enum member (NOTE: not reflected in spec).
            if (ast.kind() === SyntaxKind.MemberAccessExpression && astSymbol.kind === PullElementKind.EnumMember) {
                return false;
            }

            return true;
        }

        private checkForSuperMemberAccess(
            expression: ISyntaxElement,
            name: ISyntaxToken,
            resolvedName: PullSymbol,
            context: PullTypeResolutionContext): boolean {
            if (resolvedName) {
                if (expression.kind() === SyntaxKind.SuperKeyword &&
                    !resolvedName.isError() &&
                    resolvedName.kind !== PullElementKind.Method) {

                    context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name,
                        DiagnosticCode.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword));
                    return true;
                }
            }

            return false;
        }

        private getEnclosingDeclForAST(ast: ISyntaxElement): PullDecl {
            return this.semanticInfoChain.getEnclosingDecl(ast);
        }

        private getEnclosingSymbolForAST(ast: ISyntaxElement) {
            var enclosingDecl = this.getEnclosingDeclForAST(ast);
            return enclosingDecl ? enclosingDecl.getSymbol(this.semanticInfoChain) : null;
        }

        private checkForPrivateMemberAccess(
            name: ISyntaxToken,
            expressionType: PullTypeSymbol,
            resolvedName: PullSymbol,
            context: PullTypeResolutionContext): boolean {

            if (resolvedName) {
                if (resolvedName.anyDeclHasFlag(PullElementFlags.Private)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.kind === PullElementKind.ConstructorType) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }

                    if (memberContainer && memberContainer.isClass()) {
                        // We're accessing a private member of a class.  We can only do that if we're 
                        // actually contained within that class.
                        var memberClass = memberContainer.getDeclarations()[0].ast();
                        Debug.assert(memberClass);

                        var containingClass = this.getEnclosingClassDeclaration(name);

                        if (!containingClass || containingClass !== memberClass) {
                            context.postDiagnostic(this.semanticInfoChain.diagnosticFromAST(name, DiagnosticCode._0_1_is_inaccessible, [memberContainer.toString(/*scopeSymbol*/ null, /*useConstraintInName*/ false), name.text()]));
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        public instantiateType(type: PullTypeSymbol, typeParameterArgumentMap: TypeSubstitutionMap): PullTypeSymbol {
            // if the type is a primitive type, nothing to do here
            if (type.isPrimitive()) {
                return type;
            }

            // if the type is an error, nothing to do here
            if (type.isError()) {
                return type;
            }

            if (typeParameterArgumentMap[type.pullSymbolID]) {
                return typeParameterArgumentMap[type.pullSymbolID];
            }

            type._resolveDeclaredSymbol();

            if (type.wrapsSomeTypeParameter(typeParameterArgumentMap)) {
                return InstantiatedTypeReferenceSymbol.create(this, type, typeParameterArgumentMap);
            }

            return type;
        }

        public instantiateSignature(signature: PullSignatureSymbol, typeParameterSubstitutionMap: TypeSubstitutionMap): PullSignatureSymbol {
            return this.getOrCreateSignatureWithSubstitutionOrInstantiation(signature, typeParameterSubstitutionMap, /*isInstantiation*/ true);
        }

        public getOrCreateSignatureWithSubstitution(signature: PullSignatureSymbol, typeParameterSubstitutionMap: TypeSubstitutionMap): PullSignatureSymbol {
            return this.getOrCreateSignatureWithSubstitutionOrInstantiation(signature, typeParameterSubstitutionMap, /*isInstantiation*/ false);
        }

        // This method is a helper to be called by instantiateSignature, as well as getOrCreateSignatureWithSubstitution,
        // since they are almost the same. The only difference is that one produces an InstantiatedSignatureSymbol,
        // and the other produces 
        private getOrCreateSignatureWithSubstitutionOrInstantiation(signature: PullSignatureSymbol, typeParameterSubstitutionMap: TypeSubstitutionMap, isInstantiation: boolean): PullSignatureSymbol {
            if (!signature.wrapsSomeTypeParameter(typeParameterSubstitutionMap)) {
                return signature;
            }

            var rootSignature = <PullSignatureSymbol>signature.getRootSymbol();
            var mutableTypeParameterMap = new PullInstantiationHelpers.MutableTypeParameterSubstitutionMap(typeParameterSubstitutionMap);
            PullInstantiationHelpers.instantiateTypeArgument(this, signature, mutableTypeParameterMap);

            // Note that instantiated signatures and signatures with substitution are stored in the
            // same cache! The reason this is safe is that the substitution map uniquely identifies
            // a signature as instantiated or not. Namely, there are 3 cases:
            //
            // 1. The map does not contain any substitutions for the signature's own type parameters:
            //    In this case, the signature has a substitution for surrounding type parameters,
            //    but it is not an instantiated signature.
            // 2. The map contains substitutions for the signature's own type parameters, but the
            //    substituted types are not synthesized type parameters:
            //    In this case, we have an instantiated signature, since a signature with substitution
            //    either lacks mappings for its own type parameters, or has them mapped to synthesized
            //    type parameters.
            // 3. The map contains substitutions for the signature's own type parameters, and the
            //    substituted types are synthesized type parameters:
            //    In this case, it clearly could be a signature with substitution. Also, it cannot
            //    be an instantiated signature because an instantiated signature has type arguments.
            //    These type arguments can be referenced types or referenced values with certain types.
            //    But a synthesized type parameter is impossible to reference, even through a value.
            //
            // This is the reasoning. We also have the assert below to enforce this.
            var instantiatedSignatureOrSignatureWithSubstitution = rootSignature.getSpecialization(mutableTypeParameterMap.typeParameterSubstitutionMap);
            if (instantiatedSignatureOrSignatureWithSubstitution) {
                var symbolFromCacheIsInstantiatedSignature = instantiatedSignatureOrSignatureWithSubstitution.getIsInstantiated();
                Debug.assert(symbolFromCacheIsInstantiatedSignature === isInstantiation);
                return instantiatedSignatureOrSignatureWithSubstitution;
            }

            // Cleanup the type parameter argument map
            PullInstantiationHelpers.cleanUpTypeParameterSubstitutionMap(signature, mutableTypeParameterMap);
            typeParameterSubstitutionMap = mutableTypeParameterMap.typeParameterSubstitutionMap;

            // Create a new one
            instantiatedSignatureOrSignatureWithSubstitution = isInstantiation ?
                new InstantiatedSignatureSymbol(rootSignature, typeParameterSubstitutionMap):
                new SignatureSymbolWithSubstitution(rootSignature, typeParameterSubstitutionMap);

            // if the instantiation occurred via a recursive funciton invocation, the return type may be null so we should set it to any
            instantiatedSignatureOrSignatureWithSubstitution.returnType = this.instantiateType((rootSignature.returnType || this.semanticInfoChain.anyTypeSymbol), typeParameterSubstitutionMap);
            instantiatedSignatureOrSignatureWithSubstitution.functionType = this.instantiateType(rootSignature.functionType, typeParameterSubstitutionMap);

            var parameters = rootSignature.parameters;
            var parameter: PullSymbol = null;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].name, PullElementKind.Parameter, this.semanticInfoChain);
                    parameter.setRootSymbol(parameters[j]);

                    if (parameters[j].isOptional) {
                        parameter.isOptional = true;
                    }
                    if (parameters[j].isVarArg) {
                        parameter.isVarArg = true;
                        instantiatedSignatureOrSignatureWithSubstitution.hasVarArgs = true;
                    }
                    instantiatedSignatureOrSignatureWithSubstitution.addParameter(parameter, parameter.isOptional);

                    parameter.type = this.instantiateType(parameters[j].type, typeParameterSubstitutionMap);
                }
            }

            return instantiatedSignatureOrSignatureWithSubstitution;
        }
    }

    export class TypeComparisonInfo {
        public onlyCaptureFirstError = false;
        public message = "";
        public stringConstantVal: ISyntaxElement = null;
        private indent = 1;

        constructor(sourceComparisonInfo?: TypeComparisonInfo, useSameIndent?: boolean) {
            if (sourceComparisonInfo) {
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent;
                if (!useSameIndent) {
                    this.indent++;
                }
            }
        }

        private indentString(): string {
            var result = "";

            for (var i = 0; i < this.indent; i++) {
                result += "\t";
            }

            return result;
        }

        public addMessage(message: string) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = this.message + TypeScript.newLine() + this.indentString() + message;
            }
            else {
                this.message = this.indentString() + message;
            }
        }
    }

    export function getPropertyAssignmentNameTextFromIdentifier(identifier: ISyntaxElement): { actualText: string; memberName: string } {
        if (identifier.kind() === SyntaxKind.IdentifierName) {
            return { actualText: (<ISyntaxToken>identifier).text(), memberName: tokenValueText((<ISyntaxToken>identifier)) };
        }
        else if (identifier.kind() === SyntaxKind.StringLiteral) {
            return { actualText: (<ISyntaxToken>identifier).text(), memberName: tokenValueText((<ISyntaxToken>identifier)) };
        }
        else if (identifier.kind() === SyntaxKind.NumericLiteral) {
            return { actualText: (<ISyntaxToken>identifier).text(), memberName: tokenValueText((<ISyntaxToken>identifier)) };
        }
        else {
            throw Errors.invalidOperation();
        }
    }

    export function isTypesOnlyLocation(ast: ISyntaxElement): boolean {
        while (ast && ast.parent) {
            switch (ast.parent.kind()) {
                case SyntaxKind.TypeAnnotation:
                    return true;
                case SyntaxKind.TypeQuery:
                    // Inside a type query is actually an expression.
                    return false;
                case SyntaxKind.ConstructorType:
                    var constructorType = <ConstructorTypeSyntax>ast.parent;
                    if (constructorType.type === ast) {
                        return true;
                    }
                    break;
                case SyntaxKind.FunctionType:
                    var functionType = <FunctionTypeSyntax>ast.parent;
                    if (functionType.type === ast) {
                        return true;
                    }
                    break;
                case SyntaxKind.Constraint:
                    var constraint = <ConstraintSyntax>ast.parent;
                    if (constraint.type === ast) {
                        return true;
                    }
                    break;
                case SyntaxKind.CastExpression:
                    var castExpression = <CastExpressionSyntax>ast.parent;
                    return castExpression.type === ast;
                case SyntaxKind.ExtendsHeritageClause:
                case SyntaxKind.ImplementsHeritageClause:
                    return true;
                case SyntaxKind.TypeArgumentList:
                    return true;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.MemberAccessExpression:
                case SyntaxKind.Parameter:
                    return false;
            }

            ast = ast.parent;
        }

        return false;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\references.ts' />

module TypeScript {
    export class CandidateInferenceInfo {
        public typeParameter: PullTypeParameterSymbol = null;
        public _inferredTypeAfterFixing: PullTypeSymbol = null;
        public inferenceCandidates: PullTypeSymbol[] = [];

        public addCandidate(candidate: PullTypeSymbol) {
            if (!this._inferredTypeAfterFixing) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        }

        public isFixed() {
            return !!this._inferredTypeAfterFixing;
        }

        public fixTypeParameter(resolver: PullTypeResolver, context: PullTypeResolutionContext): void {
            if (!this._inferredTypeAfterFixing) {
                // November 18, 2013: Section 4.12.2:
                // The inferred type argument for a particular type parameter is the widened form
                // (section 3.9) of the best common type(section 3.10) of a set of candidate types.
                var collection = {
                    getLength: () => this.inferenceCandidates.length,
                    getTypeAtIndex: (index: number) => this.inferenceCandidates[index].type
                };

                // Now widen (per the spec citation above)
                var bestCommonType = resolver.findBestCommonType(collection, context, new TypeComparisonInfo());
                this._inferredTypeAfterFixing = bestCommonType.widenedType(resolver, /*ast*/ null, context);
            }
        }
    }

    export class TypeArgumentInferenceContext {
        public inferenceCache: IBitMatrix = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ false);
        public candidateCache: CandidateInferenceInfo[] = [];

        constructor(public resolver: PullTypeResolver, public context: PullTypeResolutionContext, public signatureBeingInferred: PullSignatureSymbol) {
            var typeParameters = signatureBeingInferred.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                this.addInferenceRoot(typeParameters[i]);
            }
        }

        public alreadyRelatingTypes(objectType: PullTypeSymbol, parameterType: PullTypeSymbol) {
            if (this.inferenceCache.valueAt(objectType.pullSymbolID, parameterType.pullSymbolID)) {
                return true;
            }
            else {
                this.inferenceCache.setValueAt(objectType.pullSymbolID, parameterType.pullSymbolID, true);
                return false;
            }
        }

        public resetRelationshipCache() {
            this.inferenceCache.release();
            this.inferenceCache = BitMatrix.getBitMatrix(/*allowUndefinedValues:*/ false);
        }

        public addInferenceRoot(param: PullTypeParameterSymbol) {
            var info = this.candidateCache[param.pullSymbolID];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.pullSymbolID] = info;
            }
        }

        public getInferenceInfo(param: PullTypeParameterSymbol): CandidateInferenceInfo {
            return this.candidateCache[param.pullSymbolID];
        }

        public addCandidateForInference(param: PullTypeParameterSymbol, candidate: PullTypeSymbol) {
            var info = this.getInferenceInfo(param);

            // Add the candidate to the CandidateInferenceInfo for this type parameter
            // only if the candidate is not already present.
            if (info && candidate && info.inferenceCandidates.indexOf(candidate) < 0) {
                info.addCandidate(candidate);
            }
        }

        public inferTypeArguments(): PullTypeSymbol[] {
            throw Errors.abstract();
        }

        public fixTypeParameter(typeParameter: PullTypeParameterSymbol) {
            var candidateInfo = this.candidateCache[typeParameter.pullSymbolID];
            if (candidateInfo) {
                candidateInfo.fixTypeParameter(this.resolver, this.context);
            }
        }

        public _finalizeInferredTypeArguments(): PullTypeSymbol[]{
            var results: PullTypeSymbol[] = [];
            var typeParameters = this.signatureBeingInferred.getTypeParameters();
            for (var i = 0; i < typeParameters.length; i++) {
                var info = this.candidateCache[typeParameters[i].pullSymbolID];

                info.fixTypeParameter(this.resolver, this.context);

                // is there already a substitution for this type?
                for (var i = 0; i < results.length; i++) {
                    if (results[i].type === info.typeParameter) {
                        results[i].type = info._inferredTypeAfterFixing;
                    }
                }

                results.push(info._inferredTypeAfterFixing);
            }

            return results;
        }

        public isInvocationInferenceContext(): boolean {
            throw Errors.abstract();
        }
    }

    export class InvocationTypeArgumentInferenceContext extends TypeArgumentInferenceContext {
        constructor(
            resolver: PullTypeResolver,
            context: PullTypeResolutionContext,
            signatureBeingInferred: PullSignatureSymbol,
            public argumentList: ArgumentListSyntax) {

            super(resolver, context, signatureBeingInferred);
        }

        public isInvocationInferenceContext() {
            return true;
        }

        public inferTypeArguments(): PullTypeSymbol[] {
            // Resolve all of the argument ASTs in the callback
            this.signatureBeingInferred.forAllParameterTypes(/*length*/ this.argumentList.arguments.length, (parameterType, argumentIndex) => {
                var argumentAST = this.argumentList.arguments[argumentIndex];

                this.context.pushInferentialType(parameterType, this);
                var argumentType = this.resolver.resolveAST(argumentAST, /*isContextuallyTyped*/ true, this.context).type;
                this.resolver.relateTypeToTypeParametersWithNewEnclosingTypes(argumentType, parameterType, this, this.context);
                this.context.popAnyContextualType();

                return true; // Continue iterating
            });

            return this._finalizeInferredTypeArguments();
        }
    }

    export class ContextualSignatureInstantiationTypeArgumentInferenceContext extends TypeArgumentInferenceContext {
        // for the shouldFixContextualSignatureParameterTypes flag, pass true during inferential typing
        // and false during signature relation checking
        constructor(
            resolver: PullTypeResolver,
            context: PullTypeResolutionContext,
            signatureBeingInferred: PullSignatureSymbol,
            private contextualSignature: PullSignatureSymbol,
            private shouldFixContextualSignatureParameterTypes: boolean) {
            super(resolver, context, signatureBeingInferred);
        }

        public isInvocationInferenceContext() {
            return false;
        }

        public inferTypeArguments(): PullTypeSymbol[] {
            // We are in contextual signature instantiation. This callback will be executed
            // for each parameter we are trying to relate in order to infer type arguments.
            var relateTypesCallback = (parameterTypeBeingInferred: PullTypeSymbol, contextualParameterType: PullTypeSymbol) => {
                if (this.shouldFixContextualSignatureParameterTypes) {
                    // Need to modify the callback to cause fixing. Per spec section 4.12.2
                    // 4th bullet of inferential typing:
                    // ... then any inferences made for type parameters referenced by the
                    // parameters of T's call signature are fixed
                    // (T here is the contextual signature)
                    contextualParameterType = this.context.fixAllTypeParametersReferencedByType(contextualParameterType, this.resolver, this);
                }
                this.resolver.relateTypeToTypeParametersWithNewEnclosingTypes(contextualParameterType, parameterTypeBeingInferred, this, this.context);

                return true; // continue iterating
            };

            this.signatureBeingInferred.forAllCorrespondingParameterTypesInThisAndOtherSignature(this.contextualSignature, relateTypesCallback);

            return this._finalizeInferredTypeArguments();
        }
    }

    export class PullContextualTypeContext {
        public provisionallyTypedSymbols: PullSymbol[] = [];
        public hasProvisionalErrors = false;
        private astSymbolMap: PullSymbol[] = [];

        constructor(public contextualType: PullTypeSymbol,
            public provisional: boolean,
            public isInferentiallyTyping: boolean,
            public typeArgumentInferenceContext: TypeArgumentInferenceContext) { }

        public recordProvisionallyTypedSymbol(symbol: PullSymbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        }

        public invalidateProvisionallyTypedSymbols() {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].setUnresolved();
            }
        }

        public setSymbolForAST(ast: ISyntaxElement, symbol: PullSymbol): void {
            Debug.assert(!isShared(ast));
            this.astSymbolMap[syntaxID(ast)] = symbol;
        }

        public getSymbolForAST(ast: ISyntaxElement): PullSymbol {
            return isShared(ast) ? null : this.astSymbolMap[syntaxID(ast)];
        }
    }

    export class PullTypeResolutionContext {
        private contextStack: PullContextualTypeContext[] = [];
        private typeCheckedNodes: IBitVector = null;
        private enclosingTypeWalker1: PullTypeEnclosingTypeWalker = null;
        private enclosingTypeWalker2: PullTypeEnclosingTypeWalker = null;

        constructor(private resolver: PullTypeResolver, public inTypeCheck = false, public fileName: string = null) {
            if (inTypeCheck) {
                Debug.assert(fileName, "A file name must be provided if you are typechecking");
                this.typeCheckedNodes = BitVector.getBitVector(/*allowUndefinedValues:*/ false);
            }
        }

        public setTypeChecked(ast: ISyntaxElement): void {
            if (!this.inProvisionalResolution()) {
                this.typeCheckedNodes.setValueAt(syntaxID(ast), true);
            }
        }

        public canTypeCheckAST(ast: ISyntaxElement): boolean {
            // If we're in a context where we're type checking, and the ast we're typechecking
            // hasn't been typechecked in this phase yet, *and* the ast is from the file we're
            // currently typechecking, then we can typecheck.
            //
            // If the ast has been typechecked in this phase, then there's no need to typecheck
            // it again.  Also, if it's from another file, there's no need to typecheck it since
            // whatever host we're in will eventually get around to typechecking it.  This is 
            // also important as it's very possible to stack overflow when typechecking if we 
            // keep jumping around to ISyntaxElement nodes all around a large project.
            return !isShared(ast) &&
                this.typeCheck() &&
                !this.typeCheckedNodes.valueAt(syntaxID(ast)) &&
                this.fileName === syntaxTree(ast).fileName();
        }

        private _pushAnyContextualType(type: PullTypeSymbol, provisional: boolean, isInferentiallyTyping: boolean, argContext: TypeArgumentInferenceContext) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, isInferentiallyTyping, argContext));
        }

        // Use this to push any kind of contextual type if it is NOT propagated inward from a parent
        // contextual type. This corresponds to the first series of bullets in Section 4.19 of the spec.
        public pushNewContextualType(type: PullTypeSymbol) {
            this._pushAnyContextualType(type, this.inProvisionalResolution(), /*isInferentiallyTyping*/ false, null);
        }

        // Use this when propagating a contextual type from a parent contextual type to a subexpression.
        // This corresponds to the second series of bullets in section 4.19 of the spec.
        public propagateContextualType(type: PullTypeSymbol) {
            this._pushAnyContextualType(type, this.inProvisionalResolution(), this.isInferentiallyTyping(), this.getCurrentTypeArgumentInferenceContext());
        }

        // Use this if you are trying to infer type arguments.
        public pushInferentialType(type: PullTypeSymbol, typeArgumentInferenceContext: TypeArgumentInferenceContext) {
            this._pushAnyContextualType(type, /*provisional*/ true, /*isInferentiallyTyping*/ true, typeArgumentInferenceContext);
        }

        // Use this if you are trying to choose an overload and are trying a contextual type.
        public pushProvisionalType(type: PullTypeSymbol) {
            this._pushAnyContextualType(type, /*provisional*/ true, /*isInferentiallyTyping*/ false, null);
        }

        // Use this to pop any kind of contextual type
        public popAnyContextualType(): PullContextualTypeContext {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            // If the context we just popped off had provisional errors, and we are *still* in a provisional context,
            // we need to not forget that we had provisional errors in a deeper context. We do this by setting the 
            // hasProvisioanlErrors flag on the now top context on the stack. 
            if (tc.hasProvisionalErrors && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].hasProvisionalErrors = true;
            }

            return tc;
        }

        public hasProvisionalErrors() {
            return this.contextStack.length ? this.contextStack[this.contextStack.length - 1].hasProvisionalErrors : false;
        }

        // Gets the current contextual or inferential type
        public getContextualType(): PullTypeSymbol {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];
            
            if (context) {
                var type = context.contextualType;

                if (!type) {
                    return null;
                }

                return type;
            }

            return null;
        }

        public fixAllTypeParametersReferencedByType(type: PullTypeSymbol, resolver: PullTypeResolver, argContext?: TypeArgumentInferenceContext): PullTypeSymbol {
            var argContext = this.getCurrentTypeArgumentInferenceContext();
            if (type.wrapsSomeTypeParameter(argContext.candidateCache)) {
                // Build up a type parameter argument map with which we will instantiate this type
                // after fixing type parameters
                var typeParameterArgumentMap: PullTypeSymbol[] = [];
                // Iterate over all the type parameters and fix any one that is wrapped
                for (var n in argContext.candidateCache) {
                    var typeParameter = argContext.candidateCache[n] && argContext.candidateCache[n].typeParameter;
                    if (typeParameter) {
                        var dummyMap: PullTypeSymbol[] = [];
                        dummyMap[typeParameter.pullSymbolID] = typeParameter;
                        if (type.wrapsSomeTypeParameter(dummyMap)) {
                            argContext.fixTypeParameter(typeParameter);
                            Debug.assert(argContext.candidateCache[n]._inferredTypeAfterFixing);
                            typeParameterArgumentMap[typeParameter.pullSymbolID] = argContext.candidateCache[n]._inferredTypeAfterFixing;
                        }
                    }
                }

                return resolver.instantiateType(type, typeParameterArgumentMap);
            }

            return type;
        }

        // If we are not in inferential typing, this will return null
        private getCurrentTypeArgumentInferenceContext() {
            return this.contextStack.length
                ? this.contextStack[this.contextStack.length - 1].typeArgumentInferenceContext
                : null;
        }

        public isInferentiallyTyping(): boolean {
            return this.contextStack.length > 0 && this.contextStack[this.contextStack.length - 1].isInferentiallyTyping;
        }

        public inProvisionalResolution() {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        }

        private inBaseTypeResolution = false;

        public isInBaseTypeResolution() { return this.inBaseTypeResolution; }

        public startBaseTypeResolution() {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        }

        public doneBaseTypeResolution(wasInBaseTypeResolution: boolean) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        }

        public setTypeInContext(symbol: PullSymbol, type: PullTypeSymbol) {
            // if type of symbol was already determined and it is error - do not replace it with something else
            // otherwise it might cause problems in cases like:
            // var bar: foo;
            // class bar {}
            // class foo {}
            // Symbol for variable bar will get created first, then after binding class constructor of class bar conflict will be detected and symbol.type will be set to error.
            // Later after binding type reference 'foo', symbol.type (that is now 'error') will be incorrectly replace with 'foo'.
            // Since this symbol shared between explicit variable declaration and implicit variable for class constructor 
            // we now ended up in situation where class constructor for 'baz' is type reference to 'foo' which is wrong.
            if (symbol.type && symbol.type.isError() && !type.isError()) {
                return;
            }
            symbol.type = type;

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        }

        public postDiagnostic(diagnostic: Diagnostic): void {
            if (diagnostic) {
                if (this.inProvisionalResolution()) {
                    (this.contextStack[this.contextStack.length - 1]).hasProvisionalErrors = true;
                }
                else if (this.inTypeCheck && this.resolver) {
                    this.resolver.semanticInfoChain.addDiagnostic(diagnostic);
                }
            }
        }

        public typeCheck() {
            return this.inTypeCheck && !this.inProvisionalResolution();
        }

        public setSymbolForAST(ast: ISyntaxElement, symbol: PullSymbol): void {
            this.contextStack[this.contextStack.length - 1].setSymbolForAST(ast, symbol);
        }

        public getSymbolForAST(ast: ISyntaxElement): PullSymbol {
            for (var i = this.contextStack.length - 1; i >= 0; i--) {
                var typeContext = this.contextStack[i];
                if (!typeContext.provisional) {
                    // Only provisional contexts have caches
                    break;
                }

                var symbol = typeContext.getSymbolForAST(ast);
                if (symbol) {
                    return symbol;
                }
            }

            return null;
        }

        public startWalkingTypes(symbol1: PullTypeSymbol, symbol2: PullTypeSymbol) {
            if (!this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1 = new PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var stateWhenStartedWalkingTypes1 = this.enclosingTypeWalker1.startWalkingType(symbol1);
            if (!this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2 = new PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var stateWhenStartedWalkingTypes2 = this.enclosingTypeWalker2.startWalkingType(symbol2);            
            return {
                stateWhenStartedWalkingTypes1: stateWhenStartedWalkingTypes1,
                stateWhenStartedWalkingTypes2: stateWhenStartedWalkingTypes2
            };
        }

        public endWalkingTypes(statesWhenStartedWalkingTypes: {
            stateWhenStartedWalkingTypes1: EnclosingTypeWalkerState;
            stateWhenStartedWalkingTypes2: EnclosingTypeWalkerState;
        }) {
            this.enclosingTypeWalker1.endWalkingType(statesWhenStartedWalkingTypes.stateWhenStartedWalkingTypes1);
            this.enclosingTypeWalker2.endWalkingType(statesWhenStartedWalkingTypes.stateWhenStartedWalkingTypes2);
        }

        public setEnclosingTypeForSymbols(symbol1: PullSymbol, symbol2: PullSymbol) {
            if (!this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1 = new PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var enclosingTypeWalkerState1  = this.enclosingTypeWalker1.setEnclosingTypeForSymbol(symbol1);
            if (!this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2 = new PullTypeEnclosingTypeWalker(this.resolver.semanticInfoChain);
            }
            var enclosingTypeWalkerState2 = this.enclosingTypeWalker2.setEnclosingTypeForSymbol(symbol2);
            return {
                enclosingTypeWalkerState1: enclosingTypeWalkerState1,
                enclosingTypeWalkerState2: enclosingTypeWalkerState2
            }
        }

        public walkMemberTypes(memberName: string) {
            this.enclosingTypeWalker1.walkMemberType(memberName, this.resolver);
            this.enclosingTypeWalker2.walkMemberType(memberName, this.resolver);
        }

        public postWalkMemberTypes() {
            this.enclosingTypeWalker1.postWalkMemberType();
            this.enclosingTypeWalker2.postWalkMemberType();
        }

        public walkSignatures(kind: PullElementKind, index: number, index2?: number) {
            this.enclosingTypeWalker1.walkSignature(kind, index);
            this.enclosingTypeWalker2.walkSignature(kind, index2 == undefined ? index : index2);
        }

        public postWalkSignatures() {
            this.enclosingTypeWalker1.postWalkSignature();
            this.enclosingTypeWalker2.postWalkSignature();
        }

        public walkTypeParameterConstraints(index: number) {
            this.enclosingTypeWalker1.walkTypeParameterConstraint(index);
            this.enclosingTypeWalker2.walkTypeParameterConstraint(index);
        }

        public postWalkTypeParameterConstraints() {
            this.enclosingTypeWalker1.postWalkTypeParameterConstraint();
            this.enclosingTypeWalker2.postWalkTypeParameterConstraint();
        }

        public walkTypeArgument(index: number): void {
            this.enclosingTypeWalker1.walkTypeArgument(index);
            this.enclosingTypeWalker2.walkTypeArgument(index);
        }

        public postWalkTypeArgument(): void {
            this.enclosingTypeWalker1.postWalkTypeArgument();
            this.enclosingTypeWalker2.postWalkTypeArgument();
        }

        public walkReturnTypes() {
            this.enclosingTypeWalker1.walkReturnType();
            this.enclosingTypeWalker2.walkReturnType();
        }

        public postWalkReturnTypes() {
            this.enclosingTypeWalker1.postWalkReturnType();
            this.enclosingTypeWalker2.postWalkReturnType();
        }

        public walkParameterTypes(iParam: number) {
            this.enclosingTypeWalker1.walkParameterType(iParam);
            this.enclosingTypeWalker2.walkParameterType(iParam);
        }

        public postWalkParameterTypes() {
            this.enclosingTypeWalker1.postWalkParameterType();
            this.enclosingTypeWalker2.postWalkParameterType();
        }

        public getBothKindOfIndexSignatures(includeAugmentedType1: boolean, includeAugmentedType2: boolean) {
            var indexSigs1 = this.enclosingTypeWalker1.getBothKindOfIndexSignatures(this.resolver, this, includeAugmentedType1);
            var indexSigs2 = this.enclosingTypeWalker2.getBothKindOfIndexSignatures(this.resolver, this, includeAugmentedType2);
            return { indexSigs1: indexSigs1, indexSigs2: indexSigs2 };
        }

        public walkIndexSignatureReturnTypes(indexSigs: { indexSigs1: IndexSignatureInfo; indexSigs2: IndexSignatureInfo; },
            useStringIndexSignature1: boolean, useStringIndexSignature2: boolean, onlySignature?: boolean) {
            this.enclosingTypeWalker1.walkIndexSignatureReturnType(indexSigs.indexSigs1, useStringIndexSignature1, onlySignature);
            this.enclosingTypeWalker2.walkIndexSignatureReturnType(indexSigs.indexSigs2, useStringIndexSignature2, onlySignature);
        }

        public postWalkIndexSignatureReturnTypes(onlySignature?: boolean) {
            this.enclosingTypeWalker1.postWalkIndexSignatureReturnType(onlySignature);
            this.enclosingTypeWalker2.postWalkIndexSignatureReturnType(onlySignature);
        }

        public swapEnclosingTypeWalkers() {
            var tempEnclosingWalker1 = this.enclosingTypeWalker1;
            this.enclosingTypeWalker1 = this.enclosingTypeWalker2;
            this.enclosingTypeWalker2 = tempEnclosingWalker1;
        }

        public oneOfClassificationsIsInfinitelyExpanding() {
            var generativeClassification1 = this.enclosingTypeWalker1.getGenerativeClassification();
            if (generativeClassification1 === GenerativeTypeClassification.InfinitelyExpanding) {
                return true;
            }
            var generativeClassification2 = this.enclosingTypeWalker2.getGenerativeClassification();
            if (generativeClassification2 === GenerativeTypeClassification.InfinitelyExpanding) {
                return true;
            }

            return false;
        }

        public resetEnclosingTypeWalkerStates() {
            var enclosingTypeWalkerState1 = this.enclosingTypeWalker1 ? this.enclosingTypeWalker1.resetEnclosingTypeWalkerState() : null;
            var enclosingTypeWalkerState2 = this.enclosingTypeWalker2 ? this.enclosingTypeWalker2.resetEnclosingTypeWalkerState() : null;
            return {
                enclosingTypeWalkerState1: enclosingTypeWalkerState1,
                enclosingTypeWalkerState2: enclosingTypeWalkerState2
            }
        }

        public setEnclosingTypeWalkerStates(enclosingTypeWalkerStates: {
            enclosingTypeWalkerState1: EnclosingTypeWalkerState;
            enclosingTypeWalkerState2: EnclosingTypeWalkerState;
        }) {
            Debug.assert(this.enclosingTypeWalker1 || !enclosingTypeWalkerStates.enclosingTypeWalkerState1);
            if (this.enclosingTypeWalker1) {
                this.enclosingTypeWalker1.setEnclosingTypeWalkerState(enclosingTypeWalkerStates.enclosingTypeWalkerState1);
            }
            Debug.assert(this.enclosingTypeWalker2 || !enclosingTypeWalkerStates.enclosingTypeWalkerState2);
            if (this.enclosingTypeWalker2) {
                this.enclosingTypeWalker2.setEnclosingTypeWalkerState(enclosingTypeWalkerStates.enclosingTypeWalkerState2);
            }
        }
    }
}
