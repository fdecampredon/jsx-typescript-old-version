/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_separator_not_allowed: "Trailing separator not allowed.",
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        Rest_parameter_must_be_last_in_list: "Rest parameter must be last in list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        Required_parameter_cannot_follow_optional_parameter: "Required parameter cannot follow optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        Implementations_are_not_allowed_in_ambient_contexts: "Implementations are not allowed in ambient contexts.",
        declare_modifier_not_allowed_for_code_already_in_an_ambient_context: "'declare' modifier not allowed for code already in an ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        Parameter_property_declarations_can_only_be_used_in_constructors: "Parameter property declarations can only be used in constructors.",
        Function_implementation_expected: "Function implementation expected.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        declare_modifier_cannot_appear_on_an_interface_declaration: "'declare' modifier cannot appear on an interface declaration.",
        declare_modifier_required_for_top_level_element: "'declare' modifier required for top level element.",
        Rest_parameter_cannot_be_optional: "Rest parameter cannot be optional.",
        Rest_parameter_cannot_have_an_initializer: "Rest parameter cannot have an initializer.",
        set_accessor_must_have_one_and_only_one_parameter: "'set' accessor must have one and only one parameter.",
        set_accessor_parameter_cannot_have_accessibility_modifier: "'set' accessor parameter cannot have accessibility modifier.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        Module_name_cannot_be_0: "Module name cannot be '{0}'.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        Module_cannot_have_multiple_export_assignments: "Module cannot have multiple export assignments.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        declare_modifier_not_allowed_on_import_declaration: "'declare' modifier not allowed on import declaration.",
        Function_overload_must_be_static: "Function overload must be static.",
        Function_overload_must_not_be_static: "Function overload must not be static.",
        Parameter_property_declarations_cannot_be_used_in_an_ambient_context: "Parameter property declarations cannot be used in an ambient context.",
        Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: "Parameter property declarations cannot be used in a constructor overload.",
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: "Octal literals are not available when targeting ECMAScript 5 and higher.",
        Accessors_are_not_allowed_in_ambient_contexts: "Accessors are not allowed in ambient contexts.",
        Index_member_declaration_can_only_have_the_static_modifier: "Index member declaration can only have the 'static' modifier.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        Value_of_type_0_is_not_indexable_by_type_1: "Value of type '{0}' is not indexable by type '{1}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2_3: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
        Cannot_convert_0_to_1: "Cannot convert '{0}' to '{1}'.",
        Cannot_convert_0_to_1_NL_2: "Cannot convert '{0}' to '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Operator_0_cannot_be_applied_to_type_1: "Operator '{0}' cannot be applied to type '{1}'.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Accessors_cannot_have_type_parameters: "Accessors cannot have type parameters.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Unable_to_resolve_external_module_0: "Unable to resolve external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_another_class_or_interface: "An interface may only extend another class or interface.",
        An_interface_cannot_implement_another_type: "An interface cannot implement another type.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Invalid_new_expression: "Invalid 'new' expression.",
        Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: "Call signatures used in a 'new' expression must have a 'void' return type.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_conditional_expression_cannot_be_determined_0_is_not_identical_to_a_supertype_of_or_a_subtype_of_1: "Type of conditional expression cannot be determined . '{0}' is not identical to, a supertype of, or a subtype of '{1}'.",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        The_property_0_does_not_exist_on_value_of_type_1: "The property '{0}' does not exist on value of type '{1}'.",
        Could_not_find_symbol_0: "Could not find symbol '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_methods_cannot_reference_class_type_parameters: "Static methods cannot reference class type parameters.",
        Class_0_is_recursively_referenced_as_a_base_type_of_itself: "Class '{0}' is recursively referenced as a base type of itself.",
        Interface_0_is_recursively_referenced_as_a_base_type_of_itself: "Interface '{0}' is recursively referenced as a base type of itself.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_cannot_be_referenced_in_non_derived_classes: "'super' cannot be referenced in non-derived classes.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: "Super calls are not permitted outside constructors or in local functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_within_module_bodies: "'this' cannot be referenced within module bodies.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_string_or_any: "The left-hand side of an 'in' expression must be of types 'string' or 'any'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Function_0_declared_a_non_void_return_type_but_has_no_return_expression: "Function '{0}' declared a non-void return type, but has no return expression.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_static_initializers_in_a_class_body: "'this' cannot be referenced in static initializers in a class body.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Duplicate_overload_signature_for_0: "Duplicate overload signature for '{0}'.",
        Duplicate_constructor_overload_signature: "Duplicate constructor overload signature.",
        Duplicate_overload_call_signature: "Duplicate overload call signature.",
        Duplicate_overload_construct_signature: "Duplicate overload construct signature.",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_not_exported: "Overload signatures must all be exported or not exported.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: "Specialized overload signature is not subtype of any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Static_member_cannot_be_accessed_off_an_instance_variable: "Static member cannot be accessed off an instance variable.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        Rest_parameters_must_be_array_types: "Rest parameters must be array types.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0: "All numerically named properties must be subtypes of numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1: "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0: "All named properties must be subtypes of string indexer type '{0}'.",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1: "All named properties must be subtypes of string indexer type '{0}':{NL}{1}",
        Generic_type_references_must_include_all_type_arguments: "Generic type references must include all type arguments.",
        Default_arguments_are_not_allowed_in_an_overload_parameter: "Default arguments are not allowed in an overload parameter.",
        Overloads_cannot_differ_only_by_return_type: "Overloads cannot differ only by return type.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Could_not_find_symbol_0_in_module_1: "Could not find symbol '{0}' in module '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_reference_0_in_extends_clause_doesn_t_reference_constructor_function_for_1: "Type reference '{0}' in extends clause doesn't reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_doesn_t_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration doesn't reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_Types_of_property_3_of_types_1_and_2_are_not_identical: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}Types of property '{3}' of types '{1}' and '{2}' are not identical.",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: "Ambient external module declaration cannot be reopened.",
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: "Return type of constructor signature must be assignable to the instance type of the class.",
        Ambient_external_module_declaration_must_be_defined_in_global_context: "Ambient external module declaration must be defined in global context.",
        Ambient_external_module_declaration_cannot_specify_relative_module_name: "Ambient external module declaration cannot specify relative module name.",
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.",
        Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions: "Could not find the best common type of types of all return statement expressions.",
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: "Import declaration cannot refer to external module reference when --noResolve option is set.",
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: "Jump target not found.",
        Jump_target_cannot_cross_function_boundary: "Jump target cannot cross function boundary.",
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element: "Enums with multiple declarations must provide an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: "Variable declaration cannot have the same name as an import declaration.",
        Signature_expected_0_type_arguments_got_1_instead: "Signature expected {0} type arguments, got {1} instead.",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Module_code_generation_0_not_supported: "Module code generation '{0}' not supported.",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Should_not_emit_a_type_query: "Should not emit a type query.",
        Should_not_emit_a_type_reference: "Should not emit a type reference.",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Key_was_already_in_table: "Key was already in table.",
        Unknown_option_0: "Unknown option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead.",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Invalid_argument_0_1: "Invalid argument: {0}. {1}",
        Invalid_argument_0: "Invalid argument: {0}.",
        Argument_out_of_range_0: "Argument out of range: {0}.",
        Argument_null_0: "Argument null: {0}.",
        Operation_not_implemented_properly_by_subclass: "Operation not implemented properly by subclass.",
        Not_yet_implemented: "Not yet implemented.",
        Invalid_operation_0: "Invalid operation: {0}",
        Invalid_operation: "Invalid operation.",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file.",
        Generates_corresponding_0_file: "Generates corresponding {0} file.",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files.",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory.",
        Do_not_emit_comments_to_output: "Do not emit comments to output.",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing.",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: "Print this message.",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file1: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        file2: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        NUMBER: "NUMBER",
        Specify_the_codepage_to_use_when_opening_source_files: "Specify the codepage to use when opening source files.",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Looking_up_path_for_identifier_token_did_not_result_in_an_identifer: "Looking up path for identifier token did not result in an identifer.",
        Unknown_rule: "Unknown rule.",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening."
    };
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.isArray = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        };

        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.groupBy = function (array, func) {
            var result = {};

            for (var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);

                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }

            return result;
        };

        ArrayUtilities.distinct = function (array, equalsFn) {
            var result = [];

            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }

                if (j === result.length) {
                    result.push(current);
                }
            }

            return result;
        };

        ArrayUtilities.min = function (array, func) {
            var min = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }

            return min;
        };

        ArrayUtilities.max = function (array, func) {
            var max = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }

            return max;
        };

        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        };

        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }

            return null;
        };

        ArrayUtilities.lastOrDefault = function (array, func) {
            for (var i = array.length - 1; i >= 0; i--) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }

            return null;
        };

        ArrayUtilities.sum = function (array, func) {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        };

        ArrayUtilities.whereNotNull = function (array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var value = array[i];
                if (value !== null) {
                    result.push(value);
                }
            }

            return result;
        };

        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);

            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }

            return result;
        };

        ArrayUtilities.where = function (values, func) {
            var result = new Array();

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        };

        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                } else if (midValue > value) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            }

            return ~low;
        };

        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }

            return result;
        };

        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };

        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Constants) {
        Constants[Constants["Max31BitInteger"] = 1073741823] = "Max31BitInteger";
        Constants[Constants["Min31BitInteger"] = -1073741824] = "Min31BitInteger";
    })(TypeScript.Constants || (TypeScript.Constants = {}));
    var Constants = TypeScript.Constants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Debug = (function () {
        function Debug() {
        }
        Debug.assert = function (expression, message) {
            if (!expression) {
                throw new Error("Debug Failure. False expression: " + (message ? message : ""));
            }
        };
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error(message ? TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_argument_0_1, [argument, message]) : TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_argument_0, [argument]));
        };

        Errors.argumentOutOfRange = function (argument) {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Argument_out_of_range_0, [argument]));
        };

        Errors.argumentNull = function (argument) {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Argument_null_0, [argument]));
        };

        Errors.abstract = function () {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Operation_not_implemented_properly_by_subclass, null));
        };

        Errors.notYetImplemented = function () {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Not_yet_implemented, null));
        };

        Errors.invalidOperation = function (message) {
            return new Error(message ? TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_operation_0, [message]) : TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_operation, null));
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() {
        }
        Hash.computeFnv1aCharArrayHashCode = function (text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(hashCode ^ text[i], Hash.FNV_PRIME);
            }

            return hashCode;
        };

        Hash.computeSimple31BitCharArrayHashCode = function (key, start, len) {
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeSimple31BitStringHashCode = function (key) {
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeMurmur2StringHashCode = function (key, seed) {
            var m = 0x5bd1e995;
            var r = 24;

            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);

            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = Math.abs(c1 | (c2 << 16));

                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);

                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft == 1) {
                h ^= key.charCodeAt(index);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }

            h ^= h >> 13;
            h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;

            return h;
        };

        Hash.getPrime = function (min) {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }

            throw TypeScript.Errors.notYetImplemented();
        };

        Hash.expandPrime = function (oldSize) {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                return 2146435069;
            }
            return Hash.getPrime(num);
        };

        Hash.combine = function (value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;

        Hash.primes = [
            3,
            7,
            11,
            17,
            23,
            29,
            37,
            47,
            59,
            71,
            89,
            107,
            131,
            163,
            197,
            239,
            293,
            353,
            431,
            521,
            631,
            761,
            919,
            1103,
            1327,
            1597,
            1931,
            2333,
            2801,
            3371,
            4049,
            4861,
            5839,
            7013,
            8419,
            10103,
            12143,
            14591,
            17519,
            21023,
            25229,
            30293,
            36353,
            43627,
            52361,
            62851,
            75431,
            90523,
            108631,
            130363,
            156437,
            187751,
            225307,
            270371,
            324449,
            389357,
            467237,
            560689,
            672827,
            807403,
            968897,
            1162687,
            1395263,
            1674319,
            2009191,
            2411033,
            2893249,
            3471899,
            4166287,
            4999559,
            5999471,
            7199369
        ];
        return Hash;
    })();
    TypeScript.Hash = Hash;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultHashTableCapacity = 1024;

        var HashTableEntry = (function () {
            function HashTableEntry(Key, Value, HashCode, Next) {
                this.Key = Key;
                this.Value = Value;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return HashTableEntry;
        })();

        var HashTable = (function () {
            function HashTable(capacity, hash) {
                this.hash = hash;
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            HashTable.prototype.set = function (key, value) {
                this.addOrSet(key, value, false);
            };

            HashTable.prototype.add = function (key, value) {
                this.addOrSet(key, value, true);
            };

            HashTable.prototype.containsKey = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry !== null;
            };

            HashTable.prototype.get = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);

                return entry === null ? null : entry.Value;
            };

            HashTable.prototype.computeHashCode = function (key) {
                var hashCode = this.hash === null ? key.hashCode : this.hash(key);

                hashCode = hashCode & 0x7FFFFFFF;
                TypeScript.Debug.assert(hashCode >= 0);

                return hashCode;
            };

            HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
                var hashCode = this.computeHashCode(key);

                var entry = this.findEntry(key, hashCode);
                if (entry !== null) {
                    if (throwOnExistingEntry) {
                        throw TypeScript.Errors.argument('key', TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Key_was_already_in_table, null));
                    }

                    entry.Key = key;
                    entry.Value = value;
                    return;
                }

                return this.addEntry(key, value, hashCode);
            };

            HashTable.prototype.findEntry = function (key, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && key === e.Key) {
                        return e;
                    }
                }

                return null;
            };

            HashTable.prototype.addEntry = function (key, value, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count >= (this.entries.length / 2)) {
                    this.grow();
                }

                this.count++;
                return e.Key;
            };

            HashTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];

                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            return HashTable;
        })();
        Collections.HashTable = HashTable;

        function createHashTable(capacity, hash) {
            if (typeof capacity === "undefined") { capacity = Collections.DefaultHashTableCapacity; }
            if (typeof hash === "undefined") { hash = null; }
            return new HashTable(capacity, hash);
        }
        Collections.createHashTable = createHashTable;

        var currentHashCode = 1;
        function identityHashCode(value) {
            if (value.__hash === undefined) {
                value.__hash = currentHashCode;
                currentHashCode++;
            }

            return value.__hash;
        }
        Collections.identityHashCode = identityHashCode;
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.LocalizedDiagnosticMessages = null;

    function newLine() {
        return Environment ? Environment.newLine : "\r\n";
    }
    TypeScript.newLine = newLine;

    var Diagnostic = (function () {
        function Diagnostic(fileName, start, length, diagnosticKey, arguments) {
            if (typeof arguments === "undefined") { arguments = null; }
            this._diagnosticKey = diagnosticKey;
            this._arguments = (arguments && arguments.length > 0) ? arguments : null;
            this._fileName = fileName;
            this._start = start;
            this._length = length;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();

            result.diagnosticCode = this._diagnosticKey;

            var arguments = this.arguments();
            if (arguments && arguments.length > 0) {
                result.arguments = arguments;
            }

            return result;
        };

        Diagnostic.prototype.fileName = function () {
            return this._fileName;
        };

        Diagnostic.prototype.start = function () {
            return this._start;
        };

        Diagnostic.prototype.length = function () {
            return this._length;
        };

        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };

        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };

        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.additionalLocations = function () {
            return [];
        };

        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return diagnostic1._fileName === diagnostic2._fileName && diagnostic1._start === diagnostic2._start && diagnostic1._length === diagnostic2._length && diagnostic1._diagnosticKey === diagnostic2._diagnosticKey && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
                return v1 === v2;
            });
        };
        return Diagnostic;
    })();
    TypeScript.Diagnostic = Diagnostic;

    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;

        var match;
        while ((match = regex.exec(diagnostic)) != null) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }

        return largest;
    }

    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];

        return result;
    }
    TypeScript.getDiagnosticInfoFromKey = getDiagnosticInfoFromKey;

    function getLocalizedText(diagnosticKey, args) {
        if (TypeScript.LocalizedDiagnosticMessages) {
        }

        var diagnosticMessageText = TypeScript.LocalizedDiagnosticMessages ? TypeScript.LocalizedDiagnosticMessages[diagnosticKey] : diagnosticKey;

        var actualCount = args ? args.length : 0;

        var expectedCount = 1 + getLargestIndex(diagnosticKey);

        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }

        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }

        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });

        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;

    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);

        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else if (diagnostic.category === 0 /* Warning */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else {
            message = diagnosticMessageText;
        }

        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMakeDirectoryTime = 0;
    TypeScript.nodeCreateBufferTime = 0;
    TypeScript.nodeWriteFileSyncTime = 0;
})(TypeScript || (TypeScript = {}));

var ByteOrderMark;
(function (ByteOrderMark) {
    ByteOrderMark[ByteOrderMark["None"] = 0] = "None";
    ByteOrderMark[ByteOrderMark["Utf8"] = 1] = "Utf8";
    ByteOrderMark[ByteOrderMark["Utf16BigEndian"] = 2] = "Utf16BigEndian";
    ByteOrderMark[ByteOrderMark["Utf16LittleEndian"] = 3] = "Utf16LittleEndian";
})(ByteOrderMark || (ByteOrderMark = {}));

var FileInformation = (function () {
    function FileInformation(contents, byteOrderMark) {
        this.contents = contents;
        this.byteOrderMark = byteOrderMark;
    }
    return FileInformation;
})();

var Environment = (function () {
    function getWindowsScriptHostEnvironment() {
        try  {
            var fso = new ActiveXObject("Scripting.FileSystemObject");
        } catch (e) {
            return null;
        }

        var streamObjectPool = [];

        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            newLine: "\r\n",
            currentDirectory: function () {
                return WScript.CreateObject("WScript.Shell").CurrentDirectory;
            },
            supportsCodePage: function () {
                return WScript.ReadFile;
            },
            readFile: function (path, codepage) {
                try  {
                    if (codepage !== null && this.supportsCodePage()) {
                        try  {
                            var contents = WScript.ReadFile(path, codepage);
                            return new FileInformation(contents, 0 /* None */);
                        } catch (e) {
                        }
                    }

                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2;

                    streamObj.Charset = 'x-ansi';

                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2);

                    streamObj.Position = 0;

                    var byteOrderMark = 0 /* None */;

                    if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 2 /* Utf16BigEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 3 /* Utf16LittleEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                        streamObj.Charset = 'utf-8';
                        byteOrderMark = 1 /* Utf8 */;
                    } else {
                        streamObj.Charset = 'utf-8';
                    }

                    var contents = streamObj.ReadText(-1);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return new FileInformation(contents, byteOrderMark);
                } catch (err) {
                    var message;
                    if (err.number === -2147024809) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unsupported_file_encoding, null);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_read_file_0_1, [path, err.message]);
                    }

                    throw new Error(message);
                }
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                var textStream = getStreamObject();
                textStream.Charset = 'utf-8';
                textStream.Open();
                textStream.WriteText(contents, 0);

                if (!writeByteOrderMark) {
                    textStream.Position = 3;
                } else {
                    textStream.Position = 0;
                }

                var fileStream = getStreamObject();
                fileStream.Type = 1;
                fileStream.Open();

                textStream.CopyTo(fileStream);

                fileStream.Flush();
                fileStream.SaveToFile(path, 2);
                fileStream.Close();

                textStream.Flush();
                textStream.Close();
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            deleteFile: function (path) {
                if (fso.FileExists(path)) {
                    fso.DeleteFile(path, true);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            listFiles: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "\\" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },
            arguments: args,
            standardOut: WScript.StdOut
        };
    }
    ;

    function getNodeEnvironment() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');
        var _os = require('os');

        return {
            newLine: _os.EOL,
            currentDirectory: function () {
                return process.cwd();
            },
            supportsCodePage: function () {
                return false;
            },
            readFile: function (file, codepage) {
                if (codepage !== null) {
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.codepage_option_not_supported_on_current_platform, null));
                }

                var buffer = _fs.readFileSync(file);
                switch (buffer[0]) {
                    case 0xFE:
                        if (buffer[1] === 0xFF) {
                            var i = 0;
                            while ((i + 1) < buffer.length) {
                                var temp = buffer[i];
                                buffer[i] = buffer[i + 1];
                                buffer[i + 1] = temp;
                                i += 2;
                            }
                            return new FileInformation(buffer.toString("ucs2", 2), 2 /* Utf16BigEndian */);
                        }
                        break;
                    case 0xFF:
                        if (buffer[1] === 0xFE) {
                            return new FileInformation(buffer.toString("ucs2", 2), 3 /* Utf16LittleEndian */);
                        }
                        break;
                    case 0xEF:
                        if (buffer[1] === 0xBB) {
                            return new FileInformation(buffer.toString("utf8", 3), 1 /* Utf8 */);
                        }
                }

                return new FileInformation(buffer.toString("utf8", 0), 0 /* None */);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        throw "\"" + path + "\" exists but isn't a directory.";
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 509);
                    }
                }
                var start = new Date().getTime();
                mkdirRecursiveSync(_path.dirname(path));
                TypeScript.nodeMakeDirectoryTime += new Date().getTime() - start;

                if (writeByteOrderMark) {
                    contents = '\uFEFF' + contents;
                }

                var start = new Date().getTime();

                var chunkLength = 4 * 1024;
                var fileDescriptor = _fs.openSync(path, "w");
                try  {
                    for (var index = 0; index < contents.length; index += chunkLength) {
                        var bufferStart = new Date().getTime();
                        var buffer = new Buffer(contents.substr(index, chunkLength), "utf8");
                        TypeScript.nodeCreateBufferTime += new Date().getTime() - bufferStart;

                        _fs.writeSync(fileDescriptor, buffer, 0, buffer.length, null);
                    }
                } finally {
                    _fs.closeSync(fileDescriptor);
                }

                TypeScript.nodeWriteFileSyncTime += new Date().getTime() - start;
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            listFiles: function dir(path, spec, options) {
                options = options || {};

                function filesInFolder(folder) {
                    var paths = [];

                    var files = _fs.readdirSync(folder);
                    for (var i = 0; i < files.length; i++) {
                        var stat = _fs.statSync(folder + "\\" + files[i]);
                        if (options.recursive && stat.isDirectory()) {
                            paths = paths.concat(filesInFolder(folder + "\\" + files[i]));
                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                            paths.push(folder + "\\" + files[i]);
                        }
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            arguments: process.argv.slice(2),
            standardOut: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            }
        };
    }
    ;

    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
        return getWindowsScriptHostEnvironment();
    } else if (typeof module !== 'undefined' && module.exports) {
        return getNodeEnvironment();
    } else {
        return null;
    }
})();
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities = (function () {
        function IntegerUtilities() {
        }
        IntegerUtilities.integerDivide = function (numerator, denominator) {
            return (numerator / denominator) >> 0;
        };

        IntegerUtilities.integerMultiplyLow32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        };

        IntegerUtilities.integerMultiplyHigh32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        };
        return IntegerUtilities;
    })();
    TypeScript.IntegerUtilities = IntegerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MathPrototype = (function () {
        function MathPrototype() {
        }
        MathPrototype.max = function (a, b) {
            return a >= b ? a : b;
        };

        MathPrototype.min = function (a, b) {
            return a <= b ? a : b;
        };
        return MathPrototype;
    })();
    TypeScript.MathPrototype = MathPrototype;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultStringTableCapacity = 256;

        var StringTableEntry = (function () {
            function StringTableEntry(Text, HashCode, Next) {
                this.Text = Text;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return StringTableEntry;
        })();

        var StringTable = (function () {
            function StringTable(capacity) {
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            StringTable.prototype.addCharArray = function (key, start, len) {
                var hashCode = TypeScript.Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;

                var entry = this.findCharArrayEntry(key, start, len, hashCode);
                if (entry !== null) {
                    return entry.Text;
                }

                var slice = key.slice(start, start + len);
                return this.addEntry(TypeScript.StringUtilities.fromCharCodeArray(slice), hashCode);
            };

            StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                        return e;
                    }
                }

                return null;
            };

            StringTable.prototype.addEntry = function (text, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new StringTableEntry(text, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count === this.entries.length) {
                    this.grow();
                }

                this.count++;
                return e.Text;
            };

            StringTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };

            StringTable.textCharArrayEquals = function (text, array, start, length) {
                if (text.length !== length) {
                    return false;
                }

                var s = start;
                for (var i = 0; i < length; i++) {
                    if (text.charCodeAt(i) !== array[s]) {
                        return false;
                    }

                    s++;
                }

                return true;
            };
            return StringTable;
        })();
        Collections.StringTable = StringTable;

        Collections.DefaultStringTable = new StringTable(Collections.DefaultStringTableCapacity);
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };

        StringUtilities.fromCharCodeArray = function (array) {
            return String.fromCharCode.apply(null, array);
        };

        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };

        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };

        StringUtilities.copyTo = function (source, sourceIndex, destination, destinationIndex, count) {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        };

        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };

        StringUtilities.stringEquals = function (val1, val2) {
            return val1 === val2;
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);

var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        Clock.now;
        Clock.resolution;

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();

            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };

            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            Clock.now = function () {
                return Date.now();
            };

            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));

    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };

        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    })();
    TypeScript.Timer = Timer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": {
            "code": 0,
            "category": 3 /* NoPrefix */
        },
        "warning TS{0}: {1}": {
            "code": 1,
            "category": 3 /* NoPrefix */
        },
        "Unrecognized escape sequence.": {
            "code": 1000,
            "category": 1 /* Error */
        },
        "Unexpected character {0}.": {
            "code": 1001,
            "category": 1 /* Error */
        },
        "Missing close quote character.": {
            "code": 1002,
            "category": 1 /* Error */
        },
        "Identifier expected.": {
            "code": 1003,
            "category": 1 /* Error */
        },
        "'{0}' keyword expected.": {
            "code": 1004,
            "category": 1 /* Error */
        },
        "'{0}' expected.": {
            "code": 1005,
            "category": 1 /* Error */
        },
        "Identifier expected; '{0}' is a keyword.": {
            "code": 1006,
            "category": 1 /* Error */
        },
        "Automatic semicolon insertion not allowed.": {
            "code": 1007,
            "category": 1 /* Error */
        },
        "Unexpected token; '{0}' expected.": {
            "code": 1008,
            "category": 1 /* Error */
        },
        "Trailing separator not allowed.": {
            "code": 1009,
            "category": 1 /* Error */
        },
        "'*/' expected.": {
            "code": 1010,
            "category": 1 /* Error */
        },
        "'public' or 'private' modifier must precede 'static'.": {
            "code": 1011,
            "category": 1 /* Error */
        },
        "Unexpected token.": {
            "code": 1012,
            "category": 1 /* Error */
        },
        "Catch clause parameter cannot have a type annotation.": {
            "code": 1013,
            "category": 1 /* Error */
        },
        "Rest parameter must be last in list.": {
            "code": 1014,
            "category": 1 /* Error */
        },
        "Parameter cannot have question mark and initializer.": {
            "code": 1015,
            "category": 1 /* Error */
        },
        "Required parameter cannot follow optional parameter.": {
            "code": 1016,
            "category": 1 /* Error */
        },
        "Index signatures cannot have rest parameters.": {
            "code": 1017,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have accessibility modifiers.": {
            "code": 1018,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have a question mark.": {
            "code": 1019,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have an initializer.": {
            "code": 1020,
            "category": 1 /* Error */
        },
        "Index signature must have a type annotation.": {
            "code": 1021,
            "category": 1 /* Error */
        },
        "Index signature parameter must have a type annotation.": {
            "code": 1022,
            "category": 1 /* Error */
        },
        "Index signature parameter type must be 'string' or 'number'.": {
            "code": 1023,
            "category": 1 /* Error */
        },
        "'extends' clause already seen.": {
            "code": 1024,
            "category": 1 /* Error */
        },
        "'extends' clause must precede 'implements' clause.": {
            "code": 1025,
            "category": 1 /* Error */
        },
        "Classes can only extend a single class.": {
            "code": 1026,
            "category": 1 /* Error */
        },
        "'implements' clause already seen.": {
            "code": 1027,
            "category": 1 /* Error */
        },
        "Accessibility modifier already seen.": {
            "code": 1028,
            "category": 1 /* Error */
        },
        "'{0}' modifier must precede '{1}' modifier.": {
            "code": 1029,
            "category": 1 /* Error */
        },
        "'{0}' modifier already seen.": {
            "code": 1030,
            "category": 1 /* Error */
        },
        "'{0}' modifier cannot appear on a class element.": {
            "code": 1031,
            "category": 1 /* Error */
        },
        "Interface declaration cannot have 'implements' clause.": {
            "code": 1032,
            "category": 1 /* Error */
        },
        "'super' invocation cannot have type arguments.": {
            "code": 1034,
            "category": 1 /* Error */
        },
        "Only ambient modules can use quoted names.": {
            "code": 1035,
            "category": 1 /* Error */
        },
        "Statements are not allowed in ambient contexts.": {
            "code": 1036,
            "category": 1 /* Error */
        },
        "Implementations are not allowed in ambient contexts.": {
            "code": 1037,
            "category": 1 /* Error */
        },
        "'declare' modifier not allowed for code already in an ambient context.": {
            "code": 1038,
            "category": 1 /* Error */
        },
        "Initializers are not allowed in ambient contexts.": {
            "code": 1039,
            "category": 1 /* Error */
        },
        "Parameter property declarations can only be used in constructors.": {
            "code": 1040,
            "category": 1 /* Error */
        },
        "Function implementation expected.": {
            "code": 1041,
            "category": 1 /* Error */
        },
        "Constructor implementation expected.": {
            "code": 1042,
            "category": 1 /* Error */
        },
        "Function overload name must be '{0}'.": {
            "code": 1043,
            "category": 1 /* Error */
        },
        "'{0}' modifier cannot appear on a module element.": {
            "code": 1044,
            "category": 1 /* Error */
        },
        "'declare' modifier cannot appear on an interface declaration.": {
            "code": 1045,
            "category": 1 /* Error */
        },
        "'declare' modifier required for top level element.": {
            "code": 1046,
            "category": 1 /* Error */
        },
        "Rest parameter cannot be optional.": {
            "code": 1047,
            "category": 1 /* Error */
        },
        "Rest parameter cannot have an initializer.": {
            "code": 1048,
            "category": 1 /* Error */
        },
        "'set' accessor must have one and only one parameter.": {
            "code": 1049,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot have accessibility modifier.": {
            "code": 1050,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot be optional.": {
            "code": 1051,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot have an initializer.": {
            "code": 1052,
            "category": 1 /* Error */
        },
        "'set' accessor cannot have rest parameter.": {
            "code": 1053,
            "category": 1 /* Error */
        },
        "'get' accessor cannot have parameters.": {
            "code": 1054,
            "category": 1 /* Error */
        },
        "Modifiers cannot appear here.": {
            "code": 1055,
            "category": 1 /* Error */
        },
        "Accessors are only available when targeting ECMAScript 5 and higher.": {
            "code": 1056,
            "category": 1 /* Error */
        },
        "Class name cannot be '{0}'.": {
            "code": 1057,
            "category": 1 /* Error */
        },
        "Interface name cannot be '{0}'.": {
            "code": 1058,
            "category": 1 /* Error */
        },
        "Enum name cannot be '{0}'.": {
            "code": 1059,
            "category": 1 /* Error */
        },
        "Module name cannot be '{0}'.": {
            "code": 1060,
            "category": 1 /* Error */
        },
        "Enum member must have initializer.": {
            "code": 1061,
            "category": 1 /* Error */
        },
        "Export assignment cannot be used in internal modules.": {
            "code": 1063,
            "category": 1 /* Error */
        },
        "Export assignment not allowed in module with exported element.": {
            "code": 1064,
            "category": 1 /* Error */
        },
        "Module cannot have multiple export assignments.": {
            "code": 1065,
            "category": 1 /* Error */
        },
        "Ambient enum elements can only have integer literal initializers.": {
            "code": 1066,
            "category": 1 /* Error */
        },
        "module, class, interface, enum, import or statement": {
            "code": 1067,
            "category": 3 /* NoPrefix */
        },
        "constructor, function, accessor or variable": {
            "code": 1068,
            "category": 3 /* NoPrefix */
        },
        "statement": {
            "code": 1069,
            "category": 3 /* NoPrefix */
        },
        "case or default clause": {
            "code": 1070,
            "category": 3 /* NoPrefix */
        },
        "identifier": {
            "code": 1071,
            "category": 3 /* NoPrefix */
        },
        "call, construct, index, property or function signature": {
            "code": 1072,
            "category": 3 /* NoPrefix */
        },
        "expression": {
            "code": 1073,
            "category": 3 /* NoPrefix */
        },
        "type name": {
            "code": 1074,
            "category": 3 /* NoPrefix */
        },
        "property or accessor": {
            "code": 1075,
            "category": 3 /* NoPrefix */
        },
        "parameter": {
            "code": 1076,
            "category": 3 /* NoPrefix */
        },
        "type": {
            "code": 1077,
            "category": 3 /* NoPrefix */
        },
        "type parameter": {
            "code": 1078,
            "category": 3 /* NoPrefix */
        },
        "'declare' modifier not allowed on import declaration.": {
            "code": 1079,
            "category": 1 /* Error */
        },
        "Function overload must be static.": {
            "code": 1080,
            "category": 1 /* Error */
        },
        "Function overload must not be static.": {
            "code": 1081,
            "category": 1 /* Error */
        },
        "Parameter property declarations cannot be used in an ambient context.": {
            "code": 1082,
            "category": 1 /* Error */
        },
        "Parameter property declarations cannot be used in a constructor overload.": {
            "code": 1083,
            "category": 1 /* Error */
        },
        "Invalid 'reference' directive syntax.": {
            "code": 1084,
            "category": 1 /* Error */
        },
        "Octal literals are not available when targeting ECMAScript 5 and higher.": {
            "code": 1085,
            "category": 1 /* Error */
        },
        "Accessors are not allowed in ambient contexts.": {
            "code": 1086,
            "category": 1 /* Error */
        },
        "Index member declaration can only have the 'static' modifier.": {
            "code": 1088,
            "category": 1 /* Error */
        },
        "Duplicate identifier '{0}'.": {
            "code": 2000,
            "category": 1 /* Error */
        },
        "The name '{0}' does not exist in the current scope.": {
            "code": 2001,
            "category": 1 /* Error */
        },
        "The name '{0}' does not refer to a value.": {
            "code": 2002,
            "category": 1 /* Error */
        },
        "'super' can only be used inside a class instance method.": {
            "code": 2003,
            "category": 1 /* Error */
        },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": {
            "code": 2004,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": {
            "code": 2161,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not callable.": {
            "code": 2006,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not newable.": {
            "code": 2007,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not indexable by type '{1}'.": {
            "code": 2008,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": {
            "code": 2009,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": {
            "code": 2010,
            "category": 1 /* Error */
        },
        "Cannot convert '{0}' to '{1}'.": {
            "code": 2011,
            "category": 1 /* Error */
        },
        "Cannot convert '{0}' to '{1}':{NL}{2}": {
            "code": 2012,
            "category": 1 /* Error */
        },
        "Expected var, class, interface, or module.": {
            "code": 2013,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to type '{1}'.": {
            "code": 2014,
            "category": 1 /* Error */
        },
        "Getter '{0}' already declared.": {
            "code": 2015,
            "category": 1 /* Error */
        },
        "Setter '{0}' already declared.": {
            "code": 2016,
            "category": 1 /* Error */
        },
        "Accessors cannot have type parameters.": {
            "code": 2017,
            "category": 1 /* Error */
        },
        "Exported class '{0}' extends private class '{1}'.": {
            "code": 2018,
            "category": 1 /* Error */
        },
        "Exported class '{0}' implements private interface '{1}'.": {
            "code": 2019,
            "category": 1 /* Error */
        },
        "Exported interface '{0}' extends private interface '{1}'.": {
            "code": 2020,
            "category": 1 /* Error */
        },
        "Exported class '{0}' extends class from inaccessible module {1}.": {
            "code": 2021,
            "category": 1 /* Error */
        },
        "Exported class '{0}' implements interface from inaccessible module {1}.": {
            "code": 2022,
            "category": 1 /* Error */
        },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": {
            "code": 2023,
            "category": 1 /* Error */
        },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2024,
            "category": 1 /* Error */
        },
        "Public property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2025,
            "category": 1 /* Error */
        },
        "Property '{0}' of exported interface has or is using private type '{1}'.": {
            "code": 2026,
            "category": 1 /* Error */
        },
        "Exported variable '{0}' has or is using private type '{1}'.": {
            "code": 2027,
            "category": 1 /* Error */
        },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2028,
            "category": 1 /* Error */
        },
        "Public property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2029,
            "category": 1 /* Error */
        },
        "Property '{0}' of exported interface is using inaccessible module {1}.": {
            "code": 2030,
            "category": 1 /* Error */
        },
        "Exported variable '{0}' is using inaccessible module {1}.": {
            "code": 2031,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": {
            "code": 2032,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": {
            "code": 2033,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": {
            "code": 2034,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": 2035,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": 2036,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": 2037,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": 2038,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": 2039,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": 2040,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": {
            "code": 2041,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": {
            "code": 2042,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": {
            "code": 2043,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": 2044,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": 2045,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": 2046,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": 2047,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": 2048,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": 2049,
            "category": 1 /* Error */
        },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": {
            "code": 2050,
            "category": 1 /* Error */
        },
        "Return type of public property getter from exported class has or is using private type '{0}'.": {
            "code": 2051,
            "category": 1 /* Error */
        },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": {
            "code": 2052,
            "category": 1 /* Error */
        },
        "Return type of call signature from exported interface has or is using private type '{0}'.": {
            "code": 2053,
            "category": 1 /* Error */
        },
        "Return type of index signature from exported interface has or is using private type '{0}'.": {
            "code": 2054,
            "category": 1 /* Error */
        },
        "Return type of public static method from exported class has or is using private type '{0}'.": {
            "code": 2055,
            "category": 1 /* Error */
        },
        "Return type of public method from exported class has or is using private type '{0}'.": {
            "code": 2056,
            "category": 1 /* Error */
        },
        "Return type of method from exported interface has or is using private type '{0}'.": {
            "code": 2057,
            "category": 1 /* Error */
        },
        "Return type of exported function has or is using private type '{0}'.": {
            "code": 2058,
            "category": 1 /* Error */
        },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": {
            "code": 2059,
            "category": 1 /* Error */
        },
        "Return type of public property getter from exported class is using inaccessible module {0}.": {
            "code": 2060,
            "category": 1 /* Error */
        },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": {
            "code": 2061,
            "category": 1 /* Error */
        },
        "Return type of call signature from exported interface is using inaccessible module {0}.": {
            "code": 2062,
            "category": 1 /* Error */
        },
        "Return type of index signature from exported interface is using inaccessible module {0}.": {
            "code": 2063,
            "category": 1 /* Error */
        },
        "Return type of public static method from exported class is using inaccessible module {0}.": {
            "code": 2064,
            "category": 1 /* Error */
        },
        "Return type of public method from exported class is using inaccessible module {0}.": {
            "code": 2065,
            "category": 1 /* Error */
        },
        "Return type of method from exported interface is using inaccessible module {0}.": {
            "code": 2066,
            "category": 1 /* Error */
        },
        "Return type of exported function is using inaccessible module {0}.": {
            "code": 2067,
            "category": 1 /* Error */
        },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": {
            "code": 2068,
            "category": 1 /* Error */
        },
        "A parameter list must follow a generic type argument list. '(' expected.": {
            "code": 2069,
            "category": 1 /* Error */
        },
        "Multiple constructor implementations are not allowed.": {
            "code": 2070,
            "category": 1 /* Error */
        },
        "Unable to resolve external module '{0}'.": {
            "code": 2071,
            "category": 1 /* Error */
        },
        "Module cannot be aliased to a non-module type.": {
            "code": 2072,
            "category": 1 /* Error */
        },
        "A class may only extend another class.": {
            "code": 2073,
            "category": 1 /* Error */
        },
        "A class may only implement another class or interface.": {
            "code": 2074,
            "category": 1 /* Error */
        },
        "An interface may only extend another class or interface.": {
            "code": 2075,
            "category": 1 /* Error */
        },
        "An interface cannot implement another type.": {
            "code": 2076,
            "category": 1 /* Error */
        },
        "Unable to resolve type.": {
            "code": 2077,
            "category": 1 /* Error */
        },
        "Unable to resolve type of '{0}'.": {
            "code": 2078,
            "category": 1 /* Error */
        },
        "Unable to resolve type parameter constraint.": {
            "code": 2079,
            "category": 1 /* Error */
        },
        "Type parameter constraint cannot be a primitive type.": {
            "code": 2080,
            "category": 1 /* Error */
        },
        "Supplied parameters do not match any signature of call target.": {
            "code": 2081,
            "category": 1 /* Error */
        },
        "Supplied parameters do not match any signature of call target:{NL}{0}": {
            "code": 2082,
            "category": 1 /* Error */
        },
        "Invalid 'new' expression.": {
            "code": 2083,
            "category": 1 /* Error */
        },
        "Call signatures used in a 'new' expression must have a 'void' return type.": {
            "code": 2084,
            "category": 1 /* Error */
        },
        "Could not select overload for 'new' expression.": {
            "code": 2085,
            "category": 1 /* Error */
        },
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": {
            "code": 2086,
            "category": 1 /* Error */
        },
        "Could not select overload for 'call' expression.": {
            "code": 2087,
            "category": 1 /* Error */
        },
        "Cannot invoke an expression whose type lacks a call signature.": {
            "code": 2088,
            "category": 1 /* Error */
        },
        "Calls to 'super' are only valid inside a class.": {
            "code": 2089,
            "category": 1 /* Error */
        },
        "Generic type '{0}' requires {1} type argument(s).": {
            "code": 2090,
            "category": 1 /* Error */
        },
        "Type of conditional expression cannot be determined . '{0}' is not identical to, a supertype of, or a subtype of '{1}'.": {
            "code": 2091,
            "category": 1 /* Error */
        },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": {
            "code": 2092,
            "category": 1 /* Error */
        },
        "Could not find enclosing symbol for dotted name '{0}'.": {
            "code": 2093,
            "category": 1 /* Error */
        },
        "The property '{0}' does not exist on value of type '{1}'.": {
            "code": 2094,
            "category": 1 /* Error */
        },
        "Could not find symbol '{0}'.": {
            "code": 2095,
            "category": 1 /* Error */
        },
        "'get' and 'set' accessor must have the same type.": {
            "code": 2096,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in current location.": {
            "code": 2097,
            "category": 1 /* Error */
        },
        "Static methods cannot reference class type parameters.": {
            "code": 2099,
            "category": 1 /* Error */
        },
        "Class '{0}' is recursively referenced as a base type of itself.": {
            "code": 2100,
            "category": 1 /* Error */
        },
        "Interface '{0}' is recursively referenced as a base type of itself.": {
            "code": 2101,
            "category": 1 /* Error */
        },
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": {
            "code": 2102,
            "category": 1 /* Error */
        },
        "'super' cannot be referenced in non-derived classes.": {
            "code": 2103,
            "category": 1 /* Error */
        },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": {
            "code": 2104,
            "category": 1 /* Error */
        },
        "Constructors for derived classes must contain a 'super' call.": {
            "code": 2105,
            "category": 1 /* Error */
        },
        "Super calls are not permitted outside constructors or in local functions inside constructors.": {
            "code": 2106,
            "category": 1 /* Error */
        },
        "'{0}.{1}' is inaccessible.": {
            "code": 2107,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced within module bodies.": {
            "code": 2108,
            "category": 1 /* Error */
        },
        "Invalid '+' expression - types not known to support the addition operator.": {
            "code": 2111,
            "category": 1 /* Error */
        },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2112,
            "category": 1 /* Error */
        },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2113,
            "category": 1 /* Error */
        },
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": {
            "code": 2114,
            "category": 1 /* Error */
        },
        "Variable declarations of a 'for' statement cannot use a type annotation.": {
            "code": 2115,
            "category": 1 /* Error */
        },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": {
            "code": 2116,
            "category": 1 /* Error */
        },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": {
            "code": 2117,
            "category": 1 /* Error */
        },
        "The left-hand side of an 'in' expression must be of types 'string' or 'any'.": {
            "code": 2118,
            "category": 1 /* Error */
        },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2119,
            "category": 1 /* Error */
        },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2120,
            "category": 1 /* Error */
        },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.": {
            "code": 2121,
            "category": 1 /* Error */
        },
        "Setters cannot return a value.": {
            "code": 2122,
            "category": 1 /* Error */
        },
        "Tried to query type of uninitialized module '{0}'.": {
            "code": 2123,
            "category": 1 /* Error */
        },
        "Tried to set variable type to uninitialized module type '{0}'.": {
            "code": 2124,
            "category": 1 /* Error */
        },
        "Function '{0}' declared a non-void return type, but has no return expression.": {
            "code": 2125,
            "category": 1 /* Error */
        },
        "Getters must return a value.": {
            "code": 2126,
            "category": 1 /* Error */
        },
        "Getter and setter accessors do not agree in visibility.": {
            "code": 2127,
            "category": 1 /* Error */
        },
        "Invalid left-hand side of assignment expression.": {
            "code": 2130,
            "category": 1 /* Error */
        },
        "Function declared a non-void return type, but has no return expression.": {
            "code": 2131,
            "category": 1 /* Error */
        },
        "Cannot resolve return type reference.": {
            "code": 2132,
            "category": 1 /* Error */
        },
        "Constructors cannot have a return type of 'void'.": {
            "code": 2133,
            "category": 1 /* Error */
        },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": {
            "code": 2134,
            "category": 1 /* Error */
        },
        "All symbols within a with block will be resolved to 'any'.": {
            "code": 2135,
            "category": 1 /* Error */
        },
        "Import declarations in an internal module cannot reference an external module.": {
            "code": 2136,
            "category": 1 /* Error */
        },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": {
            "code": 2137,
            "category": 1 /* Error */
        },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": {
            "code": 2138,
            "category": 1 /* Error */
        },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": {
            "code": 2139,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in static initializers in a class body.": {
            "code": 2140,
            "category": 1 /* Error */
        },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2141,
            "category": 1 /* Error */
        },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2142,
            "category": 1 /* Error */
        },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": {
            "code": 2143,
            "category": 1 /* Error */
        },
        "Duplicate overload signature for '{0}'.": {
            "code": 2144,
            "category": 1 /* Error */
        },
        "Duplicate constructor overload signature.": {
            "code": 2145,
            "category": 1 /* Error */
        },
        "Duplicate overload call signature.": {
            "code": 2146,
            "category": 1 /* Error */
        },
        "Duplicate overload construct signature.": {
            "code": 2147,
            "category": 1 /* Error */
        },
        "Overload signature is not compatible with function definition.": {
            "code": 2148,
            "category": 1 /* Error */
        },
        "Overload signature is not compatible with function definition:{NL}{0}": {
            "code": 2149,
            "category": 1 /* Error */
        },
        "Overload signatures must all be public or private.": {
            "code": 2150,
            "category": 1 /* Error */
        },
        "Overload signatures must all be exported or not exported.": {
            "code": 2151,
            "category": 1 /* Error */
        },
        "Overload signatures must all be ambient or non-ambient.": {
            "code": 2152,
            "category": 1 /* Error */
        },
        "Overload signatures must all be optional or required.": {
            "code": 2153,
            "category": 1 /* Error */
        },
        "Specialized overload signature is not subtype of any non-specialized signature.": {
            "code": 2154,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in constructor arguments.": {
            "code": 2155,
            "category": 1 /* Error */
        },
        "Static member cannot be accessed off an instance variable.": {
            "code": 2156,
            "category": 1 /* Error */
        },
        "Instance member cannot be accessed off a class.": {
            "code": 2157,
            "category": 1 /* Error */
        },
        "Untyped function calls may not accept type arguments.": {
            "code": 2158,
            "category": 1 /* Error */
        },
        "Non-generic functions may not accept type arguments.": {
            "code": 2159,
            "category": 1 /* Error */
        },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": {
            "code": 2160,
            "category": 1 /* Error */
        },
        "Rest parameters must be array types.": {
            "code": 2162,
            "category": 1 /* Error */
        },
        "Overload signature implementation cannot use specialized type.": {
            "code": 2163,
            "category": 1 /* Error */
        },
        "Export assignments may only be used at the top-level of external modules.": {
            "code": 2164,
            "category": 1 /* Error */
        },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": 2165,
            "category": 1 /* Error */
        },
        "Only public methods of the base class are accessible via the 'super' keyword.": {
            "code": 2166,
            "category": 1 /* Error */
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.": {
            "code": 2167,
            "category": 1 /* Error */
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}": {
            "code": 2168,
            "category": 1 /* Error */
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}'.": {
            "code": 2169,
            "category": 1 /* Error */
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}": {
            "code": 2170,
            "category": 1 /* Error */
        },
        "All named properties must be subtypes of string indexer type '{0}'.": {
            "code": 2171,
            "category": 1 /* Error */
        },
        "All named properties must be subtypes of string indexer type '{0}':{NL}{1}": {
            "code": 2172,
            "category": 1 /* Error */
        },
        "Generic type references must include all type arguments.": {
            "code": 2173,
            "category": 1 /* Error */
        },
        "Default arguments are not allowed in an overload parameter.": {
            "code": 2174,
            "category": 1 /* Error */
        },
        "Overloads cannot differ only by return type.": {
            "code": 2175,
            "category": 1 /* Error */
        },
        "Function expression declared a non-void return type, but has no return expression.": {
            "code": 2176,
            "category": 1 /* Error */
        },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": 2177,
            "category": 1 /* Error */
        },
        "Could not find symbol '{0}' in module '{1}'.": {
            "code": 2178,
            "category": 1 /* Error */
        },
        "Unable to resolve module reference '{0}'.": {
            "code": 2179,
            "category": 1 /* Error */
        },
        "Could not find module '{0}' in module '{1}'.": {
            "code": 2180,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": {
            "code": 2181,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": {
            "code": 2182,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": {
            "code": 2183,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": {
            "code": 2184,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": {
            "code": 2185,
            "category": 1 /* Error */
        },
        "Type reference '{0}' in extends clause doesn't reference constructor function for '{1}'.": {
            "code": 2186,
            "category": 1 /* Error */
        },
        "Internal module reference '{0}' in import declaration doesn't reference module instance for '{1}'.": {
            "code": 2187,
            "category": 1 /* Error */
        },
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": {
            "code": 2188,
            "category": 1 /* Error */
        },
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}Types of property '{3}' of types '{1}' and '{2}' are not identical.": {
            "code": 2189,
            "category": 1 /* Error */
        },
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": {
            "code": 2190,
            "category": 1 /* Error */
        },
        "Ambient external module declaration cannot be reopened.": {
            "code": 2191,
            "category": 1 /* Error */
        },
        "All declarations of merged declaration '{0}' must be exported or not exported.": {
            "code": 2192,
            "category": 1 /* Error */
        },
        "'super' cannot be referenced in constructor arguments.": {
            "code": 2193,
            "category": 1 /* Error */
        },
        "Return type of constructor signature must be assignable to the instance type of the class.": {
            "code": 2194,
            "category": 1 /* Error */
        },
        "Ambient external module declaration must be defined in global context.": {
            "code": 2195,
            "category": 1 /* Error */
        },
        "Ambient external module declaration cannot specify relative module name.": {
            "code": 2196,
            "category": 1 /* Error */
        },
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": {
            "code": 2197,
            "category": 1 /* Error */
        },
        "Could not find the best common type of types of all return statement expressions.": {
            "code": 2198,
            "category": 1 /* Error */
        },
        "Import declaration cannot refer to external module reference when --noResolve option is set.": {
            "code": 2199,
            "category": 1 /* Error */
        },
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": {
            "code": 2200,
            "category": 1 /* Error */
        },
        "'continue' statement can only be used within an enclosing iteration statement.": {
            "code": 2201,
            "category": 1 /* Error */
        },
        "'break' statement can only be used within an enclosing iteration or switch statement.": {
            "code": 2202,
            "category": 1 /* Error */
        },
        "Jump target not found.": {
            "code": 2203,
            "category": 1 /* Error */
        },
        "Jump target cannot cross function boundary.": {
            "code": 2204,
            "category": 1 /* Error */
        },
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": {
            "code": 2205,
            "category": 1 /* Error */
        },
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": {
            "code": 2206,
            "category": 1 /* Error */
        },
        "Expression resolves to '_super' that compiler uses to capture base class reference.": {
            "code": 2207,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": 2208,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": 2209,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": 2210,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": 2211,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": 2212,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": 2213,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": 2214,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": 2215,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": 2216,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": 2217,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": 2218,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": 2219,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2220,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": {
            "code": 2221,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2222,
            "category": 1 /* Error */
        },
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": {
            "code": 2223,
            "category": 1 /* Error */
        },
        "Type '{0}' is missing property '{1}' from type '{2}'.": {
            "code": 4000,
            "category": 3 /* NoPrefix */
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": {
            "code": 4001,
            "category": 3 /* NoPrefix */
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": {
            "code": 4002,
            "category": 3 /* NoPrefix */
        },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": {
            "code": 4003,
            "category": 3 /* NoPrefix */
        },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": {
            "code": 4004,
            "category": 3 /* NoPrefix */
        },
        "Types '{0}' and '{1}' define property '{2}' as private.": {
            "code": 4005,
            "category": 3 /* NoPrefix */
        },
        "Call signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4006,
            "category": 3 /* NoPrefix */
        },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4007,
            "category": 3 /* NoPrefix */
        },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": {
            "code": 4008,
            "category": 3 /* NoPrefix */
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4009,
            "category": 3 /* NoPrefix */
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4010,
            "category": 3 /* NoPrefix */
        },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": {
            "code": 4011,
            "category": 3 /* NoPrefix */
        },
        "Index signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4012,
            "category": 3 /* NoPrefix */
        },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4013,
            "category": 3 /* NoPrefix */
        },
        "Call signature expects {0} or fewer parameters.": {
            "code": 4014,
            "category": 3 /* NoPrefix */
        },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": {
            "code": 4015,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4016,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4017,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": {
            "code": 4018,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": {
            "code": 4019,
            "category": 3 /* NoPrefix */
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": {
            "code": 4020,
            "category": 3 /* NoPrefix */
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": {
            "code": 4021,
            "category": 3 /* NoPrefix */
        },
        "Type reference cannot refer to container '{0}'.": {
            "code": 4022,
            "category": 1 /* Error */
        },
        "Type reference must refer to type.": {
            "code": 4023,
            "category": 1 /* Error */
        },
        "Enums with multiple declarations must provide an initializer for the first enum element.": {
            "code": 4024,
            "category": 1 /* Error */
        },
        " (+ {0} overload(s))": {
            "code": 4025,
            "category": 2 /* Message */
        },
        "Variable declaration cannot have the same name as an import declaration.": {
            "code": 4026,
            "category": 1 /* Error */
        },
        "Signature expected {0} type arguments, got {1} instead.": {
            "code": 4027,
            "category": 1 /* Error */
        },
        "Current host does not support '{0}' option.": {
            "code": 5001,
            "category": 1 /* Error */
        },
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": {
            "code": 5002,
            "category": 1 /* Error */
        },
        "Module code generation '{0}' not supported.": {
            "code": 5003,
            "category": 1 /* Error */
        },
        "Could not find file: '{0}'.": {
            "code": 5004,
            "category": 1 /* Error */
        },
        "A file cannot have a reference to itself.": {
            "code": 5006,
            "category": 1 /* Error */
        },
        "Cannot resolve referenced file: '{0}'.": {
            "code": 5007,
            "category": 1 /* Error */
        },
        "Cannot find the common subdirectory path for the input files.": {
            "code": 5009,
            "category": 1 /* Error */
        },
        "Emit Error: {0}.": {
            "code": 5011,
            "category": 1 /* Error */
        },
        "Cannot read file '{0}': {1}": {
            "code": 5012,
            "category": 1 /* Error */
        },
        "Unsupported file encoding.": {
            "code": 5013,
            "category": 3 /* NoPrefix */
        },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": {
            "code": 5014,
            "category": 1 /* Error */
        },
        "Unsupported locale: '{0}'.": {
            "code": 5015,
            "category": 1 /* Error */
        },
        "Execution Failed.{NL}": {
            "code": 5016,
            "category": 1 /* Error */
        },
        "Should not emit a type query.": {
            "code": 5017,
            "category": 1 /* Error */
        },
        "Should not emit a type reference.": {
            "code": 5018,
            "category": 1 /* Error */
        },
        "Invalid call to 'up'": {
            "code": 5019,
            "category": 1 /* Error */
        },
        "Invalid call to 'down'": {
            "code": 5020,
            "category": 1 /* Error */
        },
        "Base64 value '{0}' finished with a continuation bit.": {
            "code": 5021,
            "category": 1 /* Error */
        },
        "Key was already in table.": {
            "code": 5022,
            "category": 1 /* Error */
        },
        "Unknown option '{0}'": {
            "code": 5023,
            "category": 1 /* Error */
        },
        "Expected {0} arguments to message, got {1} instead.": {
            "code": 5024,
            "category": 1 /* Error */
        },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": {
            "code": 5025,
            "category": 1 /* Error */
        },
        "Invalid argument: {0}. {1}": {
            "code": 5026,
            "category": 1 /* Error */
        },
        "Invalid argument: {0}.": {
            "code": 5027,
            "category": 1 /* Error */
        },
        "Argument out of range: {0}.": {
            "code": 5028,
            "category": 1 /* Error */
        },
        "Argument null: {0}.": {
            "code": 5029,
            "category": 1 /* Error */
        },
        "Operation not implemented properly by subclass.": {
            "code": 5030,
            "category": 1 /* Error */
        },
        "Not yet implemented.": {
            "code": 5031,
            "category": 1 /* Error */
        },
        "Invalid operation: {0}": {
            "code": 5032,
            "category": 1 /* Error */
        },
        "Invalid operation.": {
            "code": 5033,
            "category": 1 /* Error */
        },
        "Could not delete file '{0}'": {
            "code": 5034,
            "category": 1 /* Error */
        },
        "Could not create directory '{0}'": {
            "code": 5035,
            "category": 1 /* Error */
        },
        "Error while executing file '{0}': ": {
            "code": 5036,
            "category": 1 /* Error */
        },
        "Cannot compile external modules unless the '--module' flag is provided.": {
            "code": 5037,
            "category": 1 /* Error */
        },
        "Option mapRoot cannot be specified without specifying sourcemap option.": {
            "code": 5038,
            "category": 1 /* Error */
        },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5039,
            "category": 1 /* Error */
        },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5040,
            "category": 1 /* Error */
        },
        "Option '{0}' specified without '{1}'": {
            "code": 5041,
            "category": 1 /* Error */
        },
        "'codepage' option not supported on current platform.": {
            "code": 5042,
            "category": 1 /* Error */
        },
        "Concatenate and emit output to single file.": {
            "code": 6001,
            "category": 2 /* Message */
        },
        "Generates corresponding {0} file.": {
            "code": 6002,
            "category": 2 /* Message */
        },
        "Specifies the location where debugger should locate map files instead of generated locations.": {
            "code": 6003,
            "category": 2 /* Message */
        },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": {
            "code": 6004,
            "category": 2 /* Message */
        },
        "Watch input files.": {
            "code": 6005,
            "category": 2 /* Message */
        },
        "Redirect output structure to the directory.": {
            "code": 6006,
            "category": 2 /* Message */
        },
        "Do not emit comments to output.": {
            "code": 6009,
            "category": 2 /* Message */
        },
        "Skip resolution and preprocessing.": {
            "code": 6010,
            "category": 2 /* Message */
        },
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": {
            "code": 6015,
            "category": 2 /* Message */
        },
        "Specify module code generation: '{0}' or '{1}'": {
            "code": 6016,
            "category": 2 /* Message */
        },
        "Print this message.": {
            "code": 6017,
            "category": 2 /* Message */
        },
        "Print the compiler's version: {0}": {
            "code": 6019,
            "category": 2 /* Message */
        },
        "Allow use of deprecated '{0}' keyword when referencing an external module.": {
            "code": 6021,
            "category": 2 /* Message */
        },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": {
            "code": 6022,
            "category": 2 /* Message */
        },
        "Syntax:   {0}": {
            "code": 6023,
            "category": 2 /* Message */
        },
        "options": {
            "code": 6024,
            "category": 2 /* Message */
        },
        "file1": {
            "code": 6025,
            "category": 2 /* Message */
        },
        "Examples:": {
            "code": 6026,
            "category": 2 /* Message */
        },
        "Options:": {
            "code": 6027,
            "category": 2 /* Message */
        },
        "Insert command line options and files from a file.": {
            "code": 6030,
            "category": 2 /* Message */
        },
        "Version {0}": {
            "code": 6029,
            "category": 2 /* Message */
        },
        "Use the '{0}' flag to see options.": {
            "code": 6031,
            "category": 2 /* Message */
        },
        "{NL}Recompiling ({0}):": {
            "code": 6032,
            "category": 2 /* Message */
        },
        "STRING": {
            "code": 6033,
            "category": 2 /* Message */
        },
        "KIND": {
            "code": 6034,
            "category": 2 /* Message */
        },
        "file2": {
            "code": 6035,
            "category": 2 /* Message */
        },
        "VERSION": {
            "code": 6036,
            "category": 2 /* Message */
        },
        "LOCATION": {
            "code": 6037,
            "category": 2 /* Message */
        },
        "DIRECTORY": {
            "code": 6038,
            "category": 2 /* Message */
        },
        "NUMBER": {
            "code": 6039,
            "category": 2 /* Message */
        },
        "Specify the codepage to use when opening source files.": {
            "code": 6040,
            "category": 2 /* Message */
        },
        "This version of the Javascript runtime does not support the '{0}' function.": {
            "code": 7000,
            "category": 1 /* Error */
        },
        "Looking up path for identifier token did not result in an identifer.": {
            "code": 7001,
            "category": 1 /* Error */
        },
        "Unknown rule.": {
            "code": 7002,
            "category": 1 /* Error */
        },
        "Invalid line number ({0})": {
            "code": 7003,
            "category": 1 /* Error */
        },
        "Warn on expressions and declarations with an implied 'any' type.": {
            "code": 7004,
            "category": 2 /* Message */
        },
        "Variable '{0}' implicitly has an 'any' type.": {
            "code": 7005,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": {
            "code": 7006,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of function type implicitly has an 'any' type.": {
            "code": 7007,
            "category": 1 /* Error */
        },
        "Member '{0}' of object type implicitly has an 'any' type.": {
            "code": 7008,
            "category": 1 /* Error */
        },
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": {
            "code": 7009,
            "category": 1 /* Error */
        },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7010,
            "category": 1 /* Error */
        },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7011,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": {
            "code": 7012,
            "category": 1 /* Error */
        },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7013,
            "category": 1 /* Error */
        },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7014,
            "category": 1 /* Error */
        },
        "Array Literal implicitly has an 'any' type from widening.": {
            "code": 7015,
            "category": 1 /* Error */
        }
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";

        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";

        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";

        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";

        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";

        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";

        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";

        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";

        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";

        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    

    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };

            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };

            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                return TypeScript.TextUtilities.parseLineStarts(TypeScript.SimpleText.fromString(this.text));
            };

            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();

        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
    var ScriptSnapshot = TypeScript.ScriptSnapshot;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_lineStarts, length) {
            this._lineStarts = _lineStarts;
            this.length = length;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this._lineStarts, length: this.length };
        };

        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) {
                return v1 === v2;
            });
        };

        LineMap.prototype.lineStarts = function () {
            return this._lineStarts;
        };

        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };

        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };

        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                return this.lineCount() - 1;
            }

            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        };

        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };

        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };

        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };

        LineMap.fromSimpleText = function (text) {
            var lineStarts = TypeScript.TextUtilities.parseLineStarts(text);

            return new LineMap(lineStarts, text.length());
        };

        LineMap.fromScriptSnapshot = function (scriptSnapshot) {
            return new LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        };

        LineMap.fromString = function (text) {
            return LineMap.fromSimpleText(TypeScript.SimpleText.fromString(text));
        };
        LineMap.empty = new LineMap([0], 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };

        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    (function (TextFactory) {
        function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
            var c = text.charCodeAt(index);
            if (c === 10 /* lineFeed */) {
                if (index > 0 && text.charCodeAt(index - 1) === 13 /* carriageReturn */) {
                    info.startPosition = index - 1;
                    info.length = 2;
                } else {
                    info.startPosition = index;
                    info.length = 1;
                }
            } else if (TypeScript.TextUtilities.isAnyLineBreakCharacter(c)) {
                info.startPosition = index;
                info.length = 1;
            } else {
                info.startPosition = index + 1;
                info.length = 0;
            }
        }

        var LinebreakInfo = (function () {
            function LinebreakInfo(startPosition, length) {
                this.startPosition = startPosition;
                this.length = length;
            }
            return LinebreakInfo;
        })();

        var TextLine = (function () {
            function TextLine(text, body, lineBreakLength, lineNumber) {
                this._text = null;
                this._textSpan = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull('text');
                }
                TypeScript.Debug.assert(lineBreakLength >= 0);
                TypeScript.Debug.assert(lineNumber >= 0);
                this._text = text;
                this._textSpan = body;
                this._lineBreakLength = lineBreakLength;
                this._lineNumber = lineNumber;
            }
            TextLine.prototype.start = function () {
                return this._textSpan.start();
            };

            TextLine.prototype.end = function () {
                return this._textSpan.end();
            };

            TextLine.prototype.endIncludingLineBreak = function () {
                return this.end() + this._lineBreakLength;
            };

            TextLine.prototype.extent = function () {
                return this._textSpan;
            };

            TextLine.prototype.extentIncludingLineBreak = function () {
                return TypeScript.TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
            };

            TextLine.prototype.toString = function () {
                return this._text.toString(this._textSpan);
            };

            TextLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            return TextLine;
        })();

        var TextBase = (function () {
            function TextBase() {
                this.lazyLineStarts = null;
                this.linebreakInfo = new LinebreakInfo(0, 0);
                this.lastLineFoundForPosition = null;
            }
            TextBase.prototype.length = function () {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.charCodeAt = function (position) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            TextBase.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this, span);
            };

            TextBase.prototype.substr = function (start, length, intern) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.lineCount = function () {
                return this.lineStarts().length;
            };

            TextBase.prototype.lines = function () {
                var lines = [];

                var length = this.lineCount();
                for (var i = 0; i < length; ++i) {
                    lines[i] = this.getLineFromLineNumber(i);
                }

                return lines;
            };

            TextBase.prototype.lineMap = function () {
                return new TypeScript.LineMap(this.lineStarts(), this.length());
            };

            TextBase.prototype.lineStarts = function () {
                if (this.lazyLineStarts === null) {
                    this.lazyLineStarts = TypeScript.TextUtilities.parseLineStarts(this);
                }

                return this.lazyLineStarts;
            };

            TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
                var lineStarts = this.lineStarts();

                if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                    throw TypeScript.Errors.argumentOutOfRange("lineNumber");
                }

                var first = lineStarts[lineNumber];
                if (lineNumber === lineStarts.length - 1) {
                    return new TextLine(this, new TypeScript.TextSpan(first, this.length() - first), 0, lineNumber);
                } else {
                    getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                    return new TextLine(this, new TypeScript.TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
                }
            };

            TextBase.prototype.getLineFromPosition = function (position) {
                var lastFound = this.lastLineFoundForPosition;
                if (lastFound !== null && lastFound.start() <= position && lastFound.endIncludingLineBreak() > position) {
                    return lastFound;
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                var result = this.getLineFromLineNumber(lineNumber);
                this.lastLineFoundForPosition = result;
                return result;
            };

            TextBase.prototype.getLineNumberFromPosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                if (position === this.length()) {
                    return this.lineCount() - 1;
                }

                var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
                if (lineNumber < 0) {
                    lineNumber = (~lineNumber) - 1;
                }

                return lineNumber;
            };

            TextBase.prototype.getLinePosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
            };
            return TextBase;
        })();

        var SubText = (function (_super) {
            __extends(SubText, _super);
            function SubText(text, span) {
                _super.call(this);

                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SubText.prototype.length = function () {
                return this.span.length();
            };

            SubText.prototype.charCodeAt = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.text.charCodeAt(this.span.start() + position);
            };

            SubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            return SubText;
        })(TextBase);

        var StringText = (function (_super) {
            __extends(StringText, _super);
            function StringText(data) {
                _super.call(this);
                this.source = null;

                if (data === null) {
                    throw TypeScript.Errors.argumentNull("data");
                }

                this.source = data;
            }
            StringText.prototype.length = function () {
                return this.source.length;
            };

            StringText.prototype.charCodeAt = function (position) {
                if (position < 0 || position >= this.source.length) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.source.charCodeAt(position);
            };

            StringText.prototype.substr = function (start, length, intern) {
                return this.source.substr(start, length);
            };

            StringText.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                if (span === null) {
                    span = new TypeScript.TextSpan(0, this.length());
                }

                this.checkSubSpan(span);

                if (span.start() === 0 && span.length() === this.length()) {
                    return this.source;
                }

                return this.source.substr(span.start(), span.length());
            };

            StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
            };
            return StringText;
        })(TextBase);

        function createText(value) {
            return new StringText(value);
        }
        TextFactory.createText = createText;
    })(TypeScript.TextFactory || (TypeScript.TextFactory = {}));
    var TextFactory = TypeScript.TextFactory;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (SimpleText) {
        var SimpleSubText = (function () {
            function SimpleSubText(text, span) {
                this.text = null;
                this.span = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SimpleSubText.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            SimpleSubText.prototype.checkSubPosition = function (position) {
                if (position < 0 || position >= this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
            };

            SimpleSubText.prototype.length = function () {
                return this.span.length();
            };

            SimpleSubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SimpleSubText.prototype.substr = function (start, length, intern) {
                var span = this.getCompositeSpan(start, length);
                return this.text.substr(span.start(), span.length(), intern);
            };

            SimpleSubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };

            SimpleSubText.prototype.charCodeAt = function (index) {
                this.checkSubPosition(index);
                return this.text.charCodeAt(this.span.start() + index);
            };

            SimpleSubText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            return SimpleSubText;
        })();

        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };

            SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
            };

            SimpleStringText.prototype.substr = function (start, length, intern) {
                if (intern) {
                    var array = length <= SimpleStringText.charArray.length ? SimpleStringText.charArray : TypeScript.ArrayUtilities.createArray(length, 0);
                    this.copyTo(start, array, 0, length);
                    return TypeScript.Collections.DefaultStringTable.addCharArray(array, 0, length);
                }

                return this.value.substr(start, length);
            };

            SimpleStringText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };

            SimpleStringText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            SimpleStringText.charArray = TypeScript.ArrayUtilities.createArray(1024, 0);
            return SimpleStringText;
        })();

        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };

            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };

            SimpleScriptSnapshotText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
                TypeScript.StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
            };

            SimpleScriptSnapshotText.prototype.substr = function (start, length, intern) {
                return this.scriptSnapshot.getText(start, start + length);
            };

            SimpleScriptSnapshotText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var lineStartPositions = this.scriptSnapshot.getLineStartPositions();
                return new TypeScript.LineMap(lineStartPositions, this.length());
            };
            return SimpleScriptSnapshotText;
        })();

        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;

        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(TypeScript.SimpleText || (TypeScript.SimpleText = {}));
    var SimpleText = TypeScript.SimpleText;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length();

            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }

            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;

            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;

                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                } else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                } else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }

                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }

            arrayBuilder.push(position);

            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;

        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length()) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            } else if (isAnyLineBreakCharacter(c)) {
                return 1;
            } else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;

        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);

            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }

            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;

        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
    var TextUtilities = TypeScript.TextUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }

            if (length < 0) {
                TypeScript.Errors.argument("length");
            }

            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };

        TextSpan.prototype.length = function () {
            return this._length;
        };

        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };

        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };

        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };

        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };

        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        };

        TextSpan.prototype.overlap = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        };

        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };

        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };

        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };

        TextSpan.prototype.intersection = function (span) {
            var intersectStart = TypeScript.MathPrototype.max(this._start, span._start);
            var intersectEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        };

        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.prototype.span = function () {
            return this._span;
        };

        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };

        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };

        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };

        TextChangeRange.collapseChangesFromSingleVersion = function (changes) {
            var diff = 0;
            var start = 1073741823 /* Max31BitInteger */;
            var end = 0;

            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();

                if (change.span().start() < start) {
                    start = change.span().start();
                }

                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }

            if (start > end) {
                return null;
            }

            var combined = TypeScript.TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;

            return new TextChangeRange(combined, newLen);
        };

        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length === 1) {
                return changes[0];
            }

            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = TypeScript.MathPrototype.min(oldStart1, oldStart2);
                oldEndN = TypeScript.MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = TypeScript.MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterInfo = (function () {
        function CharacterInfo() {
        }
        CharacterInfo.isDecimalDigit = function (c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        };
        CharacterInfo.isOctalDigit = function (c) {
            return c >= 48 /* _0 */ && c <= 55 /* _7 */;
        };

        CharacterInfo.isHexDigit = function (c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        };

        CharacterInfo.hexValue = function (c) {
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        };

        CharacterInfo.isWhitespace = function (ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:

                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }

            return false;
        };

        CharacterInfo.isLineTerminator = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }

            return false;
        };
        return CharacterInfo;
    })();
    TypeScript.CharacterInfo = CharacterInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["TriviaNewLineMask"] = 0x00000001] = "TriviaNewLineMask";
        SyntaxConstants[SyntaxConstants["TriviaCommentMask"] = 0x00000002] = "TriviaCommentMask";
        SyntaxConstants[SyntaxConstants["TriviaFullWidthShift"] = 2] = "TriviaFullWidthShift";

        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";

        SyntaxConstants[SyntaxConstants["IsVariableWidthKeyword"] = 1 << 31] = "IsVariableWidthKeyword";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
var FormattingOptions = (function () {
    function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
        this.useTabs = useTabs;
        this.spacesPerTab = spacesPerTab;
        this.indentSpaces = indentSpaces;
        this.newLineCharacter = newLineCharacter;
    }
    FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
    return FormattingOptions;
})();
var TypeScript;
(function (TypeScript) {
    (function (Indentation) {
        function columnForEndOfToken(token, syntaxInformationMap, options) {
            return columnForStartOfToken(token, syntaxInformationMap, options) + token.width();
        }
        Indentation.columnForEndOfToken = columnForEndOfToken;

        function columnForStartOfToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            var current = token;
            while (current !== firstTokenInLine) {
                current = syntaxInformationMap.previousToken(current);

                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                } else {
                    leadingTextInReverse.push(current.fullText());
                }
            }

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfToken = columnForStartOfToken;

        function columnForStartOfFirstTokenInLineContainingToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingToken = columnForStartOfFirstTokenInLineContainingToken;

        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();

            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    break;
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));

                    if (lineSegments.length > 0) {
                        break;
                    }
                }

                leadingTextInReverse.push(trivia.fullText());
            }
        }

        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;

            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }

            return column;
        }

        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;

        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;

            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);

                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                } else {
                    column++;
                }
            }

            return column;
        }

        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = TypeScript.MathPrototype.max(0, column);

            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }

            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;

        function indentationTrivia(column, options) {
            return TypeScript.Syntax.whitespace(this.indentationString(column, options));
        }
        Indentation.indentationTrivia = indentationTrivia;

        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }

            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(TypeScript.Indentation || (TypeScript.Indentation = {}));
    var Indentation = TypeScript.Indentation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
    var LanguageVersion = TypeScript.LanguageVersion;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ParseOptions = (function () {
        function ParseOptions(languageVersion, allowAutomaticSemicolonInsertion) {
            this._languageVersion = languageVersion;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
        }
        ParseOptions.prototype.toJSON = function (key) {
            return { allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion };
        };

        ParseOptions.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };
        return ParseOptions;
    })();
    TypeScript.ParseOptions = ParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionedElement = (function () {
        function PositionedElement(parent, element, fullStart) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }
        PositionedElement.create = function (parent, element, fullStart) {
            if (element === null) {
                return null;
            }

            if (element.isNode()) {
                return new PositionedNode(parent, element, fullStart);
            } else if (element.isToken()) {
                return new PositionedToken(parent, element, fullStart);
            } else if (element.isList()) {
                return new PositionedList(parent, element, fullStart);
            } else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, element, fullStart);
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        };

        PositionedElement.prototype.parent = function () {
            return this._parent;
        };

        PositionedElement.prototype.parentElement = function () {
            return this._parent && this._parent._element;
        };

        PositionedElement.prototype.element = function () {
            return this._element;
        };

        PositionedElement.prototype.kind = function () {
            return this.element().kind();
        };

        PositionedElement.prototype.childIndex = function (child) {
            return TypeScript.Syntax.childIndex(this.element(), child);
        };

        PositionedElement.prototype.childCount = function () {
            return this.element().childCount();
        };

        PositionedElement.prototype.childAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            return PositionedElement.create(this, this.element().childAt(index), this.fullStart() + offset);
        };

        PositionedElement.prototype.childStart = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEnd = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.childStartAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEndAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.getPositionedChild = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return PositionedElement.create(this, child, this.fullStart() + offset);
        };

        PositionedElement.prototype.fullStart = function () {
            return this._fullStart;
        };

        PositionedElement.prototype.fullEnd = function () {
            return this.fullStart() + this.element().fullWidth();
        };

        PositionedElement.prototype.fullWidth = function () {
            return this.element().fullWidth();
        };

        PositionedElement.prototype.start = function () {
            return this.fullStart() + this.element().leadingTriviaWidth();
        };

        PositionedElement.prototype.end = function () {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        };

        PositionedElement.prototype.root = function () {
            var current = this;
            while (current.parent() !== null) {
                current = current.parent();
            }

            return current;
        };

        PositionedElement.prototype.containingNode = function () {
            var current = this.parent();

            while (current !== null && !current.element().isNode()) {
                current = current.parent();
            }

            return current;
        };
        return PositionedElement;
    })();
    TypeScript.PositionedElement = PositionedElement;

    var PositionedNodeOrToken = (function (_super) {
        __extends(PositionedNodeOrToken, _super);
        function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
            _super.call(this, parent, nodeOrToken, fullStart);
        }
        PositionedNodeOrToken.prototype.nodeOrToken = function () {
            return this.element();
        };
        return PositionedNodeOrToken;
    })(PositionedElement);
    TypeScript.PositionedNodeOrToken = PositionedNodeOrToken;

    var PositionedNode = (function (_super) {
        __extends(PositionedNode, _super);
        function PositionedNode(parent, node, fullStart) {
            _super.call(this, parent, node, fullStart);
        }
        PositionedNode.prototype.node = function () {
            return this.element();
        };
        return PositionedNode;
    })(PositionedNodeOrToken);
    TypeScript.PositionedNode = PositionedNode;

    var PositionedToken = (function (_super) {
        __extends(PositionedToken, _super);
        function PositionedToken(parent, token, fullStart) {
            _super.call(this, parent, token, fullStart);
        }
        PositionedToken.prototype.token = function () {
            return this.element();
        };

        PositionedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var triviaList = this.token().leadingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = this.start();
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), currentTriviaEndPosition - trivia.fullWidth());
                    }

                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }

            var start = this.fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            var triviaList = this.token().trailingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var fullStart = this.end();
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), fullStart);
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return this.root().node().findToken(this.fullEnd(), includeSkippedTokens);
        };
        return PositionedToken;
    })(PositionedNodeOrToken);
    TypeScript.PositionedToken = PositionedToken;

    var PositionedList = (function (_super) {
        __extends(PositionedList, _super);
        function PositionedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedList.prototype.list = function () {
            return this.element();
        };
        return PositionedList;
    })(PositionedElement);
    TypeScript.PositionedList = PositionedList;

    var PositionedSeparatedList = (function (_super) {
        __extends(PositionedSeparatedList, _super);
        function PositionedSeparatedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedSeparatedList.prototype.list = function () {
            return this.element();
        };
        return PositionedSeparatedList;
    })(PositionedElement);
    TypeScript.PositionedSeparatedList = PositionedSeparatedList;

    var PositionedSkippedToken = (function (_super) {
        __extends(PositionedSkippedToken, _super);
        function PositionedSkippedToken(parentToken, token, fullStart) {
            _super.call(this, parentToken.parent(), token, fullStart);
            this._parentToken = parentToken;
        }
        PositionedSkippedToken.prototype.parentToken = function () {
            return this._parentToken;
        };

        PositionedSkippedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var start = this.fullStart();

            if (includeSkippedTokens) {
                var previousToken;

                if (start >= this.parentToken().end()) {
                    previousToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }

                    return this.parentToken();
                } else {
                    previousToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }
                }
            }

            var start = this.parentToken().fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedSkippedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            if (includeSkippedTokens) {
                var end = this.end();
                var nextToken;

                if (end <= this.parentToken().start()) {
                    nextToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }

                    return this.parentToken();
                } else {
                    nextToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }
                }
            }

            return this.root().node().findToken(this.parentToken().fullEnd(), includeSkippedTokens);
        };
        return PositionedSkippedToken;
    })(PositionedToken);
    TypeScript.PositionedSkippedToken = PositionedSkippedToken;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";

        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";

        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";

        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";

        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";

        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";

        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";

        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";

        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 62] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 63] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 64] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 65] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 66] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 67] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 68] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 69] = "StringKeyword";

        SyntaxKind[SyntaxKind["OpenBraceToken"] = 70] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 71] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 72] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 73] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 74] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 75] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 76] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 77] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 78] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 79] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 80] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 81] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 82] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 83] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 84] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 85] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 86] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 87] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 88] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 89] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 90] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 91] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 92] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 93] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 94] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 95] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 96] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 98] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 99] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 100] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 101] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 102] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 103] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 104] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 105] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 106] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 107] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 108] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 109] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 110] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 111] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 112] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 115] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 116] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 117] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 118] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 119] = "SlashEqualsToken";

        SyntaxKind[SyntaxKind["SourceUnit"] = 120] = "SourceUnit";

        SyntaxKind[SyntaxKind["QualifiedName"] = 121] = "QualifiedName";

        SyntaxKind[SyntaxKind["ObjectType"] = 122] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 123] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 124] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 125] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 126] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 127] = "TypeQuery";

        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 128] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 129] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 130] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 131] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 132] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 133] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 134] = "ExportAssignment";

        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 135] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 136] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 137] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["GetMemberAccessorDeclaration"] = 138] = "GetMemberAccessorDeclaration";
        SyntaxKind[SyntaxKind["SetMemberAccessorDeclaration"] = 139] = "SetMemberAccessorDeclaration";
        SyntaxKind[SyntaxKind["IndexMemberDeclaration"] = 140] = "IndexMemberDeclaration";

        SyntaxKind[SyntaxKind["PropertySignature"] = 141] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 142] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 143] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 144] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 145] = "MethodSignature";

        SyntaxKind[SyntaxKind["Block"] = 146] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 147] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 148] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 149] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 150] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 151] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 152] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 153] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 154] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 155] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 156] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 157] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 158] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 159] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 160] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 161] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 162] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 163] = "WithStatement";

        SyntaxKind[SyntaxKind["PlusExpression"] = 164] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 165] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 166] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 167] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 168] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 169] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 170] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 171] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 172] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 173] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 174] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 175] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 176] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 177] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 178] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 179] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 180] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 181] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 182] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 183] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 184] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 185] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 186] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 187] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 188] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 189] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 190] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 191] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 192] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 193] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 194] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 195] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 196] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 197] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 198] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 199] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 200] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 201] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 202] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 203] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 204] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 205] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 206] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 207] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 208] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 209] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 210] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 211] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 212] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 213] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 214] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 215] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 216] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 217] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 218] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 219] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 220] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 221] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 222] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 223] = "OmittedExpression";

        SyntaxKind[SyntaxKind["VariableDeclaration"] = 224] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 225] = "VariableDeclarator";

        SyntaxKind[SyntaxKind["ArgumentList"] = 226] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 227] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 228] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 229] = "TypeParameterList";

        SyntaxKind[SyntaxKind["HeritageClause"] = 230] = "HeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 231] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 232] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 233] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 234] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 235] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 236] = "FinallyClause";

        SyntaxKind[SyntaxKind["TypeParameter"] = 237] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 238] = "Constraint";

        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 239] = "SimplePropertyAssignment";
        SyntaxKind[SyntaxKind["GetAccessorPropertyAssignment"] = 240] = "GetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["SetAccessorPropertyAssignment"] = 241] = "SetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 242] = "FunctionPropertyAssignment";

        SyntaxKind[SyntaxKind["Parameter"] = 243] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 244] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 245] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 246] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 247] = "ModuleNameModuleReference";

        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";

        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";

        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";

        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";

        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";

        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 60 /* AnyKeyword */,
            "boolean": 61 /* BooleanKeyword */,
            "break": 15 /* BreakKeyword */,
            "case": 16 /* CaseKeyword */,
            "catch": 17 /* CatchKeyword */,
            "class": 44 /* ClassKeyword */,
            "continue": 18 /* ContinueKeyword */,
            "const": 45 /* ConstKeyword */,
            "constructor": 62 /* ConstructorKeyword */,
            "debugger": 19 /* DebuggerKeyword */,
            "declare": 63 /* DeclareKeyword */,
            "default": 20 /* DefaultKeyword */,
            "delete": 21 /* DeleteKeyword */,
            "do": 22 /* DoKeyword */,
            "else": 23 /* ElseKeyword */,
            "enum": 46 /* EnumKeyword */,
            "export": 47 /* ExportKeyword */,
            "extends": 48 /* ExtendsKeyword */,
            "false": 24 /* FalseKeyword */,
            "finally": 25 /* FinallyKeyword */,
            "for": 26 /* ForKeyword */,
            "function": 27 /* FunctionKeyword */,
            "get": 64 /* GetKeyword */,
            "if": 28 /* IfKeyword */,
            "implements": 51 /* ImplementsKeyword */,
            "import": 49 /* ImportKeyword */,
            "in": 29 /* InKeyword */,
            "instanceof": 30 /* InstanceOfKeyword */,
            "interface": 52 /* InterfaceKeyword */,
            "let": 53 /* LetKeyword */,
            "module": 65 /* ModuleKeyword */,
            "new": 31 /* NewKeyword */,
            "null": 32 /* NullKeyword */,
            "number": 67 /* NumberKeyword */,
            "package": 54 /* PackageKeyword */,
            "private": 55 /* PrivateKeyword */,
            "protected": 56 /* ProtectedKeyword */,
            "public": 57 /* PublicKeyword */,
            "require": 66 /* RequireKeyword */,
            "return": 33 /* ReturnKeyword */,
            "set": 68 /* SetKeyword */,
            "static": 58 /* StaticKeyword */,
            "string": 69 /* StringKeyword */,
            "super": 50 /* SuperKeyword */,
            "switch": 34 /* SwitchKeyword */,
            "this": 35 /* ThisKeyword */,
            "throw": 36 /* ThrowKeyword */,
            "true": 37 /* TrueKeyword */,
            "try": 38 /* TryKeyword */,
            "typeof": 39 /* TypeOfKeyword */,
            "var": 40 /* VarKeyword */,
            "void": 41 /* VoidKeyword */,
            "while": 42 /* WhileKeyword */,
            "with": 43 /* WithKeyword */,
            "yield": 59 /* YieldKeyword */,
            "{": 70 /* OpenBraceToken */,
            "}": 71 /* CloseBraceToken */,
            "(": 72 /* OpenParenToken */,
            ")": 73 /* CloseParenToken */,
            "[": 74 /* OpenBracketToken */,
            "]": 75 /* CloseBracketToken */,
            ".": 76 /* DotToken */,
            "...": 77 /* DotDotDotToken */,
            ";": 78 /* SemicolonToken */,
            ",": 79 /* CommaToken */,
            "<": 80 /* LessThanToken */,
            ">": 81 /* GreaterThanToken */,
            "<=": 82 /* LessThanEqualsToken */,
            ">=": 83 /* GreaterThanEqualsToken */,
            "==": 84 /* EqualsEqualsToken */,
            "=>": 85 /* EqualsGreaterThanToken */,
            "!=": 86 /* ExclamationEqualsToken */,
            "===": 87 /* EqualsEqualsEqualsToken */,
            "!==": 88 /* ExclamationEqualsEqualsToken */,
            "+": 89 /* PlusToken */,
            "-": 90 /* MinusToken */,
            "*": 91 /* AsteriskToken */,
            "%": 92 /* PercentToken */,
            "++": 93 /* PlusPlusToken */,
            "--": 94 /* MinusMinusToken */,
            "<<": 95 /* LessThanLessThanToken */,
            ">>": 96 /* GreaterThanGreaterThanToken */,
            ">>>": 97 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 98 /* AmpersandToken */,
            "|": 99 /* BarToken */,
            "^": 100 /* CaretToken */,
            "!": 101 /* ExclamationToken */,
            "~": 102 /* TildeToken */,
            "&&": 103 /* AmpersandAmpersandToken */,
            "||": 104 /* BarBarToken */,
            "?": 105 /* QuestionToken */,
            ":": 106 /* ColonToken */,
            "=": 107 /* EqualsToken */,
            "+=": 108 /* PlusEqualsToken */,
            "-=": 109 /* MinusEqualsToken */,
            "*=": 110 /* AsteriskEqualsToken */,
            "%=": 111 /* PercentEqualsToken */,
            "<<=": 112 /* LessThanLessThanEqualsToken */,
            ">>=": 113 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 115 /* AmpersandEqualsToken */,
            "|=": 116 /* BarEqualsToken */,
            "^=": 117 /* CaretEqualsToken */,
            "/": 118 /* SlashToken */,
            "/=": 119 /* SlashEqualsToken */
        };

        var kindToText = new Array();

        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }

        kindToText[62 /* ConstructorKeyword */] = "constructor";

        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }

            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;

        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;

        function isTokenKind(kind) {
            return kind >= 9 /* FirstToken */ && kind <= 119 /* LastToken */;
        }
        SyntaxFacts.isTokenKind = isTokenKind;

        function isAnyKeyword(kind) {
            return kind >= 15 /* FirstKeyword */ && kind <= 69 /* LastKeyword */;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;

        function isStandardKeyword(kind) {
            return kind >= 15 /* FirstStandardKeyword */ && kind <= 43 /* LastStandardKeyword */;
        }
        SyntaxFacts.isStandardKeyword = isStandardKeyword;

        function isFutureReservedKeyword(kind) {
            return kind >= 44 /* FirstFutureReservedKeyword */ && kind <= 50 /* LastFutureReservedKeyword */;
        }
        SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;

        function isFutureReservedStrictKeyword(kind) {
            return kind >= 51 /* FirstFutureReservedStrictKeyword */ && kind <= 59 /* LastFutureReservedStrictKeyword */;
        }
        SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;

        function isAnyPunctuation(kind) {
            return kind >= 70 /* FirstPunctuation */ && kind <= 119 /* LastPunctuation */;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;

        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;

        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;

        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 89 /* PlusToken */:
                    return 164 /* PlusExpression */;
                case 90 /* MinusToken */:
                    return 165 /* NegateExpression */;
                case 102 /* TildeToken */:
                    return 166 /* BitwiseNotExpression */;
                case 101 /* ExclamationToken */:
                    return 167 /* LogicalNotExpression */;
                case 93 /* PlusPlusToken */:
                    return 168 /* PreIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 169 /* PreDecrementExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;

        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 93 /* PlusPlusToken */:
                    return 210 /* PostIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 211 /* PostDecrementExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;

        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 91 /* AsteriskToken */:
                    return 205 /* MultiplyExpression */;

                case 118 /* SlashToken */:
                    return 206 /* DivideExpression */;

                case 92 /* PercentToken */:
                    return 207 /* ModuloExpression */;

                case 89 /* PlusToken */:
                    return 208 /* AddExpression */;

                case 90 /* MinusToken */:
                    return 209 /* SubtractExpression */;

                case 95 /* LessThanLessThanToken */:
                    return 202 /* LeftShiftExpression */;

                case 96 /* GreaterThanGreaterThanToken */:
                    return 203 /* SignedRightShiftExpression */;

                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 204 /* UnsignedRightShiftExpression */;

                case 80 /* LessThanToken */:
                    return 196 /* LessThanExpression */;

                case 81 /* GreaterThanToken */:
                    return 197 /* GreaterThanExpression */;

                case 82 /* LessThanEqualsToken */:
                    return 198 /* LessThanOrEqualExpression */;

                case 83 /* GreaterThanEqualsToken */:
                    return 199 /* GreaterThanOrEqualExpression */;

                case 30 /* InstanceOfKeyword */:
                    return 200 /* InstanceOfExpression */;

                case 29 /* InKeyword */:
                    return 201 /* InExpression */;

                case 84 /* EqualsEqualsToken */:
                    return 192 /* EqualsWithTypeConversionExpression */;

                case 86 /* ExclamationEqualsToken */:
                    return 193 /* NotEqualsWithTypeConversionExpression */;

                case 87 /* EqualsEqualsEqualsToken */:
                    return 194 /* EqualsExpression */;

                case 88 /* ExclamationEqualsEqualsToken */:
                    return 195 /* NotEqualsExpression */;

                case 98 /* AmpersandToken */:
                    return 191 /* BitwiseAndExpression */;

                case 100 /* CaretToken */:
                    return 190 /* BitwiseExclusiveOrExpression */;

                case 99 /* BarToken */:
                    return 189 /* BitwiseOrExpression */;

                case 103 /* AmpersandAmpersandToken */:
                    return 188 /* LogicalAndExpression */;

                case 104 /* BarBarToken */:
                    return 187 /* LogicalOrExpression */;

                case 116 /* BarEqualsToken */:
                    return 182 /* OrAssignmentExpression */;

                case 115 /* AmpersandEqualsToken */:
                    return 180 /* AndAssignmentExpression */;

                case 117 /* CaretEqualsToken */:
                    return 181 /* ExclusiveOrAssignmentExpression */;

                case 112 /* LessThanLessThanEqualsToken */:
                    return 183 /* LeftShiftAssignmentExpression */;

                case 113 /* GreaterThanGreaterThanEqualsToken */:
                    return 184 /* SignedRightShiftAssignmentExpression */;

                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return 185 /* UnsignedRightShiftAssignmentExpression */;

                case 108 /* PlusEqualsToken */:
                    return 175 /* AddAssignmentExpression */;

                case 109 /* MinusEqualsToken */:
                    return 176 /* SubtractAssignmentExpression */;

                case 110 /* AsteriskEqualsToken */:
                    return 177 /* MultiplyAssignmentExpression */;

                case 119 /* SlashEqualsToken */:
                    return 178 /* DivideAssignmentExpression */;

                case 111 /* PercentEqualsToken */:
                    return 179 /* ModuloAssignmentExpression */;

                case 107 /* EqualsToken */:
                    return 174 /* AssignmentExpression */;

                case 79 /* CommaToken */:
                    return 173 /* CommaExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;

        function isAnyDivideToken(kind) {
            switch (kind) {
                case 118 /* SlashToken */:
                case 119 /* SlashEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideToken = isAnyDivideToken;

        function isAnyDivideOrRegularExpressionToken(kind) {
            switch (kind) {
                case 118 /* SlashToken */:
                case 119 /* SlashEqualsToken */:
                case 12 /* RegularExpressionLiteral */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;

        function isParserGenerated(kind) {
            switch (kind) {
                case 96 /* GreaterThanGreaterThanToken */:
                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                case 83 /* GreaterThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isParserGenerated = isParserGenerated;

        function isAnyBinaryExpression(kind) {
            switch (kind) {
                case 173 /* CommaExpression */:
                case 174 /* AssignmentExpression */:
                case 175 /* AddAssignmentExpression */:
                case 176 /* SubtractAssignmentExpression */:
                case 177 /* MultiplyAssignmentExpression */:
                case 178 /* DivideAssignmentExpression */:
                case 179 /* ModuloAssignmentExpression */:
                case 180 /* AndAssignmentExpression */:
                case 181 /* ExclusiveOrAssignmentExpression */:
                case 182 /* OrAssignmentExpression */:
                case 183 /* LeftShiftAssignmentExpression */:
                case 184 /* SignedRightShiftAssignmentExpression */:
                case 185 /* UnsignedRightShiftAssignmentExpression */:
                case 187 /* LogicalOrExpression */:
                case 188 /* LogicalAndExpression */:
                case 189 /* BitwiseOrExpression */:
                case 190 /* BitwiseExclusiveOrExpression */:
                case 191 /* BitwiseAndExpression */:
                case 192 /* EqualsWithTypeConversionExpression */:
                case 193 /* NotEqualsWithTypeConversionExpression */:
                case 194 /* EqualsExpression */:
                case 195 /* NotEqualsExpression */:
                case 196 /* LessThanExpression */:
                case 197 /* GreaterThanExpression */:
                case 198 /* LessThanOrEqualExpression */:
                case 199 /* GreaterThanOrEqualExpression */:
                case 200 /* InstanceOfExpression */:
                case 201 /* InExpression */:
                case 202 /* LeftShiftExpression */:
                case 203 /* SignedRightShiftExpression */:
                case 204 /* UnsignedRightShiftExpression */:
                case 205 /* MultiplyExpression */:
                case 206 /* DivideExpression */:
                case 207 /* ModuloExpression */:
                case 208 /* AddExpression */:
                case 209 /* SubtractExpression */:
                    return true;
            }

            return false;
        }
        SyntaxFacts.isAnyBinaryExpression = isAnyBinaryExpression;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isNumericLiteralStart = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);

    for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
        if (character >= 97 /* a */ && character <= 122 /* z */) {
            isIdentifierStartCharacter[character] = true;
            isIdentifierPartCharacter[character] = true;
        } else if ((character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
            isIdentifierStartCharacter[character] = true;
            isIdentifierPartCharacter[character] = true;
        } else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
            isIdentifierPartCharacter[character] = true;
            isNumericLiteralStart[character] = true;
        }
    }

    isNumericLiteralStart[46 /* dot */] = true;

    for (var keywordKind = 15 /* FirstKeyword */; keywordKind <= 69 /* LastKeyword */; keywordKind++) {
        var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
        isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
    }

    var Scanner = (function () {
        function Scanner(fileName, text, languageVersion, window) {
            if (typeof window === "undefined") { window = TypeScript.ArrayUtilities.createArray(2048, 0); }
            this.slidingWindow = new TypeScript.SlidingWindow(this, window, 0, text.length());
            this.fileName = fileName;
            this.text = text;
            this._languageVersion = languageVersion;
        }
        Scanner.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        Scanner.prototype.fetchMoreItems = function (argument, sourceIndex, window, destinationIndex, spaceAvailable) {
            var charactersRemaining = this.text.length() - sourceIndex;
            var amountToRead = TypeScript.MathPrototype.min(charactersRemaining, spaceAvailable);
            this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
            return amountToRead;
        };

        Scanner.prototype.currentCharCode = function () {
            return this.slidingWindow.currentItem(null);
        };

        Scanner.prototype.absoluteIndex = function () {
            return this.slidingWindow.absoluteIndex();
        };

        Scanner.prototype.setAbsoluteIndex = function (index) {
            this.slidingWindow.setAbsoluteIndex(index);
        };

        Scanner.prototype.scan = function (diagnostics, allowRegularExpression) {
            var diagnosticsLength = diagnostics.length;
            var fullStart = this.slidingWindow.absoluteIndex();
            var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, false);

            var start = this.slidingWindow.absoluteIndex();
            var kindAndFlags = this.scanSyntaxToken(diagnostics, allowRegularExpression);
            var end = this.slidingWindow.absoluteIndex();

            var trailingTriviaInfo = this.scanTriviaInfo(diagnostics, true);

            var isVariableWidthKeyword = (kindAndFlags & -2147483648 /* IsVariableWidthKeyword */) !== 0;
            var kind = kindAndFlags & ~-2147483648 /* IsVariableWidthKeyword */;

            var token = this.createToken(fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo, isVariableWidthKeyword);

            return diagnosticsLength !== diagnostics.length ? TypeScript.Syntax.realizeToken(token) : token;
        };

        Scanner.prototype.createToken = function (fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo, isVariableWidthKeyword) {
            if (!isVariableWidthKeyword && kind >= 15 /* FirstFixedWidth */) {
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.FixedWidthTokenWithNoTrivia(kind);
                    } else {
                        return new TypeScript.Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
                } else {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
                }
            } else {
                var width = end - start;
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                    } else {
                        return new TypeScript.Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
                } else {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
                }
            }
        };

        Scanner.scanTrivia = function (text, start, length, isTrailing) {
            var scanner = new Scanner(null, text.subText(new TypeScript.TextSpan(start, length)), 1 /* EcmaScript5 */, Scanner.triviaWindow);
            return scanner.scanTrivia(isTrailing);
        };

        Scanner.prototype.scanTrivia = function (isTrailing) {
            var trivia = new Array();

            while (true) {
                if (!this.slidingWindow.isAtEndOfSource()) {
                    var ch = this.currentCharCode();

                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:

                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            trivia.push(this.scanWhitespaceTrivia());
                            continue;

                        case 47 /* slash */:
                            var ch2 = this.slidingWindow.peekItemN(1);
                            if (ch2 === 47 /* slash */) {
                                trivia.push(this.scanSingleLineCommentTrivia());
                                continue;
                            }

                            if (ch2 === 42 /* asterisk */) {
                                trivia.push(this.scanMultiLineCommentTrivia());
                                continue;
                            }

                            throw TypeScript.Errors.invalidOperation();

                        case 13 /* carriageReturn */:
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            trivia.push(this.scanLineTerminatorSequenceTrivia(ch));

                            if (!isTrailing) {
                                continue;
                            }

                            break;

                        default:
                            throw TypeScript.Errors.invalidOperation();
                    }
                }

                return TypeScript.Syntax.triviaList(trivia);
            }
        };

        Scanner.prototype.scanTriviaInfo = function (diagnostics, isTrailing) {
            var width = 0;
            var hasCommentOrNewLine = 0;

            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;

                    case 47 /* slash */:
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === 47 /* slash */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanSingleLineCommentTriviaLength();
                            continue;
                        }

                        if (ch2 === 42 /* asterisk */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanMultiLineCommentTriviaLength(diagnostics);
                            continue;
                        }

                        break;

                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        hasCommentOrNewLine |= 1 /* TriviaNewLineMask */;
                        width += this.scanLineTerminatorSequenceLength(ch);

                        if (!isTrailing) {
                            continue;
                        }

                        break;
                }

                return (width << 2 /* TriviaFullWidthShift */) | hasCommentOrNewLine;
            }
        };

        Scanner.prototype.isNewLineCharacter = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
                default:
                    return false;
            }
        };

        Scanner.prototype.scanWhitespaceTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var width = 0;
            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                }

                break;
            }

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.whitespace(text);
        };

        Scanner.prototype.scanSingleLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanSingleLineCommentTriviaLength();

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.singleLineComment(text);
        };

        Scanner.prototype.scanSingleLineCommentTriviaLength = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanMultiLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanMultiLineCommentTriviaLength(null);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.multiLineComment(text);
        };

        Scanner.prototype.scanMultiLineCommentTriviaLength = function (diagnostics) {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource()) {
                    if (diagnostics !== null) {
                        diagnostics.push(new TypeScript.Diagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 0, TypeScript.DiagnosticCode.AsteriskSlash_expected, null));
                    }

                    return width;
                }

                var ch = this.currentCharCode();
                if (ch === 42 /* asterisk */ && this.slidingWindow.peekItemN(1) === 47 /* slash */) {
                    this.slidingWindow.moveToNextItem();
                    this.slidingWindow.moveToNextItem();
                    width += 2;
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanLineTerminatorSequenceTrivia = function (ch) {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanLineTerminatorSequenceLength(ch);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.trivia(5 /* NewLineTrivia */, text);
        };

        Scanner.prototype.scanLineTerminatorSequenceLength = function (ch) {
            this.slidingWindow.moveToNextItem();

            if (ch === 13 /* carriageReturn */ && this.currentCharCode() === 10 /* lineFeed */) {
                this.slidingWindow.moveToNextItem();
                return 2;
            } else {
                return 1;
            }
        };

        Scanner.prototype.scanSyntaxToken = function (diagnostics, allowRegularExpression) {
            if (this.slidingWindow.isAtEndOfSource()) {
                return 10 /* EndOfFileToken */;
            }

            var character = this.currentCharCode();

            switch (character) {
                case 34 /* doubleQuote */:
                case 39 /* singleQuote */:
                    return this.scanStringLiteral(diagnostics);

                case 47 /* slash */:
                    return this.scanSlashToken(allowRegularExpression);

                case 46 /* dot */:
                    return this.scanDotToken(diagnostics);

                case 45 /* minus */:
                    return this.scanMinusToken();

                case 33 /* exclamation */:
                    return this.scanExclamationToken();

                case 61 /* equals */:
                    return this.scanEqualsToken();

                case 124 /* bar */:
                    return this.scanBarToken();

                case 42 /* asterisk */:
                    return this.scanAsteriskToken();

                case 43 /* plus */:
                    return this.scanPlusToken();

                case 37 /* percent */:
                    return this.scanPercentToken();

                case 38 /* ampersand */:
                    return this.scanAmpersandToken();

                case 94 /* caret */:
                    return this.scanCaretToken();

                case 60 /* lessThan */:
                    return this.scanLessThanToken();

                case 62 /* greaterThan */:
                    return this.advanceAndSetTokenKind(81 /* GreaterThanToken */);

                case 44 /* comma */:
                    return this.advanceAndSetTokenKind(79 /* CommaToken */);

                case 58 /* colon */:
                    return this.advanceAndSetTokenKind(106 /* ColonToken */);

                case 59 /* semicolon */:
                    return this.advanceAndSetTokenKind(78 /* SemicolonToken */);

                case 126 /* tilde */:
                    return this.advanceAndSetTokenKind(102 /* TildeToken */);

                case 40 /* openParen */:
                    return this.advanceAndSetTokenKind(72 /* OpenParenToken */);

                case 41 /* closeParen */:
                    return this.advanceAndSetTokenKind(73 /* CloseParenToken */);

                case 123 /* openBrace */:
                    return this.advanceAndSetTokenKind(70 /* OpenBraceToken */);

                case 125 /* closeBrace */:
                    return this.advanceAndSetTokenKind(71 /* CloseBraceToken */);

                case 91 /* openBracket */:
                    return this.advanceAndSetTokenKind(74 /* OpenBracketToken */);

                case 93 /* closeBracket */:
                    return this.advanceAndSetTokenKind(75 /* CloseBracketToken */);

                case 63 /* question */:
                    return this.advanceAndSetTokenKind(105 /* QuestionToken */);
            }

            if (isNumericLiteralStart[character]) {
                return this.scanNumericLiteral(diagnostics);
            }

            if (isIdentifierStartCharacter[character]) {
                var result = this.tryFastScanIdentifierOrKeyword(character);
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
                return this.slowScanIdentifierOrKeyword(diagnostics);
            }

            return this.scanDefaultCharacter(character, diagnostics);
        };

        Scanner.prototype.isIdentifierStart = function (interpretedChar) {
            if (isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.isIdentifierPart = function (interpretedChar) {
            if (isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.tryFastScanIdentifierOrKeyword = function (firstCharacter) {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            while (true) {
                var character = this.currentCharCode();
                if (isIdentifierPartCharacter[character]) {
                    this.slidingWindow.moveToNextItem();
                } else if (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return 0 /* None */;
                } else {
                    var endIndex = this.slidingWindow.absoluteIndex();

                    var kind;
                    if (isKeywordStartCharacter[firstCharacter]) {
                        var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                        kind = TypeScript.ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                    } else {
                        kind = 11 /* IdentifierName */;
                    }

                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return kind;
                }
            }
        };

        Scanner.prototype.slowScanIdentifierOrKeyword = function (diagnostics) {
            var startIndex = this.slidingWindow.absoluteIndex();
            var sawUnicodeEscape = false;

            do {
                var unicodeEscape = this.scanCharOrUnicodeEscape(diagnostics);
                sawUnicodeEscape = sawUnicodeEscape || unicodeEscape;
            } while(this.isIdentifierPart(this.peekCharOrUnicodeEscape()));

            if (sawUnicodeEscape) {
                var text = this.text.substr(startIndex, this.slidingWindow.absoluteIndex(), false);
                var valueText = TypeScript.Syntax.massageEscapes(text);

                var keywordKind = TypeScript.SyntaxFacts.getTokenKind(valueText);
                if (keywordKind >= 15 /* FirstKeyword */ && keywordKind <= 69 /* LastKeyword */) {
                    return keywordKind | -2147483648 /* IsVariableWidthKeyword */;
                }
            }

            return 11 /* IdentifierName */;
        };

        Scanner.prototype.scanNumericLiteral = function (diagnostics) {
            if (this.isHexNumericLiteral()) {
                this.scanHexNumericLiteral();
            } else if (this.isOctalNumericLiteral()) {
                this.scanOctalNumericLiteral(diagnostics);
            } else {
                this.scanDecimalNumericLiteral();
            }

            return 13 /* NumericLiteral */;
        };

        Scanner.prototype.isOctalNumericLiteral = function () {
            return this.currentCharCode() === 48 /* _0 */ && TypeScript.CharacterInfo.isOctalDigit(this.slidingWindow.peekItemN(1));
        };

        Scanner.prototype.scanOctalNumericLiteral = function (diagnostics) {
            var position = this.absoluteIndex();

            while (TypeScript.CharacterInfo.isOctalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            if (this.languageVersion() >= 1 /* EcmaScript5 */) {
                diagnostics.push(new TypeScript.Diagnostic(this.fileName, position, this.absoluteIndex() - position, TypeScript.DiagnosticCode.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher, null));
            }
        };

        Scanner.prototype.scanDecimalDigits = function () {
            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
        };

        Scanner.prototype.scanDecimalNumericLiteral = function () {
            this.scanDecimalDigits();

            if (this.currentCharCode() === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
            }

            this.scanDecimalDigits();

            var ch = this.currentCharCode();
            if (ch === 101 /* e */ || ch === 69 /* E */) {
                var nextChar1 = this.slidingWindow.peekItemN(1);

                if (TypeScript.CharacterInfo.isDecimalDigit(nextChar1)) {
                    this.slidingWindow.moveToNextItem();
                    this.scanDecimalDigits();
                } else if (nextChar1 === 45 /* minus */ || nextChar1 === 43 /* plus */) {
                    var nextChar2 = this.slidingWindow.peekItemN(2);
                    if (TypeScript.CharacterInfo.isDecimalDigit(nextChar2)) {
                        this.slidingWindow.moveToNextItem();
                        this.slidingWindow.moveToNextItem();
                        this.scanDecimalDigits();
                    }
                }
            }
        };

        Scanner.prototype.scanHexNumericLiteral = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            while (TypeScript.CharacterInfo.isHexDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
        };

        Scanner.prototype.isHexNumericLiteral = function () {
            if (this.currentCharCode() === 48 /* _0 */) {
                var ch = this.slidingWindow.peekItemN(1);

                if (ch === 120 /* x */ || ch === 88 /* X */) {
                    ch = this.slidingWindow.peekItemN(2);

                    return TypeScript.CharacterInfo.isHexDigit(ch);
                }
            }

            return false;
        };

        Scanner.prototype.advanceAndSetTokenKind = function (kind) {
            this.slidingWindow.moveToNextItem();
            return kind;
        };

        Scanner.prototype.scanLessThanToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 82 /* LessThanEqualsToken */;
            } else if (this.currentCharCode() === 60 /* lessThan */) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();
                    return 112 /* LessThanLessThanEqualsToken */;
                } else {
                    return 95 /* LessThanLessThanToken */;
                }
            } else {
                return 80 /* LessThanToken */;
            }
        };

        Scanner.prototype.scanBarToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 116 /* BarEqualsToken */;
            } else if (this.currentCharCode() === 124 /* bar */) {
                this.slidingWindow.moveToNextItem();
                return 104 /* BarBarToken */;
            } else {
                return 99 /* BarToken */;
            }
        };

        Scanner.prototype.scanCaretToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 117 /* CaretEqualsToken */;
            } else {
                return 100 /* CaretToken */;
            }
        };

        Scanner.prototype.scanAmpersandToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 115 /* AmpersandEqualsToken */;
            } else if (this.currentCharCode() === 38 /* ampersand */) {
                this.slidingWindow.moveToNextItem();
                return 103 /* AmpersandAmpersandToken */;
            } else {
                return 98 /* AmpersandToken */;
            }
        };

        Scanner.prototype.scanPercentToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 111 /* PercentEqualsToken */;
            } else {
                return 92 /* PercentToken */;
            }
        };

        Scanner.prototype.scanMinusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();

            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 109 /* MinusEqualsToken */;
            } else if (character === 45 /* minus */) {
                this.slidingWindow.moveToNextItem();
                return 94 /* MinusMinusToken */;
            } else {
                return 90 /* MinusToken */;
            }
        };

        Scanner.prototype.scanPlusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 108 /* PlusEqualsToken */;
            } else if (character === 43 /* plus */) {
                this.slidingWindow.moveToNextItem();
                return 93 /* PlusPlusToken */;
            } else {
                return 89 /* PlusToken */;
            }
        };

        Scanner.prototype.scanAsteriskToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 110 /* AsteriskEqualsToken */;
            } else {
                return 91 /* AsteriskToken */;
            }
        };

        Scanner.prototype.scanEqualsToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 87 /* EqualsEqualsEqualsToken */;
                } else {
                    return 84 /* EqualsEqualsToken */;
                }
            } else if (character === 62 /* greaterThan */) {
                this.slidingWindow.moveToNextItem();
                return 85 /* EqualsGreaterThanToken */;
            } else {
                return 107 /* EqualsToken */;
            }
        };

        Scanner.prototype.isDotPrefixedNumericLiteral = function () {
            if (this.currentCharCode() === 46 /* dot */) {
                var ch = this.slidingWindow.peekItemN(1);
                return TypeScript.CharacterInfo.isDecimalDigit(ch);
            }

            return false;
        };

        Scanner.prototype.scanDotToken = function (diagnostics) {
            if (this.isDotPrefixedNumericLiteral()) {
                return this.scanNumericLiteral(diagnostics);
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 46 /* dot */ && this.slidingWindow.peekItemN(1) === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                return 77 /* DotDotDotToken */;
            } else {
                return 76 /* DotToken */;
            }
        };

        Scanner.prototype.scanSlashToken = function (allowRegularExpression) {
            if (allowRegularExpression) {
                var result = this.tryScanRegularExpressionToken();
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 119 /* SlashEqualsToken */;
            } else {
                return 118 /* SlashToken */;
            }
        };

        Scanner.prototype.tryScanRegularExpressionToken = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = this.currentCharCode();
                    if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                        this.slidingWindow.rewindToPinnedIndex(startIndex);
                        return 0 /* None */;
                    }

                    this.slidingWindow.moveToNextItem();
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }

                    switch (ch) {
                        case 92 /* backslash */:
                            inEscape = true;
                            continue;

                        case 91 /* openBracket */:
                            inCharacterClass = true;
                            continue;

                        case 93 /* closeBracket */:
                            inCharacterClass = false;
                            continue;

                        case 47 /* slash */:
                            if (inCharacterClass) {
                                continue;
                            }

                            break;

                        default:
                            continue;
                    }

                    break;
                }

                while (isIdentifierPartCharacter[this.currentCharCode()]) {
                    this.slidingWindow.moveToNextItem();
                }

                return 12 /* RegularExpressionLiteral */;
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            }
        };

        Scanner.prototype.scanExclamationToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 88 /* ExclamationEqualsEqualsToken */;
                } else {
                    return 86 /* ExclamationEqualsToken */;
                }
            } else {
                return 101 /* ExclamationToken */;
            }
        };

        Scanner.prototype.scanDefaultCharacter = function (character, diagnostics) {
            var position = this.slidingWindow.absoluteIndex();
            this.slidingWindow.moveToNextItem();

            var text = String.fromCharCode(character);
            var messageText = this.getErrorMessageText(text);
            diagnostics.push(new TypeScript.Diagnostic(this.fileName, position, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [messageText]));

            return 9 /* ErrorToken */;
        };

        Scanner.prototype.getErrorMessageText = function (text) {
            if (text === "\\") {
                return '"\\"';
            }

            return JSON.stringify(text);
        };

        Scanner.prototype.skipEscapeSequence = function (diagnostics) {
            var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var ch = this.currentCharCode();
                this.slidingWindow.moveToNextItem();
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                        var value = this.scanUnicodeOrHexEscape(diagnostics);
                        return;

                    case 13 /* carriageReturn */:
                        if (this.currentCharCode() === 10 /* lineFeed */) {
                            this.slidingWindow.moveToNextItem();
                        }
                        return;

                    default:
                        return;
                }
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
            }
        };

        Scanner.prototype.scanStringLiteral = function (diagnostics) {
            var quoteCharacter = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            while (true) {
                var ch = this.currentCharCode();
                if (ch === 92 /* backslash */) {
                    this.skipEscapeSequence(diagnostics);
                } else if (ch === quoteCharacter) {
                    this.slidingWindow.moveToNextItem();
                    break;
                } else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    diagnostics.push(new TypeScript.Diagnostic(this.fileName, TypeScript.MathPrototype.min(this.slidingWindow.absoluteIndex(), this.text.length()), 1, TypeScript.DiagnosticCode.Missing_close_quote_character, null));
                    break;
                } else {
                    this.slidingWindow.moveToNextItem();
                }
            }

            return 14 /* StringLiteral */;
        };

        Scanner.prototype.isUnicodeOrHexEscape = function (character) {
            return this.isUnicodeEscape(character) || this.isHexEscape(character);
        };

        Scanner.prototype.isUnicodeEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.isHexEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 120 /* x */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.peekCharOrUnicodeOrHexEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeOrHexEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekCharOrUnicodeEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekUnicodeOrHexEscape = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var ch = this.scanUnicodeOrHexEscape(null);

            this.slidingWindow.rewindToPinnedIndex(startIndex);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);

            return ch;
        };

        Scanner.prototype.scanCharOrUnicodeEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    this.scanUnicodeOrHexEscape(errors);
                    return true;
                }
            }

            this.slidingWindow.moveToNextItem();
            return false;
        };

        Scanner.prototype.scanCharOrUnicodeOrHexEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */ || ch2 === 120 /* x */) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        };

        Scanner.prototype.scanUnicodeOrHexEscape = function (errors) {
            var start = this.slidingWindow.absoluteIndex();
            var character = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            character = this.currentCharCode();

            var intChar = 0;
            this.slidingWindow.moveToNextItem();

            var count = character === 117 /* u */ ? 4 : 2;

            for (var i = 0; i < count; i++) {
                var ch2 = this.currentCharCode();
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    if (errors !== null) {
                        var end = this.slidingWindow.absoluteIndex();
                        var info = this.createIllegalEscapeDiagnostic(start, end);
                        errors.push(info);
                    }

                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                this.slidingWindow.moveToNextItem();
            }

            return intChar;
        };

        Scanner.prototype.substring = function (start, end, intern) {
            var length = end - start;
            var offset = start - this.slidingWindow.windowAbsoluteStartIndex;

            if (intern) {
                return TypeScript.Collections.DefaultStringTable.addCharArray(this.slidingWindow.window, offset, length);
            } else {
                return TypeScript.StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
            }
        };

        Scanner.prototype.createIllegalEscapeDiagnostic = function (start, end) {
            return new TypeScript.Diagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, null);
        };

        Scanner.isValidIdentifier = function (text, languageVersion) {
            var scanner = new Scanner(null, text, languageVersion, Scanner.triviaWindow);
            var errors = new Array();
            var token = scanner.scan(errors, false);

            return errors.length === 0 && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && token.width() === text.length();
        };
        Scanner.triviaWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
        return Scanner;
    })();
    TypeScript.Scanner = Scanner;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (array, startIndex, length) {
            switch (length) {
                case 2:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 111 /* o */) ? 22 /* DoKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 102 /* f */:
                                    return 28 /* IfKeyword */;
                                case 110 /* n */:
                                    return 29 /* InKeyword */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 3:
                    switch (array[startIndex]) {
                        case 102 /* f */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 114 /* r */) ? 26 /* ForKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 119 /* w */) ? 31 /* NewKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 121 /* y */) ? 38 /* TryKeyword */ : 11 /* IdentifierName */;
                        case 118 /* v */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 114 /* r */) ? 40 /* VarKeyword */ : 11 /* IdentifierName */;
                        case 108 /* l */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 53 /* LetKeyword */ : 11 /* IdentifierName */;
                        case 97 /* a */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 121 /* y */) ? 60 /* AnyKeyword */ : 11 /* IdentifierName */;
                        case 103 /* g */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 64 /* GetKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 68 /* SetKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 4:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 16 /* CaseKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            switch (array[startIndex + 1]) {
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 23 /* ElseKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 109 /* m */) ? 46 /* EnumKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 108 /* l */) ? 32 /* NullKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            switch (array[startIndex + 1]) {
                                case 104 /* h */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 115 /* s */) ? 35 /* ThisKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 101 /* e */) ? 37 /* TrueKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 118 /* v */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 100 /* d */) ? 41 /* VoidKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 104 /* h */) ? 43 /* WithKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 5:
                    switch (array[startIndex]) {
                        case 98 /* b */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 107 /* k */) ? 15 /* BreakKeyword */ : 11 /* IdentifierName */;
                        case 99 /* c */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 104 /* h */) ? 17 /* CatchKeyword */ : 11 /* IdentifierName */;
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 97 /* a */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 115 /* s */) ? 44 /* ClassKeyword */ : 11 /* IdentifierName */;
                                case 111 /* o */:
                                    return (array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */) ? 45 /* ConstKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 101 /* e */) ? 24 /* FalseKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 114 /* r */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 119 /* w */) ? 36 /* ThrowKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */) ? 42 /* WhileKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */) ? 50 /* SuperKeyword */ : 11 /* IdentifierName */;
                        case 121 /* y */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 100 /* d */) ? 59 /* YieldKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 6:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 101 /* e */) ? 21 /* DeleteKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 110 /* n */) ? 33 /* ReturnKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            switch (array[startIndex + 1]) {
                                case 119 /* w */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 99 /* c */ && array[startIndex + 5] === 104 /* h */) ? 34 /* SwitchKeyword */ : 11 /* IdentifierName */;
                                case 116 /* t */:
                                    switch (array[startIndex + 2]) {
                                        case 97 /* a */:
                                            return (array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 58 /* StaticKeyword */ : 11 /* IdentifierName */;
                                        case 114 /* r */:
                                            return (array[startIndex + 3] === 105 /* i */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 103 /* g */) ? 69 /* StringKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 116 /* t */:
                            return (array[startIndex + 1] === 121 /* y */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 111 /* o */ && array[startIndex + 5] === 102 /* f */) ? 39 /* TypeOfKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 47 /* ExportKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            return (array[startIndex + 1] === 109 /* m */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 49 /* ImportKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 57 /* PublicKeyword */ : 11 /* IdentifierName */;
                        case 109 /* m */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 100 /* d */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 101 /* e */) ? 65 /* ModuleKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 109 /* m */ && array[startIndex + 3] === 98 /* b */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 114 /* r */) ? 67 /* NumberKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 7:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            switch (array[startIndex + 1]) {
                                case 101 /* e */:
                                    switch (array[startIndex + 2]) {
                                        case 102 /* f */:
                                            return (array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 117 /* u */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 116 /* t */) ? 20 /* DefaultKeyword */ : 11 /* IdentifierName */;
                                        case 99 /* c */:
                                            return (array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 63 /* DeclareKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 121 /* y */) ? 25 /* FinallyKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 100 /* d */ && array[startIndex + 6] === 115 /* s */) ? 48 /* ExtendsKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 99 /* c */ && array[startIndex + 3] === 107 /* k */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */) ? 54 /* PackageKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 118 /* v */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 116 /* t */ && array[startIndex + 6] === 101 /* e */) ? 55 /* PrivateKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 98 /* b */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 97 /* a */ && array[startIndex + 6] === 110 /* n */) ? 61 /* BooleanKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 113 /* q */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 66 /* RequireKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 8:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 101 /* e */) ? 18 /* ContinueKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 103 /* g */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 114 /* r */) ? 19 /* DebuggerKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 105 /* i */ && array[startIndex + 6] === 111 /* o */ && array[startIndex + 7] === 110 /* n */) ? 27 /* FunctionKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 9:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 102 /* f */ && array[startIndex + 6] === 97 /* a */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 101 /* e */) ? 52 /* InterfaceKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 99 /* c */ && array[startIndex + 6] === 116 /* t */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 100 /* d */) ? 56 /* ProtectedKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 10:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 99 /* c */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 111 /* o */ && array[startIndex + 9] === 102 /* f */) ? 30 /* InstanceOfKeyword */ : 11 /* IdentifierName */;
                                case 109 /* m */:
                                    return (array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 109 /* m */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 110 /* n */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 115 /* s */) ? 51 /* ImplementsKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 11:
                    return (array[startIndex] === 99 /* c */ && array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 111 /* o */ && array[startIndex + 10] === 114 /* r */) ? 62 /* ConstructorKeyword */ : 11 /* IdentifierName */;
                default:
                    return 11 /* IdentifierName */;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySeparatedSyntaxList = (function () {
            function EmptySeparatedSyntaxList() {
            }
            EmptySeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            EmptySeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isList = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            EmptySeparatedSyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySeparatedSyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySeparatedSyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            };

            EmptySeparatedSyntaxList.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            return EmptySeparatedSyntaxList;
        })();

        Syntax.emptySeparatedList = new EmptySeparatedSyntaxList();

        var SingletonSeparatedSyntaxList = (function () {
            function SingletonSeparatedSyntaxList(item) {
                this.item = item;
            }
            SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            SingletonSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            SingletonSeparatedSyntaxList.prototype.childCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            SingletonSeparatedSyntaxList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSeparatedSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSeparatedSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSeparatedSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSeparatedSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return this.item.findTokenInternal(new TypeScript.PositionedSeparatedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSeparatedSyntaxList;
        })();

        var NormalSeparatedSyntaxList = (function () {
            function NormalSeparatedSyntaxList(elements) {
                this._data = 0;
                this.elements = elements;
            }
            NormalSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            NormalSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            NormalSeparatedSyntaxList.prototype.toJSON = function (key) {
                return this.elements;
            };

            NormalSeparatedSyntaxList.prototype.childCount = function () {
                return this.elements.length;
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length + 1, 2);
            };
            NormalSeparatedSyntaxList.prototype.separatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length, 2);
            };

            NormalSeparatedSyntaxList.prototype.toArray = function () {
                return this.elements.slice(0);
            };

            NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                var result = [];
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    result.push(this.nonSeparatorAt(i));
                }

                return result;
            };

            NormalSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[index];
            };

            NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                var value = index * 2;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
                var value = index * 2 + 1;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.firstToken = function () {
                var token;
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.firstToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.lastToken = function () {
                var token;
                for (var i = this.elements.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.lastToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSeparatedSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    isIncrementallyUnusable = isIncrementallyUnusable || element.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSeparatedSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedSeparatedList(parent, this, fullStart);
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return element.findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.elements);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.elements));
                }
            };
            return NormalSeparatedSyntaxList;
        })();

        function separatedList(nodes) {
            return separatedListAndValidate(nodes, false);
        }
        Syntax.separatedList = separatedList;

        function separatedListAndValidate(nodes, validate) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptySeparatedList;
            }

            if (validate) {
                for (var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];

                    if (i % 2 === 1) {
                    }
                }
            }

            if (nodes.length === 1) {
                return new SingletonSeparatedSyntaxList(nodes[0]);
            }

            return new NormalSeparatedSyntaxList(nodes);
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(source, window, defaultValue, sourceLength) {
            if (typeof sourceLength === "undefined") { sourceLength = -1; }
            this.source = source;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            this.windowCount = 0;
            this.windowAbsoluteStartIndex = 0;
            this.currentRelativeItemIndex = 0;
            this._pinCount = 0;
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.windowAbsoluteEndIndex = function () {
            return this.windowAbsoluteStartIndex + this.windowCount;
        };

        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
                return false;
            }

            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var spaceAvailable = this.window.length - this.windowCount;
            var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);

            this.windowCount += amountFetched;
            return amountFetched > 0;
        };

        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                var shiftCount = this.windowCount - shiftStartIndex;

                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                this.windowAbsoluteStartIndex += shiftStartIndex;

                this.windowCount -= shiftStartIndex;

                this.currentRelativeItemIndex -= shiftStartIndex;
            } else {
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };

        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };

        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        };

        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                this.firstPinnedAbsoluteIndex = -1;
            }
        };

        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            this.currentRelativeItemIndex = relativeIndex;
        };

        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        };

        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        };

        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };

        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            this.windowCount = this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.setAbsoluteIndex = function (absoluteIndex) {
            if (this.absoluteIndex() === absoluteIndex) {
                return;
            }

            if (this._pinCount > 0) {
            }

            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            } else {
                this.windowAbsoluteStartIndex = absoluteIndex;

                this.windowCount = 0;

                this.currentRelativeItemIndex = 0;
            }
        };

        SlidingWindow.prototype.pinCount = function () {
            return this._pinCount;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function emptySourceUnit() {
            return TypeScript.Syntax.normalModeFactory.sourceUnit(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(10 /* EndOfFileToken */, { text: "" }));
        }
        Syntax.emptySourceUnit = emptySourceUnit;

        function getStandaloneExpression(positionedToken) {
            var token = positionedToken.token();
            if (positionedToken !== null && positionedToken.kind() === 11 /* IdentifierName */) {
                var parentPositionedNode = positionedToken.containingNode();
                var parentNode = parentPositionedNode.node();

                if (parentNode.kind() === 121 /* QualifiedName */ && parentNode.right === token) {
                    return parentPositionedNode;
                } else if (parentNode.kind() === 212 /* MemberAccessExpression */ && parentNode.name === token) {
                    return parentPositionedNode;
                }
            }

            return positionedToken;
        }
        Syntax.getStandaloneExpression = getStandaloneExpression;

        function isInModuleOrTypeContext(positionedToken) {
            if (positionedToken !== null) {
                var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
                var parent = positionedNodeOrToken.containingNode();

                if (parent !== null) {
                    switch (parent.kind()) {
                        case 247 /* ModuleNameModuleReference */:
                            return true;
                        case 121 /* QualifiedName */:
                            return true;
                        default:
                            return isInTypeOnlyContext(positionedToken);
                    }
                }
            }

            return false;
        }
        Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;

        function isInTypeOnlyContext(positionedToken) {
            var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
            var positionedParent = positionedNodeOrToken.containingNode();

            var parent = positionedParent.node();
            var nodeOrToken = positionedNodeOrToken.nodeOrToken();

            if (parent !== null) {
                switch (parent.kind()) {
                    case 124 /* ArrayType */:
                        return parent.type === nodeOrToken;
                    case 220 /* CastExpression */:
                        return parent.type === nodeOrToken;
                    case 245 /* TypeAnnotation */:
                    case 230 /* HeritageClause */:
                    case 228 /* TypeArgumentList */:
                        return true;
                }
            }

            return false;
        }
        Syntax.isInTypeOnlyContext = isInTypeOnlyContext;

        function childOffset(parent, child) {
            var offset = 0;
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return offset;
                }

                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childOffset = childOffset;

        function childOffsetAt(parent, index) {
            var offset = 0;
            for (var i = 0; i < index; i++) {
                var current = parent.childAt(i);
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            return offset;
        }
        Syntax.childOffsetAt = childOffsetAt;

        function childIndex(parent, child) {
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return i;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;

        function nodeStructuralEquals(node1, node2) {
            if (node1 === null) {
                return node2 === null;
            }

            return node1.structuralEquals(node2);
        }
        Syntax.nodeStructuralEquals = nodeStructuralEquals;

        function nodeOrTokenStructuralEquals(node1, node2) {
            if (node1 === node2) {
                return true;
            }

            if (node1 === null || node2 === null) {
                return false;
            }

            if (node1.isToken()) {
                return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
            }

            return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
        }
        Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;

        function tokenStructuralEquals(token1, token2) {
            if (token1 === token2) {
                return true;
            }

            if (token1 === null || token2 === null) {
                return false;
            }

            return token1.kind() === token2.kind() && token1.width() === token2.width() && token1.fullWidth() === token2.fullWidth() && token1.text() === token2.text() && TypeScript.Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) && TypeScript.Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
        }
        Syntax.tokenStructuralEquals = tokenStructuralEquals;

        function triviaListStructuralEquals(triviaList1, triviaList2) {
            if (triviaList1.count() !== triviaList2.count()) {
                return false;
            }

            for (var i = 0, n = triviaList1.count(); i < n; i++) {
                if (!TypeScript.Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                    return false;
                }
            }

            return true;
        }
        Syntax.triviaListStructuralEquals = triviaListStructuralEquals;

        function triviaStructuralEquals(trivia1, trivia2) {
            return trivia1.kind() === trivia2.kind() && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
        }
        Syntax.triviaStructuralEquals = triviaStructuralEquals;

        function listStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var child1 = list1.childAt(i);
                var child2 = list2.childAt(i);

                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(child1, child2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.listStructuralEquals = listStructuralEquals;

        function separatedListStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var element1 = list1.childAt(i);
                var element2 = list2.childAt(i);
                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.separatedListStructuralEquals = separatedListStructuralEquals;

        function elementStructuralEquals(element1, element2) {
            if (element1 === element2) {
                return true;
            }

            if (element1 === null || element2 === null) {
                return false;
            }

            if (element2.kind() !== element2.kind()) {
                return false;
            }

            if (element1.isToken()) {
                return tokenStructuralEquals(element1, element2);
            } else if (element1.isNode()) {
                return nodeStructuralEquals(element1, element2);
            } else if (element1.isList()) {
                return listStructuralEquals(element1, element2);
            } else if (element1.isSeparatedList()) {
                return separatedListStructuralEquals(element1, element2);
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.elementStructuralEquals = elementStructuralEquals;

        function identifierName(text, info) {
            if (typeof info === "undefined") { info = null; }
            return TypeScript.Syntax.identifier(text);
        }
        Syntax.identifierName = identifierName;

        function trueExpression() {
            return TypeScript.Syntax.token(37 /* TrueKeyword */);
        }
        Syntax.trueExpression = trueExpression;

        function falseExpression() {
            return TypeScript.Syntax.token(24 /* FalseKeyword */);
        }
        Syntax.falseExpression = falseExpression;

        function numericLiteralExpression(text) {
            return TypeScript.Syntax.token(13 /* NumericLiteral */, { text: text });
        }
        Syntax.numericLiteralExpression = numericLiteralExpression;

        function stringLiteralExpression(text) {
            return TypeScript.Syntax.token(14 /* StringLiteral */, { text: text });
        }
        Syntax.stringLiteralExpression = stringLiteralExpression;

        function isSuperInvocationExpression(node) {
            return node.kind() === 213 /* InvocationExpression */ && node.expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperInvocationExpression = isSuperInvocationExpression;

        function isSuperInvocationExpressionStatement(node) {
            return node.kind() === 149 /* ExpressionStatement */ && isSuperInvocationExpression(node.expression);
        }
        Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;

        function isSuperMemberAccessExpression(node) {
            return node.kind() === 212 /* MemberAccessExpression */ && node.expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;

        function isSuperMemberAccessInvocationExpression(node) {
            return node.kind() === 213 /* InvocationExpression */ && isSuperMemberAccessExpression(node.expression);
        }
        Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;

        function assignmentExpression(left, token, right) {
            return TypeScript.Syntax.normalModeFactory.binaryExpression(174 /* AssignmentExpression */, left, token, right);
        }
        Syntax.assignmentExpression = assignmentExpression;

        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < node.childCount(); i++) {
                var child = node.childAt(i);
                if (child !== null && child.isToken()) {
                    var token = child;

                    if (token.hasSkippedToken() || (token.width() === 0 && token.kind() !== 10 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;

        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === 14 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }

            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;

        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;

        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                } else if (position === end) {
                    return trivia.kind() === 7 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }

            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;

        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;

            if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                if (positionedToken.token().hasLeadingTrivia()) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else {
                    positionedToken = positionedToken.previousToken();
                    if (positionedToken) {
                        if (positionedToken && positionedToken.token().hasTrailingTrivia()) {
                            triviaList = positionedToken.token().trailingTrivia();
                            fullStart = positionedToken.end();
                        }
                    }
                }
            } else {
                if (position <= (fullStart + positionedToken.token().leadingTriviaWidth())) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else if (position >= (fullStart + positionedToken.token().width())) {
                    triviaList = positionedToken.token().trailingTrivia();
                    fullStart = positionedToken.end();
                }
            }

            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    } else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        lastTriviaBeforeToken = trivia;
                        break;
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;

        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);

            if (positionedToken) {
                if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                    positionedToken = positionedToken.previousToken();
                    return positionedToken && positionedToken.token().trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken.token());
                } else if (position > positionedToken.start()) {
                    return (position < positionedToken.end() && (positionedToken.kind() === 14 /* StringLiteral */ || positionedToken.kind() === 12 /* RegularExpressionLiteral */)) || (position <= positionedToken.end() && isUnterminatedStringLiteral(positionedToken.token()));
                }
            }

            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;

        function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullStart;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullStart = positionedToken.fullStart();
            } else {
                triviaList = positionedToken.token().trailingTrivia();
                fullStart = positionedToken.end();
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullStart);
                    }

                    fullStart += triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenOnLeftInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullEnd;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
            } else {
                triviaList = positionedToken.token().trailingTrivia();
                fullEnd = positionedToken.fullEnd();
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullEnd) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullEnd - triviaWidth);
                    }

                    fullEnd -= triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, true);
        }
        Syntax.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;

        function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, false);
        }
        Syntax.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;

        function findSkippedTokenInPositionedToken(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;

        function findSkippedTokenOnLeft(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenOnLeftInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenOnLeft = findSkippedTokenOnLeft;

        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent()) {
                if (positionedToken.parent().kind() === kind) {
                    return positionedToken.parent();
                }

                positionedToken = positionedToken.parent();
            }

            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;

        function hasAncestorOfKind(positionedToken, kind) {
            return TypeScript.Syntax.getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;

        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 164 /* PlusExpression */:
                    case 165 /* NegateExpression */:
                        expression = expression.operand;
                        return expression.isToken() && isInteger(expression.text());

                    case 13 /* NumericLiteral */:
                        var text = expression.text();
                        return isInteger(text) || isHexInteger(text);
                }
            }

            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;

        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }

        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        Syntax.isHexInteger = isHexInteger;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var NormalModeFactory = (function () {
            function NormalModeFactory() {
            }
            NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, false);
            };
            NormalModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, false);
            };
            NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, false);
            };
            NormalModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
            };
            NormalModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, false);
            };
            NormalModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, false);
            };
            NormalModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
            };
            NormalModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, false);
            };
            NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
            };
            NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
            };
            NormalModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(false);
            };
            NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
            };
            NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, false);
            };
            NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
            };
            NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
            };
            NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
            };
            NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, false);
            };
            NormalModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, false);
            };
            NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, false);
            };
            NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, false);
            };
            NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
            };
            NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
            };
            NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, false);
            };
            NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, false);
            };
            NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, false);
            };
            NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
            };
            NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, false);
            };
            NormalModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, false);
            };
            NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
            };
            NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
            };
            NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
            };
            NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, false);
            };
            NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, false);
            };
            NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, false);
            };
            NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
            };
            NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, false);
            };
            NormalModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, false);
            };
            NormalModeFactory.prototype.indexMemberDeclaration = function (modifiers, indexSignature, semicolonToken) {
                return new TypeScript.IndexMemberDeclaration(modifiers, indexSignature, semicolonToken, false);
            };
            NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
            };
            NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
            };
            NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
            };
            NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
            };
            NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, false);
            };
            NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
            };
            NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
            };
            NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
            };
            NormalModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, false);
            };
            NormalModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
            };
            NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, false);
            };
            NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
            };
            NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, false);
            };
            NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, false);
            };
            NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
            };
            NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, false);
            };
            NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, false);
            };
            NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, false);
            };
            NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
            };
            return NormalModeFactory;
        })();
        Syntax.NormalModeFactory = NormalModeFactory;

        var StrictModeFactory = (function () {
            function StrictModeFactory() {
            }
            StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, true);
            };
            StrictModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, true);
            };
            StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, true);
            };
            StrictModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
            };
            StrictModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, true);
            };
            StrictModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, true);
            };
            StrictModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
            };
            StrictModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, true);
            };
            StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
            };
            StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
            };
            StrictModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(true);
            };
            StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
            };
            StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, true);
            };
            StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
            };
            StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
            };
            StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
            };
            StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, true);
            };
            StrictModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, true);
            };
            StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, true);
            };
            StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, true);
            };
            StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
            };
            StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
            };
            StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, true);
            };
            StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, true);
            };
            StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, true);
            };
            StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
            };
            StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, true);
            };
            StrictModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, true);
            };
            StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
            };
            StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
            };
            StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
            };
            StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, true);
            };
            StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, true);
            };
            StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, true);
            };
            StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
            };
            StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, true);
            };
            StrictModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, true);
            };
            StrictModeFactory.prototype.indexMemberDeclaration = function (modifiers, indexSignature, semicolonToken) {
                return new TypeScript.IndexMemberDeclaration(modifiers, indexSignature, semicolonToken, true);
            };
            StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
            };
            StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
            };
            StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
            };
            StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
            };
            StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, true);
            };
            StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
            };
            StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
            };
            StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
            };
            StrictModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, true);
            };
            StrictModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
            };
            StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, true);
            };
            StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
            };
            StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, true);
            };
            StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, true);
            };
            StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
            };
            StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, true);
            };
            StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, true);
            };
            StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, true);
            };
            StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
            };
            return StrictModeFactory;
        })();
        Syntax.StrictModeFactory = StrictModeFactory;

        Syntax.normalModeFactory = new NormalModeFactory();
        Syntax.strictModeFactory = new StrictModeFactory();
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === 149 /* ExpressionStatement */) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;

                if (expression.kind() === 14 /* StringLiteral */) {
                    return true;
                }
            }

            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;

        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;

            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;

        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.tokenKind;
            return tokenKind === 11 /* IdentifierName */ || TypeScript.SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySyntaxList = (function () {
            function EmptySyntaxList() {
            }
            EmptySyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            EmptySyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySyntaxList.prototype.isList = function () {
                return true;
            };
            EmptySyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            EmptySyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySyntaxList.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            return EmptySyntaxList;
        })();
        Syntax.EmptySyntaxList = EmptySyntaxList;

        Syntax.emptyList = new EmptySyntaxList();

        var SingletonSyntaxList = (function () {
            function SingletonSyntaxList(item) {
                this.item = item;
            }
            SingletonSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            SingletonSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isList = function () {
                return true;
            };
            SingletonSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            SingletonSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxList.prototype.childCount = function () {
                return 1;
            };

            SingletonSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return this.item.findTokenInternal(new TypeScript.PositionedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSyntaxList;
        })();

        var NormalSyntaxList = (function () {
            function NormalSyntaxList(nodeOrTokens) {
                this._data = 0;
                this.nodeOrTokens = nodeOrTokens;
            }
            NormalSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            NormalSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSyntaxList.prototype.isList = function () {
                return true;
            };
            NormalSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            NormalSyntaxList.prototype.toJSON = function (key) {
                return this.nodeOrTokens;
            };

            NormalSyntaxList.prototype.childCount = function () {
                return this.nodeOrTokens.length;
            };

            NormalSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.nodeOrTokens.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.nodeOrTokens[index];
            };

            NormalSyntaxList.prototype.toArray = function () {
                return this.nodeOrTokens.slice(0);
            };

            NormalSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var element = this.nodeOrTokens[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSyntaxList.prototype.firstToken = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var token = this.nodeOrTokens[i].firstToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.lastToken = function () {
                for (var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                    var token = this.nodeOrTokens[i].lastToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.fullText = function () {
                var elements = new Array();
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var node = this.nodeOrTokens[i];
                    fullWidth += node.fullWidth();
                    isIncrementallyUnusable = isIncrementallyUnusable || node.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedList(parent, this, fullStart);
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var nodeOrToken = this.nodeOrTokens[i];

                    var childWidth = nodeOrToken.fullWidth();
                    if (position < childWidth) {
                        return nodeOrToken.findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.nodeOrTokens);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.nodeOrTokens));
                }
            };
            return NormalSyntaxList;
        })();

        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptyList;
            }

            if (nodes.length === 1) {
                var item = nodes[0];
                return new SingletonSyntaxList(item);
            }

            return new NormalSyntaxList(nodes);
        }
        Syntax.list = list;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(parsedInStrictMode) {
            this._data = parsedInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
        }
        SyntaxNode.prototype.isNode = function () {
            return true;
        };
        SyntaxNode.prototype.isToken = function () {
            return false;
        };
        SyntaxNode.prototype.isList = function () {
            return false;
        };
        SyntaxNode.prototype.isSeparatedList = function () {
            return false;
        };

        SyntaxNode.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childCount = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childAt = function (slot) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.firstToken = function () {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.firstToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.lastToken = function () {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.lastToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.insertChildrenInto = function (array, index) {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    } else if (element.isList()) {
                        element.insertChildrenInto(array, index);
                    } else if (element.isSeparatedList()) {
                        element.insertChildrenInto(array, index);
                    } else {
                        throw TypeScript.Errors.invalidOperation();
                    }
                }
            }
        };

        SyntaxNode.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };

        SyntaxNode.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };

        SyntaxNode.prototype.toJSON = function (key) {
            var result = {
                kind: TypeScript.SyntaxKind[this.kind()],
                fullWidth: this.fullWidth()
            };

            if (this.isIncrementallyUnusable()) {
                result.isIncrementallyUnusable = true;
            }

            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);

                if (value) {
                    for (var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }

            return result;
        };

        SyntaxNode.prototype.accept = function (visitor) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };

        SyntaxNode.prototype.collectTextElements = function (elements) {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    element.collectTextElements(elements);
                }
            }
        };

        SyntaxNode.prototype.replaceToken = function (token1, token2) {
            if (token1 === token2) {
                return this;
            }

            return this.accept(new TypeScript.SyntaxTokenReplacer(token1, token2));
        };

        SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        };

        SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        };

        SyntaxNode.prototype.hasLeadingTrivia = function () {
            return this.lastToken().hasLeadingTrivia();
        };

        SyntaxNode.prototype.hasTrailingTrivia = function () {
            return this.lastToken().hasTrailingTrivia();
        };

        SyntaxNode.prototype.isTypeScriptSpecific = function () {
            return false;
        };

        SyntaxNode.prototype.isIncrementallyUnusable = function () {
            return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
        };

        SyntaxNode.prototype.parsedInStrictMode = function () {
            return (this.data() & 4 /* NodeParsedInStrictModeMask */) !== 0;
        };

        SyntaxNode.prototype.fullWidth = function () {
            return this.data() >>> 3 /* NodeFullWidthShift */;
        };

        SyntaxNode.prototype.computeData = function () {
            var slotCount = this.childCount();

            var fullWidth = 0;
            var childWidth = 0;

            var isIncrementallyUnusable = ((this._data & 2 /* NodeIncrementallyUnusableMask */) !== 0) || slotCount === 0;

            for (var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    if (!isIncrementallyUnusable) {
                        isIncrementallyUnusable = element.isIncrementallyUnusable();
                    }
                }
            }

            return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
        };

        SyntaxNode.prototype.data = function () {
            if ((this._data & 1 /* NodeDataComputed */) === 0) {
                this._data |= this.computeData();
            }

            return this._data;
        };

        SyntaxNode.prototype.findToken = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }

            if (position < 0 || position >= this.fullWidth()) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var positionedToken = this.findTokenInternal(null, position, 0);

            if (includeSkippedTokens) {
                return TypeScript.Syntax.findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
            }

            return positionedToken;
        };

        SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
            if (this.kind() === 120 /* SourceUnit */ && position === this.fullWidth()) {
                var sourceUnit = this;
                return new TypeScript.PositionedToken(new TypeScript.PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }

            return null;
        };

        SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new TypeScript.PositionedNode(parent, this, fullStart);
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    var childWidth = element.fullWidth();

                    if (position < childWidth) {
                        return element.findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxNode.prototype.findTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);
            var start = positionedToken.start();

            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (position > start) {
                return positionedToken;
            }

            if (positionedToken.fullStart() === 0) {
                return null;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.findCompleteTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);

            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (positionedToken.token().width() > 0 && position >= positionedToken.end()) {
                return positionedToken;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.isModuleElement = function () {
            return false;
        };

        SyntaxNode.prototype.isClassElement = function () {
            return false;
        };

        SyntaxNode.prototype.isTypeMember = function () {
            return false;
        };

        SyntaxNode.prototype.isStatement = function () {
            return false;
        };

        SyntaxNode.prototype.isExpression = function () {
            return false;
        };

        SyntaxNode.prototype.isSwitchClause = function () {
            return false;
        };

        SyntaxNode.prototype.structuralEquals = function (node) {
            if (this === node) {
                return true;
            }
            if (node === null) {
                return false;
            }
            if (this.kind() !== node.kind()) {
                return false;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);

                if (!TypeScript.Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        };

        SyntaxNode.prototype.width = function () {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };

        SyntaxNode.prototype.leadingTriviaWidth = function () {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        };

        SyntaxNode.prototype.trailingTriviaWidth = function () {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    var SourceUnitSyntax = (function (_super) {
        __extends(SourceUnitSyntax, _super);
        function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleElements = moduleElements;
            this.endOfFileToken = endOfFileToken;
        }
        SourceUnitSyntax.prototype.accept = function (visitor) {
            return visitor.visitSourceUnit(this);
        };

        SourceUnitSyntax.prototype.kind = function () {
            return 120 /* SourceUnit */;
        };

        SourceUnitSyntax.prototype.childCount = function () {
            return 2;
        };

        SourceUnitSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleElements;
                case 1:
                    return this.endOfFileToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
            if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
                return this;
            }

            return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
        };

        SourceUnitSyntax.create = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.create1 = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(moduleElements, this.endOfFileToken);
        };

        SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
            return this.update(this.moduleElements, endOfFileToken);
        };

        SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.moduleElements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SourceUnitSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SourceUnitSyntax = SourceUnitSyntax;

    var ModuleReferenceSyntax = (function (_super) {
        __extends(ModuleReferenceSyntax, _super);
        function ModuleReferenceSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        ModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };

        ModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleReferenceSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleReferenceSyntax = ModuleReferenceSyntax;

    var ExternalModuleReferenceSyntax = (function (_super) {
        __extends(ExternalModuleReferenceSyntax, _super);
        function ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.requireKeyword = requireKeyword;
            this.openParenToken = openParenToken;
            this.stringLiteral = stringLiteral;
            this.closeParenToken = closeParenToken;
        }
        ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitExternalModuleReference(this);
        };

        ExternalModuleReferenceSyntax.prototype.kind = function () {
            return 246 /* ExternalModuleReference */;
        };

        ExternalModuleReferenceSyntax.prototype.childCount = function () {
            return 4;
        };

        ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.requireKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.stringLiteral;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExternalModuleReferenceSyntax.prototype.update = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
            if (this.requireKeyword === requireKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
        };

        ExternalModuleReferenceSyntax.create1 = function (stringLiteral) {
            return new ExternalModuleReferenceSyntax(TypeScript.Syntax.token(66 /* RequireKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), stringLiteral, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withRequireKeyword = function (requireKeyword) {
            return this.update(requireKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.requireKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.requireKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.requireKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExternalModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;

    var ModuleNameModuleReferenceSyntax = (function (_super) {
        __extends(ModuleNameModuleReferenceSyntax, _super);
        function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleName = moduleName;
        }
        ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleNameModuleReference(this);
        };

        ModuleNameModuleReferenceSyntax.prototype.kind = function () {
            return 247 /* ModuleNameModuleReference */;
        };

        ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
            return 1;
        };

        ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleName;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
            if (this.moduleName === moduleName) {
                return this;
            }

            return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
        };

        ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(moduleName);
        };

        ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleNameModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;

    var ImportDeclarationSyntax = (function (_super) {
        __extends(ImportDeclarationSyntax, _super);
        function ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.importKeyword = importKeyword;
            this.identifier = identifier;
            this.equalsToken = equalsToken;
            this.moduleReference = moduleReference;
            this.semicolonToken = semicolonToken;
        }
        ImportDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitImportDeclaration(this);
        };

        ImportDeclarationSyntax.prototype.kind = function () {
            return 133 /* ImportDeclaration */;
        };

        ImportDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        ImportDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.importKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.equalsToken;
                case 4:
                    return this.moduleReference;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ImportDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ImportDeclarationSyntax.prototype.update = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            if (this.modifiers === modifiers && this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
        };

        ImportDeclarationSyntax.create = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
        };

        ImportDeclarationSyntax.create1 = function (identifier, moduleReference) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(49 /* ImportKeyword */), identifier, TypeScript.Syntax.token(107 /* EqualsToken */), moduleReference, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
            return this.update(this.modifiers, importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
        };

        ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ImportDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ImportDeclarationSyntax = ImportDeclarationSyntax;

    var ExportAssignmentSyntax = (function (_super) {
        __extends(ExportAssignmentSyntax, _super);
        function ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.exportKeyword = exportKeyword;
            this.equalsToken = equalsToken;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ExportAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitExportAssignment(this);
        };

        ExportAssignmentSyntax.prototype.kind = function () {
            return 134 /* ExportAssignment */;
        };

        ExportAssignmentSyntax.prototype.childCount = function () {
            return 4;
        };

        ExportAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.exportKeyword;
                case 1:
                    return this.equalsToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExportAssignmentSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExportAssignmentSyntax.prototype.update = function (exportKeyword, equalsToken, identifier, semicolonToken) {
            if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ExportAssignmentSyntax.create1 = function (identifier) {
            return new ExportAssignmentSyntax(TypeScript.Syntax.token(47 /* ExportKeyword */), TypeScript.Syntax.token(107 /* EqualsToken */), identifier, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ExportAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withExportKeyword = function (exportKeyword) {
            return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
        };

        ExportAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExportAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExportAssignmentSyntax = ExportAssignmentSyntax;

    var ClassDeclarationSyntax = (function (_super) {
        __extends(ClassDeclarationSyntax, _super);
        function ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.classKeyword = classKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.openBraceToken = openBraceToken;
            this.classElements = classElements;
            this.closeBraceToken = closeBraceToken;
        }
        ClassDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitClassDeclaration(this);
        };

        ClassDeclarationSyntax.prototype.kind = function () {
            return 131 /* ClassDeclaration */;
        };

        ClassDeclarationSyntax.prototype.childCount = function () {
            return 8;
        };

        ClassDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.classKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.openBraceToken;
                case 6:
                    return this.classElements;
                case 7:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ClassDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ClassDeclarationSyntax.prototype.update = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
        };

        ClassDeclarationSyntax.create = function (classKeyword, identifier, openBraceToken, closeBraceToken) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, classKeyword, identifier, null, TypeScript.Syntax.emptyList, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ClassDeclarationSyntax.create1 = function (identifier) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(44 /* ClassKeyword */), identifier, null, TypeScript.Syntax.emptyList, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
            return this.update(this.modifiers, classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.classKeyword, identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
            return this.withClassElements(TypeScript.Syntax.list([classElement]));
        };

        ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ClassDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ClassDeclarationSyntax = ClassDeclarationSyntax;

    var InterfaceDeclarationSyntax = (function (_super) {
        __extends(InterfaceDeclarationSyntax, _super);
        function InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.interfaceKeyword = interfaceKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.body = body;
        }
        InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitInterfaceDeclaration(this);
        };

        InterfaceDeclarationSyntax.prototype.kind = function () {
            return 128 /* InterfaceDeclaration */;
        };

        InterfaceDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.interfaceKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        InterfaceDeclarationSyntax.prototype.update = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
            if (this.modifiers === modifiers && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.body === body) {
                return this;
            }

            return new InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, this.parsedInStrictMode());
        };

        InterfaceDeclarationSyntax.create = function (interfaceKeyword, identifier, body) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, interfaceKeyword, identifier, null, TypeScript.Syntax.emptyList, body, false);
        };

        InterfaceDeclarationSyntax.create1 = function (identifier) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(52 /* InterfaceKeyword */), identifier, null, TypeScript.Syntax.emptyList, ObjectTypeSyntax.create1(), false);
        };

        InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
            return this.update(this.modifiers, interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.interfaceKeyword, identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        InterfaceDeclarationSyntax.prototype.withBody = function (body) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, body);
        };

        InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return InterfaceDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;

    var HeritageClauseSyntax = (function (_super) {
        __extends(HeritageClauseSyntax, _super);
        function HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsOrImplementsKeyword = extendsOrImplementsKeyword;
            this.typeNames = typeNames;
        }
        HeritageClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitHeritageClause(this);
        };

        HeritageClauseSyntax.prototype.kind = function () {
            return 230 /* HeritageClause */;
        };

        HeritageClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        HeritageClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsOrImplementsKeyword;
                case 1:
                    return this.typeNames;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        HeritageClauseSyntax.prototype.update = function (extendsOrImplementsKeyword, typeNames) {
            if (this.extendsOrImplementsKeyword === extendsOrImplementsKeyword && this.typeNames === typeNames) {
                return this;
            }

            return new HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, this.parsedInStrictMode());
        };

        HeritageClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withExtendsOrImplementsKeyword = function (extendsOrImplementsKeyword) {
            return this.update(extendsOrImplementsKeyword, this.typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeNames = function (typeNames) {
            return this.update(this.extendsOrImplementsKeyword, typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeName = function (typeName) {
            return this.withTypeNames(TypeScript.Syntax.separatedList([typeName]));
        };

        HeritageClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return HeritageClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.HeritageClauseSyntax = HeritageClauseSyntax;

    var ModuleDeclarationSyntax = (function (_super) {
        __extends(ModuleDeclarationSyntax, _super);
        function ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.moduleKeyword = moduleKeyword;
            this.moduleName = moduleName;
            this.stringLiteral = stringLiteral;
            this.openBraceToken = openBraceToken;
            this.moduleElements = moduleElements;
            this.closeBraceToken = closeBraceToken;
        }
        ModuleDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleDeclaration(this);
        };

        ModuleDeclarationSyntax.prototype.kind = function () {
            return 130 /* ModuleDeclaration */;
        };

        ModuleDeclarationSyntax.prototype.childCount = function () {
            return 7;
        };

        ModuleDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.moduleKeyword;
                case 2:
                    return this.moduleName;
                case 3:
                    return this.stringLiteral;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.moduleElements;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ModuleDeclarationSyntax.prototype.update = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
        };

        ModuleDeclarationSyntax.create = function (moduleKeyword, openBraceToken, closeBraceToken) {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, moduleKeyword, null, null, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ModuleDeclarationSyntax.create1 = function () {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(65 /* ModuleKeyword */), null, null, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(this.modifiers, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(this.modifiers, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleDeclarationSyntax = ModuleDeclarationSyntax;

    var FunctionDeclarationSyntax = (function (_super) {
        __extends(FunctionDeclarationSyntax, _super);
        function FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        FunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionDeclaration(this);
        };

        FunctionDeclarationSyntax.prototype.kind = function () {
            return 129 /* FunctionDeclaration */;
        };

        FunctionDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        FunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.functionKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.callSignature;
                case 4:
                    return this.block;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionDeclarationSyntax.prototype.isStatement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.update = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        FunctionDeclarationSyntax.create = function (functionKeyword, identifier, callSignature) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, functionKeyword, identifier, callSignature, null, null, false);
        };

        FunctionDeclarationSyntax.create1 = function (identifier) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(27 /* FunctionKeyword */), identifier, CallSignatureSyntax.create1(), null, null, false);
        };

        FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(this.modifiers, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block !== null && this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionDeclarationSyntax = FunctionDeclarationSyntax;

    var VariableStatementSyntax = (function (_super) {
        __extends(VariableStatementSyntax, _super);
        function VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclaration = variableDeclaration;
            this.semicolonToken = semicolonToken;
        }
        VariableStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableStatement(this);
        };

        VariableStatementSyntax.prototype.kind = function () {
            return 148 /* VariableStatement */;
        };

        VariableStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclaration;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.update = function (modifiers, variableDeclaration, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, this.parsedInStrictMode());
        };

        VariableStatementSyntax.create = function (variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, semicolonToken, false);
        };

        VariableStatementSyntax.create1 = function (variableDeclaration) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.modifiers, variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclaration, semicolonToken);
        };

        VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableStatementSyntax = VariableStatementSyntax;

    var VariableDeclarationSyntax = (function (_super) {
        __extends(VariableDeclarationSyntax, _super);
        function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.varKeyword = varKeyword;
            this.variableDeclarators = variableDeclarators;
        }
        VariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclaration(this);
        };

        VariableDeclarationSyntax.prototype.kind = function () {
            return 224 /* VariableDeclaration */;
        };

        VariableDeclarationSyntax.prototype.childCount = function () {
            return 2;
        };

        VariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.varKeyword;
                case 1:
                    return this.variableDeclarators;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
            if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
                return this;
            }

            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
        };

        VariableDeclarationSyntax.create1 = function (variableDeclarators) {
            return new VariableDeclarationSyntax(TypeScript.Syntax.token(40 /* VarKeyword */), variableDeclarators, false);
        };

        VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
            return this.update(varKeyword, this.variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
            return this.update(this.varKeyword, variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.withVariableDeclarators(TypeScript.Syntax.separatedList([variableDeclarator]));
        };

        VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclarators.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclarationSyntax = VariableDeclarationSyntax;

    var VariableDeclaratorSyntax = (function (_super) {
        __extends(VariableDeclaratorSyntax, _super);
        function VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        VariableDeclaratorSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclarator(this);
        };

        VariableDeclaratorSyntax.prototype.kind = function () {
            return 225 /* VariableDeclarator */;
        };

        VariableDeclaratorSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableDeclaratorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.typeAnnotation;
                case 2:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclaratorSyntax.prototype.update = function (identifier, typeAnnotation, equalsValueClause) {
            if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        VariableDeclaratorSyntax.create = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.create1 = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclaratorSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclaratorSyntax = VariableDeclaratorSyntax;

    var EqualsValueClauseSyntax = (function (_super) {
        __extends(EqualsValueClauseSyntax, _super);
        function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsToken = equalsToken;
            this.value = value;
        }
        EqualsValueClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitEqualsValueClause(this);
        };

        EqualsValueClauseSyntax.prototype.kind = function () {
            return 231 /* EqualsValueClause */;
        };

        EqualsValueClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        EqualsValueClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.equalsToken;
                case 1:
                    return this.value;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
            if (this.equalsToken === equalsToken && this.value === value) {
                return this;
            }

            return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
        };

        EqualsValueClauseSyntax.create1 = function (value) {
            return new EqualsValueClauseSyntax(TypeScript.Syntax.token(107 /* EqualsToken */), value, false);
        };

        EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(equalsToken, this.value);
        };

        EqualsValueClauseSyntax.prototype.withValue = function (value) {
            return this.update(this.equalsToken, value);
        };

        EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.value.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EqualsValueClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EqualsValueClauseSyntax = EqualsValueClauseSyntax;

    var PrefixUnaryExpressionSyntax = (function (_super) {
        __extends(PrefixUnaryExpressionSyntax, _super);
        function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operatorToken = operatorToken;
            this.operand = operand;

            this._kind = kind;
        }
        PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPrefixUnaryExpression(this);
        };

        PrefixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operatorToken;
                case 1:
                    return this.operand;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
            if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
                return this;
            }

            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
        };

        PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, this.operatorToken, operand);
        };

        PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PrefixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;

    var ArrayLiteralExpressionSyntax = (function (_super) {
        __extends(ArrayLiteralExpressionSyntax, _super);
        function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.expressions = expressions;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayLiteralExpression(this);
        };

        ArrayLiteralExpressionSyntax.prototype.kind = function () {
            return 214 /* ArrayLiteralExpression */;
        };

        ArrayLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.expressions;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayLiteralExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
            if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayLiteralExpressionSyntax.create = function (openBracketToken, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, TypeScript.Syntax.emptySeparatedList, closeBracketToken, false);
        };

        ArrayLiteralExpressionSyntax.create1 = function () {
            return new ArrayLiteralExpressionSyntax(TypeScript.Syntax.token(74 /* OpenBracketToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
            return this.update(this.openBracketToken, expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
            return this.withExpressions(TypeScript.Syntax.separatedList([expression]));
        };

        ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.expressions, closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expressions.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArrayLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;

    var OmittedExpressionSyntax = (function (_super) {
        __extends(OmittedExpressionSyntax, _super);
        function OmittedExpressionSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        OmittedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitOmittedExpression(this);
        };

        OmittedExpressionSyntax.prototype.kind = function () {
            return 223 /* OmittedExpression */;
        };

        OmittedExpressionSyntax.prototype.childCount = function () {
            return 0;
        };

        OmittedExpressionSyntax.prototype.childAt = function (slot) {
            throw TypeScript.Errors.invalidOperation();
        };

        OmittedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        OmittedExpressionSyntax.prototype.update = function () {
            return this;
        };

        OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return OmittedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.OmittedExpressionSyntax = OmittedExpressionSyntax;

    var ParenthesizedExpressionSyntax = (function (_super) {
        __extends(ParenthesizedExpressionSyntax, _super);
        function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
        }
        ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedExpression(this);
        };

        ParenthesizedExpressionSyntax.prototype.kind = function () {
            return 217 /* ParenthesizedExpression */;
        };

        ParenthesizedExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.expression;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
            if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
        };

        ParenthesizedExpressionSyntax.create1 = function (expression) {
            return new ParenthesizedExpressionSyntax(TypeScript.Syntax.token(72 /* OpenParenToken */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.openParenToken, expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.expression, closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParenthesizedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;

    var ArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ArrowFunctionExpressionSyntax, _super);
        function ArrowFunctionExpressionSyntax(equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.body = body;
        }
        ArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrowFunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrowFunctionExpressionSyntax = ArrowFunctionExpressionSyntax;

    var SimpleArrowFunctionExpressionSyntax = (function (_super) {
        __extends(SimpleArrowFunctionExpressionSyntax, _super);
        function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.identifier = identifier;
        }
        SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimpleArrowFunctionExpression(this);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 219 /* SimpleArrowFunctionExpression */;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, body) {
            if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        SimpleArrowFunctionExpressionSyntax.create1 = function (identifier, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), body, false);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.identifier, equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.identifier, this.equalsGreaterThanToken, body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SimpleArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;

    var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
        function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.callSignature = callSignature;
        }
        ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedArrowFunctionExpression(this);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 218 /* ParenthesizedArrowFunctionExpression */;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.callSignature;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, body) {
            if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        ParenthesizedArrowFunctionExpressionSyntax.create1 = function (body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), body, false);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(callSignature, this.equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.callSignature, equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ParenthesizedArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;

    var QualifiedNameSyntax = (function (_super) {
        __extends(QualifiedNameSyntax, _super);
        function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.dotToken = dotToken;
            this.right = right;
        }
        QualifiedNameSyntax.prototype.accept = function (visitor) {
            return visitor.visitQualifiedName(this);
        };

        QualifiedNameSyntax.prototype.kind = function () {
            return 121 /* QualifiedName */;
        };

        QualifiedNameSyntax.prototype.childCount = function () {
            return 3;
        };

        QualifiedNameSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        QualifiedNameSyntax.prototype.isName = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isType = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
            if (this.left === left && this.dotToken === dotToken && this.right === right) {
                return this;
            }

            return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
        };

        QualifiedNameSyntax.create1 = function (left, right) {
            return new QualifiedNameSyntax(left, TypeScript.Syntax.token(76 /* DotToken */), right, false);
        };

        QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withLeft = function (left) {
            return this.update(left, this.dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.left, dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withRight = function (right) {
            return this.update(this.left, this.dotToken, right);
        };

        QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return QualifiedNameSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.QualifiedNameSyntax = QualifiedNameSyntax;

    var TypeArgumentListSyntax = (function (_super) {
        __extends(TypeArgumentListSyntax, _super);
        function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeArguments = typeArguments;
            this.greaterThanToken = greaterThanToken;
        }
        TypeArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeArgumentList(this);
        };

        TypeArgumentListSyntax.prototype.kind = function () {
            return 228 /* TypeArgumentList */;
        };

        TypeArgumentListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeArguments;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
        };

        TypeArgumentListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeArgumentListSyntax.create1 = function () {
            return new TypeArgumentListSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(81 /* GreaterThanToken */), false);
        };

        TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
            return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
            return this.withTypeArguments(TypeScript.Syntax.separatedList([typeArgument]));
        };

        TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeArgumentListSyntax = TypeArgumentListSyntax;

    var ConstructorTypeSyntax = (function (_super) {
        __extends(ConstructorTypeSyntax, _super);
        function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        ConstructorTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorType(this);
        };

        ConstructorTypeSyntax.prototype.kind = function () {
            return 125 /* ConstructorType */;
        };

        ConstructorTypeSyntax.prototype.childCount = function () {
            return 5;
        };

        ConstructorTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.typeParameterList;
                case 2:
                    return this.parameterList;
                case 3:
                    return this.equalsGreaterThanToken;
                case 4:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorTypeSyntax.prototype.isType = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        ConstructorTypeSyntax.create = function (newKeyword, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
        };

        ConstructorTypeSyntax.create1 = function (type) {
            return new ConstructorTypeSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), null, ParameterListSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), type, false);
        };

        ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withType = function (type) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorTypeSyntax = ConstructorTypeSyntax;

    var FunctionTypeSyntax = (function (_super) {
        __extends(FunctionTypeSyntax, _super);
        function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        FunctionTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionType(this);
        };

        FunctionTypeSyntax.prototype.kind = function () {
            return 123 /* FunctionType */;
        };

        FunctionTypeSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.equalsGreaterThanToken;
                case 3:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionTypeSyntax.prototype.isType = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        FunctionTypeSyntax.create = function (parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
        };

        FunctionTypeSyntax.create1 = function (type) {
            return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), type, false);
        };

        FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withType = function (type) {
            return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return FunctionTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionTypeSyntax = FunctionTypeSyntax;

    var ObjectTypeSyntax = (function (_super) {
        __extends(ObjectTypeSyntax, _super);
        function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.typeMembers = typeMembers;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectType(this);
        };

        ObjectTypeSyntax.prototype.kind = function () {
            return 122 /* ObjectType */;
        };

        ObjectTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.typeMembers;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectTypeSyntax.prototype.isType = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectTypeSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectTypeSyntax.create1 = function () {
            return new ObjectTypeSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
            return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
            return this.withTypeMembers(TypeScript.Syntax.separatedList([typeMember]));
        };

        ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
        };

        ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ObjectTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectTypeSyntax = ObjectTypeSyntax;

    var ArrayTypeSyntax = (function (_super) {
        __extends(ArrayTypeSyntax, _super);
        function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.type = type;
            this.openBracketToken = openBracketToken;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayType(this);
        };

        ArrayTypeSyntax.prototype.kind = function () {
            return 124 /* ArrayType */;
        };

        ArrayTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.type;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayTypeSyntax.prototype.isType = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
            if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayTypeSyntax.create1 = function (type) {
            return new ArrayTypeSyntax(type, TypeScript.Syntax.token(74 /* OpenBracketToken */), TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withType = function (type) {
            return this.update(type, this.openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.type, openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.type, this.openBracketToken, closeBracketToken);
        };

        ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrayTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayTypeSyntax = ArrayTypeSyntax;

    var GenericTypeSyntax = (function (_super) {
        __extends(GenericTypeSyntax, _super);
        function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.name = name;
            this.typeArgumentList = typeArgumentList;
        }
        GenericTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitGenericType(this);
        };

        GenericTypeSyntax.prototype.kind = function () {
            return 126 /* GenericType */;
        };

        GenericTypeSyntax.prototype.childCount = function () {
            return 2;
        };

        GenericTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.name;
                case 1:
                    return this.typeArgumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GenericTypeSyntax.prototype.isType = function () {
            return true;
        };

        GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
            if (this.name === name && this.typeArgumentList === typeArgumentList) {
                return this;
            }

            return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
        };

        GenericTypeSyntax.create1 = function (name) {
            return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
        };

        GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withName = function (name) {
            return this.update(name, this.typeArgumentList);
        };

        GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(this.name, typeArgumentList);
        };

        GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GenericTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.GenericTypeSyntax = GenericTypeSyntax;

    var TypeQuerySyntax = (function (_super) {
        __extends(TypeQuerySyntax, _super);
        function TypeQuerySyntax(typeOfKeyword, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.name = name;
        }
        TypeQuerySyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeQuery(this);
        };

        TypeQuerySyntax.prototype.kind = function () {
            return 127 /* TypeQuery */;
        };

        TypeQuerySyntax.prototype.childCount = function () {
            return 2;
        };

        TypeQuerySyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeQuerySyntax.prototype.isType = function () {
            return true;
        };

        TypeQuerySyntax.prototype.update = function (typeOfKeyword, name) {
            if (this.typeOfKeyword === typeOfKeyword && this.name === name) {
                return this;
            }

            return new TypeQuerySyntax(typeOfKeyword, name, this.parsedInStrictMode());
        };

        TypeQuerySyntax.create1 = function (name) {
            return new TypeQuerySyntax(TypeScript.Syntax.token(39 /* TypeOfKeyword */), name, false);
        };

        TypeQuerySyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeQuerySyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeQuerySyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.name);
        };

        TypeQuerySyntax.prototype.withName = function (name) {
            return this.update(this.typeOfKeyword, name);
        };

        TypeQuerySyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeQuerySyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeQuerySyntax = TypeQuerySyntax;

    var TypeAnnotationSyntax = (function (_super) {
        __extends(TypeAnnotationSyntax, _super);
        function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.type = type;
        }
        TypeAnnotationSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeAnnotation(this);
        };

        TypeAnnotationSyntax.prototype.kind = function () {
            return 245 /* TypeAnnotation */;
        };

        TypeAnnotationSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeAnnotationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.colonToken;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
            if (this.colonToken === colonToken && this.type === type) {
                return this;
            }

            return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
        };

        TypeAnnotationSyntax.create1 = function (type) {
            return new TypeAnnotationSyntax(TypeScript.Syntax.token(106 /* ColonToken */), type, false);
        };

        TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(colonToken, this.type);
        };

        TypeAnnotationSyntax.prototype.withType = function (type) {
            return this.update(this.colonToken, type);
        };

        TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeAnnotationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeAnnotationSyntax = TypeAnnotationSyntax;

    var BlockSyntax = (function (_super) {
        __extends(BlockSyntax, _super);
        function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.statements = statements;
            this.closeBraceToken = closeBraceToken;
        }
        BlockSyntax.prototype.accept = function (visitor) {
            return visitor.visitBlock(this);
        };

        BlockSyntax.prototype.kind = function () {
            return 146 /* Block */;
        };

        BlockSyntax.prototype.childCount = function () {
            return 3;
        };

        BlockSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.statements;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BlockSyntax.prototype.isStatement = function () {
            return true;
        };

        BlockSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
        };

        BlockSyntax.create = function (openBraceToken, closeBraceToken) {
            return new BlockSyntax(openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        BlockSyntax.create1 = function () {
            return new BlockSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatements = function (statements) {
            return this.update(this.openBraceToken, statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.statements, closeBraceToken);
        };

        BlockSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BlockSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BlockSyntax = BlockSyntax;

    var ParameterSyntax = (function (_super) {
        __extends(ParameterSyntax, _super);
        function ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.dotDotDotToken = dotDotDotToken;
            this.publicOrPrivateKeyword = publicOrPrivateKeyword;
            this.identifier = identifier;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        ParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameter(this);
        };

        ParameterSyntax.prototype.kind = function () {
            return 243 /* Parameter */;
        };

        ParameterSyntax.prototype.childCount = function () {
            return 6;
        };

        ParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.dotDotDotToken;
                case 1:
                    return this.publicOrPrivateKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.questionToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterSyntax.prototype.update = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        ParameterSyntax.create = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.create1 = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
            return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
            return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
        };

        ParameterSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.dotDotDotToken !== null) {
                return true;
            }
            if (this.publicOrPrivateKeyword !== null) {
                return true;
            }
            if (this.questionToken !== null) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null) {
                return true;
            }
            return false;
        };
        return ParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterSyntax = ParameterSyntax;

    var MemberAccessExpressionSyntax = (function (_super) {
        __extends(MemberAccessExpressionSyntax, _super);
        function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.dotToken = dotToken;
            this.name = name;
        }
        MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberAccessExpression(this);
        };

        MemberAccessExpressionSyntax.prototype.kind = function () {
            return 212 /* MemberAccessExpression */;
        };

        MemberAccessExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberAccessExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
            if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
                return this;
            }

            return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
        };

        MemberAccessExpressionSyntax.create1 = function (expression, name) {
            return new MemberAccessExpressionSyntax(expression, TypeScript.Syntax.token(76 /* DotToken */), name, false);
        };

        MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.expression, dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withName = function (name) {
            return this.update(this.expression, this.dotToken, name);
        };

        MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MemberAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;

    var PostfixUnaryExpressionSyntax = (function (_super) {
        __extends(PostfixUnaryExpressionSyntax, _super);
        function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operand = operand;
            this.operatorToken = operatorToken;

            this._kind = kind;
        }
        PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPostfixUnaryExpression(this);
        };

        PostfixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operand;
                case 1:
                    return this.operatorToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PostfixUnaryExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
            if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
                return this;
            }

            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
        };

        PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.operand, operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PostfixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;

    var ElementAccessExpressionSyntax = (function (_super) {
        __extends(ElementAccessExpressionSyntax, _super);
        function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.openBracketToken = openBracketToken;
            this.argumentExpression = argumentExpression;
            this.closeBracketToken = closeBracketToken;
        }
        ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitElementAccessExpression(this);
        };

        ElementAccessExpressionSyntax.prototype.kind = function () {
            return 221 /* ElementAccessExpression */;
        };

        ElementAccessExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.argumentExpression;
                case 3:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElementAccessExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
        };

        ElementAccessExpressionSyntax.create1 = function (expression, argumentExpression) {
            return new ElementAccessExpressionSyntax(expression, TypeScript.Syntax.token(74 /* OpenBracketToken */), argumentExpression, TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
            return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentExpression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElementAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;

    var InvocationExpressionSyntax = (function (_super) {
        __extends(InvocationExpressionSyntax, _super);
        function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.argumentList = argumentList;
        }
        InvocationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitInvocationExpression(this);
        };

        InvocationExpressionSyntax.prototype.kind = function () {
            return 213 /* InvocationExpression */;
        };

        InvocationExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        InvocationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InvocationExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
            if (this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
        };

        InvocationExpressionSyntax.create1 = function (expression) {
            return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
        };

        InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.argumentList);
        };

        InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.expression, argumentList);
        };

        InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return InvocationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InvocationExpressionSyntax = InvocationExpressionSyntax;

    var ArgumentListSyntax = (function (_super) {
        __extends(ArgumentListSyntax, _super);
        function ArgumentListSyntax(typeArgumentList, openParenToken, arguments, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeArgumentList = typeArgumentList;
            this.openParenToken = openParenToken;
            this.arguments = arguments;
            this.closeParenToken = closeParenToken;
        }
        ArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitArgumentList(this);
        };

        ArgumentListSyntax.prototype.kind = function () {
            return 226 /* ArgumentList */;
        };

        ArgumentListSyntax.prototype.childCount = function () {
            return 4;
        };

        ArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeArgumentList;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.arguments;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, this.parsedInStrictMode());
        };

        ArgumentListSyntax.create = function (openParenToken, closeParenToken) {
            return new ArgumentListSyntax(null, openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ArgumentListSyntax.create1 = function () {
            return new ArgumentListSyntax(null, TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArguments = function (_arguments) {
            return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArgument = function (_argument) {
            return this.withArguments(TypeScript.Syntax.separatedList([_argument]));
        };

        ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
        };

        ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.arguments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArgumentListSyntax = ArgumentListSyntax;

    var BinaryExpressionSyntax = (function (_super) {
        __extends(BinaryExpressionSyntax, _super);
        function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.operatorToken = operatorToken;
            this.right = right;

            this._kind = kind;
        }
        BinaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitBinaryExpression(this);
        };

        BinaryExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        BinaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.operatorToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BinaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        BinaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
            if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
                return this;
            }

            return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
        };

        BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withLeft = function (left) {
            return this.update(this._kind, left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.left, operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withRight = function (right) {
            return this.update(this._kind, this.left, this.operatorToken, right);
        };

        BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.right.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BinaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BinaryExpressionSyntax = BinaryExpressionSyntax;

    var ConditionalExpressionSyntax = (function (_super) {
        __extends(ConditionalExpressionSyntax, _super);
        function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.condition = condition;
            this.questionToken = questionToken;
            this.whenTrue = whenTrue;
            this.colonToken = colonToken;
            this.whenFalse = whenFalse;
        }
        ConditionalExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitConditionalExpression(this);
        };

        ConditionalExpressionSyntax.prototype.kind = function () {
            return 186 /* ConditionalExpression */;
        };

        ConditionalExpressionSyntax.prototype.childCount = function () {
            return 5;
        };

        ConditionalExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.condition;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.whenTrue;
                case 3:
                    return this.colonToken;
                case 4:
                    return this.whenFalse;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConditionalExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
                return this;
            }

            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
        };

        ConditionalExpressionSyntax.create1 = function (condition, whenTrue, whenFalse) {
            return new ConditionalExpressionSyntax(condition, TypeScript.Syntax.token(105 /* QuestionToken */), whenTrue, TypeScript.Syntax.token(106 /* ColonToken */), whenFalse, false);
        };

        ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
            return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
            return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
            return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
        };

        ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenTrue.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenFalse.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ConditionalExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConditionalExpressionSyntax = ConditionalExpressionSyntax;

    var ConstructSignatureSyntax = (function (_super) {
        __extends(ConstructSignatureSyntax, _super);
        function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.callSignature = callSignature;
        }
        ConstructSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructSignature(this);
        };

        ConstructSignatureSyntax.prototype.kind = function () {
            return 143 /* ConstructSignature */;
        };

        ConstructSignatureSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstructSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
            if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
                return this;
            }

            return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
        };

        ConstructSignatureSyntax.create1 = function () {
            return new ConstructSignatureSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), CallSignatureSyntax.create1(), false);
        };

        ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.callSignature);
        };

        ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.newKeyword, callSignature);
        };

        ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructSignatureSyntax = ConstructSignatureSyntax;

    var MethodSignatureSyntax = (function (_super) {
        __extends(MethodSignatureSyntax, _super);
        function MethodSignatureSyntax(propertyName, questionToken, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.callSignature = callSignature;
        }
        MethodSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitMethodSignature(this);
        };

        MethodSignatureSyntax.prototype.kind = function () {
            return 145 /* MethodSignature */;
        };

        MethodSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        MethodSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MethodSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        MethodSignatureSyntax.prototype.update = function (propertyName, questionToken, callSignature) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
                return this;
            }

            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, this.parsedInStrictMode());
        };

        MethodSignatureSyntax.create = function (propertyName, callSignature) {
            return new MethodSignatureSyntax(propertyName, null, callSignature, false);
        };

        MethodSignatureSyntax.create1 = function (propertyName) {
            return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), false);
        };

        MethodSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, this.questionToken, callSignature);
        };

        MethodSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MethodSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MethodSignatureSyntax = MethodSignatureSyntax;

    var IndexSignatureSyntax = (function (_super) {
        __extends(IndexSignatureSyntax, _super);
        function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.parameter = parameter;
            this.closeBracketToken = closeBracketToken;
            this.typeAnnotation = typeAnnotation;
        }
        IndexSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexSignature(this);
        };

        IndexSignatureSyntax.prototype.kind = function () {
            return 144 /* IndexSignature */;
        };

        IndexSignatureSyntax.prototype.childCount = function () {
            return 4;
        };

        IndexSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.parameter;
                case 2:
                    return this.closeBracketToken;
                case 3:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IndexSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
        };

        IndexSignatureSyntax.create = function (openBracketToken, parameter, closeBracketToken) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
        };

        IndexSignatureSyntax.create1 = function (parameter) {
            return new IndexSignatureSyntax(TypeScript.Syntax.token(74 /* OpenBracketToken */), parameter, TypeScript.Syntax.token(75 /* CloseBracketToken */), null, false);
        };

        IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
        };

        IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IndexSignatureSyntax = IndexSignatureSyntax;

    var PropertySignatureSyntax = (function (_super) {
        __extends(PropertySignatureSyntax, _super);
        function PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
        }
        PropertySignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitPropertySignature(this);
        };

        PropertySignatureSyntax.prototype.kind = function () {
            return 141 /* PropertySignature */;
        };

        PropertySignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        PropertySignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PropertySignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        PropertySignatureSyntax.prototype.update = function (propertyName, questionToken, typeAnnotation) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, this.parsedInStrictMode());
        };

        PropertySignatureSyntax.create = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.create1 = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, this.questionToken, typeAnnotation);
        };

        PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return PropertySignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertySignatureSyntax = PropertySignatureSyntax;

    var CallSignatureSyntax = (function (_super) {
        __extends(CallSignatureSyntax, _super);
        function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.typeAnnotation = typeAnnotation;
        }
        CallSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitCallSignature(this);
        };

        CallSignatureSyntax.prototype.kind = function () {
            return 142 /* CallSignature */;
        };

        CallSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        CallSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CallSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
        };

        CallSignatureSyntax.create = function (parameterList) {
            return new CallSignatureSyntax(null, parameterList, null, false);
        };

        CallSignatureSyntax.create1 = function () {
            return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
        };

        CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
        };

        CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeParameterList !== null) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            return false;
        };
        return CallSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CallSignatureSyntax = CallSignatureSyntax;

    var ParameterListSyntax = (function (_super) {
        __extends(ParameterListSyntax, _super);
        function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.parameters = parameters;
            this.closeParenToken = closeParenToken;
        }
        ParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameterList(this);
        };

        ParameterListSyntax.prototype.kind = function () {
            return 227 /* ParameterList */;
        };

        ParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        ParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.parameters;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
            if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
        };

        ParameterListSyntax.create = function (openParenToken, closeParenToken) {
            return new ParameterListSyntax(openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ParameterListSyntax.create1 = function () {
            return new ParameterListSyntax(TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameters = function (parameters) {
            return this.update(this.openParenToken, parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameter = function (parameter) {
            return this.withParameters(TypeScript.Syntax.separatedList([parameter]));
        };

        ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.parameters, closeParenToken);
        };

        ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameters.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterListSyntax = ParameterListSyntax;

    var TypeParameterListSyntax = (function (_super) {
        __extends(TypeParameterListSyntax, _super);
        function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeParameters = typeParameters;
            this.greaterThanToken = greaterThanToken;
        }
        TypeParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameterList(this);
        };

        TypeParameterListSyntax.prototype.kind = function () {
            return 229 /* TypeParameterList */;
        };

        TypeParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeParameters;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
        };

        TypeParameterListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeParameterListSyntax.create1 = function () {
            return new TypeParameterListSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(81 /* GreaterThanToken */), false);
        };

        TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
            return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
            return this.withTypeParameters(TypeScript.Syntax.separatedList([typeParameter]));
        };

        TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
        };

        TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterListSyntax = TypeParameterListSyntax;

    var TypeParameterSyntax = (function (_super) {
        __extends(TypeParameterSyntax, _super);
        function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.constraint = constraint;
        }
        TypeParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameter(this);
        };

        TypeParameterSyntax.prototype.kind = function () {
            return 237 /* TypeParameter */;
        };

        TypeParameterSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.constraint;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterSyntax.prototype.update = function (identifier, constraint) {
            if (this.identifier === identifier && this.constraint === constraint) {
                return this;
            }

            return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
        };

        TypeParameterSyntax.create = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.create1 = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.constraint);
        };

        TypeParameterSyntax.prototype.withConstraint = function (constraint) {
            return this.update(this.identifier, constraint);
        };

        TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterSyntax = TypeParameterSyntax;

    var ConstraintSyntax = (function (_super) {
        __extends(ConstraintSyntax, _super);
        function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsKeyword = extendsKeyword;
            this.type = type;
        }
        ConstraintSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstraint(this);
        };

        ConstraintSyntax.prototype.kind = function () {
            return 238 /* Constraint */;
        };

        ConstraintSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstraintSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsKeyword;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
            if (this.extendsKeyword === extendsKeyword && this.type === type) {
                return this;
            }

            return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
        };

        ConstraintSyntax.create1 = function (type) {
            return new ConstraintSyntax(TypeScript.Syntax.token(48 /* ExtendsKeyword */), type, false);
        };

        ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
            return this.update(extendsKeyword, this.type);
        };

        ConstraintSyntax.prototype.withType = function (type) {
            return this.update(this.extendsKeyword, type);
        };

        ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstraintSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstraintSyntax = ConstraintSyntax;

    var ElseClauseSyntax = (function (_super) {
        __extends(ElseClauseSyntax, _super);
        function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.elseKeyword = elseKeyword;
            this.statement = statement;
        }
        ElseClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitElseClause(this);
        };

        ElseClauseSyntax.prototype.kind = function () {
            return 234 /* ElseClause */;
        };

        ElseClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        ElseClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.elseKeyword;
                case 1:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
            if (this.elseKeyword === elseKeyword && this.statement === statement) {
                return this;
            }

            return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
        };

        ElseClauseSyntax.create1 = function (statement) {
            return new ElseClauseSyntax(TypeScript.Syntax.token(23 /* ElseKeyword */), statement, false);
        };

        ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
            return this.update(elseKeyword, this.statement);
        };

        ElseClauseSyntax.prototype.withStatement = function (statement) {
            return this.update(this.elseKeyword, statement);
        };

        ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElseClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElseClauseSyntax = ElseClauseSyntax;

    var IfStatementSyntax = (function (_super) {
        __extends(IfStatementSyntax, _super);
        function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.ifKeyword = ifKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
            this.elseClause = elseClause;
        }
        IfStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitIfStatement(this);
        };

        IfStatementSyntax.prototype.kind = function () {
            return 147 /* IfStatement */;
        };

        IfStatementSyntax.prototype.childCount = function () {
            return 6;
        };

        IfStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.ifKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                case 5:
                    return this.elseClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IfStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IfStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
                return this;
            }

            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
        };

        IfStatementSyntax.create = function (ifKeyword, openParenToken, condition, closeParenToken, statement) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
        };

        IfStatementSyntax.create1 = function (condition, statement) {
            return new IfStatementSyntax(TypeScript.Syntax.token(28 /* IfKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, null, false);
        };

        IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
            return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withElseClause = function (elseClause) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
        };

        IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return IfStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IfStatementSyntax = IfStatementSyntax;

    var ExpressionStatementSyntax = (function (_super) {
        __extends(ExpressionStatementSyntax, _super);
        function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ExpressionStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitExpressionStatement(this);
        };

        ExpressionStatementSyntax.prototype.kind = function () {
            return 149 /* ExpressionStatement */;
        };

        ExpressionStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        ExpressionStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExpressionStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
            if (this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
        };

        ExpressionStatementSyntax.create1 = function (expression) {
            return new ExpressionStatementSyntax(expression, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.semicolonToken);
        };

        ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.expression, semicolonToken);
        };

        ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ExpressionStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExpressionStatementSyntax = ExpressionStatementSyntax;

    var ConstructorDeclarationSyntax = (function (_super) {
        __extends(ConstructorDeclarationSyntax, _super);
        function ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.constructorKeyword = constructorKeyword;
            this.parameterList = parameterList;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorDeclaration(this);
        };

        ConstructorDeclarationSyntax.prototype.kind = function () {
            return 137 /* ConstructorDeclaration */;
        };

        ConstructorDeclarationSyntax.prototype.childCount = function () {
            return 4;
        };

        ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.constructorKeyword;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.block;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        ConstructorDeclarationSyntax.prototype.update = function (constructorKeyword, parameterList, block, semicolonToken) {
            if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
        };

        ConstructorDeclarationSyntax.create = function (constructorKeyword, parameterList) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, false);
        };

        ConstructorDeclarationSyntax.create1 = function () {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.token(62 /* ConstructorKeyword */), ParameterListSyntax.create1(), null, null, false);
        };

        ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
            return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;

    var MemberFunctionDeclarationSyntax = (function (_super) {
        __extends(MemberFunctionDeclarationSyntax, _super);
        function MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberFunctionDeclaration(this);
        };

        MemberFunctionDeclarationSyntax.prototype.kind = function () {
            return 135 /* MemberFunctionDeclaration */;
        };

        MemberFunctionDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.update = function (modifiers, propertyName, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        MemberFunctionDeclarationSyntax.create = function (propertyName, callSignature) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, callSignature, null, null, false);
        };

        MemberFunctionDeclarationSyntax.create1 = function (propertyName) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, CallSignatureSyntax.create1(), null, null, false);
        };

        MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberFunctionDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.propertyName, callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, this.block, semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberFunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;

    var MemberAccessorDeclarationSyntax = (function (_super) {
        __extends(MemberAccessorDeclarationSyntax, _super);
        function MemberAccessorDeclarationSyntax(modifiers, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.parameterList = parameterList;
            this.block = block;
        }
        MemberAccessorDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberAccessorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessorDeclarationSyntax = MemberAccessorDeclarationSyntax;

    var GetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(GetMemberAccessorDeclarationSyntax, _super);
        function GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetMemberAccessorDeclaration(this);
        };

        GetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 138 /* GetMemberAccessorDeclaration */;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.getKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
            if (this.modifiers === modifiers && this.getKeyword === getKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetMemberAccessorDeclarationSyntax.create = function (getKeyword, propertyName, parameterList, block) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, getKeyword, propertyName, parameterList, null, block, false);
        };

        GetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(64 /* GetKeyword */), propertyName, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        GetMemberAccessorDeclarationSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(this.modifiers, getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.getKeyword, propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.GetMemberAccessorDeclarationSyntax = GetMemberAccessorDeclarationSyntax;

    var SetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(SetMemberAccessorDeclarationSyntax, _super);
        function SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
        }
        SetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetMemberAccessorDeclaration(this);
        };

        SetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 139 /* SetMemberAccessorDeclaration */;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.setKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, setKeyword, propertyName, parameterList, block) {
            if (this.modifiers === modifiers && this.setKeyword === setKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.block === block) {
                return this;
            }

            return new SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, this.parsedInStrictMode());
        };

        SetMemberAccessorDeclarationSyntax.create = function (setKeyword, propertyName, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, setKeyword, propertyName, parameterList, block, false);
        };

        SetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(68 /* SetKeyword */), propertyName, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        SetMemberAccessorDeclarationSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(this.modifiers, setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.setKeyword, propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, this.parameterList, block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.SetMemberAccessorDeclarationSyntax = SetMemberAccessorDeclarationSyntax;

    var MemberVariableDeclarationSyntax = (function (_super) {
        __extends(MemberVariableDeclarationSyntax, _super);
        function MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclarator = variableDeclarator;
            this.semicolonToken = semicolonToken;
        }
        MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberVariableDeclaration(this);
        };

        MemberVariableDeclarationSyntax.prototype.kind = function () {
            return 136 /* MemberVariableDeclaration */;
        };

        MemberVariableDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclarator;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.update = function (modifiers, variableDeclarator, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, this.parsedInStrictMode());
        };

        MemberVariableDeclarationSyntax.create = function (variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, semicolonToken, false);
        };

        MemberVariableDeclarationSyntax.create1 = function (variableDeclarator) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.update(this.modifiers, variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclarator, semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberVariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;

    var IndexMemberDeclaration = (function (_super) {
        __extends(IndexMemberDeclaration, _super);
        function IndexMemberDeclaration(modifiers, indexSignature, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.indexSignature = indexSignature;
            this.semicolonToken = semicolonToken;
        }
        IndexMemberDeclaration.prototype.accept = function (visitor) {
            return visitor.visitIndexMemberDeclaration(this);
        };

        IndexMemberDeclaration.prototype.kind = function () {
            return 140 /* IndexMemberDeclaration */;
        };

        IndexMemberDeclaration.prototype.childCount = function () {
            return 3;
        };

        IndexMemberDeclaration.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.indexSignature;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IndexMemberDeclaration.prototype.isClassElement = function () {
            return true;
        };

        IndexMemberDeclaration.prototype.update = function (modifiers, indexSignature, semicolonToken) {
            if (this.modifiers === modifiers && this.indexSignature === indexSignature && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new IndexMemberDeclaration(modifiers, indexSignature, semicolonToken, this.parsedInStrictMode());
        };

        IndexMemberDeclaration.create = function (indexSignature, semicolonToken) {
            return new IndexMemberDeclaration(TypeScript.Syntax.emptyList, indexSignature, semicolonToken, false);
        };

        IndexMemberDeclaration.create1 = function (indexSignature) {
            return new IndexMemberDeclaration(TypeScript.Syntax.emptyList, indexSignature, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        IndexMemberDeclaration.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IndexMemberDeclaration.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IndexMemberDeclaration.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.indexSignature, this.semicolonToken);
        };

        IndexMemberDeclaration.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        IndexMemberDeclaration.prototype.withIndexSignature = function (indexSignature) {
            return this.update(this.modifiers, indexSignature, this.semicolonToken);
        };

        IndexMemberDeclaration.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.indexSignature, semicolonToken);
        };

        IndexMemberDeclaration.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexMemberDeclaration;
    })(TypeScript.SyntaxNode);
    TypeScript.IndexMemberDeclaration = IndexMemberDeclaration;

    var ThrowStatementSyntax = (function (_super) {
        __extends(ThrowStatementSyntax, _super);
        function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.throwKeyword = throwKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ThrowStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitThrowStatement(this);
        };

        ThrowStatementSyntax.prototype.kind = function () {
            return 157 /* ThrowStatement */;
        };

        ThrowStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ThrowStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.throwKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ThrowStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
            if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ThrowStatementSyntax.create1 = function (expression) {
            return new ThrowStatementSyntax(TypeScript.Syntax.token(36 /* ThrowKeyword */), expression, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
            return this.update(throwKeyword, this.expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.throwKeyword, expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.throwKeyword, this.expression, semicolonToken);
        };

        ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ThrowStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ThrowStatementSyntax = ThrowStatementSyntax;

    var ReturnStatementSyntax = (function (_super) {
        __extends(ReturnStatementSyntax, _super);
        function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.returnKeyword = returnKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ReturnStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitReturnStatement(this);
        };

        ReturnStatementSyntax.prototype.kind = function () {
            return 150 /* ReturnStatement */;
        };

        ReturnStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ReturnStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.returnKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ReturnStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
            if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ReturnStatementSyntax.create = function (returnKeyword, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
        };

        ReturnStatementSyntax.create1 = function () {
            return new ReturnStatementSyntax(TypeScript.Syntax.token(33 /* ReturnKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
            return this.update(returnKeyword, this.expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.returnKeyword, expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.returnKeyword, this.expression, semicolonToken);
        };

        ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ReturnStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ReturnStatementSyntax = ReturnStatementSyntax;

    var ObjectCreationExpressionSyntax = (function (_super) {
        __extends(ObjectCreationExpressionSyntax, _super);
        function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.expression = expression;
            this.argumentList = argumentList;
        }
        ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectCreationExpression(this);
        };

        ObjectCreationExpressionSyntax.prototype.kind = function () {
            return 216 /* ObjectCreationExpression */;
        };

        ObjectCreationExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectCreationExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
            if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
        };

        ObjectCreationExpressionSyntax.create = function (newKeyword, expression) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
        };

        ObjectCreationExpressionSyntax.create1 = function (expression) {
            return new ObjectCreationExpressionSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), expression, null, false);
        };

        ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.newKeyword, expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.newKeyword, this.expression, argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectCreationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;

    var SwitchStatementSyntax = (function (_super) {
        __extends(SwitchStatementSyntax, _super);
        function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.switchKeyword = switchKeyword;
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
            this.openBraceToken = openBraceToken;
            this.switchClauses = switchClauses;
            this.closeBraceToken = closeBraceToken;
        }
        SwitchStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitSwitchStatement(this);
        };

        SwitchStatementSyntax.prototype.kind = function () {
            return 151 /* SwitchStatement */;
        };

        SwitchStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        SwitchStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.switchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.expression;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.switchClauses;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SwitchStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
        };

        SwitchStatementSyntax.create = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        SwitchStatementSyntax.create1 = function (expression) {
            return new SwitchStatementSyntax(TypeScript.Syntax.token(34 /* SwitchKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
            return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
            return this.withSwitchClauses(TypeScript.Syntax.list([switchClause]));
        };

        SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
        };

        SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.switchClauses.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SwitchStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchStatementSyntax = SwitchStatementSyntax;

    var SwitchClauseSyntax = (function (_super) {
        __extends(SwitchClauseSyntax, _super);
        function SwitchClauseSyntax(colonToken, statements, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.statements = statements;
        }
        SwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };

        SwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return SwitchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchClauseSyntax = SwitchClauseSyntax;

    var CaseSwitchClauseSyntax = (function (_super) {
        __extends(CaseSwitchClauseSyntax, _super);
        function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.caseKeyword = caseKeyword;
            this.expression = expression;
        }
        CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCaseSwitchClause(this);
        };

        CaseSwitchClauseSyntax.prototype.kind = function () {
            return 232 /* CaseSwitchClause */;
        };

        CaseSwitchClauseSyntax.prototype.childCount = function () {
            return 4;
        };

        CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.caseKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.colonToken;
                case 3:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
            if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
        };

        CaseSwitchClauseSyntax.create = function (caseKeyword, expression, colonToken) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.create1 = function (expression) {
            return new CaseSwitchClauseSyntax(TypeScript.Syntax.token(16 /* CaseKeyword */), expression, TypeScript.Syntax.token(106 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
            return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
            return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CaseSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;

    var DefaultSwitchClauseSyntax = (function (_super) {
        __extends(DefaultSwitchClauseSyntax, _super);
        function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.defaultKeyword = defaultKeyword;
        }
        DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitDefaultSwitchClause(this);
        };

        DefaultSwitchClauseSyntax.prototype.kind = function () {
            return 233 /* DefaultSwitchClause */;
        };

        DefaultSwitchClauseSyntax.prototype.childCount = function () {
            return 3;
        };

        DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.defaultKeyword;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
            if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
        };

        DefaultSwitchClauseSyntax.create = function (defaultKeyword, colonToken) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.create1 = function () {
            return new DefaultSwitchClauseSyntax(TypeScript.Syntax.token(20 /* DefaultKeyword */), TypeScript.Syntax.token(106 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
            return this.update(defaultKeyword, this.colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.defaultKeyword, colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.defaultKeyword, this.colonToken, statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DefaultSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;

    var BreakStatementSyntax = (function (_super) {
        __extends(BreakStatementSyntax, _super);
        function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.breakKeyword = breakKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        BreakStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitBreakStatement(this);
        };

        BreakStatementSyntax.prototype.kind = function () {
            return 152 /* BreakStatement */;
        };

        BreakStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        BreakStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.breakKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BreakStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
            if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        BreakStatementSyntax.create = function (breakKeyword, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
        };

        BreakStatementSyntax.create1 = function () {
            return new BreakStatementSyntax(TypeScript.Syntax.token(15 /* BreakKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
            return this.update(breakKeyword, this.identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.breakKeyword, identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.breakKeyword, this.identifier, semicolonToken);
        };

        BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BreakStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BreakStatementSyntax = BreakStatementSyntax;

    var ContinueStatementSyntax = (function (_super) {
        __extends(ContinueStatementSyntax, _super);
        function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.continueKeyword = continueKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ContinueStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitContinueStatement(this);
        };

        ContinueStatementSyntax.prototype.kind = function () {
            return 153 /* ContinueStatement */;
        };

        ContinueStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ContinueStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.continueKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ContinueStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
            if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ContinueStatementSyntax.create = function (continueKeyword, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
        };

        ContinueStatementSyntax.create1 = function () {
            return new ContinueStatementSyntax(TypeScript.Syntax.token(18 /* ContinueKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
            return this.update(continueKeyword, this.identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.continueKeyword, identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.continueKeyword, this.identifier, semicolonToken);
        };

        ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return ContinueStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ContinueStatementSyntax = ContinueStatementSyntax;

    var IterationStatementSyntax = (function (_super) {
        __extends(IterationStatementSyntax, _super);
        function IterationStatementSyntax(openParenToken, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        IterationStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return IterationStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IterationStatementSyntax = IterationStatementSyntax;

    var BaseForStatementSyntax = (function (_super) {
        __extends(BaseForStatementSyntax, _super);
        function BaseForStatementSyntax(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.forKeyword = forKeyword;
            this.variableDeclaration = variableDeclaration;
        }
        BaseForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BaseForStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.BaseForStatementSyntax = BaseForStatementSyntax;

    var ForStatementSyntax = (function (_super) {
        __extends(ForStatementSyntax, _super);
        function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.initializer = initializer;
            this.firstSemicolonToken = firstSemicolonToken;
            this.condition = condition;
            this.secondSemicolonToken = secondSemicolonToken;
            this.incrementor = incrementor;
        }
        ForStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForStatement(this);
        };

        ForStatementSyntax.prototype.kind = function () {
            return 154 /* ForStatement */;
        };

        ForStatementSyntax.prototype.childCount = function () {
            return 10;
        };

        ForStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.initializer;
                case 4:
                    return this.firstSemicolonToken;
                case 5:
                    return this.condition;
                case 6:
                    return this.secondSemicolonToken;
                case 7:
                    return this.incrementor;
                case 8:
                    return this.closeParenToken;
                case 9:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForStatementSyntax.create = function (forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
        };

        ForStatementSyntax.create1 = function (statement) {
            return new ForStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), null, null, TypeScript.Syntax.token(78 /* SemicolonToken */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), null, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withInitializer = function (initializer) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
        };

        ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForStatementSyntax = ForStatementSyntax;

    var ForInStatementSyntax = (function (_super) {
        __extends(ForInStatementSyntax, _super);
        function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.left = left;
            this.inKeyword = inKeyword;
            this.expression = expression;
        }
        ForInStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForInStatement(this);
        };

        ForInStatementSyntax.prototype.kind = function () {
            return 155 /* ForInStatement */;
        };

        ForInStatementSyntax.prototype.childCount = function () {
            return 8;
        };

        ForInStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.left;
                case 4:
                    return this.inKeyword;
                case 5:
                    return this.expression;
                case 6:
                    return this.closeParenToken;
                case 7:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForInStatementSyntax.create = function (forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
        };

        ForInStatementSyntax.create1 = function (expression, statement) {
            return new ForInStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), null, null, TypeScript.Syntax.token(29 /* InKeyword */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withLeft = function (left) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
        };

        ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.left !== null && this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForInStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForInStatementSyntax = ForInStatementSyntax;

    var WhileStatementSyntax = (function (_super) {
        __extends(WhileStatementSyntax, _super);
        function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.whileKeyword = whileKeyword;
            this.condition = condition;
        }
        WhileStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWhileStatement(this);
        };

        WhileStatementSyntax.prototype.kind = function () {
            return 158 /* WhileStatement */;
        };

        WhileStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WhileStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.whileKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WhileStatementSyntax.create1 = function (condition, statement) {
            return new WhileStatementSyntax(TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WhileStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.WhileStatementSyntax = WhileStatementSyntax;

    var WithStatementSyntax = (function (_super) {
        __extends(WithStatementSyntax, _super);
        function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.withKeyword = withKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        WithStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWithStatement(this);
        };

        WithStatementSyntax.prototype.kind = function () {
            return 163 /* WithStatement */;
        };

        WithStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WithStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.withKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WithStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        WithStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WithStatementSyntax.create1 = function (condition, statement) {
            return new WithStatementSyntax(TypeScript.Syntax.token(43 /* WithKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
            return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WithStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.WithStatementSyntax = WithStatementSyntax;

    var EnumDeclarationSyntax = (function (_super) {
        __extends(EnumDeclarationSyntax, _super);
        function EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.enumKeyword = enumKeyword;
            this.identifier = identifier;
            this.openBraceToken = openBraceToken;
            this.enumElements = enumElements;
            this.closeBraceToken = closeBraceToken;
        }
        EnumDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumDeclaration(this);
        };

        EnumDeclarationSyntax.prototype.kind = function () {
            return 132 /* EnumDeclaration */;
        };

        EnumDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        EnumDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.enumKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.openBraceToken;
                case 4:
                    return this.enumElements;
                case 5:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EnumDeclarationSyntax.prototype.update = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, this.parsedInStrictMode());
        };

        EnumDeclarationSyntax.create = function (enumKeyword, identifier, openBraceToken, closeBraceToken) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, enumKeyword, identifier, openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        EnumDeclarationSyntax.create1 = function (identifier) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(46 /* EnumKeyword */), identifier, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
            return this.update(this.modifiers, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElements = function (enumElements) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElement = function (enumElement) {
            return this.withEnumElements(TypeScript.Syntax.separatedList([enumElement]));
        };

        EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return EnumDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumDeclarationSyntax = EnumDeclarationSyntax;

    var EnumElementSyntax = (function (_super) {
        __extends(EnumElementSyntax, _super);
        function EnumElementSyntax(propertyName, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.equalsValueClause = equalsValueClause;
        }
        EnumElementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumElement(this);
        };

        EnumElementSyntax.prototype.kind = function () {
            return 244 /* EnumElement */;
        };

        EnumElementSyntax.prototype.childCount = function () {
            return 2;
        };

        EnumElementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumElementSyntax.prototype.update = function (propertyName, equalsValueClause) {
            if (this.propertyName === propertyName && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new EnumElementSyntax(propertyName, equalsValueClause, this.parsedInStrictMode());
        };

        EnumElementSyntax.create = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.create1 = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.equalsValueClause);
        };

        EnumElementSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, equalsValueClause);
        };

        EnumElementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EnumElementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumElementSyntax = EnumElementSyntax;

    var CastExpressionSyntax = (function (_super) {
        __extends(CastExpressionSyntax, _super);
        function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.type = type;
            this.greaterThanToken = greaterThanToken;
            this.expression = expression;
        }
        CastExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitCastExpression(this);
        };

        CastExpressionSyntax.prototype.kind = function () {
            return 220 /* CastExpression */;
        };

        CastExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        CastExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.type;
                case 2:
                    return this.greaterThanToken;
                case 3:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CastExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
            if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
                return this;
            }

            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
        };

        CastExpressionSyntax.create1 = function (type, expression) {
            return new CastExpressionSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), type, TypeScript.Syntax.token(81 /* GreaterThanToken */), expression, false);
        };

        CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withType = function (type) {
            return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
        };

        CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return CastExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CastExpressionSyntax = CastExpressionSyntax;

    var ObjectLiteralExpressionSyntax = (function (_super) {
        __extends(ObjectLiteralExpressionSyntax, _super);
        function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.propertyAssignments = propertyAssignments;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectLiteralExpression(this);
        };

        ObjectLiteralExpressionSyntax.prototype.kind = function () {
            return 215 /* ObjectLiteralExpression */;
        };

        ObjectLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.propertyAssignments;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectLiteralExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectLiteralExpressionSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectLiteralExpressionSyntax.create1 = function () {
            return new ObjectLiteralExpressionSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
            return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
            return this.withPropertyAssignments(TypeScript.Syntax.separatedList([propertyAssignment]));
        };

        ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.propertyAssignments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;

    var PropertyAssignmentSyntax = (function (_super) {
        __extends(PropertyAssignmentSyntax, _super);
        function PropertyAssignmentSyntax(propertyName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
        }
        PropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return PropertyAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertyAssignmentSyntax = PropertyAssignmentSyntax;

    var SimplePropertyAssignmentSyntax = (function (_super) {
        __extends(SimplePropertyAssignmentSyntax, _super);
        function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.colonToken = colonToken;
            this.expression = expression;
        }
        SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimplePropertyAssignment(this);
        };

        SimplePropertyAssignmentSyntax.prototype.kind = function () {
            return 239 /* SimplePropertyAssignment */;
        };

        SimplePropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
            if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
                return this;
            }

            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
        };

        SimplePropertyAssignmentSyntax.create1 = function (propertyName, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, TypeScript.Syntax.token(106 /* ColonToken */), expression, false);
        };

        SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.propertyName, colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
            return this.update(this.propertyName, this.colonToken, expression);
        };

        SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SimplePropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;

    var FunctionPropertyAssignmentSyntax = (function (_super) {
        __extends(FunctionPropertyAssignmentSyntax, _super);
        function FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionPropertyAssignment(this);
        };

        FunctionPropertyAssignmentSyntax.prototype.kind = function () {
            return 242 /* FunctionPropertyAssignment */;
        };

        FunctionPropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        FunctionPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.callSignature;
                case 2:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionPropertyAssignmentSyntax.prototype.update = function (propertyName, callSignature, block) {
            if (this.propertyName === propertyName && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, this.parsedInStrictMode());
        };

        FunctionPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new FunctionPropertyAssignmentSyntax(propertyName, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.propertyName, this.callSignature, block);
        };

        FunctionPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;

    var AccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(AccessorPropertyAssignmentSyntax, _super);
        function AccessorPropertyAssignmentSyntax(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        AccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return AccessorPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.AccessorPropertyAssignmentSyntax = AccessorPropertyAssignmentSyntax;

    var GetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(GetAccessorPropertyAssignmentSyntax, _super);
        function GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetAccessorPropertyAssignment(this);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 240 /* GetAccessorPropertyAssignment */;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.getKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetAccessorPropertyAssignmentSyntax.prototype.update = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
            if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetAccessorPropertyAssignmentSyntax.create = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, null, block, false);
        };

        GetAccessorPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new GetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(64 /* GetKeyword */), propertyName, TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.token(73 /* CloseParenToken */), null, BlockSyntax.create1(), false);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return GetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.GetAccessorPropertyAssignmentSyntax = GetAccessorPropertyAssignmentSyntax;

    var SetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(SetAccessorPropertyAssignmentSyntax, _super);
        function SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
            this.parameter = parameter;
        }
        SetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetAccessorPropertyAssignment(this);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 241 /* SetAccessorPropertyAssignment */;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.setKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.parameter;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetAccessorPropertyAssignmentSyntax.prototype.update = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
            if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameter === parameter && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, this.parsedInStrictMode());
        };

        SetAccessorPropertyAssignmentSyntax.create1 = function (propertyName, parameter) {
            return new SetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(68 /* SetKeyword */), propertyName, TypeScript.Syntax.token(72 /* OpenParenToken */), parameter, TypeScript.Syntax.token(73 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameter.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.SetAccessorPropertyAssignmentSyntax = SetAccessorPropertyAssignmentSyntax;

    var FunctionExpressionSyntax = (function (_super) {
        __extends(FunctionExpressionSyntax, _super);
        function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionExpression(this);
        };

        FunctionExpressionSyntax.prototype.kind = function () {
            return 222 /* FunctionExpression */;
        };

        FunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.functionKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionExpressionSyntax.prototype.isPrimaryExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isMemberExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isPostfixExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
            if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
        };

        FunctionExpressionSyntax.create = function (functionKeyword, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
        };

        FunctionExpressionSyntax.create1 = function () {
            return new FunctionExpressionSyntax(TypeScript.Syntax.token(27 /* FunctionKeyword */), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
        };

        FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionExpressionSyntax = FunctionExpressionSyntax;

    var EmptyStatementSyntax = (function (_super) {
        __extends(EmptyStatementSyntax, _super);
        function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.semicolonToken = semicolonToken;
        }
        EmptyStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEmptyStatement(this);
        };

        EmptyStatementSyntax.prototype.kind = function () {
            return 156 /* EmptyStatement */;
        };

        EmptyStatementSyntax.prototype.childCount = function () {
            return 1;
        };

        EmptyStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EmptyStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.update = function (semicolonToken) {
            if (this.semicolonToken === semicolonToken) {
                return this;
            }

            return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
        };

        EmptyStatementSyntax.create1 = function () {
            return new EmptyStatementSyntax(TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(semicolonToken);
        };

        EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return EmptyStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EmptyStatementSyntax = EmptyStatementSyntax;

    var TryStatementSyntax = (function (_super) {
        __extends(TryStatementSyntax, _super);
        function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.tryKeyword = tryKeyword;
            this.block = block;
            this.catchClause = catchClause;
            this.finallyClause = finallyClause;
        }
        TryStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitTryStatement(this);
        };

        TryStatementSyntax.prototype.kind = function () {
            return 159 /* TryStatement */;
        };

        TryStatementSyntax.prototype.childCount = function () {
            return 4;
        };

        TryStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.tryKeyword;
                case 1:
                    return this.block;
                case 2:
                    return this.catchClause;
                case 3:
                    return this.finallyClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TryStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        TryStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
            if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
                return this;
            }

            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
        };

        TryStatementSyntax.create = function (tryKeyword, block) {
            return new TryStatementSyntax(tryKeyword, block, null, null, false);
        };

        TryStatementSyntax.create1 = function () {
            return new TryStatementSyntax(TypeScript.Syntax.token(38 /* TryKeyword */), BlockSyntax.create1(), null, null, false);
        };

        TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
            return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withBlock = function (block) {
            return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
            return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
            return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
        };

        TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
                return true;
            }
            if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TryStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TryStatementSyntax = TryStatementSyntax;

    var CatchClauseSyntax = (function (_super) {
        __extends(CatchClauseSyntax, _super);
        function CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.catchKeyword = catchKeyword;
            this.openParenToken = openParenToken;
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        CatchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCatchClause(this);
        };

        CatchClauseSyntax.prototype.kind = function () {
            return 235 /* CatchClause */;
        };

        CatchClauseSyntax.prototype.childCount = function () {
            return 6;
        };

        CatchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.catchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeAnnotation;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
            if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, this.parsedInStrictMode());
        };

        CatchClauseSyntax.create = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, false);
        };

        CatchClauseSyntax.create1 = function (identifier) {
            return new CatchClauseSyntax(TypeScript.Syntax.token(17 /* CatchKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), identifier, null, TypeScript.Syntax.token(73 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
            return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
        };

        CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CatchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CatchClauseSyntax = CatchClauseSyntax;

    var FinallyClauseSyntax = (function (_super) {
        __extends(FinallyClauseSyntax, _super);
        function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.finallyKeyword = finallyKeyword;
            this.block = block;
        }
        FinallyClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitFinallyClause(this);
        };

        FinallyClauseSyntax.prototype.kind = function () {
            return 236 /* FinallyClause */;
        };

        FinallyClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        FinallyClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.finallyKeyword;
                case 1:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
            if (this.finallyKeyword === finallyKeyword && this.block === block) {
                return this;
            }

            return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
        };

        FinallyClauseSyntax.create1 = function () {
            return new FinallyClauseSyntax(TypeScript.Syntax.token(25 /* FinallyKeyword */), BlockSyntax.create1(), false);
        };

        FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
            return this.update(finallyKeyword, this.block);
        };

        FinallyClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.finallyKeyword, block);
        };

        FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FinallyClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FinallyClauseSyntax = FinallyClauseSyntax;

    var LabeledStatementSyntax = (function (_super) {
        __extends(LabeledStatementSyntax, _super);
        function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.colonToken = colonToken;
            this.statement = statement;
        }
        LabeledStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitLabeledStatement(this);
        };

        LabeledStatementSyntax.prototype.kind = function () {
            return 160 /* LabeledStatement */;
        };

        LabeledStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        LabeledStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        LabeledStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
            if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
                return this;
            }

            return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
        };

        LabeledStatementSyntax.create1 = function (identifier, statement) {
            return new LabeledStatementSyntax(identifier, TypeScript.Syntax.token(106 /* ColonToken */), statement, false);
        };

        LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.identifier, colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.identifier, this.colonToken, statement);
        };

        LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return LabeledStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.LabeledStatementSyntax = LabeledStatementSyntax;

    var DoStatementSyntax = (function (_super) {
        __extends(DoStatementSyntax, _super);
        function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.doKeyword = doKeyword;
            this.whileKeyword = whileKeyword;
            this.condition = condition;
            this.semicolonToken = semicolonToken;
        }
        DoStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDoStatement(this);
        };

        DoStatementSyntax.prototype.kind = function () {
            return 161 /* DoStatement */;
        };

        DoStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        DoStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.doKeyword;
                case 1:
                    return this.statement;
                case 2:
                    return this.whileKeyword;
                case 3:
                    return this.openParenToken;
                case 4:
                    return this.condition;
                case 5:
                    return this.closeParenToken;
                case 6:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
        };

        DoStatementSyntax.create1 = function (statement, condition) {
            return new DoStatementSyntax(TypeScript.Syntax.token(22 /* DoKeyword */), statement, TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
            return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
        };

        DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DoStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.DoStatementSyntax = DoStatementSyntax;

    var TypeOfExpressionSyntax = (function (_super) {
        __extends(TypeOfExpressionSyntax, _super);
        function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.expression = expression;
        }
        TypeOfExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeOfExpression(this);
        };

        TypeOfExpressionSyntax.prototype.kind = function () {
            return 171 /* TypeOfExpression */;
        };

        TypeOfExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeOfExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
            if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
                return this;
            }

            return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
        };

        TypeOfExpressionSyntax.create1 = function (expression) {
            return new TypeOfExpressionSyntax(TypeScript.Syntax.token(39 /* TypeOfKeyword */), expression, false);
        };

        TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.expression);
        };

        TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.typeOfKeyword, expression);
        };

        TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TypeOfExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeOfExpressionSyntax = TypeOfExpressionSyntax;

    var DeleteExpressionSyntax = (function (_super) {
        __extends(DeleteExpressionSyntax, _super);
        function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.deleteKeyword = deleteKeyword;
            this.expression = expression;
        }
        DeleteExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitDeleteExpression(this);
        };

        DeleteExpressionSyntax.prototype.kind = function () {
            return 170 /* DeleteExpression */;
        };

        DeleteExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        DeleteExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.deleteKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
            if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
                return this;
            }

            return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
        };

        DeleteExpressionSyntax.create1 = function (expression) {
            return new DeleteExpressionSyntax(TypeScript.Syntax.token(21 /* DeleteKeyword */), expression, false);
        };

        DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
            return this.update(deleteKeyword, this.expression);
        };

        DeleteExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.deleteKeyword, expression);
        };

        DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DeleteExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DeleteExpressionSyntax = DeleteExpressionSyntax;

    var VoidExpressionSyntax = (function (_super) {
        __extends(VoidExpressionSyntax, _super);
        function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.voidKeyword = voidKeyword;
            this.expression = expression;
        }
        VoidExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitVoidExpression(this);
        };

        VoidExpressionSyntax.prototype.kind = function () {
            return 172 /* VoidExpression */;
        };

        VoidExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        VoidExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.voidKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VoidExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
            if (this.voidKeyword === voidKeyword && this.expression === expression) {
                return this;
            }

            return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
        };

        VoidExpressionSyntax.create1 = function (expression) {
            return new VoidExpressionSyntax(TypeScript.Syntax.token(41 /* VoidKeyword */), expression, false);
        };

        VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
            return this.update(voidKeyword, this.expression);
        };

        VoidExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.voidKeyword, expression);
        };

        VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VoidExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VoidExpressionSyntax = VoidExpressionSyntax;

    var DebuggerStatementSyntax = (function (_super) {
        __extends(DebuggerStatementSyntax, _super);
        function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.debuggerKeyword = debuggerKeyword;
            this.semicolonToken = semicolonToken;
        }
        DebuggerStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDebuggerStatement(this);
        };

        DebuggerStatementSyntax.prototype.kind = function () {
            return 162 /* DebuggerStatement */;
        };

        DebuggerStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        DebuggerStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.debuggerKeyword;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DebuggerStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
            if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
        };

        DebuggerStatementSyntax.create1 = function () {
            return new DebuggerStatementSyntax(TypeScript.Syntax.token(19 /* DebuggerKeyword */), TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
            return this.update(debuggerKeyword, this.semicolonToken);
        };

        DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.debuggerKeyword, semicolonToken);
        };

        DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return DebuggerStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DebuggerStatementSyntax = DebuggerStatementSyntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxRewriter = (function () {
        function SyntaxRewriter() {
        }
        SyntaxRewriter.prototype.visitToken = function (token) {
            return token;
        };

        SyntaxRewriter.prototype.visitNode = function (node) {
            return node.accept(this);
        };

        SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
            return node.isToken() ? this.visitToken(node) : this.visitNode(node);
        };

        SyntaxRewriter.prototype.visitList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.list(newItems);
        };

        SyntaxRewriter.prototype.visitSeparatedList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.separatedList(newItems);
        };

        SyntaxRewriter.prototype.visitSourceUnit = function (node) {
            return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
        };

        SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
            return node.update(this.visitToken(node.requireKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
            return node.update(this.visitNodeOrToken(node.moduleName));
        };

        SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNode(node.moduleReference), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitExportAssignment = function (node) {
            return node.update(this.visitToken(node.exportKeyword), this.visitToken(node.equalsToken), this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitNode(node.body));
        };

        SyntaxRewriter.prototype.visitHeritageClause = function (node) {
            return node.update(this.visitToken(node.extendsOrImplementsKeyword), this.visitSeparatedList(node.typeNames));
        };

        SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.moduleKeyword), node.moduleName === null ? null : this.visitNodeOrToken(node.moduleName), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.functionKeyword), this.visitToken(node.identifier), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableStatement = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
            return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
        };

        SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
            return node.update(this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
            return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
        };

        SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
        };

        SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
            return node;
        };

        SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitQualifiedName = function (node) {
            return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
        };

        SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitConstructorType = function (node) {
            return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitFunctionType = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitObjectType = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitArrayType = function (node) {
            return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitGenericType = function (node) {
            return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
        };

        SyntaxRewriter.prototype.visitTypeQuery = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.name));
        };

        SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
            return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitBlock = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitParameter = function (node) {
            return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
        };

        SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
        };

        SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitArgumentList = function (node) {
            return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.arguments), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
        };

        SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
        };

        SyntaxRewriter.prototype.visitConstructSignature = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitMethodSignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitIndexSignature = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitPropertySignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitCallSignature = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitParameterList = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitTypeParameter = function (node) {
            return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
        };

        SyntaxRewriter.prototype.visitConstraint = function (node) {
            return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitElseClause = function (node) {
            return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitIfStatement = function (node) {
            return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
        };

        SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
            return node.update(this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.propertyName), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitIndexMemberDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.indexSignature), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitThrowStatement = function (node) {
            return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitReturnStatement = function (node) {
            return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
            return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
            return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
            return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitBreakStatement = function (node) {
            return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitContinueStatement = function (node) {
            return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitForStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitForInStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWhileStatement = function (node) {
            return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWithStatement = function (node) {
            return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.enumElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitEnumElement = function (node) {
            return node.update(this.visitToken(node.propertyName), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitCastExpression = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitFunctionPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.closeParenToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitNode(node.parameter), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
            return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
            return node.update(this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTryStatement = function (node) {
            return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
        };

        SyntaxRewriter.prototype.visitCatchClause = function (node) {
            return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFinallyClause = function (node) {
            return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitDoStatement = function (node) {
            return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
            return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitVoidExpression = function (node) {
            return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
            return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
        };
        return SyntaxRewriter;
    })();
    TypeScript.SyntaxRewriter = SyntaxRewriter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDedenter = (function (_super) {
        __extends(SyntaxDedenter, _super);
        function SyntaxDedenter(dedentFirstToken, dedentationAmount, minimumIndent, options) {
            _super.call(this);
            this.dedentationAmount = dedentationAmount;
            this.minimumIndent = minimumIndent;
            this.options = options;
            this.lastTriviaWasNewLine = dedentFirstToken;
        }
        SyntaxDedenter.prototype.abort = function () {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        };

        SyntaxDedenter.prototype.isAborted = function () {
            return this.dedentationAmount === 0;
        };

        SyntaxDedenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }

            if (this.isAborted()) {
                return token;
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxDedenter.prototype.dedentTriviaList = function (triviaList) {
            var result = [];
            var dedentNextWhitespace = true;

            for (var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;

                if (dedentThisTrivia) {
                    if (trivia.kind() === 4 /* WhitespaceTrivia */) {
                        var hasFollowingNewLine = (i < triviaList.count() - 1) && triviaList.syntaxTriviaAt(i + 1).kind() === 5 /* NewLineTrivia */;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    } else if (trivia.kind() !== 5 /* NewLineTrivia */) {
                        this.abort();
                        break;
                    }
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }

                result.push(trivia);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    dedentNextWhitespace = true;
                }
            }

            if (dedentNextWhitespace) {
                this.abort();
            }

            if (this.isAborted()) {
                return triviaList;
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxDedenter.prototype.dedentSegment = function (segment, hasFollowingNewLineTrivia) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    return "";
                }
            } else if (TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment.substring(firstNonWhitespacePosition);
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = TypeScript.MathPrototype.min(firstNonWhitespaceColumn, TypeScript.MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));

            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                this.abort();
                return segment;
            }

            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            TypeScript.Debug.assert(this.dedentationAmount >= 0);

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxDedenter.prototype.dedentWhitespace = function (trivia, hasFollowingNewLineTrivia) {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return TypeScript.Syntax.whitespace(newIndentation);
        };

        SyntaxDedenter.prototype.dedentMultiLineComment = function (trivia) {
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                return trivia;
            }

            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, false);
            }

            var result = segments.join("");

            return TypeScript.Syntax.multiLineComment(result);
        };

        SyntaxDedenter.dedentNode = function (node, dedentFirstToken, dedentAmount, minimumIndent, options) {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);

            if (dedenter.isAborted()) {
                return node;
            }

            return result;
        };
        return SyntaxDedenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxDedenter = SyntaxDedenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxIndenter = (function (_super) {
        __extends(SyntaxIndenter, _super);
        function SyntaxIndenter(indentFirstToken, indentationAmount, options) {
            _super.call(this);
            this.indentationAmount = indentationAmount;
            this.options = options;
            this.lastTriviaWasNewLine = indentFirstToken;
            this.indentationTrivia = TypeScript.Indentation.indentationTrivia(this.indentationAmount, this.options);
        }
        SyntaxIndenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxIndenter.prototype.indentTriviaList = function (triviaList) {
            var result = [];

            var indentNextTrivia = true;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;

                switch (trivia.kind()) {
                    case 6 /* MultiLineCommentTrivia */:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;

                    case 7 /* SingleLineCommentTrivia */:
                    case 8 /* SkippedTokenTrivia */:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;

                    case 4 /* WhitespaceTrivia */:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;

                    case 5 /* NewLineTrivia */:
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }

            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxIndenter.prototype.indentSegment = function (segment) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment;
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxIndenter.prototype.indentWhitespace = function (trivia, indentThisTrivia, result) {
            if (!indentThisTrivia) {
                result.push(trivia);
                return;
            }

            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(TypeScript.Syntax.whitespace(newIndentation));
        };

        SyntaxIndenter.prototype.indentSingleLineOrSkippedText = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            result.push(trivia);
        };

        SyntaxIndenter.prototype.indentMultiLineComment = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);

            for (var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }

            var newText = segments.join("");
            result.push(TypeScript.Syntax.multiLineComment(newText));
        };

        SyntaxIndenter.indentNode = function (node, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        };

        SyntaxIndenter.indentNodes = function (nodes, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result = TypeScript.ArrayUtilities.select(nodes, function (n) {
                return n.accept(indenter);
            });

            return result;
        };
        return SyntaxIndenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxIndenter = SyntaxIndenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var VariableWidthTokenWithNoTrivia = (function () {
            function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithNoTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
            };

            VariableWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            VariableWidthTokenWithNoTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithNoTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithNoTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithNoTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithNoTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = TypeScript.Syntax.value(this);
                }

                return this._value;
            };

            VariableWidthTokenWithNoTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = TypeScript.Syntax.valueText(this);
                }

                return this._valueText;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            VariableWidthTokenWithNoTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            VariableWidthTokenWithNoTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithNoTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithNoTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return VariableWidthTokenWithNoTrivia;
        })();
        Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;

        var VariableWidthTokenWithLeadingTrivia = (function () {
            function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = TypeScript.Syntax.value(this);
                }

                return this._value;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = TypeScript.Syntax.valueText(this);
                }

                return this._valueText;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return VariableWidthTokenWithLeadingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;

        var VariableWidthTokenWithTrailingTrivia = (function () {
            function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = TypeScript.Syntax.value(this);
                }

                return this._value;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = TypeScript.Syntax.valueText(this);
                }

                return this._valueText;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return VariableWidthTokenWithTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;

        var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                if (this._value === undefined) {
                    this._value = TypeScript.Syntax.value(this);
                }

                return this._value;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                if (this._valueText === undefined) {
                    this._valueText = TypeScript.Syntax.valueText(this);
                }

                return this._valueText;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return VariableWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;

        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(kind) {
                this.tokenKind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this.tokenKind);
            };

            FixedWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            FixedWidthTokenWithNoTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this.text();
            };

            FixedWidthTokenWithNoTrivia.prototype.value = function () {
                return TypeScript.Syntax.value(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.valueText = function () {
                return TypeScript.Syntax.valueText(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            FixedWidthTokenWithNoTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            FixedWidthTokenWithNoTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithNoTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithNoTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;

        var FixedWidthTokenWithLeadingTrivia = (function () {
            function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
            }
            FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.value = function () {
                return TypeScript.Syntax.value(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                return TypeScript.Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return FixedWidthTokenWithLeadingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;

        var FixedWidthTokenWithTrailingTrivia = (function () {
            function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.value = function () {
                return TypeScript.Syntax.value(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                return TypeScript.Syntax.valueText(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return FixedWidthTokenWithTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;

        var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                return TypeScript.Syntax.value(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                return TypeScript.Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return TypeScript.Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return TypeScript.Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isPrimaryExpression = function () {
                return TypeScript.Syntax.isPrimaryExpression(this);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return FixedWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;

        function collectTokenTextElements(token, elements) {
            token.leadingTrivia().collectTextElements(elements);
            elements.push(token.text());
            token.trailingTrivia().collectTextElements(elements);
        }

        function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(kind);
                } else {
                    return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
            } else {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        Syntax.fixedWidthToken = fixedWidthToken;

        function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
                } else {
                    return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
            } else {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
        Syntax.variableWidthToken = variableWidthToken;

        function getTriviaWidth(value) {
            return value >>> 2 /* TriviaFullWidthShift */;
        }

        function hasTriviaComment(value) {
            return (value & 2 /* TriviaCommentMask */) !== 0;
        }

        function hasTriviaNewLine(value) {
            return (value & 1 /* TriviaNewLineMask */) !== 0;
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function isPrimaryExpression(token) {
            return false;
        }
        Syntax.isPrimaryExpression = isPrimaryExpression;

        function realizeToken(token) {
            return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.valueText(), token.trailingTrivia());
        }
        Syntax.realizeToken = realizeToken;

        function convertToIdentifierName(token) {
            TypeScript.Debug.assert(TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind));
            return new RealizedToken(11 /* IdentifierName */, token.leadingTrivia(), token.text(), token.text(), token.text(), token.trailingTrivia());
        }
        Syntax.convertToIdentifierName = convertToIdentifierName;

        function tokenToJSON(token) {
            var result = {};

            for (var name in TypeScript.SyntaxKind) {
                if (TypeScript.SyntaxKind[name] === token.kind()) {
                    result.kind = name;
                    break;
                }
            }

            result.width = token.width();
            if (token.fullWidth() !== token.width()) {
                result.fullWidth = token.fullWidth();
            }

            result.text = token.text();

            var value = token.value();
            if (value !== null) {
                result.value = value;
                result.valueText = token.valueText();
            }

            if (token.hasLeadingTrivia()) {
                result.hasLeadingTrivia = true;
            }

            if (token.hasLeadingComment()) {
                result.hasLeadingComment = true;
            }

            if (token.hasLeadingNewLine()) {
                result.hasLeadingNewLine = true;
            }

            if (token.hasLeadingSkippedText()) {
                result.hasLeadingSkippedText = true;
            }

            if (token.hasTrailingTrivia()) {
                result.hasTrailingTrivia = true;
            }

            if (token.hasTrailingComment()) {
                result.hasTrailingComment = true;
            }

            if (token.hasTrailingNewLine()) {
                result.hasTrailingNewLine = true;
            }

            if (token.hasTrailingSkippedText()) {
                result.hasTrailingSkippedText = true;
            }

            var trivia = token.leadingTrivia();
            if (trivia.count() > 0) {
                result.leadingTrivia = trivia;
            }

            trivia = token.trailingTrivia();
            if (trivia.count() > 0) {
                result.trailingTrivia = trivia;
            }

            return result;
        }
        Syntax.tokenToJSON = tokenToJSON;

        function value(token) {
            return value1(token.tokenKind, token.text());
        }
        Syntax.value = value;

        function hexValue(text, start, length) {
            var intChar = 0;
            for (var i = 0; i < length; i++) {
                var ch2 = text.charCodeAt(start + i);
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
            }

            return intChar;
        }

        var characterArray = [];

        function convertEscapes(text) {
            characterArray.length = 0;
            var result = "";

            for (var i = 0, n = text.length; i < n; i++) {
                var ch = text.charCodeAt(i);

                if (ch === 92 /* backslash */) {
                    i++;
                    if (i < n) {
                        ch = text.charCodeAt(i);
                        switch (ch) {
                            case 48 /* _0 */:
                                characterArray.push(0 /* nullCharacter */);
                                continue;

                            case 98 /* b */:
                                characterArray.push(8 /* backspace */);
                                continue;

                            case 102 /* f */:
                                characterArray.push(12 /* formFeed */);
                                continue;

                            case 110 /* n */:
                                characterArray.push(10 /* lineFeed */);
                                continue;

                            case 114 /* r */:
                                characterArray.push(13 /* carriageReturn */);
                                continue;

                            case 116 /* t */:
                                characterArray.push(9 /* tab */);
                                continue;

                            case 118 /* v */:
                                characterArray.push(11 /* verticalTab */);
                                continue;

                            case 120 /* x */:
                                characterArray.push(hexValue(text, i + 1, 2));
                                i += 2;
                                continue;

                            case 117 /* u */:
                                characterArray.push(hexValue(text, i + 1, 4));
                                i += 4;
                                continue;

                            case 13 /* carriageReturn */:
                                var nextIndex = i + 1;
                                if (nextIndex < text.length && text.charCodeAt(nextIndex) == 10 /* lineFeed */) {
                                    i++;
                                }
                                continue;

                            case 10 /* lineFeed */:
                            case 8233 /* paragraphSeparator */:
                            case 8232 /* lineSeparator */:
                                continue;

                            default:
                        }
                    }
                }

                characterArray.push(ch);

                if (i && !(i % 1024)) {
                    result = result.concat(String.fromCharCode.apply(null, characterArray));
                    characterArray.length = 0;
                }
            }

            if (characterArray.length) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
            }

            return result;
        }

        function massageEscapes(text) {
            return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
        }
        Syntax.massageEscapes = massageEscapes;

        function value1(kind, text) {
            if (kind === 11 /* IdentifierName */) {
                return massageEscapes(text);
            }

            switch (kind) {
                case 37 /* TrueKeyword */:
                    return true;
                case 24 /* FalseKeyword */:
                    return false;
                case 32 /* NullKeyword */:
                    return null;
            }

            if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TypeScript.SyntaxFacts.getText(kind);
            }

            if (kind === 13 /* NumericLiteral */) {
                return TypeScript.Syntax.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
            } else if (kind === 14 /* StringLiteral */) {
                if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                    return massageEscapes(text.substr(1, text.length - 2));
                } else {
                    return massageEscapes(text.substr(1));
                }
            } else if (kind === 12 /* RegularExpressionLiteral */) {
                try  {
                    var lastSlash = text.lastIndexOf("/");
                    var body = text.substring(1, lastSlash);
                    var flags = text.substring(lastSlash + 1);
                    return new RegExp(body, flags);
                } catch (e) {
                    return null;
                }
            } else if (kind === 10 /* EndOfFileToken */ || kind === 9 /* ErrorToken */) {
                return null;
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        }

        function valueText1(kind, text) {
            var value = value1(kind, text);
            return value === null ? "" : value.toString();
        }

        function valueText(token) {
            var value = token.value();
            return value === null ? "" : value.toString();
        }
        Syntax.valueText = valueText;

        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.tokenKind = kind;
            }
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.tokenKind);
            };

            EmptyToken.prototype.kind = function () {
                return this.tokenKind;
            };

            EmptyToken.prototype.isToken = function () {
                return true;
            };
            EmptyToken.prototype.isNode = function () {
                return false;
            };
            EmptyToken.prototype.isList = function () {
                return false;
            };
            EmptyToken.prototype.isSeparatedList = function () {
                return false;
            };

            EmptyToken.prototype.childCount = function () {
                return 0;
            };

            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptyToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            EmptyToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            EmptyToken.prototype.firstToken = function () {
                return this;
            };
            EmptyToken.prototype.lastToken = function () {
                return this;
            };
            EmptyToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.width = function () {
                return 0;
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.value = function () {
                return null;
            };
            EmptyToken.prototype.valueText = function () {
                return "";
            };

            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedToken = function () {
                return false;
            };

            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.realize = function () {
                return realizeToken(this);
            };
            EmptyToken.prototype.collectTextElements = function (elements) {
            };

            EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };

            EmptyToken.prototype.isPrimaryExpression = function () {
                return isPrimaryExpression(this);
            };

            EmptyToken.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            EmptyToken.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            EmptyToken.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return EmptyToken;
        })();

        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;

        var RealizedToken = (function () {
            function RealizedToken(tokenKind, leadingTrivia, text, value, valueText, trailingTrivia) {
                this.tokenKind = tokenKind;
                this._leadingTrivia = leadingTrivia;
                this._text = text;
                this._value = value;
                this._valueText = valueText;
                this._trailingTrivia = trailingTrivia;
            }
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.kind = function () {
                return this.tokenKind;
            };
            RealizedToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            RealizedToken.prototype.firstToken = function () {
                return this;
            };
            RealizedToken.prototype.lastToken = function () {
                return this;
            };
            RealizedToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            RealizedToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            RealizedToken.prototype.childCount = function () {
                return 0;
            };

            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            RealizedToken.prototype.isToken = function () {
                return true;
            };
            RealizedToken.prototype.isNode = function () {
                return false;
            };
            RealizedToken.prototype.isList = function () {
                return false;
            };
            RealizedToken.prototype.isSeparatedList = function () {
                return false;
            };
            RealizedToken.prototype.isTrivia = function () {
                return false;
            };
            RealizedToken.prototype.isTriviaList = function () {
                return false;
            };

            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.width = function () {
                return this.text().length;
            };

            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };

            RealizedToken.prototype.value = function () {
                return this._value;
            };
            RealizedToken.prototype.valueText = function () {
                return this._valueText;
            };

            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasLeadingNewLine = function () {
                return this._leadingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasLeadingSkippedText = function () {
                return this._leadingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingNewLine = function () {
                return this._trailingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasTrailingSkippedText = function () {
                return this._trailingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasSkippedToken = function () {
                return this.hasLeadingSkippedText() || this.hasTrailingSkippedText();
            };

            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };

            RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            RealizedToken.prototype.collectTextElements = function (elements) {
                this.leadingTrivia().collectTextElements(elements);
                elements.push(this.text());
                this.trailingTrivia().collectTextElements(elements);
            };

            RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, trailingTrivia);
            };

            RealizedToken.prototype.isPrimaryExpression = function () {
                return isPrimaryExpression(this);
            };

            RealizedToken.prototype.isMemberExpression = function () {
                return this.isPrimaryExpression();
            };

            RealizedToken.prototype.isPostfixExpression = function () {
                return this.isPrimaryExpression();
            };

            RealizedToken.prototype.isUnaryExpression = function () {
                return this.isPrimaryExpression();
            };
            return RealizedToken;
        })();

        function token(kind, info) {
            if (typeof info === "undefined") { info = null; }
            var text = (info !== null && info.text !== undefined) ? info.text : TypeScript.SyntaxFacts.getText(kind);

            return new RealizedToken(kind, TypeScript.Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value1(kind, text), valueText1(kind, text), TypeScript.Syntax.triviaList(info === null ? null : info.trailingTrivia));
        }
        Syntax.token = token;

        function identifier(text, info) {
            if (typeof info === "undefined") { info = null; }
            info = info || {};
            info.text = text;
            return token(11 /* IdentifierName */, info);
        }
        Syntax.identifier = identifier;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTokenReplacer = (function (_super) {
        __extends(SyntaxTokenReplacer, _super);
        function SyntaxTokenReplacer(token1, token2) {
            _super.call(this);
            this.token1 = token1;
            this.token2 = token2;
        }
        SyntaxTokenReplacer.prototype.visitToken = function (token) {
            if (token === this.token1) {
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;

                return result;
            }

            return token;
        };

        SyntaxTokenReplacer.prototype.visitNode = function (node) {
            if (this.token1 === null) {
                return node;
            }

            return _super.prototype.visitNode.call(this, node);
        };

        SyntaxTokenReplacer.prototype.visitList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitList.call(this, list);
        };

        SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitSeparatedList.call(this, list);
        };
        return SyntaxTokenReplacer;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxTokenReplacer = SyntaxTokenReplacer;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var SyntaxTrivia = (function () {
            function SyntaxTrivia(kind, textOrToken) {
                this._kind = kind;
                this._textOrToken = textOrToken;
            }
            SyntaxTrivia.prototype.toJSON = function (key) {
                var result = {};
                result.kind = TypeScript.SyntaxKind[this._kind];

                if (this.isSkippedToken()) {
                    result.skippedToken = this._textOrToken;
                } else {
                    result.text = this._textOrToken;
                }
                return result;
            };

            SyntaxTrivia.prototype.kind = function () {
                return this._kind;
            };

            SyntaxTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };

            SyntaxTrivia.prototype.fullText = function () {
                return this.isSkippedToken() ? this.skippedToken().fullText() : this._textOrToken;
            };

            SyntaxTrivia.prototype.isWhitespace = function () {
                return this.kind() === 4 /* WhitespaceTrivia */;
            };

            SyntaxTrivia.prototype.isComment = function () {
                return this.kind() === 7 /* SingleLineCommentTrivia */ || this.kind() === 6 /* MultiLineCommentTrivia */;
            };

            SyntaxTrivia.prototype.isNewLine = function () {
                return this.kind() === 5 /* NewLineTrivia */;
            };

            SyntaxTrivia.prototype.isSkippedToken = function () {
                return this.kind() === 8 /* SkippedTokenTrivia */;
            };

            SyntaxTrivia.prototype.skippedToken = function () {
                TypeScript.Debug.assert(this.isSkippedToken());
                return this._textOrToken;
            };

            SyntaxTrivia.prototype.collectTextElements = function (elements) {
                elements.push(this.fullText());
            };
            return SyntaxTrivia;
        })();

        function trivia(kind, text) {
            return new SyntaxTrivia(kind, text);
        }
        Syntax.trivia = trivia;

        function skippedTokenTrivia(token) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SyntaxTrivia(8 /* SkippedTokenTrivia */, token);
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;

        function spaces(count) {
            return trivia(4 /* WhitespaceTrivia */, TypeScript.StringUtilities.repeat(" ", count));
        }
        Syntax.spaces = spaces;

        function whitespace(text) {
            return trivia(4 /* WhitespaceTrivia */, text);
        }
        Syntax.whitespace = whitespace;

        function multiLineComment(text) {
            return trivia(6 /* MultiLineCommentTrivia */, text);
        }
        Syntax.multiLineComment = multiLineComment;

        function singleLineComment(text) {
            return trivia(7 /* SingleLineCommentTrivia */, text);
        }
        Syntax.singleLineComment = singleLineComment;

        Syntax.spaceTrivia = spaces(1);
        Syntax.lineFeedTrivia = trivia(5 /* NewLineTrivia */, "\n");
        Syntax.carriageReturnTrivia = trivia(5 /* NewLineTrivia */, "\r");
        Syntax.carriageReturnLineFeedTrivia = trivia(5 /* NewLineTrivia */, "\r\n");

        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];

            var triviaText = trivia.fullText();
            var currentIndex = 0;

            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);

                var isCarriageReturnLineFeed = false;
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            i++;
                        }

                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        result.push(triviaText.substring(currentIndex, i + 1));

                        currentIndex = i + 1;
                        continue;
                }
            }

            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));


var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        Syntax.emptyTriviaList = {
            kind: function () {
                return 3 /* TriviaList */;
            },
            count: function () {
                return 0;
            },
            syntaxTriviaAt: function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            last: function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            fullWidth: function () {
                return 0;
            },
            fullText: function () {
                return "";
            },
            hasComment: function () {
                return false;
            },
            hasNewLine: function () {
                return false;
            },
            hasSkippedToken: function () {
                return false;
            },
            toJSON: function (key) {
                return [];
            },
            collectTextElements: function (elements) {
            },
            toArray: function () {
                return [];
            },
            concat: function (trivia) {
                return trivia;
            }
        };

        function concatTrivia(list1, list2) {
            if (list1.count() === 0) {
                return list2;
            }

            if (list2.count() === 0) {
                return list1;
            }

            var trivia = list1.toArray();
            trivia.push.apply(trivia, list2.toArray());

            return triviaList(trivia);
        }

        function isComment(trivia) {
            return trivia.kind() === 6 /* MultiLineCommentTrivia */ || trivia.kind() === 7 /* SingleLineCommentTrivia */;
        }

        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };

            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };

            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === 5 /* NewLineTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === 8 /* SkippedTokenTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return SingletonSyntaxTriviaList;
        })();

        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                this.trivia = trivia;
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };

            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.trivia[index];
            };

            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };

            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) {
                    return t.fullWidth();
                });
            };

            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = "";

                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result += this.trivia[i].fullText();
                }

                return result;
            };

            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 5 /* NewLineTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 8 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.toJSON = function (key) {
                return this.trivia;
            };

            NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                for (var i = 0; i < this.trivia.length; i++) {
                    this.trivia[i].collectTextElements(elements);
                }
            };

            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };

            NormalSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return NormalSyntaxTriviaList;
        })();

        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return TypeScript.Syntax.emptyTriviaList;
            }

            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }

            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;

        Syntax.spaceTriviaList = triviaList([TypeScript.Syntax.spaceTrivia]);
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement.element();
            var parent = positionedElement.parentElement();
            if (parent !== null && (element.kind() === 80 /* LessThanToken */ || element.kind() === 81 /* GreaterThanToken */)) {
                switch (parent.kind()) {
                    case 228 /* TypeArgumentList */:
                    case 229 /* TypeParameterList */:
                    case 220 /* CastExpression */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var token = list.childAt(i);
                if (token.tokenKind === kind) {
                    return token;
                }
            }

            return null;
        };

        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };

        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        };

        SyntaxUtilities.getExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 148 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                case 128 /* InterfaceDeclaration */:
                case 133 /* ImportDeclaration */:
                    return SyntaxUtilities.getToken(moduleElement.modifiers, 47 /* ExportKeyword */);
                default:
                    return null;
            }
        };

        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }

            var node = positionNode.node();
            switch (node.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 148 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                        return true;
                    }

                case 133 /* ImportDeclaration */:
                case 137 /* ConstructorDeclaration */:
                case 135 /* MemberFunctionDeclaration */:
                case 138 /* GetMemberAccessorDeclaration */:
                case 139 /* SetMemberAccessorDeclaration */:
                case 136 /* MemberVariableDeclaration */:
                    if (node.isClassElement() || node.isModuleElement()) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
                    }

                case 244 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode().containingNode());

                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
            }
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxVisitor = (function () {
        function SyntaxVisitor() {
        }
        SyntaxVisitor.prototype.defaultVisit = function (node) {
            return null;
        };

        SyntaxVisitor.prototype.visitToken = function (token) {
            return this.defaultVisit(token);
        };

        SyntaxVisitor.prototype.visitSourceUnit = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExportAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitHeritageClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitQualifiedName = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGenericType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeQuery = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBlock = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMethodSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIndexSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPropertySignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCallSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstraint = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElseClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIfStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIndexMemberDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitThrowStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitReturnStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBreakStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitContinueStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForInStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWhileStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWithStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumElement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCastExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTryStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCatchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFinallyClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDoStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVoidExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
            return this.defaultVisit(node);
        };
        return SyntaxVisitor;
    })();
    TypeScript.SyntaxVisitor = SyntaxVisitor;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };

        SyntaxWalker.prototype.visitNode = function (node) {
            node.accept(this);
        };

        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken.isToken()) {
                this.visitToken(nodeOrToken);
            } else {
                this.visitNode(nodeOrToken);
            }
        };

        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        };

        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        };

        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        };

        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                this.visitNodeOrToken(list.childAt(i));
            }
        };

        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        };

        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };

        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };

        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNode(node.moduleReference);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };

        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };

        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.moduleName);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };

        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };

        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };

        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };

        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };

        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };

        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        };

        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };

        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };

        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };

        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };

        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };

        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };

        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitIndexMemberDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.indexSignature);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitToken(node.closeParenToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };

        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionTrackingWalker = (function (_super) {
        __extends(PositionTrackingWalker, _super);
        function PositionTrackingWalker() {
            _super.apply(this, arguments);
            this._position = 0;
        }
        PositionTrackingWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        PositionTrackingWalker.prototype.position = function () {
            return this._position;
        };

        PositionTrackingWalker.prototype.skip = function (element) {
            this._position += element.fullWidth();
        };
        return PositionTrackingWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.PositionTrackingWalker = PositionTrackingWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxInformationMap = (function (_super) {
        __extends(SyntaxInformationMap, _super);
        function SyntaxInformationMap(trackParents, trackPreviousToken) {
            _super.call(this);
            this.trackParents = trackParents;
            this.trackPreviousToken = trackPreviousToken;
            this.tokenToInformation = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this.elementToPosition = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._previousToken = null;
            this._previousTokenInformation = null;
            this._currentPosition = 0;
            this._elementToParent = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._parentStack = [];
            this._parentStack.push(null);
        }
        SyntaxInformationMap.create = function (node, trackParents, trackPreviousToken) {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        };

        SyntaxInformationMap.prototype.visitNode = function (node) {
            this.trackParents && this._elementToParent.add(node, TypeScript.ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);

            this.trackParents && this._parentStack.push(node);
            _super.prototype.visitNode.call(this, node);
            this.trackParents && this._parentStack.pop();
        };

        SyntaxInformationMap.prototype.visitToken = function (token) {
            this.trackParents && this._elementToParent.add(token, TypeScript.ArrayUtilities.last(this._parentStack));

            if (this.trackPreviousToken) {
                var tokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };

                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }

                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;

                this.tokenToInformation.add(token, tokenInformation);
            }

            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        };

        SyntaxInformationMap.prototype.parent = function (element) {
            return this._elementToParent.get(element);
        };

        SyntaxInformationMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };

        SyntaxInformationMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };

        SyntaxInformationMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };

        SyntaxInformationMap.prototype.previousToken = function (token) {
            return this.tokenInformation(token).previousToken;
        };

        SyntaxInformationMap.prototype.tokenInformation = function (token) {
            return this.tokenToInformation.get(token);
        };

        SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
            var current = token;
            while (true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }

                current = information.previousToken;
            }

            return current;
        };

        SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);
        };

        SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        };
        return SyntaxInformationMap;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxInformationMap = SyntaxInformationMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNodeInvariantsChecker = (function (_super) {
        __extends(SyntaxNodeInvariantsChecker, _super);
        function SyntaxNodeInvariantsChecker() {
            _super.apply(this, arguments);
            this.tokenTable = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
        }
        SyntaxNodeInvariantsChecker.checkInvariants = function (node) {
            node.accept(new SyntaxNodeInvariantsChecker());
        };

        SyntaxNodeInvariantsChecker.prototype.visitToken = function (token) {
            this.tokenTable.add(token, token);
        };
        return SyntaxNodeInvariantsChecker;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxNodeInvariantsChecker = SyntaxNodeInvariantsChecker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            } else {
                this.skip(node);
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.PositionTrackingWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Parser) {
        

        var ExpressionPrecedence;
        (function (ExpressionPrecedence) {
            ExpressionPrecedence[ExpressionPrecedence["CommaExpressionPrecedence"] = 1] = "CommaExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["AssignmentExpressionPrecedence"] = 2] = "AssignmentExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ConditionalExpressionPrecedence"] = 3] = "ConditionalExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ArrowFunctionPrecedence"] = 4] = "ArrowFunctionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["LogicalOrExpressionPrecedence"] = 5] = "LogicalOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["LogicalAndExpressionPrecedence"] = 6] = "LogicalAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 7] = "BitwiseOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 8] = "BitwiseExclusiveOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 9] = "BitwiseAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["EqualityExpressionPrecedence"] = 10] = "EqualityExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["RelationalExpressionPrecedence"] = 11] = "RelationalExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["ShiftExpressionPrecdence"] = 12] = "ShiftExpressionPrecdence";
            ExpressionPrecedence[ExpressionPrecedence["AdditiveExpressionPrecedence"] = 13] = "AdditiveExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 14] = "MultiplicativeExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["UnaryExpressionPrecedence"] = 15] = "UnaryExpressionPrecedence";
        })(ExpressionPrecedence || (ExpressionPrecedence = {}));

        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 1 << 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1 << 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 1 << 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 1 << 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 1 << 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 1 << 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 1 << 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 1 << 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 1 << 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 1 << 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 1 << 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 1 << 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 1 << 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 1 << 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 1 << 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 1 << 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 1 << 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 1 << 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 1 << 18] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 1 << 19] = "TypeParameterList_TypeParameters";

            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TypeArgumentList_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));

        var SyntaxCursor = (function () {
            function SyntaxCursor(sourceUnit) {
                this._elements = [];
                this._index = 0;
                this._pinCount = 0;
                sourceUnit.insertChildrenInto(this._elements, 0);
            }
            SyntaxCursor.prototype.isFinished = function () {
                return this._index === this._elements.length;
            };

            SyntaxCursor.prototype.currentElement = function () {
                if (this.isFinished()) {
                    return null;
                }

                return this._elements[this._index];
            };

            SyntaxCursor.prototype.currentNode = function () {
                var element = this.currentElement();
                return element !== null && element.isNode() ? element : null;
            };

            SyntaxCursor.prototype.moveToFirstChild = function () {
                if (this.isFinished()) {
                    return;
                }

                var element = this._elements[this._index];
                if (element.isToken()) {
                    return;
                }

                var node = element;

                this._elements.splice(this._index, 1);

                node.insertChildrenInto(this._elements, this._index);
            };

            SyntaxCursor.prototype.moveToNextSibling = function () {
                if (this.isFinished()) {
                    return;
                }

                if (this._pinCount > 0) {
                    this._index++;
                    return;
                }

                this._elements.shift();
            };

            SyntaxCursor.prototype.getAndPinCursorIndex = function () {
                this._pinCount++;
                return this._index;
            };

            SyntaxCursor.prototype.releaseAndUnpinCursorIndex = function (index) {
                this._pinCount--;
                if (this._pinCount === 0) {
                }
            };

            SyntaxCursor.prototype.rewindToPinnedCursorIndex = function (index) {
                this._index = index;
            };

            SyntaxCursor.prototype.pinCount = function () {
                return this._pinCount;
            };

            SyntaxCursor.prototype.moveToFirstToken = function () {
                var element;

                while (!this.isFinished()) {
                    element = this.currentElement();
                    if (element.isNode()) {
                        this.moveToFirstChild();
                        continue;
                    }

                    return;
                }
            };

            SyntaxCursor.prototype.currentToken = function () {
                this.moveToFirstToken();
                if (this.isFinished()) {
                    return null;
                }

                var element = this.currentElement();

                return element;
            };

            SyntaxCursor.prototype.peekToken = function (n) {
                this.moveToFirstToken();
                var pin = this.getAndPinCursorIndex();
                try  {
                    for (var i = 0; i < n; i++) {
                        this.moveToNextSibling();
                        this.moveToFirstToken();
                    }

                    return this.currentToken();
                } finally {
                    this.rewindToPinnedCursorIndex(pin);
                    this.releaseAndUnpinCursorIndex(pin);
                }
            };
            return SyntaxCursor;
        })();

        

        var NormalParserSource = (function () {
            function NormalParserSource(fileName, text, languageVersion) {
                this._previousToken = null;
                this._absolutePosition = 0;
                this._tokenDiagnostics = [];
                this.rewindPointPool = [];
                this.rewindPointPoolCount = 0;
                this.slidingWindow = new TypeScript.SlidingWindow(this, TypeScript.ArrayUtilities.createArray(32, null), null);
                this.scanner = new TypeScript.Scanner(fileName, text, languageVersion);
            }
            NormalParserSource.prototype.currentNode = function () {
                return null;
            };

            NormalParserSource.prototype.moveToNextNode = function () {
                throw TypeScript.Errors.invalidOperation();
            };

            NormalParserSource.prototype.absolutePosition = function () {
                return this._absolutePosition;
            };

            NormalParserSource.prototype.previousToken = function () {
                return this._previousToken;
            };

            NormalParserSource.prototype.tokenDiagnostics = function () {
                return this._tokenDiagnostics;
            };

            NormalParserSource.prototype.getOrCreateRewindPoint = function () {
                if (this.rewindPointPoolCount === 0) {
                    return {};
                }

                this.rewindPointPoolCount--;
                var result = this.rewindPointPool[this.rewindPointPoolCount];
                this.rewindPointPool[this.rewindPointPoolCount] = null;
                return result;
            };

            NormalParserSource.prototype.getRewindPoint = function () {
                var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

                var rewindPoint = this.getOrCreateRewindPoint();

                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.previousToken = this._previousToken;
                rewindPoint.absolutePosition = this._absolutePosition;

                rewindPoint.pinCount = this.slidingWindow.pinCount();

                return rewindPoint;
            };

            NormalParserSource.prototype.isPinned = function () {
                return this.slidingWindow.pinCount() > 0;
            };

            NormalParserSource.prototype.rewind = function (rewindPoint) {
                this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

                this._previousToken = rewindPoint.previousToken;
                this._absolutePosition = rewindPoint.absolutePosition;
            };

            NormalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint.absoluteIndex);

                this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
                this.rewindPointPoolCount++;
            };

            NormalParserSource.prototype.fetchMoreItems = function (allowRegularExpression, sourceIndex, window, destinationIndex, spaceAvailable) {
                window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
                return 1;
            };

            NormalParserSource.prototype.peekToken = function (n) {
                return this.slidingWindow.peekItemN(n);
            };

            NormalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();
                this._absolutePosition += currentToken.fullWidth();
                this._previousToken = currentToken;

                this.slidingWindow.moveToNextItem();
            };

            NormalParserSource.prototype.currentToken = function () {
                return this.slidingWindow.currentItem(false);
            };

            NormalParserSource.prototype.removeDiagnosticsOnOrAfterPosition = function (position) {
                var tokenDiagnosticsLength = this._tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    } else {
                        break;
                    }
                }

                this._tokenDiagnostics.length = tokenDiagnosticsLength;
            };

            NormalParserSource.prototype.resetToPosition = function (absolutePosition, previousToken) {
                this._absolutePosition = absolutePosition;
                this._previousToken = previousToken;

                this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

                this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

                this.scanner.setAbsoluteIndex(absolutePosition);
            };

            NormalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                this.resetToPosition(this._absolutePosition, this._previousToken);

                var token = this.slidingWindow.currentItem(true);

                return token;
            };
            return NormalParserSource;
        })();

        var IncrementalParserSource = (function () {
            function IncrementalParserSource(oldSyntaxTree, textChangeRange, newText) {
                this._changeDelta = 0;
                var oldSourceUnit = oldSyntaxTree.sourceUnit();
                this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);

                this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);

                this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), newText, oldSyntaxTree.parseOptions().languageVersion());
            }
            IncrementalParserSource.extendToAffectedRange = function (changeRange, sourceUnit) {
                var maxLookahead = 1;

                var start = changeRange.span().start();

                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = sourceUnit.findToken(start);

                    var position = token.fullStart();

                    start = TypeScript.MathPrototype.max(0, position - 1);
                }

                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            };

            IncrementalParserSource.prototype.absolutePosition = function () {
                return this._normalParserSource.absolutePosition();
            };

            IncrementalParserSource.prototype.previousToken = function () {
                return this._normalParserSource.previousToken();
            };

            IncrementalParserSource.prototype.tokenDiagnostics = function () {
                return this._normalParserSource.tokenDiagnostics();
            };

            IncrementalParserSource.prototype.getRewindPoint = function () {
                var rewindPoint = this._normalParserSource.getRewindPoint();
                var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();

                rewindPoint.changeDelta = this._changeDelta;
                rewindPoint.changeRange = this._changeRange;
                rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;

                return rewindPoint;
            };

            IncrementalParserSource.prototype.rewind = function (rewindPoint) {
                this._changeRange = rewindPoint.changeRange;
                this._changeDelta = rewindPoint.changeDelta;
                this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);

                this._normalParserSource.rewind(rewindPoint);
            };

            IncrementalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
                this._normalParserSource.releaseRewindPoint(rewindPoint);
            };

            IncrementalParserSource.prototype.canReadFromOldSourceUnit = function () {
                if (this._normalParserSource.isPinned()) {
                    return false;
                }

                if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                    return false;
                }

                this.syncCursorToNewTextIfBehind();

                return this._changeDelta === 0 && !this._oldSourceUnitCursor.isFinished();
            };

            IncrementalParserSource.prototype.currentNode = function () {
                if (this.canReadFromOldSourceUnit()) {
                    return this.tryGetNodeFromOldSourceUnit();
                }

                return null;
            };

            IncrementalParserSource.prototype.currentToken = function () {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.currentToken();
            };

            IncrementalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                return this._normalParserSource.currentTokenAllowingRegularExpression();
            };

            IncrementalParserSource.prototype.syncCursorToNewTextIfBehind = function () {
                while (true) {
                    if (this._oldSourceUnitCursor.isFinished()) {
                        break;
                    }

                    if (this._changeDelta >= 0) {
                        break;
                    }

                    var currentElement = this._oldSourceUnitCursor.currentElement();

                    if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                        this._oldSourceUnitCursor.moveToFirstChild();
                    } else {
                        this._oldSourceUnitCursor.moveToNextSibling();

                        this._changeDelta += currentElement.fullWidth();
                    }
                }
            };

            IncrementalParserSource.prototype.intersectsWithChangeRangeSpanInOriginalText = function (start, length) {
                return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
            };

            IncrementalParserSource.prototype.tryGetNodeFromOldSourceUnit = function () {
                while (true) {
                    var node = this._oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        return null;
                    }

                    if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                        if (!node.isIncrementallyUnusable()) {
                            return node;
                        }
                    }

                    this._oldSourceUnitCursor.moveToFirstChild();
                }
            };

            IncrementalParserSource.prototype.canReuseTokenFromOldSourceUnit = function (position, token) {
                if (token !== null) {
                    if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        if (!token.isIncrementallyUnusable()) {
                            return true;
                        }
                    }
                }

                return false;
            };

            IncrementalParserSource.prototype.tryGetTokenFromOldSourceUnit = function () {
                var token = this._oldSourceUnitCursor.currentToken();

                return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) ? token : null;
            };

            IncrementalParserSource.prototype.peekToken = function (n) {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.peekToken(n);
            };

            IncrementalParserSource.prototype.tryPeekTokenFromOldSourceUnit = function (n) {
                var currentPosition = this.absolutePosition();
                for (var i = 0; i < n; i++) {
                    var interimToken = this._oldSourceUnitCursor.peekToken(i);
                    if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }

                    currentPosition += interimToken.fullWidth();
                }

                var token = this._oldSourceUnitCursor.peekToken(n);
                return this.canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            };

            IncrementalParserSource.prototype.moveToNextNode = function () {
                var currentElement = this._oldSourceUnitCursor.currentElement();
                var currentNode = this._oldSourceUnitCursor.currentNode();

                this._oldSourceUnitCursor.moveToNextSibling();

                var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
                var previousToken = currentNode.lastToken();
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                if (this._changeRange !== null) {
                }
            };

            IncrementalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();

                if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                    var previousToken = currentToken;
                    this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                    if (this._changeRange !== null) {
                    }
                } else {
                    this._changeDelta -= currentToken.fullWidth();

                    this._normalParserSource.moveToNextToken();

                    if (this._changeRange !== null) {
                        var changeRangeSpanInNewText = this._changeRange.newSpan();
                        if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                            this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                            this._changeRange = null;
                        }
                    }
                }
            };
            return IncrementalParserSource;
        })();

        var ParserImpl = (function () {
            function ParserImpl(fileName, lineMap, source, parseOptions) {
                this.listParsingState = 0;
                this.isInStrictMode = false;
                this.diagnostics = [];
                this.factory = TypeScript.Syntax.normalModeFactory;
                this.mergeTokensStorage = [];
                this.arrayPool = [];
                this.fileName = fileName;
                this.lineMap = lineMap;
                this.source = source;
                this.parseOptions = parseOptions;
            }
            ParserImpl.prototype.getRewindPoint = function () {
                var rewindPoint = this.source.getRewindPoint();

                rewindPoint.diagnosticsCount = this.diagnostics.length;

                rewindPoint.isInStrictMode = this.isInStrictMode;
                rewindPoint.listParsingState = this.listParsingState;

                return rewindPoint;
            };

            ParserImpl.prototype.rewind = function (rewindPoint) {
                this.source.rewind(rewindPoint);

                this.diagnostics.length = rewindPoint.diagnosticsCount;
            };

            ParserImpl.prototype.releaseRewindPoint = function (rewindPoint) {
                this.source.releaseRewindPoint(rewindPoint);
            };

            ParserImpl.prototype.currentTokenStart = function () {
                return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenStart = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.source.absolutePosition() - this.previousToken().fullWidth() + this.previousToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenEnd = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.previousTokenStart() + this.previousToken().width();
            };

            ParserImpl.prototype.currentNode = function () {
                var node = this.source.currentNode();

                if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                    return null;
                }

                return node;
            };

            ParserImpl.prototype.currentToken = function () {
                return this.source.currentToken();
            };

            ParserImpl.prototype.currentTokenAllowingRegularExpression = function () {
                return this.source.currentTokenAllowingRegularExpression();
            };

            ParserImpl.prototype.peekToken = function (n) {
                return this.source.peekToken(n);
            };

            ParserImpl.prototype.eatAnyToken = function () {
                var token = this.currentToken();
                this.moveToNextToken();
                return token;
            };

            ParserImpl.prototype.moveToNextToken = function () {
                this.source.moveToNextToken();
            };

            ParserImpl.prototype.previousToken = function () {
                return this.source.previousToken();
            };

            ParserImpl.prototype.eatNode = function () {
                var node = this.source.currentNode();
                this.source.moveToNextNode();
                return node;
            };

            ParserImpl.prototype.eatToken = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.tryEatToken = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatToken(kind);
                }

                return null;
            };

            ParserImpl.prototype.tryEatKeyword = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatKeyword(kind);
                }

                return null;
            };

            ParserImpl.prototype.eatKeyword = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.isIdentifier = function (token) {
                var tokenKind = token.tokenKind;

                if (tokenKind === 11 /* IdentifierName */) {
                    return true;
                }

                if (tokenKind >= 51 /* FirstFutureReservedStrictKeyword */) {
                    if (tokenKind <= 59 /* LastFutureReservedStrictKeyword */) {
                        return !this.isInStrictMode;
                    }

                    return tokenKind <= 69 /* LastTypeScriptKeyword */;
                }

                return false;
            };

            ParserImpl.prototype.eatIdentifierNameToken = function () {
                var token = this.currentToken();

                if (token.tokenKind === 11 /* IdentifierName */) {
                    this.moveToNextToken();
                    return token;
                }

                if (TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind)) {
                    this.moveToNextToken();
                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.eatIdentifierToken = function () {
                var token = this.currentToken();
                if (this.isIdentifier(token)) {
                    this.moveToNextToken();

                    if (token.tokenKind === 11 /* IdentifierName */) {
                        return token;
                    }

                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.canEatAutomaticSemicolon = function (allowWithoutNewLine) {
                var token = this.currentToken();

                if (token.tokenKind === 10 /* EndOfFileToken */) {
                    return true;
                }

                if (token.tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                if (allowWithoutNewLine) {
                    return true;
                }

                if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.canEatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 78 /* SemicolonToken */) {
                    return true;
                }

                return this.canEatAutomaticSemicolon(allowWithoutNewline);
            };

            ParserImpl.prototype.eatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 78 /* SemicolonToken */) {
                    return this.eatToken(78 /* SemicolonToken */);
                }

                if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                    var semicolonToken = TypeScript.Syntax.emptyToken(78 /* SemicolonToken */);

                    if (!this.parseOptions.allowAutomaticSemicolonInsertion()) {
                        this.addDiagnostic(new TypeScript.Diagnostic(this.fileName, this.previousTokenEnd(), 0, TypeScript.DiagnosticCode.Automatic_semicolon_insertion_not_allowed, null));
                    }

                    return semicolonToken;
                }

                return this.eatToken(78 /* SemicolonToken */);
            };

            ParserImpl.prototype.isKeyword = function (kind) {
                if (kind >= 15 /* FirstKeyword */) {
                    if (kind <= 50 /* LastFutureReservedKeyword */) {
                        return true;
                    }

                    if (this.isInStrictMode) {
                        return kind <= 59 /* LastFutureReservedStrictKeyword */;
                    }
                }

                return false;
            };

            ParserImpl.prototype.createMissingToken = function (expectedKind, actual) {
                var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
                this.addDiagnostic(diagnostic);

                return TypeScript.Syntax.emptyToken(expectedKind);
            };

            ParserImpl.prototype.getExpectedTokenDiagnostic = function (expectedKind, actual) {
                var token = this.currentToken();

                if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                    return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(expectedKind)]);
                } else {
                    if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                        return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected_0_is_a_keyword, [TypeScript.SyntaxFacts.getText(actual.tokenKind)]);
                    } else {
                        return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected, null);
                    }
                }
            };

            ParserImpl.getPrecedence = function (expressionKind) {
                switch (expressionKind) {
                    case 173 /* CommaExpression */:
                        return 1 /* CommaExpressionPrecedence */;

                    case 174 /* AssignmentExpression */:
                    case 175 /* AddAssignmentExpression */:
                    case 176 /* SubtractAssignmentExpression */:
                    case 177 /* MultiplyAssignmentExpression */:
                    case 178 /* DivideAssignmentExpression */:
                    case 179 /* ModuloAssignmentExpression */:
                    case 180 /* AndAssignmentExpression */:
                    case 181 /* ExclusiveOrAssignmentExpression */:
                    case 182 /* OrAssignmentExpression */:
                    case 183 /* LeftShiftAssignmentExpression */:
                    case 184 /* SignedRightShiftAssignmentExpression */:
                    case 185 /* UnsignedRightShiftAssignmentExpression */:
                        return 2 /* AssignmentExpressionPrecedence */;

                    case 186 /* ConditionalExpression */:
                        return 3 /* ConditionalExpressionPrecedence */;

                    case 187 /* LogicalOrExpression */:
                        return 5 /* LogicalOrExpressionPrecedence */;

                    case 188 /* LogicalAndExpression */:
                        return 6 /* LogicalAndExpressionPrecedence */;

                    case 189 /* BitwiseOrExpression */:
                        return 7 /* BitwiseOrExpressionPrecedence */;

                    case 190 /* BitwiseExclusiveOrExpression */:
                        return 8 /* BitwiseExclusiveOrExpressionPrecedence */;

                    case 191 /* BitwiseAndExpression */:
                        return 9 /* BitwiseAndExpressionPrecedence */;

                    case 192 /* EqualsWithTypeConversionExpression */:
                    case 193 /* NotEqualsWithTypeConversionExpression */:
                    case 194 /* EqualsExpression */:
                    case 195 /* NotEqualsExpression */:
                        return 10 /* EqualityExpressionPrecedence */;

                    case 196 /* LessThanExpression */:
                    case 197 /* GreaterThanExpression */:
                    case 198 /* LessThanOrEqualExpression */:
                    case 199 /* GreaterThanOrEqualExpression */:
                    case 200 /* InstanceOfExpression */:
                    case 201 /* InExpression */:
                        return 11 /* RelationalExpressionPrecedence */;

                    case 202 /* LeftShiftExpression */:
                    case 203 /* SignedRightShiftExpression */:
                    case 204 /* UnsignedRightShiftExpression */:
                        return 12 /* ShiftExpressionPrecdence */;

                    case 208 /* AddExpression */:
                    case 209 /* SubtractExpression */:
                        return 13 /* AdditiveExpressionPrecedence */;

                    case 205 /* MultiplyExpression */:
                    case 206 /* DivideExpression */:
                    case 207 /* ModuloExpression */:
                        return 14 /* MultiplicativeExpressionPrecedence */;

                    case 164 /* PlusExpression */:
                    case 165 /* NegateExpression */:
                    case 166 /* BitwiseNotExpression */:
                    case 167 /* LogicalNotExpression */:
                    case 170 /* DeleteExpression */:
                    case 171 /* TypeOfExpression */:
                    case 172 /* VoidExpression */:
                    case 168 /* PreIncrementExpression */:
                    case 169 /* PreDecrementExpression */:
                        return 15 /* UnaryExpressionPrecedence */;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            ParserImpl.prototype.addSkippedTokenAfterNodeOrToken = function (nodeOrToken, skippedToken) {
                if (nodeOrToken.isToken()) {
                    return this.addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                } else if (nodeOrToken.isNode()) {
                    return this.addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.addSkippedTokenAfterNode = function (node, skippedToken) {
                var oldToken = node.lastToken();
                var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);

                return node.replaceToken(oldToken, newToken);
            };

            ParserImpl.prototype.addSkippedTokensBeforeNode = function (node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = node.firstToken();
                    var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);

                    return node.replaceToken(oldToken, newToken);
                }

                return node;
            };

            ParserImpl.prototype.addSkippedTokensBeforeToken = function (token, skippedTokens) {
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
                }

                this.addTriviaTo(token.leadingTrivia(), leadingTrivia);

                this.returnArray(skippedTokens);
                return token.withLeadingTrivia(TypeScript.Syntax.triviaList(leadingTrivia));
            };

            ParserImpl.prototype.addSkippedTokensAfterToken = function (token, skippedTokens) {
                if (skippedTokens.length === 0) {
                    this.returnArray(skippedTokens);
                    return token;
                }

                var trailingTrivia = token.trailingTrivia().toArray();

                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }

                this.returnArray(skippedTokens);
                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenAfterToken = function (token, skippedToken) {
                var trailingTrivia = token.trailingTrivia().toArray();
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenToTriviaArray = function (array, skippedToken) {
                this.addTriviaTo(skippedToken.leadingTrivia(), array);

                var trimmedToken = skippedToken.withLeadingTrivia(TypeScript.Syntax.emptyTriviaList).withTrailingTrivia(TypeScript.Syntax.emptyTriviaList);
                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken));

                this.addTriviaTo(skippedToken.trailingTrivia(), array);
            };

            ParserImpl.prototype.addTriviaTo = function (list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            };

            ParserImpl.prototype.parseSyntaxTree = function (isDeclaration) {
                var sourceUnit = this.parseSourceUnit();

                var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
                allDiagnostics.sort(function (a, b) {
                    return a.start() - b.start();
                });

                return new TypeScript.SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, this.fileName, this.lineMap, this.parseOptions);
            };

            ParserImpl.prototype.setStrictMode = function (isInStrictMode) {
                this.isInStrictMode = isInStrictMode;
                this.factory = isInStrictMode ? TypeScript.Syntax.strictModeFactory : TypeScript.Syntax.normalModeFactory;
            };

            ParserImpl.prototype.parseSourceUnit = function () {
                var savedIsInStrictMode = this.isInStrictMode;

                var result = this.parseSyntaxList(1 /* SourceUnit_ModuleElements */, ParserImpl.updateStrictModeState);
                var moduleElements = result.list;

                this.setStrictMode(savedIsInStrictMode);

                var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
                sourceUnit = this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

                return sourceUnit;
            };

            ParserImpl.updateStrictModeState = function (parser, items) {
                if (!parser.isInStrictMode) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }

                    parser.setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            };

            ParserImpl.prototype.isModuleElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return true;
                }

                return this.isImportDeclaration() || this.isExportAssignment() || this.isModuleDeclaration() || this.isInterfaceDeclaration() || this.isClassDeclaration() || this.isEnumDeclaration() || this.isStatement(inErrorRecovery);
            };

            ParserImpl.prototype.parseModuleElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return this.eatNode();
                }

                if (this.isImportDeclaration()) {
                    return this.parseImportDeclaration();
                } else if (this.isExportAssignment()) {
                    return this.parseExportAssignment();
                } else if (this.isModuleDeclaration()) {
                    return this.parseModuleDeclaration();
                } else if (this.isInterfaceDeclaration()) {
                    return this.parseInterfaceDeclaration();
                } else if (this.isClassDeclaration()) {
                    return this.parseClassDeclaration();
                } else if (this.isEnumDeclaration()) {
                    return this.parseEnumDeclaration();
                } else if (this.isStatement(inErrorRecovery)) {
                    return this.parseStatement(inErrorRecovery);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isImportDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 49 /* ImportKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 49 /* ImportKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseImportDeclaration = function () {
                var modifiers = this.parseModifiers();
                var importKeyword = this.eatKeyword(49 /* ImportKeyword */);
                var identifier = this.eatIdentifierToken();
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var moduleReference = this.parseModuleReference();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.importDeclaration(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
            };

            ParserImpl.prototype.isExportAssignment = function () {
                return this.currentToken().tokenKind === 47 /* ExportKeyword */ && this.peekToken(1).tokenKind === 107 /* EqualsToken */;
            };

            ParserImpl.prototype.parseExportAssignment = function () {
                var exportKeyword = this.eatKeyword(47 /* ExportKeyword */);
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var identifier = this.eatIdentifierToken();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.exportAssignment(exportKeyword, equalsToken, identifier, semicolonToken);
            };

            ParserImpl.prototype.parseModuleReference = function () {
                if (this.isExternalModuleReference()) {
                    return this.parseExternalModuleReference();
                } else {
                    return this.parseModuleNameModuleReference();
                }
            };

            ParserImpl.prototype.isExternalModuleReference = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 66 /* RequireKeyword */) {
                    return this.peekToken(1).tokenKind === 72 /* OpenParenToken */;
                }

                return false;
            };

            ParserImpl.prototype.parseExternalModuleReference = function () {
                var requireKeyword = this.eatKeyword(66 /* RequireKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var stringLiteral = this.eatToken(14 /* StringLiteral */);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.externalModuleReference(requireKeyword, openParenToken, stringLiteral, closeParenToken);
            };

            ParserImpl.prototype.parseModuleNameModuleReference = function () {
                var name = this.parseName();
                return this.factory.moduleNameModuleReference(name);
            };

            ParserImpl.prototype.parseIdentifierName = function () {
                var identifierName = this.eatIdentifierNameToken();
                return identifierName;
            };

            ParserImpl.prototype.isName = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.tryParseTypeArgumentList = function (inExpression) {
                if (this.currentToken().kind() !== 80 /* LessThanToken */) {
                    return null;
                }

                var lessThanToken;
                var greaterThanToken;
                var result;
                var typeArguments;

                if (!inExpression) {
                    lessThanToken = this.eatToken(80 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    lessThanToken = this.eatToken(80 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.canFollowTypeArgumentListInExpression = function (kind) {
                switch (kind) {
                    case 72 /* OpenParenToken */:
                    case 76 /* DotToken */:

                    case 73 /* CloseParenToken */:
                    case 75 /* CloseBracketToken */:
                    case 106 /* ColonToken */:
                    case 78 /* SemicolonToken */:
                    case 79 /* CommaToken */:
                    case 105 /* QuestionToken */:
                    case 84 /* EqualsEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                    case 103 /* AmpersandAmpersandToken */:
                    case 104 /* BarBarToken */:
                    case 100 /* CaretToken */:
                    case 98 /* AmpersandToken */:
                    case 99 /* BarToken */:
                    case 71 /* CloseBraceToken */:
                    case 10 /* EndOfFileToken */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseName = function () {
                var shouldContinue = this.isIdentifier(this.currentToken());
                var current = this.eatIdentifierToken();

                while (shouldContinue && this.currentToken().tokenKind === 76 /* DotToken */) {
                    var dotToken = this.eatToken(76 /* DotToken */);

                    var currentToken = this.currentToken();
                    var identifierName;

                    if (TypeScript.SyntaxFacts.isAnyKeyword(currentToken.tokenKind) && this.previousToken().hasTrailingNewLine() && !currentToken.hasTrailingNewLine() && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.peekToken(1))) {
                        identifierName = this.createMissingToken(11 /* IdentifierName */, currentToken);
                    } else {
                        identifierName = this.eatIdentifierNameToken();
                    }

                    current = this.factory.qualifiedName(current, dotToken, identifierName);

                    shouldContinue = identifierName.fullWidth() > 0;
                }

                return current;
            };

            ParserImpl.prototype.isEnumDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 46 /* EnumKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 46 /* EnumKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseEnumDeclaration = function () {
                var modifiers = this.parseModifiers();
                var enumKeyword = this.eatKeyword(46 /* EnumKeyword */);
                var identifier = this.eatIdentifierToken();

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);
                var enumElements = TypeScript.Syntax.emptySeparatedList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(256 /* EnumDeclaration_EnumElements */);
                    enumElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.enumDeclaration(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken);
            };

            ParserImpl.prototype.isEnumElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().kind() === 244 /* EnumElement */) {
                    return true;
                }

                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseEnumElement = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 244 /* EnumElement */) {
                    return this.eatNode();
                }

                var propertyName = this.eatPropertyName();
                var equalsValueClause = null;
                if (this.isEqualsValueClause(false)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.enumElement(propertyName, equalsValueClause);
            };

            ParserImpl.isModifier = function (token) {
                switch (token.tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                    case 47 /* ExportKeyword */:
                    case 63 /* DeclareKeyword */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.modifierCount = function () {
                var modifierCount = 0;
                while (true) {
                    if (ParserImpl.isModifier(this.peekToken(modifierCount))) {
                        modifierCount++;
                        continue;
                    }

                    break;
                }

                return modifierCount;
            };

            ParserImpl.prototype.parseModifiers = function () {
                var tokens = this.getArray();

                while (true) {
                    if (ParserImpl.isModifier(this.currentToken())) {
                        tokens.push(this.eatAnyToken());
                        continue;
                    }

                    break;
                }

                var result = TypeScript.Syntax.list(tokens);

                this.returnZeroOrOneLengthArray(tokens);

                return result;
            };

            ParserImpl.prototype.isClassDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 44 /* ClassKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 44 /* ClassKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseHeritageClauses = function () {
                var heritageClauses = TypeScript.Syntax.emptyList;

                if (this.isHeritageClause()) {
                    var result = this.parseSyntaxList(1024 /* ClassOrInterfaceDeclaration_HeritageClauses */);
                    heritageClauses = result.list;
                    TypeScript.Debug.assert(result.skippedTokens.length === 0);
                }

                return heritageClauses;
            };

            ParserImpl.prototype.parseClassDeclaration = function () {
                var modifiers = this.parseModifiers();

                var classKeyword = this.eatKeyword(44 /* ClassKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);
                var classElements = TypeScript.Syntax.emptyList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(2 /* ClassDeclaration_ClassElements */);

                    classElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.classDeclaration(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken);
            };

            ParserImpl.isPublicOrPrivateKeyword = function (token) {
                return token.tokenKind === 57 /* PublicKeyword */ || token.tokenKind === 55 /* PrivateKeyword */;
            };

            ParserImpl.prototype.isMemberAccessorDeclaration = function (inErrorRecovery) {
                var index = this.modifierCount();

                if (this.peekToken(index).tokenKind !== 64 /* GetKeyword */ && this.peekToken(index).tokenKind !== 68 /* SetKeyword */) {
                    return false;
                }

                index++;
                return this.isPropertyName(this.peekToken(index), inErrorRecovery);
            };

            ParserImpl.prototype.parseMemberAccessorDeclaration = function () {
                var modifiers = this.parseModifiers();

                if (this.currentToken().tokenKind === 64 /* GetKeyword */) {
                    return this.parseGetMemberAccessorDeclaration(modifiers);
                } else if (this.currentToken().tokenKind === 68 /* SetKeyword */) {
                    return this.parseSetMemberAccessorDeclaration(modifiers);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseGetMemberAccessorDeclaration = function (modifiers) {
                var getKeyword = this.eatKeyword(64 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, false);

                return this.factory.getMemberAccessorDeclaration(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block);
            };

            ParserImpl.prototype.parseSetMemberAccessorDeclaration = function (modifiers) {
                var setKeyword = this.eatKeyword(68 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var block = this.parseBlock(false, false);

                return this.factory.setMemberAccessorDeclaration(modifiers, setKeyword, propertyName, parameterList, block);
            };

            ParserImpl.prototype.isClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return true;
                }

                return this.isConstructorDeclaration() || this.isMemberFunctionDeclaration(inErrorRecovery) || this.isMemberAccessorDeclaration(inErrorRecovery) || this.isMemberVariableDeclaration(inErrorRecovery) || this.isIndexMemberDeclaration();
            };

            ParserImpl.prototype.parseClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return this.eatNode();
                }

                if (this.isConstructorDeclaration()) {
                    return this.parseConstructorDeclaration();
                } else if (this.isMemberFunctionDeclaration(inErrorRecovery)) {
                    return this.parseMemberFunctionDeclaration();
                } else if (this.isMemberAccessorDeclaration(inErrorRecovery)) {
                    return this.parseMemberAccessorDeclaration();
                } else if (this.isMemberVariableDeclaration(inErrorRecovery)) {
                    return this.parseMemberVariableDeclaration();
                } else if (this.isIndexMemberDeclaration()) {
                    return this.parseIndexMemberDeclaration();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isConstructorDeclaration = function () {
                return this.currentToken().tokenKind === 62 /* ConstructorKeyword */;
            };

            ParserImpl.prototype.parseConstructorDeclaration = function () {
                var constructorKeyword = this.eatKeyword(62 /* ConstructorKeyword */);
                var parameterList = this.parseParameterList();

                var semicolonToken = null;
                var block = null;

                if (this.isBlock()) {
                    block = this.parseBlock(false, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
            };

            ParserImpl.prototype.isMemberFunctionDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isCallSignature(index + 1)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(token)) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberFunctionDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isCallSignature(1)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);

                var parseBlockEvenWithNoOpenBrace = false;
                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                if (newCallSignature !== callSignature) {
                    parseBlockEvenWithNoOpenBrace = true;
                    callSignature = newCallSignature;
                }

                var block = null;
                var semicolon = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.memberFunctionDeclaration(modifiers, propertyName, callSignature, block, semicolon);
            };

            ParserImpl.prototype.isDefinitelyMemberVariablePropertyName = function (index) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(this.peekToken(index).tokenKind)) {
                    switch (this.peekToken(index + 1).tokenKind) {
                        case 78 /* SemicolonToken */:
                        case 107 /* EqualsToken */:
                        case 106 /* ColonToken */:
                        case 71 /* CloseBraceToken */:
                        case 10 /* EndOfFileToken */:
                            return true;
                        default:
                            return false;
                    }
                } else {
                    return true;
                }
            };

            ParserImpl.prototype.isMemberVariableDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isDefinitelyMemberVariablePropertyName(index)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(this.peekToken(index))) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberVariableDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isDefinitelyMemberVariablePropertyName(0)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var variableDeclarator = this.parseVariableDeclarator(true, true);
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.memberVariableDeclaration(modifiers, variableDeclarator, semicolon);
            };

            ParserImpl.prototype.isIndexMemberDeclaration = function () {
                var index = this.modifierCount();
                return this.isIndexSignature(index);
            };

            ParserImpl.prototype.parseIndexMemberDeclaration = function () {
                var modifiers = this.parseModifiers();
                var indexSignature = this.parseIndexSignature();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.indexMemberDeclaration(modifiers, indexSignature, semicolonToken);
            };

            ParserImpl.prototype.tryAddUnexpectedEqualsGreaterThanToken = function (callSignature) {
                var token0 = this.currentToken();

                var hasEqualsGreaterThanToken = token0.tokenKind === 85 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    if (callSignature.lastToken()) {
                        var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [TypeScript.SyntaxFacts.getText(70 /* OpenBraceToken */)]);
                        this.addDiagnostic(diagnostic);

                        var token = this.eatAnyToken();
                        return this.addSkippedTokenAfterNode(callSignature, token0);
                    }
                }

                return callSignature;
            };

            ParserImpl.prototype.isFunctionDeclaration = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 27 /* FunctionKeyword */;
            };

            ParserImpl.prototype.parseFunctionDeclaration = function () {
                var modifiers = this.parseModifiers();
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = this.eatIdentifierToken();
                var callSignature = this.parseCallSignature(false);

                var parseBlockEvenWithNoOpenBrace = false;
                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                if (newCallSignature !== callSignature) {
                    parseBlockEvenWithNoOpenBrace = true;
                    callSignature = newCallSignature;
                }

                var semicolonToken = null;
                var block = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.functionDeclaration(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            };

            ParserImpl.prototype.isModuleDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 65 /* ModuleKeyword */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 65 /* ModuleKeyword */) {
                    var token1 = this.peekToken(1);
                    return this.isIdentifier(token1) || token1.tokenKind === 14 /* StringLiteral */;
                }

                return false;
            };

            ParserImpl.prototype.parseModuleDeclaration = function () {
                var modifiers = this.parseModifiers();
                var moduleKeyword = this.eatKeyword(65 /* ModuleKeyword */);

                var moduleName = null;
                var stringLiteral = null;

                if (this.currentToken().tokenKind === 14 /* StringLiteral */) {
                    stringLiteral = this.eatToken(14 /* StringLiteral */);
                } else {
                    moduleName = this.parseName();
                }

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var moduleElements = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(4 /* ModuleDeclaration_ModuleElements */);
                    moduleElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.moduleDeclaration(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
            };

            ParserImpl.prototype.isInterfaceDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 52 /* InterfaceKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 52 /* InterfaceKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseInterfaceDeclaration = function () {
                var modifiers = this.parseModifiers();
                var interfaceKeyword = this.eatKeyword(52 /* InterfaceKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();

                var objectType = this.parseObjectType();
                return this.factory.interfaceDeclaration(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, objectType);
            };

            ParserImpl.prototype.parseObjectType = function () {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var typeMembers = TypeScript.Syntax.emptySeparatedList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(512 /* ObjectType_TypeMembers */);
                    typeMembers = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
            };

            ParserImpl.prototype.isTypeMember = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return true;
                }

                return this.isCallSignature(0) || this.isConstructSignature() || this.isIndexSignature(0) || this.isMethodSignature(inErrorRecovery) || this.isPropertySignature(inErrorRecovery);
            };

            ParserImpl.prototype.parseTypeMember = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return this.eatNode();
                }

                if (this.isCallSignature(0)) {
                    return this.parseCallSignature(false);
                } else if (this.isConstructSignature()) {
                    return this.parseConstructSignature();
                } else if (this.isIndexSignature(0)) {
                    return this.parseIndexSignature();
                } else if (this.isMethodSignature(inErrorRecovery)) {
                    return this.parseMethodSignature();
                } else if (this.isPropertySignature(inErrorRecovery)) {
                    return this.parsePropertySignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseConstructSignature = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.constructSignature(newKeyword, callSignature);
            };

            ParserImpl.prototype.parseIndexSignature = function () {
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                var parameter = this.parseParameter();
                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
            };

            ParserImpl.prototype.parseMethodSignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.methodSignature(propertyName, questionToken, callSignature);
            };

            ParserImpl.prototype.parsePropertySignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.propertySignature(propertyName, questionToken, typeAnnotation);
            };

            ParserImpl.prototype.isCallSignature = function (tokenIndex) {
                var tokenKind = this.peekToken(tokenIndex).tokenKind;
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructSignature = function () {
                if (this.currentToken().tokenKind !== 31 /* NewKeyword */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                return token1.tokenKind === 80 /* LessThanToken */ || token1.tokenKind === 72 /* OpenParenToken */;
            };

            ParserImpl.prototype.isIndexSignature = function (tokenIndex) {
                return this.peekToken(tokenIndex).tokenKind === 74 /* OpenBracketToken */;
            };

            ParserImpl.prototype.isMethodSignature = function (inErrorRecovery) {
                if (this.isPropertyName(this.currentToken(), inErrorRecovery)) {
                    if (this.isCallSignature(1)) {
                        return true;
                    }

                    if (this.peekToken(1).tokenKind === 105 /* QuestionToken */ && this.isCallSignature(2)) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPropertySignature = function (inErrorRecovery) {
                var currentToken = this.currentToken();

                if (ParserImpl.isModifier(currentToken) && !currentToken.hasTrailingNewLine() && this.isPropertyName(this.peekToken(1), inErrorRecovery)) {
                    return false;
                }

                return this.isPropertyName(currentToken, inErrorRecovery);
            };

            ParserImpl.prototype.isHeritageClause = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */;
            };

            ParserImpl.prototype.isNotHeritageClauseTypeName = function () {
                if (this.currentToken().tokenKind === 51 /* ImplementsKeyword */ || this.currentToken().tokenKind === 48 /* ExtendsKeyword */) {
                    return this.isIdentifier(this.peekToken(1));
                }

                return false;
            };

            ParserImpl.prototype.isHeritageClauseTypeName = function () {
                if (this.isName()) {
                    return !this.isNotHeritageClauseTypeName();
                }

                return false;
            };

            ParserImpl.prototype.parseHeritageClause = function () {
                var extendsOrImplementsKeyword = this.eatAnyToken();
                TypeScript.Debug.assert(extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */ || extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);

                var result = this.parseSeparatedSyntaxList(2048 /* HeritageClause_TypeNameList */);
                var typeNames = result.list;
                extendsOrImplementsKeyword = this.addSkippedTokensAfterToken(extendsOrImplementsKeyword, result.skippedTokens);

                return this.factory.heritageClause(extendsOrImplementsKeyword, typeNames);
            };

            ParserImpl.prototype.isStatement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return true;
                }

                switch (this.currentToken().tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                        var token1 = this.peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            return false;
                        }
                }

                return this.isVariableStatement() || this.isLabeledStatement() || this.isFunctionDeclaration() || this.isIfStatement() || this.isBlock() || this.isExpressionStatement() || this.isReturnStatement() || this.isSwitchStatement() || this.isThrowStatement() || this.isBreakStatement() || this.isContinueStatement() || this.isForOrForInStatement() || this.isEmptyStatement(inErrorRecovery) || this.isWhileStatement() || this.isWithStatement() || this.isDoStatement() || this.isTryStatement() || this.isDebuggerStatement();
            };

            ParserImpl.prototype.parseStatement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return this.eatNode();
                }

                if (this.isVariableStatement()) {
                    return this.parseVariableStatement();
                } else if (this.isLabeledStatement()) {
                    return this.parseLabeledStatement();
                } else if (this.isFunctionDeclaration()) {
                    return this.parseFunctionDeclaration();
                } else if (this.isIfStatement()) {
                    return this.parseIfStatement();
                } else if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else if (this.isReturnStatement()) {
                    return this.parseReturnStatement();
                } else if (this.isSwitchStatement()) {
                    return this.parseSwitchStatement();
                } else if (this.isThrowStatement()) {
                    return this.parseThrowStatement();
                } else if (this.isBreakStatement()) {
                    return this.parseBreakStatement();
                } else if (this.isContinueStatement()) {
                    return this.parseContinueStatement();
                } else if (this.isForOrForInStatement()) {
                    return this.parseForOrForInStatement();
                } else if (this.isEmptyStatement(inErrorRecovery)) {
                    return this.parseEmptyStatement();
                } else if (this.isWhileStatement()) {
                    return this.parseWhileStatement();
                } else if (this.isWithStatement()) {
                    return this.parseWithStatement();
                } else if (this.isDoStatement()) {
                    return this.parseDoStatement();
                } else if (this.isTryStatement()) {
                    return this.parseTryStatement();
                } else if (this.isDebuggerStatement()) {
                    return this.parseDebuggerStatement();
                } else {
                    return this.parseExpressionStatement();
                }
            };

            ParserImpl.prototype.isDebuggerStatement = function () {
                return this.currentToken().tokenKind === 19 /* DebuggerKeyword */;
            };

            ParserImpl.prototype.parseDebuggerStatement = function () {
                var debuggerKeyword = this.eatKeyword(19 /* DebuggerKeyword */);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
            };

            ParserImpl.prototype.isDoStatement = function () {
                return this.currentToken().tokenKind === 22 /* DoKeyword */;
            };

            ParserImpl.prototype.parseDoStatement = function () {
                var doKeyword = this.eatKeyword(22 /* DoKeyword */);
                var statement = this.parseStatement(false);
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(true);

                return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            };

            ParserImpl.prototype.isLabeledStatement = function () {
                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.parseLabeledStatement = function () {
                var identifier = this.eatIdentifierToken();
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statement = this.parseStatement(false);

                return this.factory.labeledStatement(identifier, colonToken, statement);
            };

            ParserImpl.prototype.isTryStatement = function () {
                return this.currentToken().tokenKind === 38 /* TryKeyword */;
            };

            ParserImpl.prototype.parseTryStatement = function () {
                var tryKeyword = this.eatKeyword(38 /* TryKeyword */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 64 /* TryBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                var catchClause = null;
                if (this.isCatchClause()) {
                    catchClause = this.parseCatchClause();
                }

                var finallyClause = null;
                if (catchClause === null || this.isFinallyClause()) {
                    finallyClause = this.parseFinallyClause();
                }

                return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
            };

            ParserImpl.prototype.isCatchClause = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */;
            };

            ParserImpl.prototype.parseCatchClause = function () {
                var catchKeyword = this.eatKeyword(17 /* CatchKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var identifier = this.eatIdentifierToken();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 128 /* CatchBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                return this.factory.catchClause(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block);
            };

            ParserImpl.prototype.isFinallyClause = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.parseFinallyClause = function () {
                var finallyKeyword = this.eatKeyword(25 /* FinallyKeyword */);
                var block = this.parseBlock(false, false);

                return this.factory.finallyClause(finallyKeyword, block);
            };

            ParserImpl.prototype.isWithStatement = function () {
                return this.currentToken().tokenKind === 43 /* WithKeyword */;
            };

            ParserImpl.prototype.parseWithStatement = function () {
                var withKeyword = this.eatKeyword(43 /* WithKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement(false);

                return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isWhileStatement = function () {
                return this.currentToken().tokenKind === 42 /* WhileKeyword */;
            };

            ParserImpl.prototype.parseWhileStatement = function () {
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement(false);

                return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isEmptyStatement = function (inErrorRecovery) {
                if (inErrorRecovery) {
                    return false;
                }

                return this.currentToken().tokenKind === 78 /* SemicolonToken */;
            };

            ParserImpl.prototype.parseEmptyStatement = function () {
                var semicolonToken = this.eatToken(78 /* SemicolonToken */);
                return this.factory.emptyStatement(semicolonToken);
            };

            ParserImpl.prototype.isForOrForInStatement = function () {
                return this.currentToken().tokenKind === 26 /* ForKeyword */;
            };

            ParserImpl.prototype.parseForOrForInStatement = function () {
                var forKeyword = this.eatKeyword(26 /* ForKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);

                var currentToken = this.currentToken();
                if (currentToken.tokenKind === 40 /* VarKeyword */) {
                    return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                } else if (currentToken.tokenKind === 78 /* SemicolonToken */) {
                    return this.parseForStatement(forKeyword, openParenToken);
                } else {
                    return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            };

            ParserImpl.prototype.parseForOrForInStatementWithVariableDeclaration = function (forKeyword, openParenToken) {
                var variableDeclaration = this.parseVariableDeclaration(false);

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            };

            ParserImpl.prototype.parseForInStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var inKeyword = this.eatKeyword(29 /* InKeyword */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement(false);

                return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration, initializer, inKeyword, expression, closeParenToken, statement);
            };

            ParserImpl.prototype.parseForOrForInStatementWithInitializer = function (forKeyword, openParenToken) {
                var initializer = this.parseExpression(false);
                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                } else {
                    return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                }
            };

            ParserImpl.prototype.parseForStatement = function (forKeyword, openParenToken) {
                var initializer = null;

                if (this.currentToken().tokenKind !== 78 /* SemicolonToken */ && this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    initializer = this.parseExpression(false);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            };

            ParserImpl.prototype.parseForStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var firstSemicolonToken = this.eatToken(78 /* SemicolonToken */);

                var condition = null;
                if (this.currentToken().tokenKind !== 78 /* SemicolonToken */ && this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    condition = this.parseExpression(true);
                }

                var secondSemicolonToken = this.eatToken(78 /* SemicolonToken */);

                var incrementor = null;
                if (this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    incrementor = this.parseExpression(true);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement(false);

                return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
            };

            ParserImpl.prototype.isBreakStatement = function () {
                return this.currentToken().tokenKind === 15 /* BreakKeyword */;
            };

            ParserImpl.prototype.parseBreakStatement = function () {
                var breakKeyword = this.eatKeyword(15 /* BreakKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.breakStatement(breakKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isContinueStatement = function () {
                return this.currentToken().tokenKind === 18 /* ContinueKeyword */;
            };

            ParserImpl.prototype.parseContinueStatement = function () {
                var continueKeyword = this.eatKeyword(18 /* ContinueKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.continueStatement(continueKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isSwitchStatement = function () {
                return this.currentToken().tokenKind === 34 /* SwitchKeyword */;
            };

            ParserImpl.prototype.parseSwitchStatement = function () {
                var switchKeyword = this.eatKeyword(34 /* SwitchKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var switchClauses = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(8 /* SwitchStatement_SwitchClauses */);
                    switchClauses = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.switchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
            };

            ParserImpl.prototype.isCaseSwitchClause = function () {
                return this.currentToken().tokenKind === 16 /* CaseKeyword */;
            };

            ParserImpl.prototype.isDefaultSwitchClause = function () {
                return this.currentToken().tokenKind === 20 /* DefaultKeyword */;
            };

            ParserImpl.prototype.isSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return true;
                }

                return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
            };

            ParserImpl.prototype.parseSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return this.eatNode();
                }

                if (this.isCaseSwitchClause()) {
                    return this.parseCaseSwitchClause();
                } else if (this.isDefaultSwitchClause()) {
                    return this.parseDefaultSwitchClause();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseCaseSwitchClause = function () {
                var caseKeyword = this.eatKeyword(16 /* CaseKeyword */);
                var expression = this.parseExpression(true);
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
            };

            ParserImpl.prototype.parseDefaultSwitchClause = function () {
                var defaultKeyword = this.eatKeyword(20 /* DefaultKeyword */);
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
            };

            ParserImpl.prototype.isThrowStatement = function () {
                return this.currentToken().tokenKind === 36 /* ThrowKeyword */;
            };

            ParserImpl.prototype.parseThrowStatement = function () {
                var throwKeyword = this.eatKeyword(36 /* ThrowKeyword */);

                var expression = null;
                if (this.canEatExplicitOrAutomaticSemicolon(false)) {
                    var token = this.createMissingToken(11 /* IdentifierName */, null);
                    expression = token;
                } else {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isReturnStatement = function () {
                return this.currentToken().tokenKind === 33 /* ReturnKeyword */;
            };

            ParserImpl.prototype.parseReturnStatement = function () {
                var returnKeyword = this.eatKeyword(33 /* ReturnKeyword */);

                var expression = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isExpressionStatement = function () {
                var currentToken = this.currentToken();

                var kind = currentToken.tokenKind;
                if (kind === 70 /* OpenBraceToken */ || kind === 27 /* FunctionKeyword */) {
                    return false;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.isAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.parseAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return this.factory.omittedExpression();
                }

                return this.parseAssignmentExpression(true);
            };

            ParserImpl.prototype.isExpression = function () {
                var currentToken = this.currentToken();
                var kind = currentToken.tokenKind;

                switch (kind) {
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                        return true;

                    case 74 /* OpenBracketToken */:
                    case 72 /* OpenParenToken */:
                        return true;

                    case 80 /* LessThanToken */:
                        return true;

                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:
                        return true;

                    case 70 /* OpenBraceToken */:
                        return true;

                    case 85 /* EqualsGreaterThanToken */:
                        return true;

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        return true;

                    case 50 /* SuperKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                        return true;

                    case 31 /* NewKeyword */:
                        return true;

                    case 21 /* DeleteKeyword */:
                    case 41 /* VoidKeyword */:
                    case 39 /* TypeOfKeyword */:
                        return true;

                    case 27 /* FunctionKeyword */:
                        return true;
                }

                if (this.isIdentifier(this.currentToken())) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpressionStatement = function () {
                var expression = this.parseExpression(true);

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.expressionStatement(expression, semicolon);
            };

            ParserImpl.prototype.isIfStatement = function () {
                return this.currentToken().tokenKind === 28 /* IfKeyword */;
            };

            ParserImpl.prototype.parseIfStatement = function () {
                var ifKeyword = this.eatKeyword(28 /* IfKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement(false);

                var elseClause = null;
                if (this.isElseClause()) {
                    elseClause = this.parseElseClause();
                }

                return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
            };

            ParserImpl.prototype.isElseClause = function () {
                return this.currentToken().tokenKind === 23 /* ElseKeyword */;
            };

            ParserImpl.prototype.parseElseClause = function () {
                var elseKeyword = this.eatKeyword(23 /* ElseKeyword */);
                var statement = this.parseStatement(false);

                return this.factory.elseClause(elseKeyword, statement);
            };

            ParserImpl.prototype.isVariableStatement = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 40 /* VarKeyword */;
            };

            ParserImpl.prototype.parseVariableStatement = function () {
                var modifiers = this.parseModifiers();
                var variableDeclaration = this.parseVariableDeclaration(true);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.variableStatement(modifiers, variableDeclaration, semicolonToken);
            };

            ParserImpl.prototype.parseVariableDeclaration = function (allowIn) {
                var varKeyword = this.eatKeyword(40 /* VarKeyword */);

                var listParsingState = allowIn ? 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */;

                var result = this.parseSeparatedSyntaxList(listParsingState);
                var variableDeclarators = result.list;
                varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);

                return this.factory.variableDeclaration(varKeyword, variableDeclarators);
            };

            ParserImpl.prototype.isVariableDeclarator = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 225 /* VariableDeclarator */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.canReuseVariableDeclaratorNode = function (node) {
                if (node === null || node.kind() !== 225 /* VariableDeclarator */) {
                    return false;
                }

                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            };

            ParserImpl.prototype.parseVariableDeclarator = function (allowIn, allowPropertyName) {
                if (this.canReuseVariableDeclaratorNode(this.currentNode())) {
                    return this.eatNode();
                }

                var propertyName = allowPropertyName ? this.eatPropertyName() : this.eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;

                if (propertyName.width() > 0) {
                    typeAnnotation = this.parseOptionalTypeAnnotation(false);

                    if (this.isEqualsValueClause(false)) {
                        equalsValueClause = this.parseEqualsValueClause(allowIn);
                    }
                }

                return this.factory.variableDeclarator(propertyName, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.isColonValueClause = function () {
                return this.currentToken().tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.isEqualsValueClause = function (inParameter) {
                var token0 = this.currentToken();
                if (token0.tokenKind === 107 /* EqualsToken */) {
                    return true;
                }

                if (!this.previousToken().hasTrailingNewLine()) {
                    if (token0.tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return false;
                    }

                    if (token0.tokenKind === 70 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }

                    return this.isExpression();
                }

                return false;
            };

            ParserImpl.prototype.parseEqualsValueClause = function (allowIn) {
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var value = this.parseAssignmentExpression(allowIn);

                return this.factory.equalsValueClause(equalsToken, value);
            };

            ParserImpl.prototype.parseExpression = function (allowIn) {
                return this.parseSubExpression(0, allowIn);
            };

            ParserImpl.prototype.parseAssignmentExpression = function (allowIn) {
                return this.parseSubExpression(2 /* AssignmentExpressionPrecedence */, allowIn);
            };

            ParserImpl.prototype.parseUnaryExpressionOrLower = function () {
                var currentTokenKind = this.currentToken().tokenKind;
                if (TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                    var operatorKind = TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

                    var operatorToken = this.eatAnyToken();

                    var operand = this.parseUnaryExpressionOrLower();
                    return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
                } else if (currentTokenKind === 39 /* TypeOfKeyword */) {
                    return this.parseTypeOfExpression();
                } else if (currentTokenKind === 41 /* VoidKeyword */) {
                    return this.parseVoidExpression();
                } else if (currentTokenKind === 21 /* DeleteKeyword */) {
                    return this.parseDeleteExpression();
                } else if (currentTokenKind === 80 /* LessThanToken */) {
                    return this.parseCastExpression();
                } else {
                    return this.parsePostfixExpressionOrLower();
                }
            };

            ParserImpl.prototype.parseSubExpression = function (precedence, allowIn) {
                if (precedence <= 2 /* AssignmentExpressionPrecedence */) {
                    if (this.isSimpleArrowFunctionExpression()) {
                        return this.parseSimpleArrowFunctionExpression();
                    }

                    var parethesizedArrowFunction = this.tryParseParenthesizedArrowFunctionExpression();
                    if (parethesizedArrowFunction !== null) {
                        return parethesizedArrowFunction;
                    }
                }

                var leftOperand = this.parseUnaryExpressionOrLower();
                return this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);
            };

            ParserImpl.prototype.parseBinaryOrConditionalExpressions = function (precedence, allowIn, leftOperand) {
                while (true) {
                    var token0 = this.currentToken();
                    var token0Kind = token0.tokenKind;

                    if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                        if (token0Kind === 29 /* InKeyword */ && !allowIn) {
                            break;
                        }

                        var mergedToken = this.tryMergeBinaryExpressionTokens();
                        var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;

                        var binaryExpressionKind = TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                        var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);

                        if (newPrecedence < precedence) {
                            break;
                        }

                        if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                            break;
                        }

                        var operatorToken = mergedToken === null ? token0 : TypeScript.Syntax.token(mergedToken.syntaxKind).withLeadingTrivia(token0.leadingTrivia()).withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());

                        var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                        for (var i = 0; i < skipCount; i++) {
                            this.eatAnyToken();
                        }

                        leftOperand = this.factory.binaryExpression(binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                        continue;
                    }

                    if (token0Kind === 105 /* QuestionToken */ && precedence <= 3 /* ConditionalExpressionPrecedence */) {
                        var questionToken = this.eatToken(105 /* QuestionToken */);

                        var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                        var colon = this.eatToken(106 /* ColonToken */);

                        var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                        leftOperand = this.factory.conditionalExpression(leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                        continue;
                    }

                    break;
                }

                return leftOperand;
            };

            ParserImpl.prototype.tryMergeBinaryExpressionTokens = function () {
                var token0 = this.currentToken();

                if (token0.tokenKind === 81 /* GreaterThanToken */ && !token0.hasTrailingTrivia()) {
                    var storage = this.mergeTokensStorage;
                    storage[0] = 0 /* None */;
                    storage[1] = 0 /* None */;
                    storage[2] = 0 /* None */;

                    for (var i = 0; i < storage.length; i++) {
                        var nextToken = this.peekToken(i + 1);

                        if (!nextToken.hasLeadingTrivia()) {
                            storage[i] = nextToken.tokenKind;
                        }

                        if (nextToken.hasTrailingTrivia()) {
                            break;
                        }
                    }

                    if (storage[0] === 81 /* GreaterThanToken */) {
                        if (storage[1] === 81 /* GreaterThanToken */) {
                            if (storage[2] === 107 /* EqualsToken */) {
                                return { tokenCount: 4, syntaxKind: 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ };
                            } else {
                                return { tokenCount: 3, syntaxKind: 97 /* GreaterThanGreaterThanGreaterThanToken */ };
                            }
                        } else if (storage[1] === 107 /* EqualsToken */) {
                            return { tokenCount: 3, syntaxKind: 113 /* GreaterThanGreaterThanEqualsToken */ };
                        } else {
                            return { tokenCount: 2, syntaxKind: 96 /* GreaterThanGreaterThanToken */ };
                        }
                    } else if (storage[0] === 107 /* EqualsToken */) {
                        return { tokenCount: 2, syntaxKind: 83 /* GreaterThanEqualsToken */ };
                    }
                }

                return null;
            };

            ParserImpl.prototype.isRightAssociative = function (expressionKind) {
                switch (expressionKind) {
                    case 174 /* AssignmentExpression */:
                    case 175 /* AddAssignmentExpression */:
                    case 176 /* SubtractAssignmentExpression */:
                    case 177 /* MultiplyAssignmentExpression */:
                    case 178 /* DivideAssignmentExpression */:
                    case 179 /* ModuloAssignmentExpression */:
                    case 180 /* AndAssignmentExpression */:
                    case 181 /* ExclusiveOrAssignmentExpression */:
                    case 182 /* OrAssignmentExpression */:
                    case 183 /* LeftShiftAssignmentExpression */:
                    case 184 /* SignedRightShiftAssignmentExpression */:
                    case 185 /* UnsignedRightShiftAssignmentExpression */:
                        return true;
                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseMemberExpressionOrLower = function (inObjectCreation) {
                if (this.currentToken().tokenKind === 31 /* NewKeyword */) {
                    return this.parseObjectCreationExpression();
                }

                var expression = this.parsePrimaryExpression();
                if (expression === null) {
                    return this.eatIdentifierToken();
                }

                return this.parseMemberExpressionRest(expression, false, inObjectCreation);
            };

            ParserImpl.prototype.parseCallExpressionOrLower = function () {
                var expression;
                if (this.currentToken().tokenKind === 50 /* SuperKeyword */) {
                    expression = this.eatKeyword(50 /* SuperKeyword */);

                    var currentTokenKind = this.currentToken().tokenKind;
                    if (currentTokenKind !== 72 /* OpenParenToken */ && currentTokenKind !== 76 /* DotToken */) {
                        expression = this.factory.memberAccessExpression(expression, this.eatToken(76 /* DotToken */), this.eatIdentifierNameToken());
                    }
                } else {
                    expression = this.parseMemberExpressionOrLower(false);
                }

                return this.parseMemberExpressionRest(expression, true, false);
            };

            ParserImpl.prototype.parseMemberExpressionRest = function (expression, allowArguments, inObjectCreation) {
                while (true) {
                    var currentTokenKind = this.currentToken().tokenKind;

                    switch (currentTokenKind) {
                        case 72 /* OpenParenToken */:
                            if (!allowArguments) {
                                return expression;
                            }

                            expression = this.factory.invocationExpression(expression, this.parseArgumentList(null));
                            continue;

                        case 80 /* LessThanToken */:
                            if (!allowArguments) {
                                return expression;
                            }

                            var argumentList = this.tryParseArgumentList();
                            if (argumentList !== null) {
                                expression = this.factory.invocationExpression(expression, argumentList);
                                continue;
                            }

                            break;

                        case 74 /* OpenBracketToken */:
                            expression = this.parseElementAccessExpression(expression, inObjectCreation);
                            continue;

                        case 76 /* DotToken */:
                            expression = this.factory.memberAccessExpression(expression, this.eatToken(76 /* DotToken */), this.eatIdentifierNameToken());
                            continue;
                    }

                    return expression;
                }
            };

            ParserImpl.prototype.parseLeftHandSideExpressionOrLower = function () {
                if (this.currentToken().tokenKind === 31 /* NewKeyword */) {
                    return this.parseObjectCreationExpression();
                } else {
                    return this.parseCallExpressionOrLower();
                }
            };

            ParserImpl.prototype.parsePostfixExpressionOrLower = function () {
                var expression = this.parseLeftHandSideExpressionOrLower();
                if (expression === null) {
                    return this.eatIdentifierToken();
                }

                var currentTokenKind = this.currentToken().tokenKind;

                switch (currentTokenKind) {
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                        if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                            break;
                        }

                        return this.factory.postfixUnaryExpression(TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                }

                return expression;
            };

            ParserImpl.prototype.tryParseArgumentList = function () {
                var typeArgumentList = null;

                if (this.currentToken().tokenKind === 80 /* LessThanToken */) {
                    var rewindPoint = this.getRewindPoint();
                    try  {
                        typeArgumentList = this.tryParseTypeArgumentList(true);
                        var token0 = this.currentToken();

                        var isOpenParen = token0.tokenKind === 72 /* OpenParenToken */;
                        var isDot = token0.tokenKind === 76 /* DotToken */;
                        var isOpenParenOrDot = isOpenParen || isDot;
                        if (typeArgumentList === null || !isOpenParenOrDot) {
                            this.rewind(rewindPoint);
                            return null;
                        }

                        if (isDot) {
                            var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, null);
                            this.addDiagnostic(diagnostic);

                            return this.factory.argumentList(typeArgumentList, TypeScript.Syntax.emptyToken(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.emptyToken(73 /* CloseParenToken */));
                        }
                    } finally {
                        this.releaseRewindPoint(rewindPoint);
                    }
                }

                if (this.currentToken().tokenKind === 72 /* OpenParenToken */) {
                    return this.parseArgumentList(typeArgumentList);
                }

                return null;
            };

            ParserImpl.prototype.parseArgumentList = function (typeArgumentList) {
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var arguments = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.fullWidth() > 0) {
                    var result = this.parseSeparatedSyntaxList(16384 /* ArgumentList_AssignmentExpressions */);
                    arguments = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
            };

            ParserImpl.prototype.parseElementAccessExpression = function (expression, inObjectCreation) {
                var start = this.currentTokenStart();
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                var argumentExpression;

                if (this.currentToken().tokenKind === 75 /* CloseBracketToken */ && inObjectCreation) {
                    var end = this.currentTokenStart() + this.currentToken().width();
                    var diagnostic = new TypeScript.Diagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, null);
                    this.addDiagnostic(diagnostic);

                    argumentExpression = TypeScript.Syntax.emptyToken(11 /* IdentifierName */);
                } else {
                    argumentExpression = this.parseExpression(true);
                }

                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
            };

            ParserImpl.prototype.parsePrimaryExpression = function () {
                var currentToken = this.currentToken();

                if (this.isIdentifier(currentToken)) {
                    return this.eatIdentifierToken();
                }

                var currentTokenKind = currentToken.tokenKind;
                switch (currentTokenKind) {
                    case 35 /* ThisKeyword */:
                        return this.parseThisExpression();

                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                        return this.parseLiteralExpression();

                    case 32 /* NullKeyword */:
                        return this.parseLiteralExpression();

                    case 27 /* FunctionKeyword */:
                        return this.parseFunctionExpression();

                    case 13 /* NumericLiteral */:
                        return this.parseLiteralExpression();

                    case 12 /* RegularExpressionLiteral */:
                        return this.parseLiteralExpression();

                    case 14 /* StringLiteral */:
                        return this.parseLiteralExpression();

                    case 74 /* OpenBracketToken */:
                        return this.parseArrayLiteralExpression();

                    case 70 /* OpenBraceToken */:
                        return this.parseObjectLiteralExpression();

                    case 72 /* OpenParenToken */:
                        return this.parseParenthesizedExpression();

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        var result = this.tryReparseDivideAsRegularExpression();
                        if (result !== null) {
                            return result;
                        }
                        break;
                }

                return null;
            };

            ParserImpl.prototype.tryReparseDivideAsRegularExpression = function () {
                var currentToken = this.currentToken();

                if (this.previousToken() !== null) {
                    var previousTokenKind = this.previousToken().tokenKind;
                    switch (previousTokenKind) {
                        case 11 /* IdentifierName */:
                            return null;

                        case 35 /* ThisKeyword */:
                        case 37 /* TrueKeyword */:
                        case 24 /* FalseKeyword */:
                            return null;

                        case 14 /* StringLiteral */:
                        case 13 /* NumericLiteral */:
                        case 12 /* RegularExpressionLiteral */:
                        case 93 /* PlusPlusToken */:
                        case 94 /* MinusMinusToken */:
                        case 75 /* CloseBracketToken */:
                            return null;
                    }
                }

                currentToken = this.currentTokenAllowingRegularExpression();

                if (currentToken.tokenKind === 118 /* SlashToken */ || currentToken.tokenKind === 119 /* SlashEqualsToken */) {
                    return null;
                } else if (currentToken.tokenKind === 12 /* RegularExpressionLiteral */) {
                    return this.parseLiteralExpression();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseTypeOfExpression = function () {
                var typeOfKeyword = this.eatKeyword(39 /* TypeOfKeyword */);
                var expression = this.parseUnaryExpressionOrLower();

                return this.factory.typeOfExpression(typeOfKeyword, expression);
            };

            ParserImpl.prototype.parseDeleteExpression = function () {
                var deleteKeyword = this.eatKeyword(21 /* DeleteKeyword */);
                var expression = this.parseUnaryExpressionOrLower();

                return this.factory.deleteExpression(deleteKeyword, expression);
            };

            ParserImpl.prototype.parseVoidExpression = function () {
                var voidKeyword = this.eatKeyword(41 /* VoidKeyword */);
                var expression = this.parseUnaryExpressionOrLower();

                return this.factory.voidExpression(voidKeyword, expression);
            };

            ParserImpl.prototype.parseSuperExpression = function () {
                var superKeyword = this.eatKeyword(50 /* SuperKeyword */);
                return superKeyword;
            };

            ParserImpl.prototype.parseFunctionExpression = function () {
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = null;

                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }

                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
            };

            ParserImpl.prototype.parseObjectCreationExpression = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);

                var expression = this.parseObjectCreationExpressionOrLower(true);
                var argumentList = this.tryParseArgumentList();

                var result = this.factory.objectCreationExpression(newKeyword, expression, argumentList);
                return this.parseMemberExpressionRest(result, true, false);
            };

            ParserImpl.prototype.parseObjectCreationExpressionOrLower = function (inObjectCreation) {
                if (this.currentToken().tokenKind === 31 /* NewKeyword */) {
                    return this.parseObjectCreationExpression();
                } else {
                    return this.parseMemberExpressionOrLower(inObjectCreation);
                }
            };

            ParserImpl.prototype.parseCastExpression = function () {
                var lessThanToken = this.eatToken(80 /* LessThanToken */);
                var type = this.parseType();
                var greaterThanToken = this.eatToken(81 /* GreaterThanToken */);
                var expression = this.parseUnaryExpressionOrLower();

                return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
            };

            ParserImpl.prototype.parseParenthesizedExpression = function () {
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
            };

            ParserImpl.prototype.tryParseParenthesizedArrowFunctionExpression = function () {
                var tokenKind = this.currentToken().tokenKind;
                if (tokenKind !== 72 /* OpenParenToken */ && tokenKind !== 80 /* LessThanToken */) {
                    return null;
                }

                if (this.isDefinitelyArrowFunctionExpression()) {
                    return this.parseParenthesizedArrowFunctionExpression(false);
                }

                if (!this.isPossiblyArrowFunctionExpression()) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.parseParenthesizedArrowFunctionExpression(true);
                    if (arrowFunction === null) {
                        this.rewind(rewindPoint);
                    }
                    return arrowFunction;
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.parseParenthesizedArrowFunctionExpression = function (requireArrow) {
                var currentToken = this.currentToken();

                var callSignature = this.parseCallSignature(true);

                if (requireArrow && this.currentToken().tokenKind !== 85 /* EqualsGreaterThanToken */) {
                    return null;
                }

                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.parseArrowFunctionBody = function () {
                if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else {
                    if (this.isStatement(false) && !this.isExpressionStatement() && !this.isFunctionDeclaration()) {
                        return this.parseBlock(true, false);
                    } else {
                        return this.parseAssignmentExpression(true);
                    }
                }
            };

            ParserImpl.prototype.isSimpleArrowFunctionExpression = function () {
                if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 85 /* EqualsGreaterThanToken */;
            };

            ParserImpl.prototype.parseSimpleArrowFunctionExpression = function () {
                var identifier = this.eatIdentifierToken();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.simpleArrowFunctionExpression(identifier, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.isBlock = function () {
                return this.currentToken().tokenKind === 70 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isDefinitelyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 72 /* OpenParenToken */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                var token2;

                if (token1.tokenKind === 73 /* CloseParenToken */) {
                    token2 = this.peekToken(2);
                    return token2.tokenKind === 106 /* ColonToken */ || token2.tokenKind === 85 /* EqualsGreaterThanToken */ || token2.tokenKind === 70 /* OpenBraceToken */;
                }

                if (token1.tokenKind === 77 /* DotDotDotToken */) {
                    return true;
                }

                token2 = this.peekToken(2);
                if (token1.tokenKind === 57 /* PublicKeyword */ || token1.tokenKind === 55 /* PrivateKeyword */) {
                    if (this.isIdentifier(token2)) {
                        return true;
                    }
                }

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                if (token2.tokenKind === 106 /* ColonToken */) {
                    return true;
                }

                var token3 = this.peekToken(3);
                if (token2.tokenKind === 105 /* QuestionToken */) {
                    if (token3.tokenKind === 106 /* ColonToken */ || token3.tokenKind === 73 /* CloseParenToken */ || token3.tokenKind === 79 /* CommaToken */) {
                        return true;
                    }
                }

                if (token2.tokenKind === 73 /* CloseParenToken */) {
                    if (token3.tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPossiblyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 72 /* OpenParenToken */) {
                    return true;
                }

                var token1 = this.peekToken(1);

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                var token2 = this.peekToken(2);
                if (token2.tokenKind === 107 /* EqualsToken */) {
                    return true;
                }

                if (token2.tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                if (token2.tokenKind === 73 /* CloseParenToken */) {
                    var token3 = this.peekToken(3);
                    if (token3.tokenKind === 106 /* ColonToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.parseObjectLiteralExpression = function () {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var result = this.parseSeparatedSyntaxList(32768 /* ObjectLiteralExpression_PropertyAssignments */);
                var propertyAssignments = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.objectLiteralExpression(openBraceToken, propertyAssignments, closeBraceToken);
            };

            ParserImpl.prototype.parsePropertyAssignment = function (inErrorRecovery) {
                if (this.isGetAccessorPropertyAssignment(inErrorRecovery)) {
                    return this.parseGetAccessorPropertyAssignment();
                } else if (this.isSetAccessorPropertyAssignment(inErrorRecovery)) {
                    return this.parseSetAccessorPropertyAssignment();
                } else if (this.isFunctionPropertyAssignment(inErrorRecovery)) {
                    return this.parseFunctionPropertyAssignment();
                } else if (this.isSimplePropertyAssignment(inErrorRecovery)) {
                    return this.parseSimplePropertyAssignment();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isPropertyAssignment = function (inErrorRecovery) {
                return this.isGetAccessorPropertyAssignment(inErrorRecovery) || this.isSetAccessorPropertyAssignment(inErrorRecovery) || this.isFunctionPropertyAssignment(inErrorRecovery) || this.isSimplePropertyAssignment(inErrorRecovery);
            };

            ParserImpl.prototype.isGetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 64 /* GetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseGetAccessorPropertyAssignment = function () {
                var getKeyword = this.eatKeyword(64 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, true);

                return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block);
            };

            ParserImpl.prototype.isSetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 68 /* SetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseSetAccessorPropertyAssignment = function () {
                var setKeyword = this.eatKeyword(68 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var parameter = this.parseParameter();
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var block = this.parseBlock(false, true);

                return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block);
            };

            ParserImpl.prototype.eatPropertyName = function () {
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken()) ? this.eatIdentifierNameToken() : this.eatAnyToken();
            };

            ParserImpl.prototype.isFunctionPropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery) && this.isCallSignature(1);
            };

            ParserImpl.prototype.parseFunctionPropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionPropertyAssignment(propertyName, callSignature, block);
            };

            ParserImpl.prototype.isSimplePropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseSimplePropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var colonToken = this.eatToken(106 /* ColonToken */);
                var expression = this.parseAssignmentExpression(true);

                return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
            };

            ParserImpl.prototype.isPropertyName = function (token, inErrorRecovery) {
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    if (inErrorRecovery) {
                        return this.isIdentifier(token);
                    } else {
                        return true;
                    }
                }

                switch (token.tokenKind) {
                    case 14 /* StringLiteral */:
                    case 13 /* NumericLiteral */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseArrayLiteralExpression = function () {
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);

                var result = this.parseSeparatedSyntaxList(65536 /* ArrayLiteralExpression_AssignmentExpressions */);
                var expressions = result.list;
                openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
            };

            ParserImpl.prototype.parseLiteralExpression = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.parseThisExpression = function () {
                return this.eatKeyword(35 /* ThisKeyword */);
            };

            ParserImpl.prototype.parseBlock = function (parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var statements = TypeScript.Syntax.emptyList;

                if (parseBlockEvenWithNoOpenBrace || openBraceToken.width() > 0) {
                    var savedIsInStrictMode = this.isInStrictMode;

                    var processItems = checkForStrictMode ? ParserImpl.updateStrictModeState : null;
                    var result = this.parseSyntaxList(32 /* Block_Statements */, processItems);
                    statements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                    this.setStrictMode(savedIsInStrictMode);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.block(openBraceToken, statements, closeBraceToken);
            };

            ParserImpl.prototype.parseCallSignature = function (requireCompleteTypeParameterList) {
                var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
            };

            ParserImpl.prototype.parseOptionalTypeParameterList = function (requireCompleteTypeParameterList) {
                if (this.currentToken().tokenKind !== 80 /* LessThanToken */) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var lessThanToken = this.eatToken(80 /* LessThanToken */);

                    var result = this.parseSeparatedSyntaxList(524288 /* TypeParameterList_TypeParameters */);
                    var typeParameterList = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    var greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.isTypeParameter = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.parseTypeParameter = function () {
                var identifier = this.eatIdentifierToken();
                var constraint = this.parseOptionalConstraint();

                return this.factory.typeParameter(identifier, constraint);
            };

            ParserImpl.prototype.parseOptionalConstraint = function () {
                if (this.currentToken().kind() !== 48 /* ExtendsKeyword */) {
                    return null;
                }

                var extendsKeyword = this.eatKeyword(48 /* ExtendsKeyword */);
                var type = this.parseType();

                return this.factory.constraint(extendsKeyword, type);
            };

            ParserImpl.prototype.parseParameterList = function () {
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var parameters = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(131072 /* ParameterList_Parameters */);
                    parameters = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                return this.factory.parameterList(openParenToken, parameters, closeParenToken);
            };

            ParserImpl.prototype.isTypeAnnotation = function () {
                return this.currentToken().tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.parseOptionalTypeAnnotation = function (allowStringLiteral) {
                return this.isTypeAnnotation() ? this.parseTypeAnnotation(allowStringLiteral) : null;
            };

            ParserImpl.prototype.parseTypeAnnotation = function (allowStringLiteral) {
                var colonToken = this.eatToken(106 /* ColonToken */);
                var type = allowStringLiteral && this.currentToken().tokenKind === 14 /* StringLiteral */ ? this.eatToken(14 /* StringLiteral */) : this.parseType();

                return this.factory.typeAnnotation(colonToken, type);
            };

            ParserImpl.prototype.isType = function () {
                return this.isPredefinedType() || this.isTypeLiteral() || this.isTypeQuery() || this.isName();
            };

            ParserImpl.prototype.parseType = function () {
                if (this.isTypeQuery()) {
                    return this.parseTypeQuery();
                } else {
                    var type = this.parseNonArrayType();

                    while (this.currentToken().tokenKind === 74 /* OpenBracketToken */) {
                        var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                        var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                        type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
                    }

                    return type;
                }
            };

            ParserImpl.prototype.isTypeQuery = function () {
                return this.currentToken().tokenKind === 39 /* TypeOfKeyword */;
            };

            ParserImpl.prototype.parseTypeQuery = function () {
                var typeOfKeyword = this.eatToken(39 /* TypeOfKeyword */);
                var name = this.parseName();

                return this.factory.typeQuery(typeOfKeyword, name);
            };

            ParserImpl.prototype.parseNonArrayType = function () {
                if (this.isPredefinedType()) {
                    return this.parsePredefinedType();
                } else if (this.isTypeLiteral()) {
                    return this.parseTypeLiteral();
                } else {
                    return this.parseNameOrGenericType();
                }
            };

            ParserImpl.prototype.parseNameOrGenericType = function () {
                var name = this.parseName();
                var typeArgumentList = this.tryParseTypeArgumentList(false);

                return typeArgumentList === null ? name : this.factory.genericType(name, typeArgumentList);
            };

            ParserImpl.prototype.parseTypeLiteral = function () {
                if (this.isObjectType()) {
                    return this.parseObjectType();
                } else if (this.isFunctionType()) {
                    return this.parseFunctionType();
                } else if (this.isConstructorType()) {
                    return this.parseConstructorType();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseFunctionType = function () {
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var returnType = this.parseType();

                return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
            };

            ParserImpl.prototype.parseConstructorType = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var type = this.parseType();

                return this.factory.constructorType(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type);
            };

            ParserImpl.prototype.isTypeLiteral = function () {
                return this.isObjectType() || this.isFunctionType() || this.isConstructorType();
            };

            ParserImpl.prototype.isObjectType = function () {
                return this.currentToken().tokenKind === 70 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isFunctionType = function () {
                var tokenKind = this.currentToken().tokenKind;
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructorType = function () {
                return this.currentToken().tokenKind === 31 /* NewKeyword */;
            };

            ParserImpl.prototype.parsePredefinedType = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.isPredefinedType = function () {
                switch (this.currentToken().tokenKind) {
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                    case 41 /* VoidKeyword */:
                        return true;
                }

                return false;
            };

            ParserImpl.prototype.isParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* Parameter */) {
                    return true;
                }

                var token = this.currentToken();
                if (token.tokenKind === 77 /* DotDotDotToken */) {
                    return true;
                }

                if (ParserImpl.isPublicOrPrivateKeyword(token)) {
                    return true;
                }

                return this.isIdentifier(token);
            };

            ParserImpl.prototype.parseParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* Parameter */) {
                    return this.eatNode();
                }

                var dotDotDotToken = this.tryEatToken(77 /* DotDotDotToken */);

                var publicOrPrivateToken = null;
                if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                    publicOrPrivateToken = this.eatAnyToken();
                }

                var identifier = this.eatIdentifierToken();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(true);

                var equalsValueClause = null;
                if (this.isEqualsValueClause(true)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.parameter(dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.parseSyntaxList = function (currentListType, processItems) {
                if (typeof processItems === "undefined") { processItems = null; }
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSyntaxListWorker(currentListType, processItems);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.parseSeparatedSyntaxList = function (currentListType) {
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSeparatedSyntaxListWorker(currentListType);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.abortParsingListOrMoveToNextToken = function (currentListType, items, skippedTokens) {
                this.reportUnexpectedTokenDiagnostic(currentListType);

                for (var state = 262144 /* LastListParsingState */; state >= 1 /* FirstListParsingState */; state >>= 1) {
                    if ((this.listParsingState & state) !== 0) {
                        if (this.isExpectedListTerminator(state) || this.isExpectedListItem(state, true)) {
                            return true;
                        }
                    }
                }

                var skippedToken = this.currentToken();

                this.moveToNextToken();

                this.addSkippedTokenToList(items, skippedTokens, skippedToken);

                return false;
            };

            ParserImpl.prototype.addSkippedTokenToList = function (items, skippedTokens, skippedToken) {
                for (var i = items.length - 1; i >= 0; i--) {
                    var item = items[i];
                    var lastToken = item.lastToken();
                    if (lastToken.fullWidth() > 0) {
                        items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                        return;
                    }
                }

                skippedTokens.push(skippedToken);
            };

            ParserImpl.prototype.tryParseExpectedListItem = function (currentListType, inErrorRecovery, items, processItems) {
                if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                    var item = this.parseExpectedListItem(currentListType, inErrorRecovery);

                    items.push(item);

                    if (processItems !== null) {
                        processItems(this, items);
                    }
                }
            };

            ParserImpl.prototype.listIsTerminated = function (currentListType) {
                return this.isExpectedListTerminator(currentListType) || this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.getArray = function () {
                if (this.arrayPool.length > 0) {
                    return this.arrayPool.pop();
                }

                return [];
            };

            ParserImpl.prototype.returnZeroOrOneLengthArray = function (array) {
                if (array.length <= 1) {
                    this.returnArray(array);
                }
            };

            ParserImpl.prototype.returnArray = function (array) {
                array.length = 0;
                this.arrayPool.push(array);
            };

            ParserImpl.prototype.parseSyntaxListWorker = function (currentListType, processItems) {
                var items = this.getArray();
                var skippedTokens = this.getArray();

                while (true) {
                    var oldItemsCount = items.length;
                    this.tryParseExpectedListItem(currentListType, false, items, processItems);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }

                var result = TypeScript.Syntax.list(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.parseSeparatedSyntaxListWorker = function (currentListType) {
                var items = this.getArray();
                var skippedTokens = this.getArray();
                TypeScript.Debug.assert(items.length === 0);
                TypeScript.Debug.assert(skippedTokens.length === 0);
                TypeScript.Debug.assert(skippedTokens !== items);

                var separatorKind = this.separatorKind(currentListType);
                var allowAutomaticSemicolonInsertion = separatorKind === 78 /* SemicolonToken */;

                var inErrorRecovery = false;
                var listWasTerminated = false;
                while (true) {
                    var oldItemsCount = items.length;

                    this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            listWasTerminated = true;
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        } else {
                            inErrorRecovery = true;
                            continue;
                        }
                    }

                    inErrorRecovery = false;

                    var currentToken = this.currentToken();
                    if (currentToken.tokenKind === separatorKind || currentToken.tokenKind === 79 /* CommaToken */) {
                        items.push(this.eatAnyToken());
                        continue;
                    }

                    if (this.listIsTerminated(currentListType)) {
                        listWasTerminated = true;
                        break;
                    }

                    if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(false)) {
                        items.push(this.eatExplicitOrAutomaticSemicolon(false));

                        continue;
                    }

                    items.push(this.eatToken(separatorKind));

                    inErrorRecovery = true;
                }

                var result = TypeScript.Syntax.separatedList(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.separatorKind = function (currentListType) {
                switch (currentListType) {
                    case 2048 /* HeritageClause_TypeNameList */:
                    case 16384 /* ArgumentList_AssignmentExpressions */:
                    case 256 /* EnumDeclaration_EnumElements */:
                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                    case 131072 /* ParameterList_Parameters */:
                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                    case 262144 /* TypeArgumentList_Types */:
                    case 524288 /* TypeParameterList_TypeParameters */:
                        return 79 /* CommaToken */;

                    case 512 /* ObjectType_TypeMembers */:
                        return 78 /* SemicolonToken */;

                    case 1 /* SourceUnit_ModuleElements */:
                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                    case 2 /* ClassDeclaration_ClassElements */:
                    case 4 /* ModuleDeclaration_ModuleElements */:
                    case 8 /* SwitchStatement_SwitchClauses */:
                    case 16 /* SwitchClause_Statements */:
                    case 32 /* Block_Statements */:
                    default:
                        throw TypeScript.Errors.notYetImplemented();
                }
            };

            ParserImpl.prototype.reportUnexpectedTokenDiagnostic = function (listType) {
                var token = this.currentToken();

                var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [this.getExpectedListElementType(listType)]);
                this.addDiagnostic(diagnostic);
            };

            ParserImpl.prototype.addDiagnostic = function (diagnostic) {
                if (this.diagnostics.length > 0 && this.diagnostics[this.diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }

                this.diagnostics.push(diagnostic);
            };

            ParserImpl.prototype.isExpectedListTerminator = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isExpectedSourceUnit_ModuleElementsTerminator();

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isExpectedClassDeclaration_ClassElementsTerminator();

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isExpectedModuleDeclaration_ModuleElementsTerminator();

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isExpectedSwitchStatement_SwitchClausesTerminator();

                    case 16 /* SwitchClause_Statements */:
                        return this.isExpectedSwitchClause_StatementsTerminator();

                    case 32 /* Block_Statements */:
                        return this.isExpectedBlock_StatementsTerminator();

                    case 64 /* TryBlock_Statements */:
                        return this.isExpectedTryBlock_StatementsTerminator();

                    case 128 /* CatchBlock_Statements */:
                        return this.isExpectedCatchBlock_StatementsTerminator();

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isExpectedEnumDeclaration_EnumElementsTerminator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isExpectedObjectType_TypeMembersTerminator();

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpressionsTerminator();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isExpectedHeritageClause_TypeNameListTerminator();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                    case 131072 /* ParameterList_Parameters */:
                        return this.isExpectedParameterList_ParametersTerminator();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isExpectedTypeArgumentList_TypesTerminator();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isExpectedTypeParameterList_TypeParametersTerminator();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedSourceUnit_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.isExpectedEnumDeclaration_EnumElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedModuleDeclaration_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectType_TypeMembersTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedLiteralExpression_AssignmentExpressionsTerminator = function () {
                return this.currentToken().tokenKind === 75 /* CloseBracketToken */;
            };

            ParserImpl.prototype.isExpectedTypeArgumentList_TypesTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedTypeParameterList_TypeParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (token.tokenKind === 72 /* OpenParenToken */ || token.tokenKind === 70 /* OpenBraceToken */ || token.tokenKind === 48 /* ExtendsKeyword */ || token.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedParameterList_ParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (token.tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }

                if (token.tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator = function () {
                if (this.currentToken().tokenKind === 78 /* SemicolonToken */ || this.currentToken().tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator = function () {
                if (this.previousToken().tokenKind === 79 /* CommaToken */) {
                    return false;
                }

                if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.canEatExplicitOrAutomaticSemicolon(false);
            };

            ParserImpl.prototype.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 70 /* OpenBraceToken */ || token0.tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedHeritageClause_TypeNameListTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                if (this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpressionsTerminator = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 73 /* CloseParenToken */ || token0.tokenKind === 78 /* SemicolonToken */;
            };

            ParserImpl.prototype.isExpectedClassDeclaration_ClassElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchStatement_SwitchClausesTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchClause_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */ || this.isSwitchClause();
            };

            ParserImpl.prototype.isExpectedBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedTryBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */ || this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedCatchBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedListItem = function (currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isClassElement(inErrorRecovery);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 32 /* Block_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 64 /* TryBlock_Statements */:
                    case 128 /* CatchBlock_Statements */:
                        return false;

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isEnumElement(inErrorRecovery);

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isVariableDeclarator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isTypeMember(inErrorRecovery);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpression();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isHeritageClauseTypeName();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isPropertyAssignment(inErrorRecovery);

                    case 131072 /* ParameterList_Parameters */:
                        return this.isParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isTypeParameter();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isAssignmentOrOmittedExpression();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpression = function () {
                if (this.isExpression()) {
                    return true;
                }

                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpectedListItem = function (currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.parseModuleElement(inErrorRecovery);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.parseHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.parseClassElement(inErrorRecovery);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.parseModuleElement(inErrorRecovery);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.parseSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.parseStatement(inErrorRecovery);

                    case 32 /* Block_Statements */:
                        return this.parseStatement(inErrorRecovery);

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.parseEnumElement();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.parseTypeMember(inErrorRecovery);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.parseAssignmentExpression(true);

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.parseNameOrGenericType();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.parseVariableDeclarator(true, false);

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.parseVariableDeclarator(false, false);

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.parsePropertyAssignment(inErrorRecovery);

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.parseAssignmentOrOmittedExpression();

                    case 131072 /* ParameterList_Parameters */:
                        return this.parseParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.parseType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.parseTypeParameter();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.getExpectedListElementType = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return '{';

                    case 2 /* ClassDeclaration_ClassElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.constructor_function_accessor_or_variable, null);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.case_or_default_clause, null);

                    case 16 /* SwitchClause_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);

                    case 32 /* Block_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);

                    case 256 /* EnumDeclaration_EnumElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);

                    case 512 /* ObjectType_TypeMembers */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.call_construct_index_property_or_function_signature, null);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);

                    case 2048 /* HeritageClause_TypeNameList */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null);

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.property_or_accessor, null);

                    case 131072 /* ParameterList_Parameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);

                    case 262144 /* TypeArgumentList_Types */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null);

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            return ParserImpl;
        })();

        function parse(fileName, text, isDeclaration, options) {
            var source = new NormalParserSource(fileName, text, options.languageVersion());

            return new ParserImpl(fileName, text.lineMap(), source, options).parseSyntaxTree(isDeclaration);
        }
        Parser.parse = parse;

        function incrementalParse(oldSyntaxTree, textChangeRange, newText) {
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }

            var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);

            return new ParserImpl(oldSyntaxTree.fileName(), newText.lineMap(), source, oldSyntaxTree.parseOptions()).parseSyntaxTree(oldSyntaxTree.isDeclaration());
        }
        Parser.incrementalParse = incrementalParse;
    })(TypeScript.Parser || (TypeScript.Parser = {}));
    var Parser = TypeScript.Parser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, lineMap, parseOtions) {
            this._allDiagnostics = null;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._parseOptions = parseOtions;
        }
        SyntaxTree.prototype.toJSON = function (key) {
            var result = {};

            result.isDeclaration = this._isDeclaration;
            result.languageVersion = TypeScript.LanguageVersion[this._parseOptions.languageVersion()];
            result.parseOptions = this._parseOptions;

            if (this.diagnostics().length > 0) {
                result.diagnostics = this.diagnostics();
            }

            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;

            return result;
        };

        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };

        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };

        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }

            var diagnostics = [];
            this.sourceUnit().accept(new GrammarCheckerWalker(this, diagnostics));

            return diagnostics;
        };

        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }

            return this._allDiagnostics;
        };

        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };

        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };

        SyntaxTree.prototype.parseOptions = function () {
            return this._parseOptions;
        };

        SyntaxTree.prototype.structuralEquals = function (tree) {
            return TypeScript.ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), TypeScript.Diagnostic.equals) && this.sourceUnit().structuralEquals(tree.sourceUnit());
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;

    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.currentConstructor = null;
        }
        GrammarCheckerWalker.prototype.childFullStart = function (parent, child) {
            return this.position() + TypeScript.Syntax.childOffset(parent, child);
        };

        GrammarCheckerWalker.prototype.childStart = function (parent, child) {
            return this.childFullStart(parent, child) + child.leadingTriviaWidth();
        };

        GrammarCheckerWalker.prototype.pushDiagnostic = function (start, length, diagnosticKey, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), start, length, diagnosticKey, args));
        };

        GrammarCheckerWalker.prototype.pushDiagnostic1 = function (elementFullStart, element, diagnosticKey, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), elementFullStart + element.leadingTriviaWidth(), element.width(), diagnosticKey, args));
        };

        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(this.childStart(node, node.typeAnnotation), node.typeAnnotation.width(), TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
            }

            _super.prototype.visitCatchClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);

            var seenOptionalParameter = false;
            var parameterCount = node.parameters.nonSeparatorCount();

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameterIndex = i / 2;
                    var parameter = node.parameters.childAt(i);

                    if (parameter.dotDotDotToken) {
                        if (parameterIndex !== (parameterCount - 1)) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_must_be_last_in_list);
                            return true;
                        }

                        if (parameter.questionToken) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_be_optional);
                            return true;
                        }

                        if (parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_have_an_initializer);
                            return true;
                        }
                    } else if (parameter.questionToken || parameter.equalsValueClause) {
                        seenOptionalParameter = true;

                        if (parameter.questionToken && parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                            return true;
                        }
                    } else {
                        if (seenOptionalParameter) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Required_parameter_cannot_follow_optional_parameter);
                            return true;
                        }
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            if (this.currentConstructor !== null && this.currentConstructor.parameterList === node && this.currentConstructor.block && !this.inAmbientDeclaration) {
                return false;
            }

            var parameterFullStart = this.childFullStart(node, node.parameters);

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameter = node.parameters.childAt(i);

                    if (parameter.publicOrPrivateKeyword) {
                        var keywordFullStart = parameterFullStart + TypeScript.Syntax.childOffset(parameter, parameter.publicOrPrivateKeyword);

                        if (this.inAmbientDeclaration) {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_an_ambient_context);
                        } else if (this.currentConstructor && !this.currentConstructor.block) {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_a_constructor_overload);
                        } else {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_can_only_be_used_in_constructors);
                        }
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForTrailingSeparator = function (parent, list) {
            if (list.childCount() === 0 || list.childCount() % 2 === 1) {
                return false;
            }

            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i === n - 1) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode.Trailing_separator_not_allowed);
                }

                currentElementFullStart += child.fullWidth();
            }

            return true;
        };

        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, expected) {
            if (list.childCount() > 0) {
                return false;
            }

            var listFullStart = this.childFullStart(parent, list);
            var tokenAtStart = this.syntaxTree.sourceUnit().findToken(listFullStart);

            this.pushDiagnostic1(listFullStart, tokenAtStart.token(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [expected]);

            return true;
        };

        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingSeparator(node, node.parameters)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitHeritageClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.arguments)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForTrailingSeparator(node, node.variableDeclarators) || this.checkForAtLeastOneElement(node, node.variableDeclarators, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameter);
            var parameter = node.parameter;

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            } else if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            } else if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            } else if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            } else if (!parameter.typeAnnotation) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            } else if (parameter.typeAnnotation.type.kind() !== 69 /* StringKeyword */ && parameter.typeAnnotation.type.kind() !== 67 /* NumberKeyword */) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                this.skip(node);
                return;
            }

            if (!node.typeAnnotation) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                this.skip(node);
                return;
            }

            _super.prototype.visitIndexSignature.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;
            var seenImplementsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }

                    if (heritageClause.typeNames.nonSeparatorCount() > 1) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }

                    seenImplementsClause = true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

                if (declareToken) {
                    this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_for_code_already_in_an_ambient_context);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, typeKeyword, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic1(this.childFullStart(moduleElement, typeKeyword), typeKeyword.firstToken(), TypeScript.DiagnosticCode.declare_modifier_required_for_top_level_element);
                    return true;
                }
            }
        };

        GrammarCheckerWalker.prototype.checkFunctionOverloads = function (node, moduleElements) {
            if (!this.inAmbientDeclaration && !this.syntaxTree.isDeclaration()) {
                var moduleElementFullStart = this.childFullStart(node, moduleElements);

                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;

                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var moduleElement = moduleElements.childAt(i);
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== 129 /* FunctionDeclaration */) {
                            this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        var functionDeclaration = moduleElement;
                        if (functionDeclaration.identifier.valueText() !== functionOverloadChainName) {
                            var identifierFullStart = moduleElementFullStart + TypeScript.Syntax.childOffset(moduleElement, functionDeclaration.identifier);
                            this.pushDiagnostic1(identifierFullStart, functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                    }

                    if (moduleElement.kind() === 129 /* FunctionDeclaration */) {
                        functionDeclaration = moduleElement;
                        if (!TypeScript.SyntaxUtilities.containsToken(functionDeclaration.modifiers, 63 /* DeclareKeyword */)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = functionDeclaration.identifier.valueText();

                            if (lastElement && inFunctionOverloadChain) {
                                this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                                return true;
                            }
                        } else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }

                    moduleElementFullStart += moduleElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkClassOverloads = function (node) {
            if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                var classElementFullStart = this.childFullStart(node, node.classElements);

                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;

                var functionOverloadChainName = null;
                var isInStaticOverloadChain = null;
                var memberFunctionDeclaration = null;

                for (var i = 0, n = node.classElements.childCount(); i < n; i++) {
                    var classElement = node.classElements.childAt(i);
                    var lastElement = i === (n - 1);
                    var isStaticOverload = null;

                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== 135 /* MemberFunctionDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        memberFunctionDeclaration = classElement;
                        if (memberFunctionDeclaration.propertyName.valueText() !== functionOverloadChainName) {
                            var propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                        isStaticOverload = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);
                        if (isStaticOverload !== isInStaticOverloadChain) {
                            propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            var diagnostic = isInStaticOverloadChain ? TypeScript.DiagnosticCode.Function_overload_must_be_static : TypeScript.DiagnosticCode.Function_overload_must_not_be_static;
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, diagnostic, null);
                            return true;
                        }
                    } else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== 137 /* ConstructorDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }

                    if (classElement.kind() === 135 /* MemberFunctionDeclaration */) {
                        memberFunctionDeclaration = classElement;

                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = memberFunctionDeclaration.propertyName.valueText();
                        isInStaticOverloadChain = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);

                        if (lastElement && inFunctionOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                    } else if (classElement.kind() === 137 /* ConstructorDeclaration */) {
                        var constructorDeclaration = classElement;

                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }

                    classElementFullStart += classElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForReservedName = function (parent, name, diagnosticKey) {
            var nameFullStart = this.childFullStart(parent, name);
            var token;
            var tokenFullStart;

            var current = name;
            while (current !== null) {
                if (current.kind() === 121 /* QualifiedName */) {
                    var qualifiedName = current;
                    token = qualifiedName.right;
                    tokenFullStart = nameFullStart + this.childFullStart(qualifiedName, token);
                    current = qualifiedName.left;
                } else {
                    TypeScript.Debug.assert(current.kind() === 11 /* IdentifierName */);
                    token = current;
                    tokenFullStart = nameFullStart;
                    current = null;
                }

                switch (token.valueText()) {
                    case "any":
                    case "number":
                    case "boolean":
                    case "string":
                    case "void":
                        this.pushDiagnostic(tokenFullStart + token.leadingTriviaWidth(), token.width(), diagnosticKey, [token.valueText()]);
                        return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Class_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node) || this.checkClassOverloads(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            var modifierFullStart = this.position();

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 63 /* DeclareKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.declare_modifier_cannot_appear_on_an_interface_declaration);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Interface_name_cannot_be_0) || this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var modifierFullStart = this.position();

            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var modifier = list.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }

                    if (seenStaticModifier) {
                        var previousToken = list.childAt(i - 1);
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }

                    seenAccessibilityModifier = true;
                } else if (modifier.tokenKind === 58 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }

                    seenStaticModifier = true;
                } else {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkGetMemberAccessorParameter = function (node) {
            var getKeywordFullStart = this.childFullStart(node, node.getKeyword);
            if (node.parameterList.parameters.childCount() !== 0) {
                this.pushDiagnostic1(getKeywordFullStart, node.getKeyword, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexMemberDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkIndexMemberModifiers(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitIndexMemberDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexMemberModifiers = function (node) {
            var modifierFullStart = this.position();

            for (var i = 0, n = node.modifiers.childCount(); i < n; i++) {
                var modifier = node.modifiers.childAt(i);
                if (modifier.tokenKind !== 58 /* StaticKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Index_member_declaration_can_only_have_the_static_modifier);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, node, languageVersion, diagnosticKey) {
            if (this.syntaxTree.parseOptions().languageVersion() < languageVersion) {
                var nodeFullStart = this.childFullStart(parent, node);
                this.pushDiagnostic1(nodeFullStart, node, diagnosticKey);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkClassElementModifiers(node.modifiers) || this.checkGetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForAccessorDeclarationInAmbientContext = function (node) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts, null);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkSetMemberAccessorParameter = function (node) {
            var setKeywordFullStart = this.childFullStart(node, node.setKeyword);
            if (node.parameterList.parameters.childCount() !== 1) {
                this.pushDiagnostic1(setKeywordFullStart, node.setKeyword, TypeScript.DiagnosticCode.set_accessor_must_have_one_and_only_one_parameter);
                return true;
            }

            var parameterListFullStart = this.childFullStart(node, node.parameterList);
            var parameterFullStart = parameterListFullStart + TypeScript.Syntax.childOffset(node.parameterList, node.parameterList.openParenToken);
            var parameter = node.parameterList.parameters.childAt(0);

            if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_accessibility_modifier);
                return true;
            }

            if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }

            if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkClassElementModifiers(node.modifiers) || this.checkSetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Enum_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var enumElementFullStart = this.childFullStart(node, node.enumElements);

            var seenComputedValue = false;
            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                var child = node.enumElements.childAt(i);

                if (i % 2 === 0) {
                    var enumElement = child;

                    if (!enumElement.equalsValueClause && seenComputedValue) {
                        this.pushDiagnostic1(enumElementFullStart, enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer, null);
                        return true;
                    }

                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        if (!TypeScript.Syntax.isIntegerLiteral(value)) {
                            seenComputedValue = true;
                        }
                    }
                }

                enumElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    this.skip(node);
                    return;
                }
            }

            _super.prototype.visitEnumElement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === 50 /* SuperKeyword */ && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }

            _super.prototype.visitInvocationExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            var seenExportModifier = false;
            var seenDeclareModifier = false;

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */ || modifier.tokenKind === 58 /* StaticKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }

                if (modifier.tokenKind === 63 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }

                    seenDeclareModifier = true;
                } else if (modifier.tokenKind === 47 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }

                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(47 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(63 /* DeclareKeyword */)]);
                        return;
                    }

                    seenExportModifier = true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            var currentElementFullStart = this.childFullStart(node, node.moduleElements);

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);
                if (child.kind() === 133 /* ImportDeclaration */) {
                    var importDeclaration = child;
                    if (importDeclaration.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                        if (node.stringLiteral === null) {
                            this.pushDiagnostic1(currentElementFullStart, importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module, null);
                        }
                    }
                }

                currentElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

            if (declareToken) {
                this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_on_import_declaration);
                return true;
            }
        };

        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitImportDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForReservedName(node, node.moduleName, TypeScript.DiagnosticCode.Module_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (!TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */) && this.checkFunctionOverloads(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    var stringLiteralFullStart = this.childFullStart(node, node.stringLiteral);
                    this.pushDiagnostic1(stringLiteralFullStart, node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    this.skip(node);
                    return;
                }
            }

            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExports = function (node, moduleElements) {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);

                if (TypeScript.SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }

            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var child = moduleElements.childAt(i);

                    if (child.kind() === 134 /* ExportAssignment */) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_not_allowed_in_module_with_exported_element);
                        return true;
                    }

                    moduleElementFullStart += child.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForMultipleExportAssignments = function (node, moduleElements) {
            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            var seenExportAssignment = false;
            var errorFound = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);
                if (child.kind() === 134 /* ExportAssignment */) {
                    if (seenExportAssignment) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Module_cannot_have_multiple_export_assignments);
                        errorFound = true;
                    }
                    seenExportAssignment = true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return errorFound;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            var moduleElementFullStart = this.childFullStart(node, node.moduleElements);

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);

                if (child.kind() === 134 /* ExportAssignment */) {
                    this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);

                    return true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }

            if (this.checkFunctionOverloads(node, node.statements)) {
                this.skip(node);
                return;
            }

            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };

        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitBreakStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitContinueStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDebuggerStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDoStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitEmptyStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitExpressionStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForInStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitIfStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitLabeledStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitReturnStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSwitchStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitThrowStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTryStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWhileStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWithStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock && modifiers.childCount() > 0) {
                var modifierFullStart = this.childFullStart(parent, modifiers);
                this.pushDiagnostic1(modifierFullStart, modifiers.childAt(0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }

                currentElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, 78 /* SemicolonToken */)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }

            _super.prototype.visitVariableDeclarator.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            _super.prototype.visitConstructorDeclaration.call(this, node);
            this.currentConstructor = savedCurrentConstructor;
        };

        GrammarCheckerWalker.prototype.visitSourceUnit = function (node) {
            if (this.checkFunctionOverloads(node, node.moduleElements) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSourceUnit.call(this, node);
        };
        return GrammarCheckerWalker;
    })(TypeScript.PositionTrackingWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpanWalker = (function (_super) {
        __extends(TextSpanWalker, _super);
        function TextSpanWalker(textSpan) {
            _super.call(this);
            this.textSpan = textSpan;
            this._position = 0;
        }
        TextSpanWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        TextSpanWalker.prototype.visitNode = function (node) {
            var nodeSpan = new TypeScript.TextSpan(this.position(), node.fullWidth());

            if (nodeSpan.intersectsWithTextSpan(this.textSpan)) {
                node.accept(this);
            } else {
                this._position += node.fullWidth();
            }
        };

        TextSpanWalker.prototype.position = function () {
            return this._position;
        };
        return TextSpanWalker;
    })(TypeScript.SyntaxWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            if (code < map[0]) {
                return false;
            }

            var lo = 0;
            var hi = map.length;
            var mid;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;

                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 2;
                }
            }

            return false;
        };

        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };

        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];

        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;

        CompilerDiagnostics.diagnosticWriter = null;

        CompilerDiagnostics.analysisPass = 0;

        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;

        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;

        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;

    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;

    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;

    function withoutFlag(val, flag) {
        return val & ~flag;
    }
    TypeScript.withoutFlag = withoutFlag;

    (function (ASTFlags) {
        ASTFlags[ASTFlags["None"] = 0] = "None";
        ASTFlags[ASTFlags["SingleLine"] = 1 << 1] = "SingleLine";
        ASTFlags[ASTFlags["OptionalName"] = 1 << 2] = "OptionalName";
        ASTFlags[ASTFlags["TypeReference"] = 1 << 3] = "TypeReference";
        ASTFlags[ASTFlags["EnumElement"] = 1 << 4] = "EnumElement";
    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));
    var ASTFlags = TypeScript.ASTFlags;

    (function (DeclFlags) {
        DeclFlags[DeclFlags["None"] = 0] = "None";
        DeclFlags[DeclFlags["Exported"] = 1] = "Exported";
        DeclFlags[DeclFlags["Private"] = 1 << 1] = "Private";
        DeclFlags[DeclFlags["Public"] = 1 << 2] = "Public";
        DeclFlags[DeclFlags["Ambient"] = 1 << 3] = "Ambient";
        DeclFlags[DeclFlags["Static"] = 1 << 4] = "Static";
    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));
    var DeclFlags = TypeScript.DeclFlags;

    (function (ModuleFlags) {
        ModuleFlags[ModuleFlags["None"] = 0] = "None";
        ModuleFlags[ModuleFlags["Exported"] = 1] = "Exported";
        ModuleFlags[ModuleFlags["Private"] = 1 << 1] = "Private";
        ModuleFlags[ModuleFlags["Public"] = 1 << 2] = "Public";
        ModuleFlags[ModuleFlags["Ambient"] = 1 << 3] = "Ambient";
        ModuleFlags[ModuleFlags["Static"] = 1 << 4] = "Static";
        ModuleFlags[ModuleFlags["IsEnum"] = 1 << 7] = "IsEnum";
        ModuleFlags[ModuleFlags["IsExternalModule"] = 1 << 8] = "IsExternalModule";
    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));
    var ModuleFlags = TypeScript.ModuleFlags;

    (function (VariableFlags) {
        VariableFlags[VariableFlags["None"] = 0] = "None";
        VariableFlags[VariableFlags["Exported"] = 1] = "Exported";
        VariableFlags[VariableFlags["Private"] = 1 << 1] = "Private";
        VariableFlags[VariableFlags["Public"] = 1 << 2] = "Public";
        VariableFlags[VariableFlags["Ambient"] = 1 << 3] = "Ambient";
        VariableFlags[VariableFlags["Static"] = 1 << 4] = "Static";
        VariableFlags[VariableFlags["Property"] = 1 << 8] = "Property";
        VariableFlags[VariableFlags["ClassProperty"] = 1 << 11] = "ClassProperty";
        VariableFlags[VariableFlags["EnumElement"] = 1 << 13] = "EnumElement";
        VariableFlags[VariableFlags["ForInVariable"] = 1 << 14] = "ForInVariable";
    })(TypeScript.VariableFlags || (TypeScript.VariableFlags = {}));
    var VariableFlags = TypeScript.VariableFlags;

    (function (FunctionFlags) {
        FunctionFlags[FunctionFlags["None"] = 0] = "None";
        FunctionFlags[FunctionFlags["Exported"] = 1] = "Exported";
        FunctionFlags[FunctionFlags["Private"] = 1 << 1] = "Private";
        FunctionFlags[FunctionFlags["Public"] = 1 << 2] = "Public";
        FunctionFlags[FunctionFlags["Ambient"] = 1 << 3] = "Ambient";
        FunctionFlags[FunctionFlags["Static"] = 1 << 4] = "Static";
        FunctionFlags[FunctionFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        FunctionFlags[FunctionFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        FunctionFlags[FunctionFlags["Signature"] = 1 << 7] = "Signature";
        FunctionFlags[FunctionFlags["Method"] = 1 << 8] = "Method";
        FunctionFlags[FunctionFlags["CallMember"] = 1 << 9] = "CallMember";
        FunctionFlags[FunctionFlags["ConstructMember"] = 1 << 10] = "ConstructMember";
        FunctionFlags[FunctionFlags["IndexerMember"] = 1 << 12] = "IndexerMember";
        FunctionFlags[FunctionFlags["IsFunctionExpression"] = 1 << 13] = "IsFunctionExpression";
        FunctionFlags[FunctionFlags["IsFunctionProperty"] = 1 << 14] = "IsFunctionProperty";
        FunctionFlags[FunctionFlags["IsClassMethod"] = 1 << 15] = "IsClassMethod";
    })(TypeScript.FunctionFlags || (TypeScript.FunctionFlags = {}));
    var FunctionFlags = TypeScript.FunctionFlags;

    function ToDeclFlags(fncOrVarOrModuleFlags) {
        return fncOrVarOrModuleFlags;
    }
    TypeScript.ToDeclFlags = ToDeclFlags;

    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags[TypeRelationshipFlags["SuccessfulComparison"] = 0] = "SuccessfulComparison";
        TypeRelationshipFlags[TypeRelationshipFlags["RequiredPropertyIsMissing"] = 1 << 1] = "RequiredPropertyIsMissing";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleSignatures"] = 1 << 2] = "IncompatibleSignatures";
        TypeRelationshipFlags[TypeRelationshipFlags["SourceSignatureHasTooManyParameters"] = 3] = "SourceSignatureHasTooManyParameters";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleReturnTypes"] = 1 << 4] = "IncompatibleReturnTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatiblePropertyTypes"] = 1 << 5] = "IncompatiblePropertyTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleParameterTypes"] = 1 << 6] = "IncompatibleParameterTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["InconsistantPropertyAccesibility"] = 1 << 7] = "InconsistantPropertyAccesibility";
    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;

    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Unspecified"] = 0] = "Unspecified";
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 1] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 2] = "Asynchronous";
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (NodeType) {
        NodeType[NodeType["None"] = 0] = "None";
        NodeType[NodeType["List"] = 1] = "List";
        NodeType[NodeType["Script"] = 2] = "Script";

        NodeType[NodeType["TrueLiteral"] = 3] = "TrueLiteral";
        NodeType[NodeType["FalseLiteral"] = 4] = "FalseLiteral";
        NodeType[NodeType["StringLiteral"] = 5] = "StringLiteral";
        NodeType[NodeType["RegularExpressionLiteral"] = 6] = "RegularExpressionLiteral";
        NodeType[NodeType["NumericLiteral"] = 7] = "NumericLiteral";
        NodeType[NodeType["NullLiteral"] = 8] = "NullLiteral";

        NodeType[NodeType["TypeParameter"] = 9] = "TypeParameter";
        NodeType[NodeType["GenericType"] = 10] = "GenericType";
        NodeType[NodeType["TypeRef"] = 11] = "TypeRef";
        NodeType[NodeType["TypeQuery"] = 12] = "TypeQuery";

        NodeType[NodeType["FunctionDeclaration"] = 13] = "FunctionDeclaration";
        NodeType[NodeType["ClassDeclaration"] = 14] = "ClassDeclaration";
        NodeType[NodeType["InterfaceDeclaration"] = 15] = "InterfaceDeclaration";
        NodeType[NodeType["ObjectType"] = 16] = "ObjectType";
        NodeType[NodeType["ModuleDeclaration"] = 17] = "ModuleDeclaration";
        NodeType[NodeType["ImportDeclaration"] = 18] = "ImportDeclaration";
        NodeType[NodeType["VariableDeclarator"] = 19] = "VariableDeclarator";
        NodeType[NodeType["VariableDeclaration"] = 20] = "VariableDeclaration";
        NodeType[NodeType["Parameter"] = 21] = "Parameter";

        NodeType[NodeType["Name"] = 22] = "Name";
        NodeType[NodeType["ArrayLiteralExpression"] = 23] = "ArrayLiteralExpression";
        NodeType[NodeType["ObjectLiteralExpression"] = 24] = "ObjectLiteralExpression";
        NodeType[NodeType["OmittedExpression"] = 25] = "OmittedExpression";
        NodeType[NodeType["VoidExpression"] = 26] = "VoidExpression";
        NodeType[NodeType["CommaExpression"] = 27] = "CommaExpression";
        NodeType[NodeType["PlusExpression"] = 28] = "PlusExpression";
        NodeType[NodeType["NegateExpression"] = 29] = "NegateExpression";
        NodeType[NodeType["DeleteExpression"] = 30] = "DeleteExpression";
        NodeType[NodeType["ThisExpression"] = 31] = "ThisExpression";
        NodeType[NodeType["SuperExpression"] = 32] = "SuperExpression";
        NodeType[NodeType["InExpression"] = 33] = "InExpression";
        NodeType[NodeType["MemberAccessExpression"] = 34] = "MemberAccessExpression";
        NodeType[NodeType["InstanceOfExpression"] = 35] = "InstanceOfExpression";
        NodeType[NodeType["TypeOfExpression"] = 36] = "TypeOfExpression";
        NodeType[NodeType["ElementAccessExpression"] = 37] = "ElementAccessExpression";
        NodeType[NodeType["InvocationExpression"] = 38] = "InvocationExpression";
        NodeType[NodeType["ObjectCreationExpression"] = 39] = "ObjectCreationExpression";
        NodeType[NodeType["AssignmentExpression"] = 40] = "AssignmentExpression";
        NodeType[NodeType["AddAssignmentExpression"] = 41] = "AddAssignmentExpression";
        NodeType[NodeType["SubtractAssignmentExpression"] = 42] = "SubtractAssignmentExpression";
        NodeType[NodeType["DivideAssignmentExpression"] = 43] = "DivideAssignmentExpression";
        NodeType[NodeType["MultiplyAssignmentExpression"] = 44] = "MultiplyAssignmentExpression";
        NodeType[NodeType["ModuloAssignmentExpression"] = 45] = "ModuloAssignmentExpression";
        NodeType[NodeType["AndAssignmentExpression"] = 46] = "AndAssignmentExpression";
        NodeType[NodeType["ExclusiveOrAssignmentExpression"] = 47] = "ExclusiveOrAssignmentExpression";
        NodeType[NodeType["OrAssignmentExpression"] = 48] = "OrAssignmentExpression";
        NodeType[NodeType["LeftShiftAssignmentExpression"] = 49] = "LeftShiftAssignmentExpression";
        NodeType[NodeType["SignedRightShiftAssignmentExpression"] = 50] = "SignedRightShiftAssignmentExpression";
        NodeType[NodeType["UnsignedRightShiftAssignmentExpression"] = 51] = "UnsignedRightShiftAssignmentExpression";
        NodeType[NodeType["ConditionalExpression"] = 52] = "ConditionalExpression";
        NodeType[NodeType["LogicalOrExpression"] = 53] = "LogicalOrExpression";
        NodeType[NodeType["LogicalAndExpression"] = 54] = "LogicalAndExpression";
        NodeType[NodeType["BitwiseOrExpression"] = 55] = "BitwiseOrExpression";
        NodeType[NodeType["BitwiseExclusiveOrExpression"] = 56] = "BitwiseExclusiveOrExpression";
        NodeType[NodeType["BitwiseAndExpression"] = 57] = "BitwiseAndExpression";
        NodeType[NodeType["EqualsWithTypeConversionExpression"] = 58] = "EqualsWithTypeConversionExpression";
        NodeType[NodeType["NotEqualsWithTypeConversionExpression"] = 59] = "NotEqualsWithTypeConversionExpression";
        NodeType[NodeType["EqualsExpression"] = 60] = "EqualsExpression";
        NodeType[NodeType["NotEqualsExpression"] = 61] = "NotEqualsExpression";
        NodeType[NodeType["LessThanExpression"] = 62] = "LessThanExpression";
        NodeType[NodeType["LessThanOrEqualExpression"] = 63] = "LessThanOrEqualExpression";
        NodeType[NodeType["GreaterThanExpression"] = 64] = "GreaterThanExpression";
        NodeType[NodeType["GreaterThanOrEqualExpression"] = 65] = "GreaterThanOrEqualExpression";
        NodeType[NodeType["AddExpression"] = 66] = "AddExpression";
        NodeType[NodeType["SubtractExpression"] = 67] = "SubtractExpression";
        NodeType[NodeType["MultiplyExpression"] = 68] = "MultiplyExpression";
        NodeType[NodeType["DivideExpression"] = 69] = "DivideExpression";
        NodeType[NodeType["ModuloExpression"] = 70] = "ModuloExpression";
        NodeType[NodeType["LeftShiftExpression"] = 71] = "LeftShiftExpression";
        NodeType[NodeType["SignedRightShiftExpression"] = 72] = "SignedRightShiftExpression";
        NodeType[NodeType["UnsignedRightShiftExpression"] = 73] = "UnsignedRightShiftExpression";
        NodeType[NodeType["BitwiseNotExpression"] = 74] = "BitwiseNotExpression";
        NodeType[NodeType["LogicalNotExpression"] = 75] = "LogicalNotExpression";
        NodeType[NodeType["PreIncrementExpression"] = 76] = "PreIncrementExpression";
        NodeType[NodeType["PreDecrementExpression"] = 77] = "PreDecrementExpression";
        NodeType[NodeType["PostIncrementExpression"] = 78] = "PostIncrementExpression";
        NodeType[NodeType["PostDecrementExpression"] = 79] = "PostDecrementExpression";
        NodeType[NodeType["CastExpression"] = 80] = "CastExpression";
        NodeType[NodeType["ParenthesizedExpression"] = 81] = "ParenthesizedExpression";
        NodeType[NodeType["ArrowFunctionExpression"] = 82] = "ArrowFunctionExpression";
        NodeType[NodeType["Member"] = 83] = "Member";

        NodeType[NodeType["Block"] = 84] = "Block";
        NodeType[NodeType["BreakStatement"] = 85] = "BreakStatement";
        NodeType[NodeType["ContinueStatement"] = 86] = "ContinueStatement";
        NodeType[NodeType["DebuggerStatement"] = 87] = "DebuggerStatement";
        NodeType[NodeType["DoStatement"] = 88] = "DoStatement";
        NodeType[NodeType["EmptyStatement"] = 89] = "EmptyStatement";
        NodeType[NodeType["ExportAssignment"] = 90] = "ExportAssignment";
        NodeType[NodeType["ExpressionStatement"] = 91] = "ExpressionStatement";
        NodeType[NodeType["ForInStatement"] = 92] = "ForInStatement";
        NodeType[NodeType["ForStatement"] = 93] = "ForStatement";
        NodeType[NodeType["IfStatement"] = 94] = "IfStatement";
        NodeType[NodeType["LabeledStatement"] = 95] = "LabeledStatement";
        NodeType[NodeType["ReturnStatement"] = 96] = "ReturnStatement";
        NodeType[NodeType["SwitchStatement"] = 97] = "SwitchStatement";
        NodeType[NodeType["ThrowStatement"] = 98] = "ThrowStatement";
        NodeType[NodeType["TryStatement"] = 99] = "TryStatement";
        NodeType[NodeType["VariableStatement"] = 100] = "VariableStatement";
        NodeType[NodeType["WhileStatement"] = 101] = "WhileStatement";
        NodeType[NodeType["WithStatement"] = 102] = "WithStatement";

        NodeType[NodeType["CaseClause"] = 103] = "CaseClause";
        NodeType[NodeType["CatchClause"] = 104] = "CatchClause";

        NodeType[NodeType["Comment"] = 105] = "Comment";
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var proto = "__proto__";

    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;

            this[proto] = null;
            this[proto] = undefined;
        }
        return BlockIntrinsics;
    })();
    TypeScript.BlockIntrinsics = BlockIntrinsics;

    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = new BlockIntrinsics();
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        };

        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.map = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };

        StringHashTable.prototype.every = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        };

        StringHashTable.prototype.some = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        };

        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };

        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;

    var IdentiferNameHashTable = (function (_super) {
        __extends(IdentiferNameHashTable, _super);
        function IdentiferNameHashTable() {
            _super.apply(this, arguments);
        }
        IdentiferNameHashTable.prototype.getAllKeys = function () {
            var result = [];

            _super.prototype.map.call(this, function (k, v, c) {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);

            return result;
        };

        IdentiferNameHashTable.prototype.add = function (key, data) {
            return _super.prototype.add.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.addOrUpdate = function (key, data) {
            return _super.prototype.addOrUpdate.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.map = function (fn, context) {
            return _super.prototype.map.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.every = function (fn, context) {
            return _super.prototype.every.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.some = function (fn, context) {
            return _super.prototype.some.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.lookup = function (key) {
            return _super.prototype.lookup.call(this, "#" + key);
        };
        return IdentiferNameHashTable;
    })(StringHashTable);
    TypeScript.IdentiferNameHashTable = IdentiferNameHashTable;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;

    var AstWalker = (function () {
        function AstWalker(childrenWalkers, pre, post, options, state) {
            this.childrenWalkers = childrenWalkers;
            this.pre = pre;
            this.post = post;
            this.options = options;
            this.state = state;
        }
        AstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }

            this.pre(ast, this);

            if (this.options.goChildren) {
                this.childrenWalkers[ast.nodeType()](ast, this);
            } else {
                this.options.goChildren = true;
            }

            if (this.post) {
                this.post(ast, this);
            }
        };
        return AstWalker;
    })();

    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
            this.childrenWalkers = [];
            this.initChildrenWalkers();
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {
            this.getWalker(pre, post, options, state).walk(ast);
        };

        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {
            return this.getSlowWalker(pre, post, options, state);
        };

        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {
            if (!options) {
                options = new AstWalkOptions();
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        };

        AstWalkerFactory.prototype.initChildrenWalkers = function () {
            this.childrenWalkers[0 /* None */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[89 /* EmptyStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[25 /* OmittedExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[3 /* TrueLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[4 /* FalseLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[31 /* ThisExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[32 /* SuperExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[5 /* StringLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[6 /* RegularExpressionLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[8 /* NullLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[23 /* ArrayLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[24 /* ObjectLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[26 /* VoidExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[27 /* CommaExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[28 /* PlusExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[29 /* NegateExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[30 /* DeleteExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[33 /* InExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[34 /* MemberAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[35 /* InstanceOfExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[36 /* TypeOfExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[7 /* NumericLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[22 /* Name */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[9 /* TypeParameter */] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[10 /* GenericType */] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[11 /* TypeRef */] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[12 /* TypeQuery */] = ChildrenWalkers.walkTypeQueryChildren;
            this.childrenWalkers[37 /* ElementAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[38 /* InvocationExpression */] = ChildrenWalkers.walkInvocationExpressionChildren;
            this.childrenWalkers[39 /* ObjectCreationExpression */] = ChildrenWalkers.walkObjectCreationExpressionChildren;
            this.childrenWalkers[40 /* AssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[41 /* AddAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[42 /* SubtractAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[43 /* DivideAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[44 /* MultiplyAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[45 /* ModuloAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[46 /* AndAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[47 /* ExclusiveOrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[48 /* OrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[49 /* LeftShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[50 /* SignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[51 /* UnsignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[52 /* ConditionalExpression */] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[53 /* LogicalOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[54 /* LogicalAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[55 /* BitwiseOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[56 /* BitwiseExclusiveOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[57 /* BitwiseAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[58 /* EqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[59 /* NotEqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[60 /* EqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[61 /* NotEqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[62 /* LessThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[63 /* LessThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[64 /* GreaterThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[65 /* GreaterThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[66 /* AddExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[67 /* SubtractExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[68 /* MultiplyExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[69 /* DivideExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[70 /* ModuloExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[71 /* LeftShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[72 /* SignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[73 /* UnsignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[74 /* BitwiseNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[75 /* LogicalNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[76 /* PreIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[77 /* PreDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[78 /* PostIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[79 /* PostDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[80 /* CastExpression */] = ChildrenWalkers.walkCastExpressionChildren;
            this.childrenWalkers[81 /* ParenthesizedExpression */] = ChildrenWalkers.walkParenthesizedExpressionChildren;
            this.childrenWalkers[82 /* ArrowFunctionExpression */] = ChildrenWalkers.walkArrowFunctionExpressionChildren;
            this.childrenWalkers[13 /* FunctionDeclaration */] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[83 /* Member */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[19 /* VariableDeclarator */] = ChildrenWalkers.walkVariableDeclaratorChildren;
            this.childrenWalkers[20 /* VariableDeclaration */] = ChildrenWalkers.walkVariableDeclarationChildren;
            this.childrenWalkers[21 /* Parameter */] = ChildrenWalkers.walkParameterChildren;
            this.childrenWalkers[96 /* ReturnStatement */] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[85 /* BreakStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[86 /* ContinueStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[98 /* ThrowStatement */] = ChildrenWalkers.walkThrowStatementChildren;
            this.childrenWalkers[93 /* ForStatement */] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[92 /* ForInStatement */] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[94 /* IfStatement */] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[101 /* WhileStatement */] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[88 /* DoStatement */] = ChildrenWalkers.walkDoStatementChildren;
            this.childrenWalkers[84 /* Block */] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[103 /* CaseClause */] = ChildrenWalkers.walkCaseClauseChildren;
            this.childrenWalkers[97 /* SwitchStatement */] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[99 /* TryStatement */] = ChildrenWalkers.walkTryStatementChildren;
            this.childrenWalkers[104 /* CatchClause */] = ChildrenWalkers.walkCatchClauseChildren;
            this.childrenWalkers[1 /* List */] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[2 /* Script */] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[14 /* ClassDeclaration */] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[15 /* InterfaceDeclaration */] = ChildrenWalkers.walkInterfaceDeclerationChildren;
            this.childrenWalkers[16 /* ObjectType */] = ChildrenWalkers.walkObjectTypeChildren;
            this.childrenWalkers[17 /* ModuleDeclaration */] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[18 /* ImportDeclaration */] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[90 /* ExportAssignment */] = ChildrenWalkers.walkExportAssignmentChildren;
            this.childrenWalkers[102 /* WithStatement */] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[91 /* ExpressionStatement */] = ChildrenWalkers.walkExpressionStatementChildren;
            this.childrenWalkers[95 /* LabeledStatement */] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[100 /* VariableStatement */] = ChildrenWalkers.walkVariableStatementChildren;
            this.childrenWalkers[105 /* Comment */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[87 /* DebuggerStatement */] = ChildrenWalkers.walkNone;

            for (var e in TypeScript.NodeType) {
                if (TypeScript.NodeType.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.NodeType[e])) {
                    TypeScript.CompilerDiagnostics.assert(this.childrenWalkers[e] !== undefined, "initWalkers function is not up to date with enum content!");
                }
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;

    var globalAstWalkerFactory;

    function getAstWalkerFactory() {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;

    var ChildrenWalkers;
    (function (ChildrenWalkers) {
        function walkNone(preAst, walker) {
        }
        ChildrenWalkers.walkNone = walkNone;

        function walkListChildren(preAst, walker) {
            var len = preAst.members.length;

            for (var i = 0; i < len; i++) {
                walker.walk(preAst.members[i]);
            }
        }
        ChildrenWalkers.walkListChildren = walkListChildren;

        function walkThrowStatementChildren(preAst, walker) {
            walker.walk(preAst.expression);
        }
        ChildrenWalkers.walkThrowStatementChildren = walkThrowStatementChildren;

        function walkUnaryExpressionChildren(preAst, walker) {
            walker.walk(preAst.operand);
        }
        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;

        function walkCastExpressionChildren(preAst, walker) {
            walker.walk(preAst.castType);
            walker.walk(preAst.operand);
        }
        ChildrenWalkers.walkCastExpressionChildren = walkCastExpressionChildren;

        function walkParenthesizedExpressionChildren(preAst, walker) {
            walker.walk(preAst.expression);
        }
        ChildrenWalkers.walkParenthesizedExpressionChildren = walkParenthesizedExpressionChildren;

        function walkBinaryExpressionChildren(preAst, walker) {
            walker.walk(preAst.operand1);
            walker.walk(preAst.operand2);
        }
        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;

        function walkTypeParameterChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.constraint);
        }
        ChildrenWalkers.walkTypeParameterChildren = walkTypeParameterChildren;

        function walkGenericTypeChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.typeArguments);
        }
        ChildrenWalkers.walkGenericTypeChildren = walkGenericTypeChildren;

        function walkTypeReferenceChildren(preAst, walker) {
            walker.walk(preAst.term);
        }
        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;

        function walkTypeQueryChildren(preAst, walker) {
            walker.walk(preAst.name);
        }
        ChildrenWalkers.walkTypeQueryChildren = walkTypeQueryChildren;

        function walkInvocationExpressionChildren(preAst, walker) {
            walker.walk(preAst.target);
            walker.walk(preAst.typeArguments);
            walker.walk(preAst.arguments);
        }
        ChildrenWalkers.walkInvocationExpressionChildren = walkInvocationExpressionChildren;

        function walkObjectCreationExpressionChildren(preAst, walker) {
            walker.walk(preAst.target);

            walker.walk(preAst.typeArguments);
            walker.walk(preAst.arguments);
        }
        ChildrenWalkers.walkObjectCreationExpressionChildren = walkObjectCreationExpressionChildren;

        function walkTrinaryExpressionChildren(preAst, walker) {
            walker.walk(preAst.operand1);
            walker.walk(preAst.operand2);
            walker.walk(preAst.operand3);
        }
        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;

        function walkArrowFunctionExpressionChildren(preAst, walker) {
            walker.walk(preAst.typeParameters);
            walker.walk(preAst.parameters);
            walker.walk(preAst.returnTypeAnnotation);
            walker.walk(preAst.block);
        }
        ChildrenWalkers.walkArrowFunctionExpressionChildren = walkArrowFunctionExpressionChildren;

        function walkFuncDeclChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.typeParameters);
            walker.walk(preAst.parameters);
            walker.walk(preAst.returnTypeAnnotation);
            walker.walk(preAst.block);
        }
        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;

        function walkParameterChildren(preAst, walker) {
            walker.walk(preAst.id);
            walker.walk(preAst.init);
            walker.walk(preAst.typeExpr);
        }
        ChildrenWalkers.walkParameterChildren = walkParameterChildren;

        function walkVariableDeclaratorChildren(preAst, walker) {
            walker.walk(preAst.id);
            walker.walk(preAst.init);
            walker.walk(preAst.typeExpr);
        }
        ChildrenWalkers.walkVariableDeclaratorChildren = walkVariableDeclaratorChildren;

        function walkReturnStatementChildren(preAst, walker) {
            walker.walk(preAst.returnExpression);
        }
        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;

        function walkForStatementChildren(preAst, walker) {
            walker.walk(preAst.init);
            walker.walk(preAst.cond);
            walker.walk(preAst.incr);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;

        function walkForInStatementChildren(preAst, walker) {
            walker.walk(preAst.lval);
            walker.walk(preAst.obj);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;

        function walkIfStatementChildren(preAst, walker) {
            walker.walk(preAst.cond);
            walker.walk(preAst.thenBod);
            walker.walk(preAst.elseBod);
        }
        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;

        function walkWhileStatementChildren(preAst, walker) {
            walker.walk(preAst.cond);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;

        function walkDoStatementChildren(preAst, walker) {
            walker.walk(preAst.cond);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkDoStatementChildren = walkDoStatementChildren;

        function walkBlockChildren(preAst, walker) {
            walker.walk(preAst.statements);
        }
        ChildrenWalkers.walkBlockChildren = walkBlockChildren;

        function walkVariableDeclarationChildren(preAst, walker) {
            walker.walk(preAst.declarators);
        }
        ChildrenWalkers.walkVariableDeclarationChildren = walkVariableDeclarationChildren;

        function walkCaseClauseChildren(preAst, walker) {
            walker.walk(preAst.expr);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkCaseClauseChildren = walkCaseClauseChildren;

        function walkSwitchStatementChildren(preAst, walker) {
            walker.walk(preAst.val);
            walker.walk(preAst.caseList);
        }
        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;

        function walkTryStatementChildren(preAst, walker) {
            walker.walk(preAst.tryBody);
            walker.walk(preAst.catchClause);
            walker.walk(preAst.finallyBody);
        }
        ChildrenWalkers.walkTryStatementChildren = walkTryStatementChildren;

        function walkCatchClauseChildren(preAst, walker) {
            walker.walk(preAst.param);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkCatchClauseChildren = walkCatchClauseChildren;

        function walkClassDeclChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.typeParameters);
            walker.walk(preAst.extendsList);
            walker.walk(preAst.implementsList);
            walker.walk(preAst.members);
        }
        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;

        function walkScriptChildren(preAst, walker) {
            walker.walk(preAst.moduleElements);
        }
        ChildrenWalkers.walkScriptChildren = walkScriptChildren;

        function walkInterfaceDeclerationChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.typeParameters);
            walker.walk(preAst.extendsList);
            walker.walk(preAst.members);
        }
        ChildrenWalkers.walkInterfaceDeclerationChildren = walkInterfaceDeclerationChildren;

        function walkObjectTypeChildren(preAst, walker) {
            walker.walk(preAst.members);
        }
        ChildrenWalkers.walkObjectTypeChildren = walkObjectTypeChildren;

        function walkModuleDeclChildren(preAst, walker) {
            walker.walk(preAst.name);
            walker.walk(preAst.members);
        }
        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;

        function walkImportDeclChildren(preAst, walker) {
            walker.walk(preAst.id);
            walker.walk(preAst.alias);
        }
        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;

        function walkExportAssignmentChildren(preAst, walker) {
            walker.walk(preAst.id);
        }
        ChildrenWalkers.walkExportAssignmentChildren = walkExportAssignmentChildren;

        function walkWithStatementChildren(preAst, walker) {
            walker.walk(preAst.expr);
            walker.walk(preAst.body);
        }
        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;

        function walkExpressionStatementChildren(preAst, walker) {
            walker.walk(preAst.expression);
        }
        ChildrenWalkers.walkExpressionStatementChildren = walkExpressionStatementChildren;

        function walkLabeledStatementChildren(preAst, walker) {
            walker.walk(preAst.identifier);
            walker.walk(preAst.statement);
        }
        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;

        function walkVariableStatementChildren(preAst, walker) {
            walker.walk(preAst.declaration);
        }
        ChildrenWalkers.walkVariableStatementChildren = walkVariableStatementChildren;
    })(ChildrenWalkers || (ChildrenWalkers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function max(a, b) {
        return a >= b ? a : b;
    }
    TypeScript.max = max;

    function min(a, b) {
        return a <= b ? a : b;
    }
    TypeScript.min = min;

    var AstPath = (function () {
        function AstPath() {
            this.asts = [];
            this.top = -1;
        }
        AstPath.reverseIndexOf = function (items, index) {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        };

        AstPath.prototype.pop = function () {
            var head = this.ast();
            this.up();

            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        };

        AstPath.prototype.push = function (ast) {
            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        };

        AstPath.prototype.up = function () {
            if (this.top <= -1)
                throw TypeScript.Errors.invalidOperation(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Invalid_call_to_up, null));
            this.top--;
        };

        AstPath.prototype.ast = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        };

        AstPath.prototype.parent = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        };

        AstPath.prototype.count = function () {
            return this.top + 1;
        };

        AstPath.prototype.get = function (index) {
            return this.asts[index];
        };

        AstPath.prototype.isNameOfClass = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 22 /* Name */) && (this.parent().nodeType() === 14 /* ClassDeclaration */) && (this.parent().name === this.ast());
        };

        AstPath.prototype.isNameOfInterface = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 22 /* Name */) && (this.parent().nodeType() === 15 /* InterfaceDeclaration */) && (this.parent().name === this.ast());
        };

        AstPath.prototype.isNameOfVariable = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 22 /* Name */) && (this.parent().nodeType() === 19 /* VariableDeclarator */) && (this.parent().id === this.ast());
        };

        AstPath.prototype.isNameOfFunction = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 22 /* Name */) && (this.parent().nodeType() === 13 /* FunctionDeclaration */) && (this.parent().name === this.ast());
        };

        AstPath.prototype.isMemberOfMemberAccessExpression = function () {
            if (this.count() > 1 && this.parent().nodeType() === 34 /* MemberAccessExpression */ && this.parent().operand2 === this.asts[this.top]) {
                return true;
            }

            return false;
        };

        AstPath.prototype.isCallExpression = function () {
            return this.count() >= 1 && (this.asts[this.top - 0].nodeType() === 38 /* InvocationExpression */ || this.asts[this.top - 0].nodeType() === 39 /* ObjectCreationExpression */);
        };

        AstPath.prototype.isCallExpressionTarget = function () {
            if (this.count() < 2) {
                return false;
            }

            var current = this.top;

            var nodeType = this.asts[current].nodeType();
            if (nodeType === 31 /* ThisExpression */ || nodeType === 32 /* SuperExpression */ || nodeType === 22 /* Name */) {
                current--;
            }

            while (current >= 0) {
                if (current < this.top && this.asts[current].nodeType() === 34 /* MemberAccessExpression */ && this.asts[current].operand2 === this.asts[current + 1]) {
                    current--;
                    continue;
                }

                break;
            }

            return current < this.top && (this.asts[current].nodeType() === 38 /* InvocationExpression */ || this.asts[current].nodeType() === 39 /* ObjectCreationExpression */) && this.asts[current + 1] === this.asts[current].target;
        };

        AstPath.prototype.isDeclaration = function () {
            if (this.ast() !== null) {
                switch (this.ast().nodeType()) {
                    case 14 /* ClassDeclaration */:
                    case 15 /* InterfaceDeclaration */:
                    case 17 /* ModuleDeclaration */:
                    case 13 /* FunctionDeclaration */:
                    case 19 /* VariableDeclarator */:
                    case 82 /* ArrowFunctionExpression */:
                        return true;
                }
            }

            return false;
        };
        return AstPath;
    })();
    TypeScript.AstPath = AstPath;

    function isValidAstNode(ast) {
        if (!ast)
            return false;

        if (ast.minChar === -1 || ast.limChar === -1)
            return false;

        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;

    var AstPathContext = (function () {
        function AstPathContext() {
            this.path = new TypeScript.AstPath();
        }
        return AstPathContext;
    })();

    function getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar, forceInclusive) {
        var lookInComments = function (comments) {
            if (comments && comments.length > 0) {
                for (var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar + (useTrailingTriviaAsLimChar ? comments[i].trailingTriviaWidth : 0);
                    if (!comments[i].isBlockComment) {
                        limChar++;
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        };

        var pre = function (cur, walker) {
            if (isValidAstNode(cur)) {
                var isInvalid1 = cur.nodeType() === 91 /* ExpressionStatement */ && cur.getLength() === 0;

                if (isInvalid1) {
                    walker.options.goChildren = false;
                } else {
                    var inclusive = forceInclusive || cur.nodeType() === 22 /* Name */ || cur.nodeType() === 34 /* MemberAccessExpression */ || cur.nodeType() === 11 /* TypeRef */ || cur.nodeType() === 20 /* VariableDeclaration */ || cur.nodeType() === 19 /* VariableDeclarator */ || cur.nodeType() === 38 /* InvocationExpression */ || pos === script.limChar + script.trailingTriviaWidth;

                    var minChar = cur.minChar;
                    var limChar = cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0) + (inclusive ? 1 : 0);
                    if (pos >= minChar && pos < limChar) {
                        if (cur.nodeType() !== 1 /* List */ || cur.limChar > cur.minChar) {
                            var previous = ctx.path.ast();
                            if (previous === null || (cur.minChar >= previous.minChar && (cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0)) <= (previous.limChar + (useTrailingTriviaAsLimChar ? previous.trailingTriviaWidth : 0)))) {
                                ctx.path.push(cur);
                            } else {
                            }
                        }
                    }

                    if (pos < limChar) {
                        lookInComments(cur.preComments());
                    }
                    if (pos >= minChar) {
                        lookInComments(cur.postComments());
                    }

                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
        };

        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }
    TypeScript.getAstPathToPosition = getAstPathToPosition;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() {
        }
        Base64Format.encode = function (inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };

        Base64Format.decodeChar = function (inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        return Base64Format;
    })();

    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {
        }
        Base64VLQFormat.encode = function (inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }

            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);

            return encodedStr;
        };

        Base64VLQFormat.decode = function (inString) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }

                shift += (i === 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Base64_value_0_finished_with_a_continuation_bit, [inString]));
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() {
        }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;

    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;

    var SourceMapper = (function () {
        function SourceMapper(jsFile, sourceMapOut, document, jsFilePath, emitOptions) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.names = [];
            this.tsFilePaths = [];
            this.allSourceMappings = [];
            this.setSourceMapOptions(document, jsFilePath, emitOptions);
            this.setNewSourceFile(document, emitOptions);
        }
        SourceMapper.prototype.setNewSourceFile = function (document, emitOptions) {
            var sourceMappings = [];
            this.allSourceMappings.push(sourceMappings);
            this.currentMappings = [sourceMappings];
            this.currentNameIndex = [];

            this.setNewSourceFilePath(document, emitOptions);
        };

        SourceMapper.prototype.setSourceMapOptions = function (document, jsFilePath, emitOptions) {
            var prettyJsFileName = TypeScript.getPrettyName(jsFilePath, false, true);
            var prettyMapFileName = prettyJsFileName + SourceMapper.MapFileExtension;
            this.jsFileName = prettyJsFileName;

            if (emitOptions.compilationSettings.mapRoot) {
                this.sourceMapDirectory = emitOptions.compilationSettings.mapRoot;
                if (emitOptions.outputMany || document.script.isExternalModule) {
                    this.sourceMapDirectory = this.sourceMapDirectory + TypeScript.switchToForwardSlashes(TypeScript.getRootFilePath((document.fileName)).replace(emitOptions.commonDirectoryPath, ""));
                }

                if (TypeScript.isRelative(this.sourceMapDirectory)) {
                    this.sourceMapDirectory = emitOptions.commonDirectoryPath + this.sourceMapDirectory;
                    this.sourceMapDirectory = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(emitOptions.ioHost.resolvePath(this.sourceMapDirectory)));
                    this.sourceMapPath = TypeScript.getRelativePathToFixedPath(TypeScript.getRootFilePath(jsFilePath), this.sourceMapDirectory + prettyMapFileName);
                } else {
                    this.sourceMapPath = this.sourceMapDirectory + prettyMapFileName;
                }
            } else {
                this.sourceMapPath = prettyMapFileName;
                this.sourceMapDirectory = TypeScript.getRootFilePath(jsFilePath);
            }
            this.sourceRoot = emitOptions.compilationSettings.sourceRoot;
        };

        SourceMapper.prototype.setNewSourceFilePath = function (document, emitOptions) {
            var tsFilePath = TypeScript.switchToForwardSlashes(document.fileName);
            if (emitOptions.compilationSettings.sourceRoot) {
                tsFilePath = TypeScript.getRelativePathToFixedPath(emitOptions.commonDirectoryPath, tsFilePath);
            } else {
                tsFilePath = TypeScript.getRelativePathToFixedPath(this.sourceMapDirectory, tsFilePath);
            }
            this.tsFilePaths.push(tsFilePath);
        };

        SourceMapper.prototype.emitSourceMapping = function (sourceMapEmitterCallback) {
            var _this = this;
            this.jsFile.WriteLine("//# sourceMappingURL=" + this.sourceMapPath);

            var mappingsString = "";

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var emitComma = false;

            var recordedPosition = null;
            for (var sourceIndex = 0; sourceIndex < this.tsFilePaths.length; sourceIndex++) {
                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition !== null && recordedPosition.emittedColumn === mappedPosition.emittedColumn && recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        return;
                    }

                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    if (sourceMapEmitterCallback) {
                        sourceMapEmitterCallback(_this.jsFileName, mappedPosition.emittedLine + 1, mappedPosition.emittedColumn + 1, _this.tsFilePaths[sourceIndex], mappedPosition.sourceLine, mappedPosition.sourceColumn + 1, nameIndex >= 0 ? _this.names[nameIndex] : undefined);
                    }

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceIndex - prevSourceIndex);
                    prevSourceIndex = sourceIndex;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(nameIndex - prevNameIndex);
                        prevNameIndex = nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                };

                var recordSourceMappingSiblings = function (sourceMappings) {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };

                recordSourceMappingSiblings(this.allSourceMappings[sourceIndex]);
            }

            this.sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: this.jsFileName,
                sourceRoot: this.sourceRoot,
                sources: this.tsFilePaths,
                names: this.names,
                mappings: mappingsString
            }));

            this.sourceMapOut.Close();
        };
        SourceMapper.MapFileExtension = ".map";
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer[EmitContainer["Prog"] = 0] = "Prog";
        EmitContainer[EmitContainer["Module"] = 1] = "Module";
        EmitContainer[EmitContainer["DynamicModule"] = 2] = "DynamicModule";
        EmitContainer[EmitContainer["Class"] = 3] = "Class";
        EmitContainer[EmitContainer["Constructor"] = 4] = "Constructor";
        EmitContainer[EmitContainer["Function"] = 5] = "Function";
        EmitContainer[EmitContainer["Args"] = 6] = "Args";
        EmitContainer[EmitContainer["Interface"] = 7] = "Interface";
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;

    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.container = 0 /* Prog */;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;

    var EmitOptions = (function () {
        function EmitOptions(compilationSettings) {
            this.compilationSettings = compilationSettings;
            this.ioHost = null;
            this.outputMany = true;
            this.commonDirectoryPath = "";
        }
        EmitOptions.prototype.mapOutputFileName = function (document, extensionChanger) {
            if (this.outputMany || document.script.isExternalModule) {
                var updatedFileName = document.fileName;
                if (this.compilationSettings.outDirOption !== "") {
                    updatedFileName = document.fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.compilationSettings.outDirOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.compilationSettings.outFileOption, true);
            }
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;

    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };

        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };

        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;

    function getClassConstructor(classDecl) {
        return TypeScript.ArrayUtilities.lastOrDefault(classDecl.members.members, function (m) {
            return m.nodeType() === 13 /* FunctionDeclaration */ && m.isConstructor;
        });
    }
    TypeScript.getClassConstructor = getClassConstructor;

    function lastParameterIsRest(parameters) {
        return parameters.members.length > 0 && TypeScript.ArrayUtilities.last(parameters.members).isRest;
    }
    TypeScript.lastParameterIsRest = lastParameterIsRest;

    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.inArrowFunction = false;
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.allSourceMappers = [];
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.declStack = [];
            this.resolvingContext = new TypeScript.PullTypeResolutionContext(null);
            this.exportAssignmentIdentifier = null;
            this.document = null;
            this.copyrightElement = null;
            TypeScript.globalSemanticInfoChain = semanticInfoChain;
            TypeScript.globalBinder.semanticInfoChain = semanticInfoChain;
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };

        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };

        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };

        Emitter.prototype.setExportAssignmentIdentifier = function (id) {
            this.exportAssignmentIdentifier = id;
        };

        Emitter.prototype.getExportAssignmentIdentifier = function () {
            return this.exportAssignmentIdentifier;
        };

        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };

        Emitter.prototype.shouldEmitImportDeclaration = function (importDeclAST) {
            var isExternalModuleReference = importDeclAST.isExternalImportDeclaration();
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var isExported = TypeScript.hasFlag(importDecl.flags, 1 /* Exported */);
            var isAmdCodeGen = this.emitOptions.compilationSettings.moduleGenTarget == 2 /* Asynchronous */;

            if (!isExternalModuleReference || isExported || !isAmdCodeGen) {
                var importSymbol = importDecl.getSymbol();
                if (!importDeclAST.isExternalImportDeclaration()) {
                    if (importSymbol.getExportAssignedValueSymbol()) {
                        return true;
                    }
                    var containerSymbol = importSymbol.getExportAssignedContainerSymbol();
                    if (containerSymbol && containerSymbol.getInstanceSymbol()) {
                        return true;
                    }
                }

                return importSymbol.isUsedAsValue;
            }

            return false;
        };

        Emitter.prototype.emitImportDeclaration = function (importDeclAST) {
            var isExternalModuleReference = importDeclAST.isExternalImportDeclaration();
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var isExported = TypeScript.hasFlag(importDecl.flags, 1 /* Exported */);
            var isAmdCodeGen = this.emitOptions.compilationSettings.moduleGenTarget == 2 /* Asynchronous */;

            this.emitComments(importDeclAST, true);

            var importSymbol = importDecl.getSymbol();

            var parentSymbol = importSymbol.getContainer();
            var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
            var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
            var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : 0 /* None */;

            var needsPropertyAssignment = false;
            var usePropertyAssignmentInsteadOfVarDecl = false;
            var moduleNamePrefix;

            if (isExported && (parentKind == 4 /* Container */ || parentKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 4 /* Container */ || associatedParentSymbolKind === 32 /* DynamicModule */)) {
                if (importSymbol.getExportAssignedTypeSymbol() || importSymbol.getExportAssignedContainerSymbol()) {
                    needsPropertyAssignment = true;
                } else {
                    var valueSymbol = importSymbol.getExportAssignedValueSymbol();
                    if (valueSymbol && (valueSymbol.kind == 65536 /* Method */ || valueSymbol.kind == 16384 /* Function */)) {
                        needsPropertyAssignment = true;
                    } else {
                        usePropertyAssignmentInsteadOfVarDecl = true;
                    }
                }

                if (this.emitState.container === 2 /* DynamicModule */) {
                    moduleNamePrefix = "exports.";
                } else {
                    moduleNamePrefix = this.moduleName + ".";
                }
            }

            if (isAmdCodeGen && isExternalModuleReference) {
                needsPropertyAssignment = true;
            } else {
                this.recordSourceMappingStart(importDeclAST);
                if (usePropertyAssignmentInsteadOfVarDecl) {
                    this.writeToOutput(moduleNamePrefix);
                } else {
                    this.writeToOutput("var ");
                }
                this.writeToOutput(importDeclAST.id.actualText + " = ");
                var aliasAST = importDeclAST.alias.nodeType() === 11 /* TypeRef */ ? importDeclAST.alias.term : importDeclAST.alias;

                if (isExternalModuleReference) {
                    this.writeToOutput("require(" + aliasAST.actualText + ")");
                } else {
                    this.emitJavascript(aliasAST, false);
                }

                this.recordSourceMappingEnd(importDeclAST);
                this.writeToOutput(";");

                if (needsPropertyAssignment) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                }
            }

            if (needsPropertyAssignment) {
                this.writeToOutputWithSourceMapRecord(moduleNamePrefix + importDeclAST.id.actualText + " = " + importDeclAST.id.actualText, importDeclAST);
                this.writeToOutput(";");
            }
            this.emitComments(importDeclAST, false);
        };

        Emitter.prototype.createSourceMapper = function (document, jsFileName, jsFile, sourceMapOut) {
            this.sourceMapper = new TypeScript.SourceMapper(jsFile, sourceMapOut, document, jsFileName, this.emitOptions);
        };

        Emitter.prototype.setSourceMapperNewSourceFile = function (document) {
            this.sourceMapper.setNewSourceFile(document, this.emitOptions);
        };

        Emitter.prototype.updateLineAndColumn = function (s) {
            var lineNumbers = TypeScript.TextUtilities.parseLineStarts(TypeScript.TextFactory.createText(s));
            if (lineNumbers.length > 1) {
                this.emitState.line += lineNumbers.length - 1;
                this.emitState.column = s.length - lineNumbers[lineNumbers.length - 1];
            } else {
                this.emitState.column += s.length;
            }
        };

        Emitter.prototype.writeToOutputWithSourceMapRecord = function (s, astSpan) {
            this.recordSourceMappingStart(astSpan);
            this.writeToOutput(s);
            this.recordSourceMappingEnd(astSpan);
        };

        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.updateLineAndColumn(s);
        };

        Emitter.prototype.writeLineToOutput = function (s) {
            this.outfile.WriteLine(s);
            this.updateLineAndColumn(s);
            this.emitState.column = 0;
            this.emitState.line++;
        };

        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord(this.captureThisStmtString, ast);
            this.writeLineToOutput("");
        };

        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };

        Emitter.prototype.getIndentString = function () {
            return this.indenter.getIndent();
        };

        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };

        Emitter.prototype.emitComment = function (comment) {
            if (this.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var text = comment.getText();
            var emitColumn = this.emitState.column;

            if (emitColumn === 0) {
                this.emitIndent();
            }

            if (comment.isBlockComment) {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                } else {
                    this.recordSourceMappingEnd(comment);
                    this.writeToOutput(" ");
                    return;
                }
            } else {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
            }

            if (emitColumn != 0) {
                this.emitIndent();
            }
        };

        Emitter.prototype.emitComments = function (ast, pre, onlyPinnedOrTripleSlashComments) {
            if (typeof onlyPinnedOrTripleSlashComments === "undefined") { onlyPinnedOrTripleSlashComments = false; }
            if (pre) {
                var preComments = ast.preComments();

                if (preComments && ast === this.copyrightElement) {
                    var copyrightComments = this.getCopyrightComments();
                    preComments = preComments.slice(copyrightComments.length);
                }

                if (onlyPinnedOrTripleSlashComments) {
                    preComments = TypeScript.ArrayUtilities.where(preComments, function (c) {
                        return c.isPinnedOrTripleSlash();
                    });
                }

                this.emitCommentsArray(preComments);
            } else {
                this.emitCommentsArray(ast.postComments());
            }
        };

        Emitter.prototype.emitCommentsArray = function (comments) {
            if (!this.emitOptions.compilationSettings.removeComments && comments) {
                for (var i = 0, n = comments.length; i < n; i++) {
                    this.emitComment(comments[i]);
                }
            }
        };

        Emitter.prototype.emitObjectLiteral = function (objectLiteral) {
            var useNewLines = !TypeScript.hasFlag(objectLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("{");
            var list = objectLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                } else {
                    this.writeToOutput(" ");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                } else {
                    this.writeToOutput(" ");
                }
            }
            this.writeToOutput("}");
        };

        Emitter.prototype.emitArrayLiteral = function (arrayLiteral) {
            var useNewLines = !TypeScript.hasFlag(arrayLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("[");
            var list = arrayLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                }
            }
            this.writeToOutput("]");
        };

        Emitter.prototype.emitObjectCreationExpression = function (objectCreationExpression) {
            this.recordSourceMappingStart(objectCreationExpression);
            this.writeToOutput("new ");
            var target = objectCreationExpression.target;
            var args = objectCreationExpression.arguments;
            if (target.nodeType() === 11 /* TypeRef */) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    typeRef.term.emit(this);
                    this.writeToOutput("()");
                }
            } else {
                target.emit(this);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitCommaSeparatedList(args);
                this.writeToOutputWithSourceMapRecord(")", objectCreationExpression.closeParenSpan);
                this.recordSourceMappingEnd(args);
            }
            this.recordSourceMappingEnd(objectCreationExpression);
        };

        Emitter.prototype.getConstantDecl = function (dotExpr) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(dotExpr, this.document.fileName);
            if (pullSymbol && pullSymbol.hasFlag(524288 /* Constant */)) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType() === 19 /* VariableDeclarator */) {
                        return { boundDecl: ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        };

        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.compilationSettings.propagateEnumConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            var boundDeclInfo = this.getConstantDecl(dotExpr);
            if (boundDeclInfo) {
                var value = boundDeclInfo.boundDecl.constantValue;
                if (value !== null) {
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.actualText;
                    comment += " */";
                    this.writeToOutput(comment);
                    return true;
                }
            }

            return false;
        };

        Emitter.prototype.emitInvocationExpression = function (callNode) {
            this.recordSourceMappingStart(callNode);
            var target = callNode.target;
            var args = callNode.arguments;

            if (target.nodeType() === 34 /* MemberAccessExpression */ && target.operand1.nodeType() === 32 /* SuperExpression */) {
                var dotNode = target;
                dotNode.emit(this);
                this.writeToOutput(".call");
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitThis();
                if (args && args.members.length > 0) {
                    this.writeToOutput(", ");
                    this.emitCommaSeparatedList(args);
                }
            } else {
                if (target.nodeType() === 13 /* FunctionDeclaration */) {
                    this.writeToOutput("(");
                }
                if (callNode.target.nodeType() === 32 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("_super.call");
                } else {
                    this.emitJavascript(target, false);
                }
                if (target.nodeType() === 13 /* FunctionDeclaration */) {
                    this.writeToOutput(")");
                }
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                if (callNode.target.nodeType() === 32 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("this");
                    if (args && args.members.length) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(args);
            }

            this.writeToOutputWithSourceMapRecord(")", callNode.closeParenSpan);
            this.recordSourceMappingEnd(args);
            this.recordSourceMappingEnd(callNode);
        };

        Emitter.prototype.emitFunctionParameters = function (parameters) {
            var argsLen = 0;

            if (parameters) {
                this.emitComments(parameters, true);

                var tempContainer = this.setContainer(6 /* Args */);
                argsLen = parameters.members.length;
                var printLen = argsLen;
                if (lastParameterIsRest(parameters)) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = parameters.members[i];
                    arg.emit(this);

                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);

                this.emitComments(parameters, false);
            }
        };

        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, includePreComments) {
            if (typeof includePreComments === "undefined") { includePreComments = true; }
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var shouldParenthesize = false;

            if (includePreComments) {
                this.emitComments(funcDecl, true);
            }

            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            var accessorSymbol = funcDecl.isAccessor() ? TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName) : null;
            var container = accessorSymbol ? accessorSymbol.getContainer() : null;
            var containerKind = container ? container.kind : 0 /* None */;
            if (!(funcDecl.isAccessor() && containerKind !== 8 /* Class */ && containerKind !== 33554432 /* ConstructorType */)) {
                this.writeToOutput("function ");
            }

            if (funcDecl.isConstructor) {
                this.writeToOutput(this.thisClassNode.name.actualText);
            }

            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            this.emitFunctionParameters(funcDecl.parameters);
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            this.emitDefaultValueAssignments(funcDecl.parameters);
            this.emitRestParameterInitializer(funcDecl.parameters);

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor) {
                this.emitConstructorStatements(funcDecl);
            } else {
                this.emitList(funcDecl.block.statements);
            }

            this.emitCommentsArray(funcDecl.block.closeBraceLeadingComments);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("}", funcDecl.block.closeBraceSpan);

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitDefaultValueAssignments = function (parameters) {
            var n = parameters.members.length;
            if (lastParameterIsRest(parameters)) {
                n--;
            }

            for (var i = 0; i < n; i++) {
                var arg = parameters.members[i];
                if (arg.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                    this.writeToOutputWithSourceMapRecord(arg.id.actualText, arg.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(arg.init, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        };

        Emitter.prototype.emitRestParameterInitializer = function (parameters) {
            if (lastParameterIsRest(parameters)) {
                var n = parameters.members.length;
                var lastArg = parameters.members[n - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.writeToOutputWithSourceMapRecord(lastArg.id.actualText, lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.writeToOutputWithSourceMapRecord("var _i = 0;", lastArg);
                this.writeToOutput(" ");
                this.writeToOutputWithSourceMapRecord("_i < (arguments.length - " + (n - 1) + ")", lastArg);
                this.writeToOutput("; ");
                this.writeToOutputWithSourceMapRecord("_i++", lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.writeToOutputWithSourceMapRecord(lastArg.id.actualText + "[_i] = arguments[_i + " + (n - 1) + "];", lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        };

        Emitter.prototype.getImportDecls = function (fileName) {
            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var result = [];

            var topLevelDecl = semanticInfo.getTopLevelDecl();
            var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
            var queue = dynamicModuleDecl.getChildDecls();

            for (var i = 0, n = queue.length; i < n; i++) {
                var decl = queue[i];

                if (decl.kind & 256 /* TypeAlias */) {
                    var importStatementAST = semanticInfo.getASTForDecl(decl);
                    if (importStatementAST.isExternalImportDeclaration()) {
                        var symbol = decl.getSymbol();
                        var typeSymbol = symbol && symbol.type;
                        if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                            result.push(decl);
                        }
                    }
                }
            }

            return result;
        };

        Emitter.prototype.getModuleImportAndDependencyList = function (script) {
            var importList = "";
            var dependencyList = "";

            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var importDecls = this.getImportDecls(this.document.fileName);

            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = importStatementDecl.getSymbol();
                    var importStatementAST = semanticInfo.getASTForDecl(importStatementDecl);

                    if (importStatementSymbol.isUsedAsValue) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += importStatementDecl.name;
                        dependencyList += importStatementAST.getAliasName();
                    }
                }
            }

            for (var i = 0; i < script.amdDependencies.length; i++) {
                dependencyList += ", \"" + script.amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };

        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast.nodeType() === 2 /* Script */) {
                var scriptDecl = this.semanticInfoChain.getUnit(this.document.fileName).getTopLevelDecl();
                return (scriptDecl.flags & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast, this.document.fileName);
            if (decl) {
                return (decl.flags & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            return false;
        };

        Emitter.prototype.emitModule = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;
            this.moduleName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(this.moduleName)) {
                this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
            }

            var isExternalModule = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsExternalModule */);
            var temp = this.setContainer(1 /* Module */);
            var isExported = TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */);

            if (isExternalModule) {
                this.setExportAssignmentIdentifier(null);
                this.setContainer(2 /* DynamicModule */);
            } else {
                if (!isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("var ");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(";");
                    this.recordSourceMappingEnd(moduleDecl);
                    this.emitIndent();
                }

                this.writeToOutput("(");
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("function (");
                this.writeToOutputWithSourceMapRecord(this.moduleName, moduleDecl.name);
                this.writeLineToOutput(") {");

                this.recordSourceMappingNameStart(this.moduleName);
            }

            if (!isExternalModule || this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                this.indenter.increaseIndent();
            }

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            this.emitList(moduleDecl.members);
            if (!isExternalModule || this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                this.indenter.decreaseIndent();
            }
            this.emitIndent();

            if (isExternalModule) {
                var exportAssignmentIdentifier = this.getExportAssignmentIdentifier();
                var exportAssignmentValueSymbol = pullDecl.getSymbol().getExportAssignedValueSymbol();

                if (this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                    if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                        this.indenter.increaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("return " + exportAssignmentIdentifier + ";");
                        this.indenter.decreaseIndent();
                    }
                    this.writeToOutput("});");
                } else if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                    this.emitIndent();
                    this.writeLineToOutput("module.exports = " + exportAssignmentIdentifier + ";");
                }

                this.recordSourceMappingEnd(moduleDecl);
            } else {
                var parentIsDynamic = temp === 2 /* DynamicModule */;
                this.recordSourceMappingStart(moduleDecl.endingToken);
                if (temp === 0 /* Prog */ && isExported) {
                    this.writeToOutput("}");
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                } else if (isExported || temp === 0 /* Prog */) {
                    var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                    this.writeToOutput("}");
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                } else if (!isExported && temp !== 0 /* Prog */) {
                    this.writeToOutput("}");
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                } else {
                    this.writeToOutput("}");
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")();");
                }

                this.recordSourceMappingEnd(moduleDecl);
                if (temp !== 0 /* Prog */ && isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    if (parentIsDynamic) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                    } else {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                }
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitEnumElement = function (varDecl) {
            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);
            var name = varDecl.id.actualText;
            var quoted = TypeScript.isQuoted(name);
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.writeToOutput('] = ');

            if (varDecl.init) {
                varDecl.init.emit(this);
            } else if (varDecl.constantValue !== null) {
                this.writeToOutput(varDecl.constantValue.toString());
            } else {
                this.writeToOutput("null");
            }

            this.writeToOutput('] = ');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.writeToOutput(';');
        };

        Emitter.prototype.emitIndex = function (operand1, operand2) {
            operand1.emit(this);
            this.writeToOutput("[");
            operand2.emit(this);
            this.writeToOutput("]");
        };

        Emitter.prototype.emitArrowFunctionExpression = function (arrowFunction) {
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = true;

            var temp = this.setContainer(5 /* Function */);

            var funcName = arrowFunction.getNameText();

            this.recordSourceMappingStart(arrowFunction);

            var pullDecl = this.semanticInfoChain.getDeclForAST(arrowFunction, this.document.fileName);
            this.pushDecl(pullDecl);

            this.emitComments(arrowFunction, true);

            this.recordSourceMappingStart(arrowFunction);
            this.writeToOutput("function ");
            this.writeToOutput("(");
            this.emitFunctionParameters(arrowFunction.parameters);
            this.writeLineToOutput(") {");

            this.recordSourceMappingNameStart(arrowFunction.getNameText());

            this.indenter.increaseIndent();

            this.emitDefaultValueAssignments(arrowFunction.parameters);
            this.emitRestParameterInitializer(arrowFunction.parameters);

            if (this.shouldCaptureThis(arrowFunction)) {
                this.writeCaptureThisStatement(arrowFunction);
            }

            this.emitList(arrowFunction.block.statements);

            this.emitCommentsArray(arrowFunction.block.closeBraceLeadingComments);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("}", arrowFunction.block.closeBraceSpan);

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(arrowFunction);

            this.recordSourceMappingEnd(arrowFunction);

            this.emitComments(arrowFunction, false);

            this.popDecl(pullDecl);
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;
        };

        Emitter.prototype.emitFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                return;
            }
            var temp;
            var savedInArrowFunction = this.inArrowFunction;
            this.inArrowFunction = false;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(4 /* Constructor */);
            } else {
                temp = this.setContainer(5 /* Function */);
            }

            var funcName = funcDecl.getNameText();

            if (((temp !== 4 /* Constructor */) || ((funcDecl.getFunctionFlags() & 256 /* Method */) === 0 /* None */))) {
                this.recordSourceMappingStart(funcDecl);
                this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()));
            }
            this.setContainer(temp);
            this.inArrowFunction = savedInArrowFunction;

            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 16 /* Static */)) {
                    if (this.thisClassNode) {
                        this.writeLineToOutput("");
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container === 1 /* Module */ || this.emitState.container === 2 /* DynamicModule */) && pullFunctionDecl && TypeScript.hasFlag(pullFunctionDecl.flags, 1 /* Exported */)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === 1 /* Module */ ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };

        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            this.recordSourceMappingStart(this.currentVariableDeclaration);
            if (varDecl.init) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.writeToOutputWithSourceMapRecord(varDecl.id.actualText, varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        };

        Emitter.prototype.emitVarDeclVar = function () {
            if (this.currentVariableDeclaration) {
                this.writeToOutput("var ");
            }
        };

        Emitter.prototype.emitVariableDeclaration = function (declaration) {
            var varDecl = declaration.declarators.members[0];

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);

            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
            var inClass = parentKind === 8 /* Class */;

            this.emitComments(declaration, true);

            var pullVarDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            var isAmbientWithoutInit = pullVarDecl && TypeScript.hasFlag(pullVarDecl.flags, 8 /* Ambient */) && varDecl.init === null;
            if (!isAmbientWithoutInit) {
                var prevVariableDeclaration = this.currentVariableDeclaration;
                this.currentVariableDeclaration = declaration;

                for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                    var declarator = declaration.declarators.members[i];

                    if (i > 0) {
                        if (inClass) {
                            this.writeToOutput(";");
                        } else {
                            this.writeToOutput(", ");
                        }
                    }

                    declarator.emit(this);
                }
                this.currentVariableDeclaration = prevVariableDeclaration;

                this.recordSourceMappingEnd(declaration);
            }

            this.emitComments(declaration, false);
        };

        Emitter.prototype.emitVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            if (pullDecl && (pullDecl.flags & 8 /* Ambient */) === 8 /* Ambient */) {
                this.emitAmbientVarDecl(varDecl);
            } else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(this.currentVariableDeclaration);
                this.recordSourceMappingStart(varDecl);

                var varDeclName = varDecl.id.actualText;
                var quotedOrNumber = TypeScript.isQuoted(varDeclName) || varDecl.id.isNumber;

                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentDecl = pullDecl && pullDecl.getParentDecl();
                var parentIsClass = parentDecl && parentDecl.kind === 8 /* Class */;
                var parentIsModule = parentDecl && (parentDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule);
                if (parentIsClass) {
                    if (this.emitState.container !== 6 /* Args */) {
                        if (varDecl.isStatic()) {
                            if (quotedOrNumber) {
                                this.writeToOutput(parentSymbol.getName() + "[");
                            } else {
                                this.writeToOutput(parentSymbol.getName() + ".");
                            }
                        } else {
                            if (quotedOrNumber) {
                                this.writeToOutput("this[");
                            } else {
                                this.writeToOutput("this.");
                            }
                        }
                    }
                } else if (parentIsModule) {
                    if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */) && !varDecl.isProperty()) {
                        this.emitVarDeclVar();
                    } else {
                        if (this.emitState.container === 2 /* DynamicModule */) {
                            if (quotedOrNumber) {
                                this.writeToOutput("exports[");
                            } else {
                                this.writeToOutput("exports.");
                            }
                        } else {
                            if (quotedOrNumber) {
                                this.writeToOutput(this.moduleName + "[");
                            } else {
                                this.writeToOutput(this.moduleName + ".");
                            }
                        }
                    }
                } else {
                    this.emitVarDeclVar();
                }

                this.writeToOutputWithSourceMapRecord(varDecl.id.actualText, varDecl.id);

                if (quotedOrNumber) {
                    this.writeToOutput("]");
                }

                if (varDecl.init) {
                    this.writeToOutput(" = ");

                    var prevVariableDeclaration = this.currentVariableDeclaration;
                    varDecl.init.emit(this);
                    this.currentVariableDeclaration = prevVariableDeclaration;
                }

                if (parentIsClass) {
                    if (this.emitState.container !== 6 /* Args */) {
                        this.writeToOutput(";");
                    }
                }

                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.currentVariableDeclaration = undefined;
            this.popDecl(pullDecl);
        };

        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (typeof dynamic === "undefined") { dynamic = false; }
            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;

                            if (!same && symbol.hasFlag(32768 /* InitializedModule */)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitSymbolContainerNameInEnclosingContext = function (pullSymbol) {
            var decl = pullSymbol.getDeclarations()[0];
            var symbolContainerDeclPath = TypeScript.getPathToDecl(decl.getParentDecl());

            var enclosingContextDeclPath = this.declStack;
            var potentialDeclPath = symbolContainerDeclPath;

            if (enclosingContextDeclPath.length) {
                var commonNodeIndex = -1;
                for (var i = symbolContainerDeclPath.length - 1; i >= 0; i--) {
                    var symbolContainerDeclPathNode = symbolContainerDeclPath[i];
                    for (var j = enclosingContextDeclPath.length - 1; j >= 0; j--) {
                        var enclosingContextDeclPathNode = enclosingContextDeclPath[j];
                        if (symbolContainerDeclPathNode === enclosingContextDeclPathNode) {
                            commonNodeIndex = i;
                            break;
                        }
                    }

                    if (commonNodeIndex >= 0) {
                        break;
                    }
                }

                if (commonNodeIndex >= 0) {
                    potentialDeclPath = symbolContainerDeclPath.slice(commonNodeIndex);
                }
            }

            var startingIndex = potentialDeclPath.length - 1;
            for (var i = startingIndex - 1; i >= 0; i--) {
                if (potentialDeclPath[i + 1].flags & 1 /* Exported */) {
                    startingIndex = i;
                } else {
                    break;
                }
            }

            for (var i = startingIndex; i < potentialDeclPath.length; i++) {
                if (potentialDeclPath[i].kind === 32 /* DynamicModule */ || potentialDeclPath[i].flags & 65536 /* InitializedDynamicModule */) {
                    this.writeToOutput("exports.");
                } else {
                    this.writeToOutput(potentialDeclPath[i].getDisplayName() + ".");
                }
            }
        };

        Emitter.prototype.emitName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                var pullSymbol = this.semanticInfoChain.getSymbolForAST(name, this.document.fileName);
                if (!pullSymbol) {
                    pullSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                var pullSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(name, this.document.fileName);
                if (pullSymbol && pullSymbolAlias) {
                    var symbolToCompare = this.resolvingContext.resolvingTypeReference ? pullSymbolAlias.getExportAssignedTypeSymbol() : pullSymbolAlias.getExportAssignedValueSymbol();

                    if (pullSymbol == symbolToCompare) {
                        pullSymbol = pullSymbolAlias;
                        pullSymbolAlias = null;
                    }
                }

                var pullSymbolKind = pullSymbol.kind;
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() == this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== 6 /* Args */) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();

                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.kind;

                        if (pullSymbolContainerKind === 8 /* Class */) {
                            if (pullSymbol.hasFlag(16 /* Static */)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            } else if (pullSymbolKind === 4096 /* Property */) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else if (TypeScript.PullHelpers.symbolIsModule(pullSymbolContainer) || pullSymbolContainerKind === 64 /* Enum */ || pullSymbolContainer.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                            if (pullSymbolKind === 4096 /* Property */ || pullSymbolKind === 67108864 /* EnumMember */) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && pullSymbolKind === 1024 /* Variable */ && !pullSymbol.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.emitSymbolContainerNameInEnclosingContext(pullSymbol);
                            }
                        } else if (pullSymbolContainerKind === 32 /* DynamicModule */ || pullSymbolContainer.hasFlag(65536 /* InitializedDynamicModule */)) {
                            if (pullSymbolKind === 4096 /* Property */) {
                                this.writeToOutput("exports.");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !isLocalAlias && !pullSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable) && pullSymbol.kind !== 32768 /* ConstructorMethod */ && pullSymbol.kind !== 8 /* Class */ && pullSymbol.kind !== 64 /* Enum */) {
                                this.writeToOutput("exports.");
                            }
                        }
                    }
                }

                this.writeToOutput(name.actualText);
            }

            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };

        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var nameIndex = -1;
                if (name) {
                    if (this.sourceMapper.currentNameIndex.length > 0) {
                        var parentNameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                        if (parentNameIndex != -1) {
                            name = this.sourceMapper.names[parentNameIndex] + "." + name;
                        }
                    }

                    var nameIndex = this.sourceMapper.names.length - 1;
                    for (nameIndex; nameIndex >= 0; nameIndex--) {
                        if (this.sourceMapper.names[nameIndex] == name) {
                            break;
                        }
                    }

                    if (nameIndex == -1) {
                        nameIndex = this.sourceMapper.names.length;
                        this.sourceMapper.names.push(name);
                    }
                }
                this.sourceMapper.currentNameIndex.push(nameIndex);
            }
        };

        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };

        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;

                var lineMap = this.document.lineMap;
                lineMap.fillLineAndCharacterFromPosition(ast.minChar, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.limChar, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };

        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };

        Emitter.prototype.emitSourceMapsAndClose = function () {
            if (this.sourceMapper !== null) {
                this.sourceMapper.emitSourceMapping(this.emitOptions.compilationSettings.sourceMapEmitterCallback);
            }

            try  {
                this.outfile.Close();
            } catch (e) {
                Emitter.throwEmitterError(e);
            }
        };

        Emitter.prototype.emitParameterPropertyAndMemberVariableAssignments = function () {
            var constructorDecl = getClassConstructor(this.thisClassNode);

            if (constructorDecl && constructorDecl.parameters) {
                for (var i = 0, n = constructorDecl.parameters.members.length; i < n; i++) {
                    var arg = constructorDecl.parameters.members[i];
                    if ((arg.getVarFlags() & 256 /* Property */) !== 0 /* None */) {
                        this.emitIndent();
                        this.recordSourceMappingStart(arg);
                        this.writeToOutputWithSourceMapRecord("this." + arg.id.actualText, arg.id);
                        this.writeToOutput(" = ");
                        this.writeToOutputWithSourceMapRecord(arg.id.actualText, arg.id);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(arg);
                    }
                }
            }

            for (var i = 0, n = this.thisClassNode.members.members.length; i < n; i++) {
                if (this.thisClassNode.members.members[i].nodeType() === 19 /* VariableDeclarator */) {
                    var varDecl = this.thisClassNode.members.members[i];
                    if (!TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitIndent();
                        this.emitVariableDeclarator(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitCommaSeparatedList = function (list, startLine) {
            if (typeof startLine === "undefined") { startLine = false; }
            if (list === null) {
                return;
            } else {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    var emitNode = list.members[i];
                    this.emitJavascript(emitNode, startLine);

                    if (i < (n - 1)) {
                        this.writeToOutput(startLine ? "," : ", ");
                    }

                    if (startLine) {
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitList = function (list, useNewLineSeparator, startInclusive, endExclusive) {
            if (typeof useNewLineSeparator === "undefined") { useNewLineSeparator = true; }
            if (typeof startInclusive === "undefined") { startInclusive = 0; }
            if (typeof endExclusive === "undefined") { endExclusive = list.members.length; }
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode = null;

            for (var i = startInclusive; i < endExclusive; i++) {
                var node = list.members[i];

                if (node.shouldEmit(this)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    if (useNewLineSeparator) {
                        this.writeLineToOutput("");
                    }

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.isDirectivePrologueElement = function (node) {
            if (node.nodeType() === 91 /* ExpressionStatement */) {
                var exprStatement = node;
                return exprStatement.expression.nodeType() === 5 /* StringLiteral */;
            }

            return false;
        };

        Emitter.prototype.emitSpaceBetweenConstructs = function (node1, node2) {
            if (node1 === null || node2 === null) {
                return;
            }

            if (node1.minChar === -1 || node1.limChar === -1 || node2.minChar === -1 || node2.limChar === -1) {
                return;
            }

            var lineMap = this.document.lineMap;
            var node1EndLine = lineMap.getLineNumberFromPosition(node1.limChar);
            var node2StartLine = lineMap.getLineNumberFromPosition(node2.minChar);

            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("");
            }
        };

        Emitter.prototype.getCopyrightComments = function () {
            var preComments = this.copyrightElement.preComments();
            if (preComments) {
                var lineMap = this.document.lineMap;

                var copyrightComments = [];
                var lastComment = null;

                for (var i = 0, n = preComments.length; i < n; i++) {
                    var comment = preComments[i];

                    if (lastComment) {
                        var lastCommentLine = lineMap.getLineNumberFromPosition(lastComment.limChar);
                        var commentLine = lineMap.getLineNumberFromPosition(comment.minChar);

                        if (commentLine >= lastCommentLine + 2) {
                            return copyrightComments;
                        }
                    }

                    copyrightComments.push(comment);
                    lastComment = comment;
                }

                var lastCommentLine = lineMap.getLineNumberFromPosition(TypeScript.ArrayUtilities.last(copyrightComments).limChar);
                var astLine = lineMap.getLineNumberFromPosition(this.copyrightElement.minChar);
                if (astLine >= lastCommentLine + 2) {
                    return copyrightComments;
                }
            }

            return [];
        };

        Emitter.prototype.emitPossibleCopyrightHeaders = function (script) {
            var list = script.moduleElements;
            if (list.members.length > 0) {
                var firstElement = list.members[0];
                if (firstElement.nodeType() === 17 /* ModuleDeclaration */) {
                    var moduleDeclaration = firstElement;
                    if (TypeScript.hasFlag(moduleDeclaration.getModuleFlags(), 256 /* IsExternalModule */)) {
                        firstElement = moduleDeclaration.members.members[0];
                    }
                }

                this.copyrightElement = firstElement;
                this.emitCommentsArray(this.getCopyrightComments());
            }
        };

        Emitter.prototype.emitScriptElements = function (script) {
            var list = script.moduleElements;

            this.emitPossibleCopyrightHeaders(script);

            for (var i = 0, n = list.members.length; i < n; i++) {
                var node = list.members[i];

                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }

                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }

            this.emitPrologue(script);

            var isNonElidedExternalModule = TypeScript.hasFlag(script.getModuleFlags(), 256 /* IsExternalModule */) && !this.scriptIsElided(script);
            if (isNonElidedExternalModule) {
                this.recordSourceMappingStart(script);

                if (this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";

                    var importAndDependencyList = this.getModuleImportAndDependencyList(script);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";

                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            }

            this.emitList(list, true, i, n);
        };

        Emitter.prototype.emitConstructorStatements = function (funcDecl) {
            var list = funcDecl.block.statements;

            if (list === null) {
                return;
            }

            this.emitComments(list, true);

            var emitPropertyAssignmentsAfterSuperCall = this.thisClassNode.extendsList && this.thisClassNode.extendsList.members.length > 0;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode = null;

            for (var i = 0, n = list.members.length; i < n; i++) {
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }

                var node = list.members[i];

                if (node.shouldEmit(this)) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }

            if (startLine && this.indenter.indentAmt > 0) {
                this.emitIndent();
            }

            ast.emit(this);
        };

        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }

            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);

            this.writeToOutput("Object.defineProperty(" + className);
            if (isProto) {
                this.writeToOutput(".prototype, ");
            } else {
                this.writeToOutput(", ");
            }

            var functionName = funcDecl.name.actualText;
            if (TypeScript.isQuoted(functionName)) {
                this.writeToOutput(functionName);
            } else {
                this.writeToOutput('"' + functionName + '"');
            }

            this.writeLineToOutput(", {");

            this.indenter.increaseIndent();

            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.document.fileName);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.writeToOutput("get: ");
                this.emitInnerFunction(accessors.getter, false);
                this.writeLineToOutput(",");
            }

            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.writeToOutput("set: ");
                this.emitInnerFunction(accessors.setter, false);
                this.writeLineToOutput(",");
            }

            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };

        Emitter.prototype.emitPrototypeMember = function (funcDecl, className) {
            if (funcDecl.isAccessor()) {
                this.emitPropertyAccessor(funcDecl, className, true);
            } else {
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.emitComments(funcDecl, true);

                var functionName = funcDecl.getNameText();
                if (TypeScript.isQuoted(functionName) || funcDecl.name.isNumber) {
                    this.writeToOutput(className + ".prototype[" + functionName + "] = ");
                } else {
                    this.writeToOutput(className + ".prototype." + functionName + " = ");
                }

                this.emitInnerFunction(funcDecl, false, false);
                this.writeLineToOutput(";");
            }
        };

        Emitter.prototype.emitClass = function (classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.name.actualText;
            this.emitComments(classDecl, true);
            var temp = this.setContainer(3 /* Class */);

            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);

            var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
            var baseTypeReference = null;
            var varDecl = null;

            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            } else {
                this.writeLineToOutput(" = (function () {");
            }

            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();

            if (hasBaseClass) {
                baseTypeReference = classDecl.extendsList.members[0];
                this.emitIndent();
                this.writeLineToOutput("__extends(" + className + ", _super);");
            }

            this.emitIndent();

            var constrDecl = getClassConstructor(classDecl);

            if (constrDecl) {
                constrDecl.emit(this);
                this.writeLineToOutput("");
            } else {
                this.recordSourceMappingStart(classDecl);

                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.name.actualText + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeLineToOutput("_super.apply(this, arguments);");
                }

                if (this.shouldCaptureThis(classDecl)) {
                    this.writeCaptureThisStatement(classDecl);
                }

                this.emitParameterPropertyAndMemberVariableAssignments();

                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");

                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }

            this.emitClassMembers(classDecl);

            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("return " + className + ";", classDecl.endingToken);
            this.writeLineToOutput("");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutputWithSourceMapRecord("}", classDecl.endingToken);
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.resolvingContext.resolvingTypeReference = true;
                this.emitJavascript(baseTypeReference.term, false);
                this.resolvingContext.resolvingTypeReference = false;
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);

            if ((temp === 1 /* Module */ || temp === 2 /* DynamicModule */) && TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === 1 /* Module */ ? this.moduleName : "exports";
                this.writeToOutputWithSourceMapRecord(modName + "." + className + " = " + className + ";", classDecl);
            }

            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitClassMembers = function (classDecl) {
            var lastEmittedMember = null;

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType() === 13 /* FunctionDeclaration */) {
                    var functionDeclaration = memberDecl;

                    if (TypeScript.hasFlag(functionDeclaration.getFunctionFlags(), 256 /* Method */) && !functionDeclaration.isSignature()) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, functionDeclaration);

                        if (!TypeScript.hasFlag(functionDeclaration.getFunctionFlags(), 16 /* Static */)) {
                            this.emitPrototypeMember(functionDeclaration, classDecl.name.actualText);
                        } else {
                            if (functionDeclaration.isAccessor()) {
                                this.emitPropertyAccessor(functionDeclaration, this.thisClassNode.name.actualText, false);
                            } else {
                                this.emitIndent();
                                this.recordSourceMappingStart(functionDeclaration);
                                this.emitComments(functionDeclaration, true);

                                var functionName = functionDeclaration.name.actualText;
                                if (TypeScript.isQuoted(functionName) || functionDeclaration.name.isNumber) {
                                    this.writeToOutput(classDecl.name.actualText + "[" + functionName + "] = ");
                                } else {
                                    this.writeToOutput(classDecl.name.actualText + "." + functionName + " = ");
                                }

                                this.emitInnerFunction(functionDeclaration, false, false);
                                this.writeLineToOutput(";");
                            }
                        }

                        lastEmittedMember = functionDeclaration;
                    }
                }
            }

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType() === 19 /* VariableDeclarator */) {
                    var varDecl = memberDecl;

                    if (TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);

                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);

                        var varDeclName = varDecl.id.actualText;
                        if (TypeScript.isQuoted(varDeclName) || varDecl.id.isNumber) {
                            this.writeToOutput(classDecl.name.actualText + "[" + varDeclName + "] = ");
                        } else {
                            this.writeToOutput(classDecl.name.actualText + "." + varDeclName + " = ");
                        }

                        varDecl.init.emit(this);

                        this.recordSourceMappingEnd(varDecl);
                        this.writeLineToOutput(";");

                        lastEmittedMember = varDecl;
                    }
                }
            }
        };

        Emitter.prototype.requiresExtendsBlock = function (moduleElements) {
            for (var i = 0, n = moduleElements.members.length; i < n; i++) {
                var moduleElement = moduleElements.members[i];

                if (moduleElement.nodeType() === 17 /* ModuleDeclaration */) {
                    var moduleAST = moduleElement;
                    if (!TypeScript.hasFlag(moduleAST.getModuleFlags(), 8 /* Ambient */) && this.requiresExtendsBlock(moduleAST.members)) {
                        return true;
                    }
                } else if (moduleElement.nodeType() === 14 /* ClassDeclaration */) {
                    var classDeclaration = moduleElement;

                    if (!TypeScript.hasFlag(classDeclaration.getVarFlags(), 8 /* Ambient */) && classDeclaration.extendsList && classDeclaration.extendsList.members.length > 0) {
                        return true;
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitPrologue = function (script) {
            if (!this.extendsPrologueEmitted) {
                if (this.requiresExtendsBlock(script.moduleElements)) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(script)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };

        Emitter.prototype.emitThis = function () {
            if (this.inArrowFunction) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };

        Emitter.prototype.emitBlockOrStatement = function (node) {
            if (node.nodeType() === 84 /* Block */) {
                node.emit(this);
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        };

        Emitter.throwEmitterError = function (e) {
            var error = new Error(e.message);
            error.isEmitterError = true;
            throw error;
        };

        Emitter.handleEmitterError = function (fileName, e) {
            if (e.isEmitterError === true) {
                return [new TypeScript.Diagnostic(fileName, 0, 0, TypeScript.DiagnosticCode.Emit_Error_0, [e.message])];
            }

            throw e;
        };

        Emitter.prototype.emitLiteralExpression = function (expression) {
            switch (expression.nodeType()) {
                case 8 /* NullLiteral */:
                    this.writeToOutputWithSourceMapRecord("null", expression);
                    break;
                case 4 /* FalseLiteral */:
                    this.writeToOutputWithSourceMapRecord("false", expression);
                    break;
                case 3 /* TrueLiteral */:
                    this.writeToOutputWithSourceMapRecord("true", expression);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
        };

        Emitter.prototype.emitThisExpression = function (expression) {
            if (this.inArrowFunction) {
                this.writeToOutputWithSourceMapRecord("_this", expression);
            } else {
                this.writeToOutputWithSourceMapRecord("this", expression);
            }
        };

        Emitter.prototype.emitSuperExpression = function (expression) {
            this.writeToOutputWithSourceMapRecord("_super.prototype", expression);
        };

        Emitter.prototype.emitParenthesizedExpression = function (parenthesizedExpression) {
            if (parenthesizedExpression.expression.nodeType() === 80 /* CastExpression */ && parenthesizedExpression.openParenTrailingComments === null) {
                parenthesizedExpression.expression.emit(this);
            } else {
                this.recordSourceMappingStart(parenthesizedExpression);
                this.writeToOutput("(");
                this.emitCommentsArray(parenthesizedExpression.openParenTrailingComments);
                parenthesizedExpression.expression.emit(this);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(parenthesizedExpression);
            }
        };

        Emitter.prototype.emitCastExpression = function (expression) {
            expression.operand.emit(this);
        };

        Emitter.prototype.emitUnaryExpression = function (expression) {
            var nodeType = expression.nodeType();

            this.recordSourceMappingStart(expression);
            switch (nodeType) {
                case 78 /* PostIncrementExpression */:
                    expression.operand.emit(this);
                    this.writeToOutput("++");
                    break;
                case 75 /* LogicalNotExpression */:
                    this.writeToOutput("!");
                    expression.operand.emit(this);
                    break;
                case 79 /* PostDecrementExpression */:
                    expression.operand.emit(this);
                    this.writeToOutput("--");
                    break;
                case 24 /* ObjectLiteralExpression */:
                    this.emitObjectLiteral(expression);
                    break;
                case 23 /* ArrayLiteralExpression */:
                    this.emitArrayLiteral(expression);
                    break;
                case 74 /* BitwiseNotExpression */:
                    this.writeToOutput("~");
                    expression.operand.emit(this);
                    break;
                case 29 /* NegateExpression */:
                    this.writeToOutput("-");
                    if (expression.operand.nodeType() === 29 /* NegateExpression */ || expression.operand.nodeType() === 77 /* PreDecrementExpression */) {
                        this.writeToOutput(" ");
                    }
                    expression.operand.emit(this);
                    break;
                case 28 /* PlusExpression */:
                    this.writeToOutput("+");
                    if (expression.operand.nodeType() === 28 /* PlusExpression */ || expression.operand.nodeType() === 76 /* PreIncrementExpression */) {
                        this.writeToOutput(" ");
                    }
                    expression.operand.emit(this);
                    break;
                case 76 /* PreIncrementExpression */:
                    this.writeToOutput("++");
                    expression.operand.emit(this);
                    break;
                case 77 /* PreDecrementExpression */:
                    this.writeToOutput("--");
                    expression.operand.emit(this);
                    break;
                case 36 /* TypeOfExpression */:
                    this.writeToOutput("typeof ");
                    expression.operand.emit(this);
                    break;
                case 30 /* DeleteExpression */:
                    this.writeToOutput("delete ");
                    expression.operand.emit(this);
                    break;
                case 26 /* VoidExpression */:
                    this.writeToOutput("void ");
                    expression.operand.emit(this);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }

            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitBinaryExpression = function (expression) {
            this.recordSourceMappingStart(expression);
            switch (expression.nodeType()) {
                case 34 /* MemberAccessExpression */:
                    if (!this.tryEmitConstant(expression)) {
                        expression.operand1.emit(this);
                        this.writeToOutput(".");
                        this.emitName(expression.operand2, false);
                    }
                    break;
                case 37 /* ElementAccessExpression */:
                    this.emitIndex(expression.operand1, expression.operand2);
                    break;

                case 83 /* Member */:
                    if (expression.operand2.nodeType() === 13 /* FunctionDeclaration */ && expression.operand2.isAccessor()) {
                        var funcDecl = expression.operand2;
                        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                            this.writeToOutput("get ");
                        } else {
                            this.writeToOutput("set ");
                        }
                        expression.operand1.emit(this);
                    } else {
                        expression.operand1.emit(this);
                        this.writeToOutput(": ");
                    }
                    expression.operand2.emit(this);
                    break;
                case 27 /* CommaExpression */:
                    expression.operand1.emit(this);
                    this.writeToOutput(", ");
                    expression.operand2.emit(this);
                    break;
                default: {
                    expression.operand1.emit(this);
                    var binOp = TypeScript.BinaryExpression.getTextForBinaryToken(expression.nodeType());
                    if (binOp === "instanceof") {
                        this.writeToOutput(" instanceof ");
                    } else if (binOp === "in") {
                        this.writeToOutput(" in ");
                    } else {
                        this.writeToOutput(" " + binOp + " ");
                    }
                    expression.operand2.emit(this);
                }
            }
            this.recordSourceMappingEnd(expression);
        };

        Emitter.prototype.emitConditionalExpression = function (expression) {
            expression.operand1.emit(this);
            this.writeToOutput(" ? ");
            expression.operand2.emit(this);
            this.writeToOutput(" : ");
            expression.operand3.emit(this);
        };

        Emitter.prototype.emitThrowStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("throw ");
            statement.expression.emit(this);
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitExpressionStatement = function (statement) {
            var isArrowExpression = statement.expression.nodeType() === 82 /* ArrowFunctionExpression */;

            this.recordSourceMappingStart(statement);
            if (isArrowExpression) {
                this.writeToOutput("(");
            }

            statement.expression.emit(this);

            if (isArrowExpression) {
                this.writeToOutput(")");
            }

            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitLabeledStatement = function (statement) {
            this.writeToOutputWithSourceMapRecord(statement.identifier.actualText, statement.identifier);
            this.writeLineToOutput(":");
            this.emitJavascript(statement.statement, true);
        };

        Emitter.prototype.emitBlock = function (block) {
            this.recordSourceMappingStart(block);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            if (block.statements) {
                this.emitList(block.statements);
            }
            this.emitCommentsArray(block.closeBraceLeadingComments);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
            this.recordSourceMappingEnd(block);
        };

        Emitter.prototype.emitJump = function (jump) {
            this.recordSourceMappingStart(jump);
            if (jump.nodeType() === 85 /* BreakStatement */) {
                this.writeToOutput("break");
            } else {
                this.writeToOutput("continue");
            }
            if (jump.target) {
                this.writeToOutput(" " + jump.target);
            }
            this.recordSourceMappingEnd(jump);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitWhileStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("while (");
            statement.cond.emit(this);
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.body);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitDoStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("do");
            this.emitBlockOrStatement(statement.body);
            this.writeToOutputWithSourceMapRecord(" while", statement.whileSpan);
            this.writeToOutput('(');
            statement.cond.emit(this);
            this.writeToOutput(")");
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitIfStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("if (");
            statement.cond.emit(this);
            this.writeToOutput(")");

            this.emitBlockOrStatement(statement.thenBod);

            if (statement.elseBod) {
                if (statement.thenBod.nodeType() !== 84 /* Block */) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                } else {
                    this.writeToOutput(" ");
                }

                if (statement.elseBod.nodeType() === 94 /* IfStatement */) {
                    this.writeToOutput("else ");
                    statement.elseBod.emit(this);
                } else {
                    this.writeToOutput("else");
                    this.emitBlockOrStatement(statement.elseBod);
                }
            }
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitReturnStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            if (statement.returnExpression) {
                this.writeToOutput("return ");
                statement.returnExpression.emit(this);
            } else {
                this.writeToOutput("return");
            }
            this.recordSourceMappingEnd(statement);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitForInStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("for (");
            statement.lval.emit(this);
            this.writeToOutput(" in ");
            statement.obj.emit(this);
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.body);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitForStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("for (");
            if (statement.init) {
                if (statement.init.nodeType() !== 1 /* List */) {
                    statement.init.emit(this);
                } else {
                    this.emitCommaSeparatedList(statement.init);
                }
            }

            this.writeToOutput("; ");
            this.emitJavascript(statement.cond, false);
            this.writeToOutput(";");
            if (statement.incr) {
                this.writeToOutput(" ");
                this.emitJavascript(statement.incr, false);
            }
            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.body);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitWithStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("with (");
            if (statement.expr) {
                statement.expr.emit(this);
            }

            this.writeToOutput(")");
            this.emitBlockOrStatement(statement.body);
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitSwitchStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.recordSourceMappingStart(statement.statement);
            this.writeToOutput("switch (");
            statement.val.emit(this);
            this.writeToOutput(")");
            this.recordSourceMappingEnd(statement.statement);
            this.writeLineToOutput(" {");
            this.indenter.increaseIndent();
            this.emitList(statement.caseList, false);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitCaseClause = function (clause) {
            this.recordSourceMappingStart(clause);
            if (clause.expr) {
                this.writeToOutput("case ");
                clause.expr.emit(this);
            } else {
                this.writeToOutput("default");
            }
            this.writeToOutput(":");

            if (clause.body.members.length === 1 && clause.body.members[0].nodeType() === 84 /* Block */) {
                clause.body.members[0].emit(this);
                this.writeLineToOutput("");
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                clause.body.emit(this);
                this.indenter.decreaseIndent();
            }
            this.recordSourceMappingEnd(clause);
        };

        Emitter.prototype.emitTryStatement = function (statement) {
            this.recordSourceMappingStart(statement);
            this.writeToOutput("try ");
            statement.tryBody.emit(this);
            this.emitJavascript(statement.catchClause, false);

            if (statement.finallyBody) {
                this.writeToOutput(" finally");
                statement.finallyBody.emit(this);
            }
            this.recordSourceMappingEnd(statement);
        };

        Emitter.prototype.emitCatchClause = function (clause) {
            this.writeToOutput(" ");
            this.recordSourceMappingStart(clause);
            this.writeToOutput("catch (");
            clause.param.id.emit(this);
            this.writeToOutput(")");
            clause.body.emit(this);
            this.recordSourceMappingEnd(clause);
        };

        Emitter.prototype.emitDebuggerStatement = function (statement) {
            this.writeToOutputWithSourceMapRecord("debugger", statement);
            this.writeToOutput(";");
        };

        Emitter.prototype.emitNumericLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text(), literal);
        };

        Emitter.prototype.emitRegularExpressionLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.text, literal);
        };

        Emitter.prototype.emitStringLiteral = function (literal) {
            this.writeToOutputWithSourceMapRecord(literal.actualText, literal);
        };

        Emitter.prototype.emitParameter = function (parameter) {
            this.writeToOutputWithSourceMapRecord(parameter.id.actualText, parameter);
        };

        Emitter.prototype.isNonAmbientAndNotSignature = function (declaration) {
            return !TypeScript.hasFlag(declaration.getFunctionFlags(), 128 /* Signature */) && !TypeScript.hasFlag(declaration.getFunctionFlags(), 8 /* Ambient */);
        };

        Emitter.prototype.shouldEmitFunctionDeclaration = function (declaration) {
            return declaration.preComments() !== null || this.isNonAmbientAndNotSignature(declaration);
        };

        Emitter.prototype.emitFunctionDeclaration = function (declaration) {
            if (this.isNonAmbientAndNotSignature(declaration)) {
                this.emitFunction(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.emitScript = function (script) {
            if (!script.isDeclareFile) {
                this.emitScriptElements(script);
            }
        };

        Emitter.prototype.scriptIsElided = function (script) {
            if (TypeScript.hasFlag(script.getModuleFlags(), 8 /* Ambient */)) {
                return true;
            }

            return this.moduleMembersAreElided(script.moduleElements);
        };

        Emitter.prototype.moduleIsElided = function (declaration) {
            if (TypeScript.hasFlag(declaration.getModuleFlags(), 8 /* Ambient */)) {
                return true;
            }

            if (TypeScript.hasFlag(declaration.getModuleFlags(), 128 /* IsEnum */)) {
                return false;
            }

            return this.moduleMembersAreElided(declaration.members);
        };

        Emitter.prototype.moduleMembersAreElided = function (members) {
            for (var i = 0, n = members.members.length; i < n; i++) {
                var member = members.members[i];

                if (member.nodeType() === 17 /* ModuleDeclaration */) {
                    if (!this.moduleIsElided(member)) {
                        return false;
                    }
                } else if (member.nodeType() !== 15 /* InterfaceDeclaration */) {
                    return false;
                }
            }

            return true;
        };

        Emitter.prototype.shouldEmitModuleDeclaration = function (declaration) {
            return declaration.preComments() !== null || !this.moduleIsElided(declaration);
        };

        Emitter.prototype.emitModuleDeclaration = function (declaration) {
            if (!this.moduleIsElided(declaration)) {
                this.emitComments(declaration, true);
                this.emitModule(declaration);
                this.emitComments(declaration, false);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitClassDeclaration = function (declaration) {
            return declaration.preComments() !== null || !TypeScript.hasFlag(declaration.getVarFlags(), 8 /* Ambient */);
        };

        Emitter.prototype.emitClassDeclaration = function (declaration) {
            if (!TypeScript.hasFlag(declaration.getVarFlags(), 8 /* Ambient */)) {
                this.emitClass(declaration);
            } else {
                this.emitComments(declaration, true, true);
            }
        };

        Emitter.prototype.shouldEmitInterfaceDeclaration = function (declaration) {
            return declaration.preComments() !== null;
        };

        Emitter.prototype.emitInterfaceDeclaration = function (declaration) {
            this.emitComments(declaration, true, true);
        };

        Emitter.prototype.firstVariableDeclarator = function (statement) {
            return statement.declaration.declarators.members[0];
        };

        Emitter.prototype.isNotAmbientOrHasInitializer = function (statement) {
            var varDecl = this.firstVariableDeclarator(statement);
            return !TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) || varDecl.init !== null;
        };

        Emitter.prototype.shouldEmitVariableStatement = function (statement) {
            return this.firstVariableDeclarator(statement).preComments() !== null || this.isNotAmbientOrHasInitializer(statement);
        };

        Emitter.prototype.emitVariableStatement = function (statement) {
            if (this.isNotAmbientOrHasInitializer(statement)) {
                if (TypeScript.hasFlag(statement.getFlags(), 16 /* EnumElement */)) {
                    this.emitEnumElement(this.firstVariableDeclarator(statement));
                } else {
                    statement.declaration.emit(this);
                    this.writeToOutput(";");
                }
            } else {
                this.emitComments(this.firstVariableDeclarator(statement), true, true);
            }
        };

        Emitter.prototype.emitGenericType = function (type) {
            type.name.emit(this);
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.isMarker = function () {
            return !this.isString() && !this.isArray();
        };

        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };

        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (typeof markerBaseLength === "undefined") { markerBaseLength = 0; }
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += memberName.text;
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }

                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        };

        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;

    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;

    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };

        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };

        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripStartAndEndQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
            return str.substring(1, str.length - 1);
        }

        return str;
    }
    TypeScript.stripStartAndEndQuotes = stripStartAndEndQuotes;

    function isSingleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 39 /* singleQuote */;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;

    function isDoubleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 34 /* doubleQuote */;
    }
    TypeScript.isDoubleQuoted = isDoubleQuoted;

    function isQuoted(str) {
        return isDoubleQuoted(str) || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;

    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;

    function swapQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1)) {
            if (firstCharCode === 34 /* doubleQuote */) {
                return '\'' + str.substring(1, str.length - 1) + '\'';
            } else if (firstCharCode === 39 /* singleQuote */) {
                return '\"' + str.substring(1, str.length - 1) + '\"';
            }
        }

        return str;
    }
    TypeScript.swapQuotes = swapQuotes;

    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;

    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }

        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }
    TypeScript.trimModName = trimModName;

    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;

    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }

    function isJSFile(fname) {
        return isFileOfExtension(fname, ".js");
    }
    TypeScript.isJSFile = isJSFile;

    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;

    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;

    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripStartAndEndQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;

    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;

    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath, isAbsoultePathURL) {
        if (typeof isAbsoultePathURL === "undefined") { isAbsoultePathURL = true; }
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }

        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }

        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;

    function quoteBaseName(modPath) {
        var modName = trimModName(stripStartAndEndQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path === "") {
            return modPath;
        } else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }
    TypeScript.quoteBaseName = quoteBaseName;

    function changePathToDTS(modPath) {
        return trimModName(stripStartAndEndQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;

    function isRelative(path) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }
    TypeScript.isRooted = isRooted;

    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;

    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;

    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;

    function convertToDirectoryPath(dirPath) {
        if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
            dirPath += "/";
        }

        return dirPath;
    }
    TypeScript.convertToDirectoryPath = convertToDirectoryPath;

    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];

        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }

            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }

            normalizedParts.push(part);
        }

        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.propagateEnumConstants = false;
            this.removeComments = false;
            this.watch = false;
            this.noResolve = false;
            this.allowAutomaticSemicolonInsertion = true;
            this.noImplicitAny = false;
            this.noLib = false;
            this.codeGenTarget = 0 /* EcmaScript3 */;
            this.moduleGenTarget = 0 /* Unspecified */;
            this.outFileOption = "";
            this.outDirOption = "";
            this.mapSourceFiles = false;
            this.mapRoot = "";
            this.sourceRoot = "";
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.updateTC = false;
            this.codepage = null;
        }
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;

    

    function isNoDefaultLibMatch(comment) {
        var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
        return isNoDefaultLibRegex.exec(comment);
    }

    TypeScript.tripleSlashReferenceRegExp = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/;

    function getFileReferenceFromReferencePath(fileName, position, comment, diagnostics) {
        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            var isNoDefaultLib = isNoDefaultLibMatch(comment);

            if (!isNoDefaultLib) {
                var fullReferenceRegEx = TypeScript.tripleSlashReferenceRegExp;
                var fullReference = fullReferenceRegEx.exec(comment);

                if (!fullReference) {
                    diagnostics.push(new TypeScript.Diagnostic(fileName, position, comment.length, TypeScript.DiagnosticCode.Invalid_reference_directive_syntax));
                } else {
                    var path = TypeScript.normalizePath(fullReference[3]);
                    var adjustedPath = TypeScript.normalizePath(path);

                    var isResident = fullReference.length >= 7 && fullReference[6] === "true";
                    if (isResident) {
                        TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
                    }
                    return {
                        line: 0,
                        character: 0,
                        position: 0,
                        length: 0,
                        path: TypeScript.switchToForwardSlashes(adjustedPath),
                        isResident: isResident
                    };
                }
            }
        }

        return null;
    }

    function getImplicitImport(comment) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);

        if (match) {
            return true;
        }

        return false;
    }
    TypeScript.getImplicitImport = getImplicitImport;

    var scannerWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];

    function processImports(lineMap, scanner, token, importedFiles) {
        var position = 0;
        var lineChar = { line: -1, character: -1 };

        while (token.tokenKind !== 10 /* EndOfFileToken */) {
            if (token.tokenKind === 49 /* ImportKeyword */) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, false);

                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, false);

                    if (token.tokenKind === 107 /* EqualsToken */) {
                        token = scanner.scan(scannerDiagnostics, false);

                        if (token.tokenKind === 65 /* ModuleKeyword */ || token.tokenKind === 66 /* RequireKeyword */) {
                            token = scanner.scan(scannerDiagnostics, false);

                            if (token.tokenKind === 72 /* OpenParenToken */) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, false);

                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);

                                if (token.tokenKind === 14 /* StringLiteral */) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: TypeScript.stripStartAndEndQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, false);
        }
    }

    function processTripleSlashDirectives(fileName, lineMap, firstToken, settings) {
        var leadingTrivia = firstToken.leadingTrivia();

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;
        var diagnostics = [];
        var referencedFiles = [];

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === 7 /* SingleLineCommentTrivia */) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(fileName, position, triviaText, diagnostics);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                if (settings) {
                    var isNoDefaultLib = isNoDefaultLibMatch(triviaText);
                    if (isNoDefaultLib) {
                        noDefaultLib = isNoDefaultLib[3] === "true";
                    }
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib, diagnostics: diagnostics, referencedFiles: referencedFiles };
    }

    function preProcessFile(fileName, sourceText, settings, readImportFiles) {
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        settings = settings || new CompilationSettings();

        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new TypeScript.Scanner(fileName, text, settings.codeGenTarget, scannerWindow);

        var firstToken = scanner.scan(scannerDiagnostics, false);

        var importedFiles = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }

        var properties = processTripleSlashDirectives(fileName, text.lineMap(), firstToken, settings);

        scannerDiagnostics.length = 0;
        return { settings: settings, referencedFiles: properties.referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib, diagnostics: properties.diagnostics };
    }
    TypeScript.preProcessFile = preProcessFile;

    function getParseOptions(settings) {
        return new TypeScript.ParseOptions(settings.codeGenTarget, settings.allowAutomaticSemicolonInsertion);
    }
    TypeScript.getParseOptions = getParseOptions;

    function getReferencedFiles(fileName, sourceText) {
        return preProcessFile(fileName, sourceText, null, false).referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ReferenceResolutionResult = (function () {
        function ReferenceResolutionResult() {
            this.resolvedFiles = [];
            this.diagnostics = [];
            this.seenNoDefaultLibTag = false;
        }
        return ReferenceResolutionResult;
    })();
    TypeScript.ReferenceResolutionResult = ReferenceResolutionResult;

    var ReferenceLocation = (function () {
        function ReferenceLocation(filePath, position, length, isImported) {
            this.filePath = filePath;
            this.position = position;
            this.length = length;
            this.isImported = isImported;
        }
        return ReferenceLocation;
    })();

    var ReferenceResolver = (function () {
        function ReferenceResolver(inputFileNames, host, settings) {
            this.inputFileNames = inputFileNames;
            this.host = host;
            this.settings = settings;
            this.visited = {};
        }
        ReferenceResolver.resolve = function (inputFileNames, host, settings) {
            var resolver = new ReferenceResolver(inputFileNames, host, settings);
            return resolver.resolveInputFiles();
        };

        ReferenceResolver.prototype.resolveInputFiles = function () {
            var result = new ReferenceResolutionResult();

            if (!this.inputFileNames || this.inputFileNames.length <= 0) {
                return result;
            }

            var referenceLocation = new ReferenceLocation(null, 0, 0, false);
            for (var i = 0, n = this.inputFileNames.length; i < n; i++) {
                this.resolveIncludedFile(this.inputFileNames[i], referenceLocation, result);
            }

            return result;
        };

        ReferenceResolver.prototype.resolveIncludedFile = function (path, referenceLocation, resolutionResult) {
            var normalizedPath = this.getNormalizedFilePath(path, referenceLocation.filePath);

            if (this.isSameFile(normalizedPath, referenceLocation.filePath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.A_file_cannot_have_a_reference_to_itself, null));
                }

                return normalizedPath;
            }

            if (!TypeScript.isTSFile(normalizedPath) && !TypeScript.isDTSFile(normalizedPath)) {
                var dtsFile = normalizedPath + ".d.ts";
                var tsFile = normalizedPath + ".ts";

                if (this.host.fileExists(dtsFile)) {
                    normalizedPath = dtsFile;
                } else {
                    normalizedPath = tsFile;
                }
            }

            if (!this.host.fileExists(normalizedPath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.Cannot_resolve_referenced_file_0, [path]));
                }

                return normalizedPath;
            }

            return this.resolveFile(normalizedPath, resolutionResult);
        };

        ReferenceResolver.prototype.resolveImportedFile = function (path, referenceLocation, resolutionResult) {
            var isRelativePath = TypeScript.isRelative(path);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(path);

            if (isRelativePath || isRootedPath) {
                return this.resolveIncludedFile(path, referenceLocation, resolutionResult);
            } else {
                var parentDirectory = this.host.getParentDirectory(referenceLocation.filePath);
                var searchFilePath = null;
                var dtsFileName = path + ".d.ts";
                var tsFilePath = path + ".ts";

                do {
                    var currentFilePath = this.host.resolveRelativePath(dtsFileName, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    currentFilePath = this.host.resolveRelativePath(tsFilePath, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    parentDirectory = this.host.getParentDirectory(parentDirectory);
                } while(parentDirectory);

                if (!searchFilePath) {
                    return path;
                }

                return this.resolveFile(searchFilePath, resolutionResult);
            }
        };

        ReferenceResolver.prototype.resolveFile = function (normalizedPath, resolutionResult) {
            var visitedPath = this.isVisited(normalizedPath);
            if (!visitedPath) {
                this.recordVisitedFile(normalizedPath);

                var preprocessedFileInformation = TypeScript.preProcessFile(normalizedPath, this.host.getScriptSnapshot(normalizedPath), this.settings);
                resolutionResult.diagnostics.push.apply(resolutionResult.diagnostics, preprocessedFileInformation.diagnostics);

                if (preprocessedFileInformation.isLibFile) {
                    resolutionResult.seenNoDefaultLibTag = true;
                }

                var normalizedReferencePaths = [];
                for (var i = 0, n = preprocessedFileInformation.referencedFiles.length; i < n; i++) {
                    var fileReference = preprocessedFileInformation.referencedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, fileReference.position, fileReference.length, false);
                    var normalizedReferencePath = this.resolveIncludedFile(fileReference.path, currentReferenceLocation, resolutionResult);
                    normalizedReferencePaths.push(normalizedReferencePath);
                }

                var normalizedImportPaths = [];
                for (var i = 0; i < preprocessedFileInformation.importedFiles.length; i++) {
                    var fileImport = preprocessedFileInformation.importedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, fileImport.position, fileImport.length, true);
                    var normalizedImportPath = this.resolveImportedFile(fileImport.path, currentReferenceLocation, resolutionResult);
                    normalizedImportPaths.push(normalizedImportPath);
                }

                resolutionResult.resolvedFiles.push({
                    path: normalizedPath,
                    referencedFiles: normalizedReferencePaths,
                    importedFiles: normalizedImportPaths
                });
            } else {
                normalizedPath = visitedPath;
            }

            return normalizedPath;
        };

        ReferenceResolver.prototype.getNormalizedFilePath = function (path, parentFilePath) {
            var parentFileDirectory = parentFilePath ? this.host.getParentDirectory(parentFilePath) : "";
            var normalizedPath = this.host.resolveRelativePath(path, parentFileDirectory);
            return normalizedPath;
        };

        ReferenceResolver.prototype.getUniqueFileId = function (filePath) {
            return this.settings.useCaseSensitiveFileResolution ? filePath : filePath.toLocaleUpperCase();
        };

        ReferenceResolver.prototype.recordVisitedFile = function (filePath) {
            this.visited[this.getUniqueFileId(filePath)] = filePath;
        };

        ReferenceResolver.prototype.isVisited = function (filePath) {
            return this.visited[this.getUniqueFileId(filePath)];
        };

        ReferenceResolver.prototype.isSameFile = function (filePath1, filePath2) {
            if (!filePath1 || !filePath2) {
                return false;
            }

            if (this.settings.useCaseSensitiveFileResolution) {
                return filePath1 === filePath2;
            } else {
                return filePath1.toLocaleUpperCase() === filePath2.toLocaleUpperCase();
            }
        };
        return ReferenceResolver;
    })();
    TypeScript.ReferenceResolver = ReferenceResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextWriter = (function () {
        function TextWriter(ioHost, path, writeByteOrderMark) {
            this.ioHost = ioHost;
            this.path = path;
            this.writeByteOrderMark = writeByteOrderMark;
            this.contents = "";
            this.onNewLine = true;
        }
        TextWriter.prototype.Write = function (s) {
            this.contents += s;
            this.onNewLine = false;
        };

        TextWriter.prototype.WriteLine = function (s) {
            this.contents += s;
            this.contents += TypeScript.newLine();
            this.onNewLine = true;
        };

        TextWriter.prototype.Close = function () {
            try  {
                this.ioHost.writeFile(this.path, this.contents, this.writeByteOrderMark);
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        return TextWriter;
    })();
    TypeScript.TextWriter = TextWriter;

    var DeclarationEmitter = (function () {
        function DeclarationEmitter(emittingFileName, document, compiler) {
            this.emittingFileName = emittingFileName;
            this.document = document;
            this.compiler = compiler;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.declarationContainerStack = [];
            this.emittedReferencePaths = false;
            this.declFile = new TextWriter(this.compiler.emitOptions.ioHost, emittingFileName, this.document.byteOrderMark !== 0 /* None */);
        }
        DeclarationEmitter.prototype.widenType = function (type) {
            if (type === this.compiler.semanticInfoChain.undefinedTypeSymbol || type === this.compiler.semanticInfoChain.nullTypeSymbol) {
                return this.compiler.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        };

        DeclarationEmitter.prototype.close = function () {
            try  {
                this.declFile.Close();
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };

        DeclarationEmitter.prototype.emitDeclarations = function (script) {
            this.emitDeclarationsForScript(script);
        };

        DeclarationEmitter.prototype.emitDeclarationsForList = function (list) {
            for (var i = 0; i < list.members.length; i++) {
                this.emitDeclarationsForAST(list.members[i]);
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForAST = function (ast) {
            switch (ast.nodeType()) {
                case 100 /* VariableStatement */:
                    return this.emitDeclarationsForVariableStatement(ast);
                case 20 /* VariableDeclaration */:
                    return this.emitDeclarationsForVariableDeclaration(ast);
                case 19 /* VariableDeclarator */:
                    return this.emitDeclarationsForVariableDeclarator(ast, true, true);
                case 13 /* FunctionDeclaration */:
                    return this.emitDeclarationsForFunctionDeclaration(ast);
                case 14 /* ClassDeclaration */:
                    return this.emitDeclarationsForClassDeclaration(ast);
                case 15 /* InterfaceDeclaration */:
                    return this.emitDeclarationsForInterfaceDeclaration(ast);
                case 18 /* ImportDeclaration */:
                    return this.emitDeclarationsForImportDeclaration(ast);
                case 17 /* ModuleDeclaration */:
                    return this.emitDeclarationsForModuleDeclaration(ast);
                case 90 /* ExportAssignment */:
                    return this.emitDeclarationsForExportAssignment(ast);
            }
        };

        DeclarationEmitter.prototype.getAstDeclarationContainer = function () {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        };

        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            return this.indenter.getIndent();
        };

        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };

        DeclarationEmitter.prototype.canEmitDeclarations = function (declFlags, declAST) {
            var container = this.getAstDeclarationContainer();

            var pullDecl = this.compiler.semanticInfoChain.getDeclForAST(declAST, this.document.fileName);
            if (container.nodeType() === 17 /* ModuleDeclaration */) {
                if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                    var start = new Date().getTime();
                    var declSymbol = this.compiler.semanticInfoChain.getSymbolForAST(declAST, this.document.fileName);
                    var result = declSymbol && declSymbol.isExternallyVisible();
                    TypeScript.declarationEmitIsExternallyVisibleTime += new Date().getTime() - start;

                    return result;
                }
            }

            return true;
        };

        DeclarationEmitter.prototype.getDeclFlagsString = function (declFlags, pullDecl, typeString) {
            var result = this.getIndentString();
            var pullFlags = pullDecl.flags;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                }
                result += "static ";
            } else {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                } else if (TypeScript.hasFlag(declFlags, 4 /* Public */)) {
                    result += "public ";
                } else {
                    var emitDeclare = !TypeScript.hasFlag(pullFlags, 1 /* Exported */);

                    var container = this.getAstDeclarationContainer();
                    var isExternalModule = container.nodeType() === 17 /* ModuleDeclaration */ && TypeScript.hasFlag(container.getModuleFlags(), 256 /* IsExternalModule */);

                    if (isExternalModule && TypeScript.hasFlag(pullFlags, 1 /* Exported */)) {
                        result += "export ";
                        emitDeclare = true;
                    }

                    if (isExternalModule || container.nodeType() == 2 /* Script */) {
                        if (emitDeclare && typeString !== "interface" && typeString != "import") {
                            result += "declare ";
                        }
                    }

                    result += typeString + " ";
                }
            }

            return result;
        };

        DeclarationEmitter.prototype.emitDeclFlags = function (declFlags, pullDecl, typeString) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, pullDecl, typeString));
        };

        DeclarationEmitter.prototype.canEmitTypeAnnotationSignature = function (declFlag) {
            if (typeof declFlag === "undefined") { declFlag = 0 /* None */; }
            return !TypeScript.hasFlag(declFlag, 2 /* Private */);
        };

        DeclarationEmitter.prototype.pushDeclarationContainer = function (ast) {
            this.declarationContainerStack.push(ast);
        };

        DeclarationEmitter.prototype.popDeclarationContainer = function (ast) {
            TypeScript.CompilerDiagnostics.assert(ast !== this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        };

        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix !== "") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.text);
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };

        DeclarationEmitter.prototype.emitTypeSignature = function (type) {
            var declarationContainerAst = this.getAstDeclarationContainer();

            var start = new Date().getTime();
            var declarationContainerDecl = this.compiler.semanticInfoChain.getDeclForAST(declarationContainerAst, this.document.fileName);
            var declarationPullSymbol = declarationContainerDecl.getSymbol();
            TypeScript.declarationEmitTypeSignatureTime += new Date().getTime() - start;

            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol);
            this.emitTypeNamesMember(typeNameMembers);
        };

        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }

            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };

        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (this.compiler.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var declComments = astOrSymbol.docComments();
            this.writeDeclarationComments(declComments, endLine);
        };

        DeclarationEmitter.prototype.writeDeclarationComments = function (declComments, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (declComments.length > 0) {
                for (var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }

                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        };

        DeclarationEmitter.prototype.emitTypeOfVariableDeclaratorOrParameter = function (boundDecl) {
            var start = new Date().getTime();
            var decl = this.compiler.semanticInfoChain.getDeclForAST(boundDecl, this.document.fileName);
            var pullSymbol = decl.getSymbol();
            TypeScript.declarationEmitGetBoundDeclTypeTime += new Date().getTime() - start;

            var type = this.widenType(pullSymbol.type);
            if (!type) {
                return;
            }

            this.declFile.Write(": ");
            this.emitTypeSignature(type);
        };

        DeclarationEmitter.prototype.emitDeclarationsForVariableDeclarator = function (varDecl, isFirstVarInList, isLastVarInList) {
            if (this.canEmitDeclarations(TypeScript.ToDeclFlags(varDecl.getVarFlags()), varDecl)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType() === 15 /* InterfaceDeclaration */);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    if (isFirstVarInList) {
                        this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.getVarFlags()), this.compiler.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName), "var");
                    }

                    this.declFile.Write(varDecl.id.actualText);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.actualText);
                    if (TypeScript.hasFlag(varDecl.id.getFlags(), 4 /* OptionalName */)) {
                        this.declFile.Write("?");
                    }
                }

                if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()))) {
                    this.emitTypeOfVariableDeclaratorOrParameter(varDecl);
                }

                if (isLastVarInList) {
                    this.declFile.WriteLine(";");
                } else {
                    this.declFile.Write(", ");
                }
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForVariableStatement = function (variableStatement) {
            this.emitDeclarationsForVariableDeclaration(variableStatement.declaration);
        };

        DeclarationEmitter.prototype.emitDeclarationsForVariableDeclaration = function (variableDeclaration) {
            var varListCount = variableDeclaration.declarators.members.length;
            for (var i = 0; i < varListCount; i++) {
                this.emitDeclarationsForVariableDeclarator(variableDeclaration.declarators.members[i], i == 0, i == varListCount - 1);
            }
        };

        DeclarationEmitter.prototype.emitArgDecl = function (argDecl, funcDecl) {
            this.indenter.increaseIndent();

            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.actualText);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }

            this.indenter.decreaseIndent();

            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.emitTypeOfVariableDeclaratorOrParameter(argDecl);
            }
        };

        DeclarationEmitter.prototype.isOverloadedCallSignature = function (funcDecl) {
            var start = new Date().getTime();
            var functionDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            var funcSymbol = functionDecl.getSymbol();
            TypeScript.declarationEmitIsOverloadedCallSignatureTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            var signatures = funcTypeSymbol.getCallSignatures();
            var result = signatures && signatures.length > 1;

            return result;
        };

        DeclarationEmitter.prototype.emitDeclarationsForFunctionDeclaration = function (funcDecl) {
            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }

            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType() === 15 /* InterfaceDeclaration */);

            var start = new Date().getTime();
            var funcSymbol = this.compiler.semanticInfoChain.getSymbolForAST(funcDecl, this.document.fileName);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return;
                }
            } else if (!isInterfaceMember && TypeScript.hasFlag(funcDecl.getFunctionFlags(), 2 /* Private */) && this.isOverloadedCallSignature(funcDecl)) {
                var callSignatures = funcTypeSymbol.getCallSignatures();
                TypeScript.Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.compiler.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl !== funcDecl) {
                    return;
                }
            }

            if (!this.canEmitDeclarations(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), funcDecl)) {
                return;
            }

            var funcPullDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            var funcSignature = funcPullDecl.getSignatureSymbol();
            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
                this.emitTypeParameters(funcDecl.typeParameters, funcSignature);
            } else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), funcPullDecl, "function");
                    if (id !== "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        if (TypeScript.hasFlag(funcDecl.name.getFlags(), 4 /* OptionalName */)) {
                            this.declFile.Write("? ");
                        }
                    }
                }
                this.emitTypeParameters(funcDecl.typeParameters, funcSignature);
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }

            if (funcDecl.parameters) {
                var argsLen = funcDecl.parameters.members.length;
                if (TypeScript.lastParameterIsRest(funcDecl.parameters)) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.parameters.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }

            if (TypeScript.lastParameterIsRest(funcDecl.parameters)) {
                var lastArg = funcDecl.parameters.members[funcDecl.parameters.members.length - 1];
                if (funcDecl.parameters.members.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }

                this.emitArgDecl(lastArg, funcDecl);
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }

            if (!funcDecl.isConstructor && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                var returnType = funcSignature.returnType;
                this.declFile.Write(": ");
                this.emitTypeSignature(returnType);
            }

            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitBaseList = function (bases, useExtendsList) {
            if (bases && (bases.members.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    var baseType = this.compiler.semanticInfoChain.getSymbolForAST(bases.members[i], this.document.fileName);
                    this.emitTypeSignature(baseType);
                }
            }
        };

        DeclarationEmitter.prototype.emitAccessorDeclarationComments = function (funcDecl) {
            if (this.compiler.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var start = new Date().getTime();
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.compiler.semanticInfoChain, this.document.fileName);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            var comments = [];
            if (accessors.getter) {
                comments = comments.concat(accessors.getter.docComments());
            }
            if (accessors.setter) {
                comments = comments.concat(accessors.setter.docComments());
            }

            this.writeDeclarationComments(comments);
        };

        DeclarationEmitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {
            var start = new Date().getTime();
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.compiler.semanticInfoChain, this.document.fileName);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */) && accessorSymbol.getGetter()) {
                return;
            }

            this.emitAccessorDeclarationComments(funcDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName), "var");
            this.declFile.Write(funcDecl.name.actualText);
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.type;
                this.emitTypeSignature(type);
            }
            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            if (funcDecl.parameters) {
                var argsLen = funcDecl.parameters.members.length;
                if (TypeScript.lastParameterIsRest(funcDecl.parameters)) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.parameters.members[i];
                    if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
                        var funcPullDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.getVarFlags()), funcPullDecl, "var");
                        this.declFile.Write(argDecl.id.actualText);

                        if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(argDecl.getVarFlags()))) {
                            this.emitTypeOfVariableDeclaratorOrParameter(argDecl);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForClassDeclaration = function (classDecl) {
            if (!this.canEmitDeclarations(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classDecl)) {
                return;
            }

            var className = classDecl.name.actualText;
            this.emitDeclarationComments(classDecl);
            var classPullDecl = this.compiler.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
            this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classPullDecl, "class");
            this.declFile.Write(className);
            this.pushDeclarationContainer(classDecl);
            this.emitTypeParameters(classDecl.typeParameters);
            this.emitBaseList(classDecl.extendsList, true);
            this.emitBaseList(classDecl.implementsList, false);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();

            var constructorDecl = TypeScript.getClassConstructor(classDecl);
            if (constructorDecl) {
                this.emitClassMembersFromConstructorDefinition(constructorDecl);
            }

            this.emitDeclarationsForList(classDecl.members);

            this.indenter.decreaseIndent();
            this.popDeclarationContainer(classDecl);

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitTypeParameters = function (typeParams, funcSignature) {
            if (!typeParams || !typeParams.members.length) {
                return;
            }

            this.declFile.Write("<");
            var containerAst = this.getAstDeclarationContainer();

            var start = new Date().getTime();
            var containerDecl = this.compiler.semanticInfoChain.getDeclForAST(containerAst, this.document.fileName);
            var containerSymbol = containerDecl.getSymbol();
            TypeScript.declarationEmitGetTypeParameterSymbolTime += new Date().getTime() - start;

            var typars;
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            } else {
                typars = containerSymbol.getTypeArgumentsOrTypeParameters();
            }

            for (var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }

                var memberName = typars[i].getScopedNameEx(containerSymbol, true);
                this.emitTypeNamesMember(memberName);
            }

            this.declFile.Write(">");
        };

        DeclarationEmitter.prototype.emitDeclarationsForInterfaceDeclaration = function (interfaceDecl) {
            if (!this.canEmitDeclarations(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfaceDecl)) {
                return;
            }

            var interfaceName = interfaceDecl.name.actualText;
            this.emitDeclarationComments(interfaceDecl);
            var interfacePullDecl = this.compiler.semanticInfoChain.getDeclForAST(interfaceDecl, this.document.fileName);
            this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfacePullDecl, "interface");
            this.declFile.Write(interfaceName);
            this.pushDeclarationContainer(interfaceDecl);
            this.emitTypeParameters(interfaceDecl.typeParameters);
            this.emitBaseList(interfaceDecl.extendsList, true);
            this.declFile.WriteLine(" {");

            this.indenter.increaseIndent();

            this.emitDeclarationsForList(interfaceDecl.members);

            this.indenter.decreaseIndent();
            this.popDeclarationContainer(interfaceDecl);

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitDeclarationsForImportDeclaration = function (importDeclAST) {
            var importDecl = this.compiler.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var importSymbol = importDecl.getSymbol();
            var isExportedImportDecl = TypeScript.hasFlag(importDeclAST.getVarFlags(), 1 /* Exported */);

            if (isExportedImportDecl || importSymbol.typeUsedExternally || TypeScript.PullContainerSymbol.usedAsSymbol(importSymbol.getContainer(), importSymbol)) {
                this.emitDeclarationComments(importDeclAST);
                this.emitIndent();
                if (isExportedImportDecl) {
                    this.declFile.Write("export ");
                }
                this.declFile.Write("import ");
                this.declFile.Write(importDeclAST.id.actualText + " = ");
                if (importDeclAST.isExternalImportDeclaration()) {
                    this.declFile.WriteLine("require(" + importDeclAST.getAliasName() + ");");
                } else {
                    this.declFile.WriteLine(importDeclAST.getAliasName() + ";");
                }
            }
        };

        DeclarationEmitter.prototype.emitEnumSignature = function (moduleDecl) {
            if (!this.canEmitDeclarations(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl)) {
                return;
            }

            this.emitDeclarationComments(moduleDecl);
            var modulePullDecl = this.compiler.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), modulePullDecl, "enum");
            this.declFile.WriteLine(moduleDecl.name.actualText + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for (var j = 0; j < membersLen; j++) {
                var memberDecl = moduleDecl.members.members[j];
                var variableStatement = memberDecl;
                var varDeclarator = variableStatement.declaration.declarators.members[0];
                this.emitDeclarationComments(varDeclarator);
                this.emitIndent();
                this.declFile.Write(varDeclarator.id.actualText);
                if (varDeclarator.init && varDeclarator.init.nodeType() == 7 /* NumericLiteral */) {
                    this.declFile.Write(" = " + varDeclarator.init.text());
                }
                this.declFile.WriteLine(",");
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");
        };

        DeclarationEmitter.prototype.emitDeclarationsForModuleDeclaration = function (moduleDecl) {
            if (moduleDecl.isEnum()) {
                return this.emitEnumSignature(moduleDecl);
            }

            var isExternalModule = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsExternalModule */);
            if (!isExternalModule && !this.canEmitDeclarations(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl)) {
                return;
            }

            var dottedModuleContainers = [];
            if (!isExternalModule) {
                var modulePullDecl = this.compiler.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
                var moduleName = this.getDeclFlagsString(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), modulePullDecl, "module");

                if (!TypeScript.isQuoted(moduleDecl.name.text())) {
                    for (; moduleDecl.members.members.length === 1 && moduleDecl.members.members[0].nodeType() === 17 /* ModuleDeclaration */ && !moduleDecl.members.members[0].isEnum() && TypeScript.hasFlag(moduleDecl.members.members[0].getModuleFlags(), 1 /* Exported */) && (moduleDecl.docComments() === null || moduleDecl.docComments().length === 0); moduleDecl = moduleDecl.members.members[0]) {
                        moduleName += moduleDecl.name.actualText + ".";
                        dottedModuleContainers.push(moduleDecl);
                        this.pushDeclarationContainer(moduleDecl);
                    }
                }

                moduleName += moduleDecl.name.actualText;

                this.emitDeclarationComments(moduleDecl);
                this.declFile.Write(moduleName);
                this.declFile.WriteLine(" {");
                this.indenter.increaseIndent();
            }

            this.pushDeclarationContainer(moduleDecl);

            this.emitDeclarationsForList(moduleDecl.members);

            if (!isExternalModule) {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            this.popDeclarationContainer(moduleDecl);

            while (moduleDecl = dottedModuleContainers.pop()) {
                this.popDeclarationContainer(moduleDecl);
            }
        };

        DeclarationEmitter.prototype.emitDeclarationsForExportAssignment = function (ast) {
            this.emitIndent();
            this.declFile.Write("export = ");
            this.declFile.Write(ast.id.actualText);
            this.declFile.WriteLine(";");
        };

        DeclarationEmitter.prototype.resolveScriptReference = function (document, reference) {
            if (!this.compiler.settings.noResolve || TypeScript.isRooted(reference)) {
                return reference;
            }

            var documentDir = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(TypeScript.getRootFilePath(document.fileName)));
            var resolvedReferencePath = this.compiler.emitOptions.ioHost.resolvePath(documentDir + reference);
            return resolvedReferencePath;
        };

        DeclarationEmitter.prototype.emitReferencePaths = function (script) {
            if (this.emittedReferencePaths) {
                return;
            }

            var documents = [];
            if (this.compiler.emitOptions.outputMany || script.isExternalModule) {
                var scriptReferences = this.document.referencedFiles;
                var addedGlobalDocument = false;
                for (var j = 0; j < scriptReferences.length; j++) {
                    var currentReference = this.resolveScriptReference(this.document, scriptReferences[j]);
                    var document = this.compiler.getDocument(currentReference);

                    if (document && (this.compiler.emitOptions.outputMany || document.script.isDeclareFile || document.script.isExternalModule || !addedGlobalDocument)) {
                        documents = documents.concat(document);

                        if (!document.script.isDeclareFile && document.script.isExternalModule) {
                            addedGlobalDocument = true;
                        }
                    }
                }
            } else {
                var allDocuments = this.compiler.getDocuments();
                for (var i = 0; i < allDocuments.length; i++) {
                    if (!allDocuments[i].script.isDeclareFile && !allDocuments[i].script.isExternalModule) {
                        var scriptReferences = allDocuments[i].referencedFiles;
                        for (var j = 0; j < scriptReferences.length; j++) {
                            var currentReference = this.resolveScriptReference(allDocuments[i], scriptReferences[j]);
                            var document = this.compiler.getDocument(currentReference);

                            if (document && (document.script.isDeclareFile || document.script.isExternalModule)) {
                                for (var k = 0; k < documents.length; k++) {
                                    if (documents[k] == document) {
                                        break;
                                    }
                                }

                                if (k == documents.length) {
                                    documents = documents.concat(document);
                                }
                            }
                        }
                    }
                }
            }

            var emittingFilePath = documents.length ? TypeScript.getRootFilePath(this.emittingFileName) : null;
            for (var i = 0; i < documents.length; i++) {
                var document = documents[i];
                var declFileName;
                if (document.script.isDeclareFile) {
                    declFileName = document.fileName;
                } else {
                    declFileName = this.compiler.emitOptions.mapOutputFileName(document, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                }

                declFileName = TypeScript.getRelativePathToFixedPath(emittingFilePath, declFileName, false);
                this.declFile.WriteLine('/// <reference path="' + declFileName + '" />');
            }

            this.emittedReferencePaths = true;
        };

        DeclarationEmitter.prototype.emitDeclarationsForScript = function (script) {
            this.emitReferencePaths(script);
            this.pushDeclarationContainer(script);

            this.emitDeclarationsForList(script.moduleElements);

            this.popDeclarationContainer(script);
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BloomFilter = (function () {
        function BloomFilter(expectedCount) {
            var m = Math.max(1, BloomFilter.computeM(expectedCount));
            var k = Math.max(1, BloomFilter.computeK(expectedCount));
            ;

            var sizeInEvenBytes = (m + 7) & ~7;

            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }
        BloomFilter.computeM = function (expectedCount) {
            var p = BloomFilter.falsePositiveProbability;
            var n = expectedCount;

            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        };

        BloomFilter.computeK = function (expectedCount) {
            var n = expectedCount;
            var m = BloomFilter.computeM(expectedCount);

            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        };

        BloomFilter.prototype.computeHash = function (key, seed) {
            return TypeScript.Hash.computeMurmur2StringHashCode(key, seed);
        };

        BloomFilter.prototype.addKeys = function (keys) {
            for (var name in keys) {
                if (keys[name]) {
                    this.add(name);
                }
            }
        };

        BloomFilter.prototype.add = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        };

        BloomFilter.prototype.probablyContains = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }

            return true;
        };

        BloomFilter.prototype.isEquivalent = function (filter) {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray) && this.hashFunctionCount == filter.hashFunctionCount;
        };

        BloomFilter.isEquivalent = function (array1, array2) {
            if (array1.length != array2.length) {
                return false;
            }

            for (var i = 0; i < array1.length; i++) {
                if (array1[i] != array2[i]) {
                    return false;
                }
            }

            return true;
        };
        BloomFilter.falsePositiveProbability = 0.0001;
        return BloomFilter;
    })();
    TypeScript.BloomFilter = BloomFilter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker(list) {
            _super.call(this);
            this.list = list;
        }
        IdentifierWalker.prototype.visitToken = function (token) {
            this.list[token.text()] = true;
        };
        return IdentifierWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.IdentifierWalker = IdentifierWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DataMap = (function () {
        function DataMap() {
            this.map = {};
        }
        DataMap.prototype.link = function (id, data) {
            this.map[id] = data;
        };

        DataMap.prototype.read = function (id) {
            var result = this.map[id];
            return result ? result : null;
        };
        return DataMap;
    })();
    TypeScript.DataMap = DataMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags[PullElementFlags["None"] = 0] = "None";
        PullElementFlags[PullElementFlags["Exported"] = 1] = "Exported";
        PullElementFlags[PullElementFlags["Private"] = 1 << 1] = "Private";
        PullElementFlags[PullElementFlags["Public"] = 1 << 2] = "Public";
        PullElementFlags[PullElementFlags["Ambient"] = 1 << 3] = "Ambient";
        PullElementFlags[PullElementFlags["Static"] = 1 << 4] = "Static";
        PullElementFlags[PullElementFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        PullElementFlags[PullElementFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        PullElementFlags[PullElementFlags["Optional"] = 1 << 7] = "Optional";
        PullElementFlags[PullElementFlags["Call"] = 1 << 8] = "Call";
        PullElementFlags[PullElementFlags["Constructor"] = 1 << 9] = "Constructor";
        PullElementFlags[PullElementFlags["Index"] = 1 << 10] = "Index";
        PullElementFlags[PullElementFlags["Signature"] = 1 << 11] = "Signature";
        PullElementFlags[PullElementFlags["Enum"] = 1 << 12] = "Enum";
        PullElementFlags[PullElementFlags["FatArrow"] = 1 << 13] = "FatArrow";

        PullElementFlags[PullElementFlags["ClassConstructorVariable"] = 1 << 14] = "ClassConstructorVariable";
        PullElementFlags[PullElementFlags["InitializedModule"] = 1 << 15] = "InitializedModule";
        PullElementFlags[PullElementFlags["InitializedDynamicModule"] = 1 << 16] = "InitializedDynamicModule";
        PullElementFlags[PullElementFlags["InitializedEnum"] = 1 << 17] = "InitializedEnum";

        PullElementFlags[PullElementFlags["MustCaptureThis"] = 1 << 18] = "MustCaptureThis";
        PullElementFlags[PullElementFlags["Constant"] = 1 << 19] = "Constant";

        PullElementFlags[PullElementFlags["ExpressionElement"] = 1 << 20] = "ExpressionElement";

        PullElementFlags[PullElementFlags["DeclaredInAWithBlock"] = 1 << 21] = "DeclaredInAWithBlock";

        PullElementFlags[PullElementFlags["HasReturnStatement"] = 1 << 22] = "HasReturnStatement";

        PullElementFlags[PullElementFlags["PropertyParameter"] = 1 << 23] = "PropertyParameter";

        PullElementFlags[PullElementFlags["IsAnnotatedWithAny"] = 1 << 24] = "IsAnnotatedWithAny";

        PullElementFlags[PullElementFlags["HasDefaultArgs"] = 1 << 25] = "HasDefaultArgs";

        PullElementFlags[PullElementFlags["ConstructorParameter"] = 1 << 26] = "ConstructorParameter";

        PullElementFlags[PullElementFlags["ImplicitVariable"] = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "ImplicitVariable";
        PullElementFlags[PullElementFlags["SomeInitializedModule"] = PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "SomeInitializedModule";
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;

    (function (PullElementKind) {
        PullElementKind[PullElementKind["None"] = 0] = "None";
        PullElementKind[PullElementKind["Global"] = 0] = "Global";

        PullElementKind[PullElementKind["Script"] = 1] = "Script";
        PullElementKind[PullElementKind["Primitive"] = 1 << 1] = "Primitive";

        PullElementKind[PullElementKind["Container"] = 1 << 2] = "Container";
        PullElementKind[PullElementKind["Class"] = 1 << 3] = "Class";
        PullElementKind[PullElementKind["Interface"] = 1 << 4] = "Interface";
        PullElementKind[PullElementKind["DynamicModule"] = 1 << 5] = "DynamicModule";
        PullElementKind[PullElementKind["Enum"] = 1 << 6] = "Enum";
        PullElementKind[PullElementKind["Array"] = 1 << 7] = "Array";
        PullElementKind[PullElementKind["TypeAlias"] = 1 << 8] = "TypeAlias";
        PullElementKind[PullElementKind["ObjectLiteral"] = 1 << 9] = "ObjectLiteral";

        PullElementKind[PullElementKind["Variable"] = 1 << 10] = "Variable";
        PullElementKind[PullElementKind["Parameter"] = 1 << 11] = "Parameter";
        PullElementKind[PullElementKind["Property"] = 1 << 12] = "Property";
        PullElementKind[PullElementKind["TypeParameter"] = 1 << 13] = "TypeParameter";

        PullElementKind[PullElementKind["Function"] = 1 << 14] = "Function";
        PullElementKind[PullElementKind["ConstructorMethod"] = 1 << 15] = "ConstructorMethod";
        PullElementKind[PullElementKind["Method"] = 1 << 16] = "Method";
        PullElementKind[PullElementKind["FunctionExpression"] = 1 << 17] = "FunctionExpression";

        PullElementKind[PullElementKind["GetAccessor"] = 1 << 18] = "GetAccessor";
        PullElementKind[PullElementKind["SetAccessor"] = 1 << 19] = "SetAccessor";

        PullElementKind[PullElementKind["CallSignature"] = 1 << 20] = "CallSignature";
        PullElementKind[PullElementKind["ConstructSignature"] = 1 << 21] = "ConstructSignature";
        PullElementKind[PullElementKind["IndexSignature"] = 1 << 22] = "IndexSignature";

        PullElementKind[PullElementKind["ObjectType"] = 1 << 23] = "ObjectType";
        PullElementKind[PullElementKind["FunctionType"] = 1 << 24] = "FunctionType";
        PullElementKind[PullElementKind["ConstructorType"] = 1 << 25] = "ConstructorType";

        PullElementKind[PullElementKind["EnumMember"] = 1 << 26] = "EnumMember";
        PullElementKind[PullElementKind["ErrorType"] = 1 << 27] = "ErrorType";

        PullElementKind[PullElementKind["Expression"] = 1 << 28] = "Expression";

        PullElementKind[PullElementKind["WithBlock"] = 1 << 29] = "WithBlock";
        PullElementKind[PullElementKind["CatchBlock"] = 1 << 30] = "CatchBlock";

        PullElementKind[PullElementKind["All"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectLiteral | PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.TypeParameter | PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.EnumMember | PullElementKind.ErrorType | PullElementKind.Expression | PullElementKind.WithBlock | PullElementKind.CatchBlock] = "All";

        PullElementKind[PullElementKind["SomeFunction"] = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor] = "SomeFunction";

        PullElementKind[PullElementKind["SomeValue"] = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.EnumMember | PullElementKind.SomeFunction] = "SomeValue";

        PullElementKind[PullElementKind["SomeType"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Array | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter | PullElementKind.ErrorType] = "SomeType";

        PullElementKind[PullElementKind["AcceptableAlias"] = PullElementKind.Variable | PullElementKind.SomeFunction | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Container | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "AcceptableAlias";

        PullElementKind[PullElementKind["SomeContainer"] = PullElementKind.Container | PullElementKind.DynamicModule | PullElementKind.TypeAlias] = "SomeContainer";

        PullElementKind[PullElementKind["SomeBlock"] = PullElementKind.WithBlock | PullElementKind.CatchBlock] = "SomeBlock";

        PullElementKind[PullElementKind["SomeSignature"] = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeSignature";

        PullElementKind[PullElementKind["SomeAccessor"] = PullElementKind.GetAccessor | PullElementKind.SetAccessor] = "SomeAccessor";

        PullElementKind[PullElementKind["SomeTypeReference"] = PullElementKind.Interface | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "SomeTypeReference";

        PullElementKind[PullElementKind["SomeLHS"] = PullElementKind.Variable | PullElementKind.Property | PullElementKind.Parameter | PullElementKind.SetAccessor | PullElementKind.Method] = "SomeLHS";

        PullElementKind[PullElementKind["InterfaceTypeExtension"] = PullElementKind.Interface | PullElementKind.Class | PullElementKind.Enum] = "InterfaceTypeExtension";
        PullElementKind[PullElementKind["ClassTypeExtension"] = PullElementKind.Interface | PullElementKind.Class] = "ClassTypeExtension";
        PullElementKind[PullElementKind["EnumTypeExtension"] = PullElementKind.Interface | PullElementKind.Enum] = "EnumTypeExtension";
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    TypeScript.lastBoundPullDeclId = 0;
    var sentinelEmptyPullDeclArray = [];

    var PullDecl = (function () {
        function PullDecl(declName, displayName, kind, declFlags, span, scriptName) {
            this.symbol = null;
            this.declGroups = new TypeScript.BlockIntrinsics();
            this.signatureSymbol = null;
            this.specializingSignatureSymbol = null;
            this.childDecls = null;
            this.typeParameters = null;
            this.childDeclTypeCache = new TypeScript.BlockIntrinsics();
            this.childDeclValueCache = new TypeScript.BlockIntrinsics();
            this.childDeclNamespaceCache = new TypeScript.BlockIntrinsics();
            this.childDeclTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.declID = TypeScript.pullDeclID++;
            this.declIDString = null;
            this.flags = 0 /* None */;
            this.parentDecl = null;
            this._parentPath = null;
            this._isBound = false;
            this.synthesizedValDecl = null;
            this.hashCode = -1;
            this.ast = null;
            this.name = declName;
            this.kind = kind;
            this.flags = declFlags;
            this.span = span;
            this.scriptName = scriptName;

            if (displayName !== this.name) {
                this.declDisplayName = displayName;
            }

            this.hashCode = this.declID ^ this.kind;
            this.declIDString = this.declID.toString();
        }
        PullDecl.prototype.getDisplayName = function () {
            return this.declDisplayName === undefined ? this.name : this.declDisplayName;
        };

        PullDecl.prototype.setSymbol = function (symbol) {
            this.symbol = symbol;
        };

        PullDecl.prototype.ensureSymbolIsBound = function (bindSignatureSymbol) {
            if (typeof bindSignatureSymbol === "undefined") { bindSignatureSymbol = false; }
            if (!((bindSignatureSymbol && this.signatureSymbol) || this.symbol) && !this._isBound && this.kind != 1 /* Script */) {
                var prevUnit = TypeScript.globalBinder.semanticInfo;
                TypeScript.globalBinder.setUnit(this.scriptName);
                TypeScript.globalBinder.bindDeclToPullSymbol(this);
                if (prevUnit) {
                    TypeScript.globalBinder.setUnit(prevUnit.getPath());
                }
            }
        };

        PullDecl.prototype.getSymbol = function () {
            if (this.kind == 1 /* Script */) {
                return null;
            }

            this.ensureSymbolIsBound();

            return this.symbol;
        };

        PullDecl.prototype.hasSymbol = function () {
            return this.symbol != null;
        };

        PullDecl.prototype.setSignatureSymbol = function (signature) {
            this.signatureSymbol = signature;
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            this.ensureSymbolIsBound(true);

            return this.signatureSymbol;
        };

        PullDecl.prototype.hasSignature = function () {
            return this.signatureSymbol != null;
        };

        PullDecl.prototype.setSpecializingSignatureSymbol = function (signature) {
            this.specializingSignatureSymbol = signature;
        };
        PullDecl.prototype.getSpecializingSignatureSymbol = function () {
            if (this.specializingSignatureSymbol) {
                return this.specializingSignatureSymbol;
            }

            return this.signatureSymbol;
        };

        PullDecl.prototype.setFlags = function (flags) {
            this.flags = flags;
        };
        PullDecl.prototype.setFlag = function (flags) {
            this.flags |= flags;
        };

        PullDecl.prototype.getSpan = function () {
            return this.span;
        };
        PullDecl.prototype.setSpan = function (span) {
            this.span = span;
        };

        PullDecl.prototype.getScriptName = function () {
            return this.scriptName;
        };

        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
        };
        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };

        PullDecl.prototype.isEqual = function (other) {
            return (this.name === other.name) && (this.kind === other.kind) && (this.flags === other.flags) && (this.scriptName === other.scriptName) && (this.span.start() === other.span.start()) && (this.span.end() === other.span.end());
        };

        PullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };

        PullDecl.prototype.setParentDecl = function (parentDecl) {
            this.parentDecl = parentDecl;
        };

        PullDecl.prototype.getChildDeclCache = function (declKind) {
            return declKind === 8192 /* TypeParameter */ ? this.childDeclTypeParameterCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeContainer) ? this.childDeclNamespaceCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
        };

        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.kind === 8192 /* TypeParameter */) {
                if (!this.typeParameters) {
                    this.typeParameters = [];
                }
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                if (!this.childDecls) {
                    this.childDecls = [];
                }
                this.childDecls[this.childDecls.length] = childDecl;
            }

            var declName = childDecl.name;

            if (!(childDecl.kind & TypeScript.PullElementKind.SomeSignature)) {
                var cache = this.getChildDeclCache(childDecl.kind);
                var childrenOfName = cache[declName];
                if (!childrenOfName) {
                    childrenOfName = [];
                }

                childrenOfName.push(childDecl);
                cache[declName] = childrenOfName;
            }
        };

        PullDecl.prototype.searchChildDecls = function (declName, searchKind) {
            var cacheVal = null;

            if (searchKind & TypeScript.PullElementKind.SomeType) {
                cacheVal = this.childDeclTypeCache[declName];
            } else if (searchKind & TypeScript.PullElementKind.SomeContainer) {
                cacheVal = this.childDeclNamespaceCache[declName];
            } else {
                cacheVal = this.childDeclValueCache[declName];
            }

            if (cacheVal) {
                return cacheVal;
            } else {
                if (searchKind & TypeScript.PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return sentinelEmptyPullDeclArray;
            }
        };

        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls ? this.childDecls : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters ? this.typeParameters : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            var declGroup = this.declGroups[decl.name];
            if (declGroup) {
                declGroup.addDecl(decl);
            } else {
                declGroup = new PullDeclGroup(decl.name);
                declGroup.addDecl(decl);
                this.declGroups[decl.name] = declGroup;
            }
        };

        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = null;

            for (var declName in this.declGroups) {
                if (this.declGroups[declName]) {
                    if (declGroups === null) {
                        declGroups = [];
                    }

                    declGroups.push(this.declGroups[declName].getDecls());
                }
            }

            return declGroups ? declGroups : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.getParentPath = function () {
            return this._parentPath;
        };

        PullDecl.prototype.setParentPath = function (path) {
            this._parentPath = path;
        };

        PullDecl.prototype.setIsBound = function (isBinding) {
            this._isBound = isBinding;
        };

        PullDecl.prototype.isBound = function () {
            return this._isBound;
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;

    var PullFunctionExpressionDecl = (function (_super) {
        __extends(PullFunctionExpressionDecl, _super);
        function PullFunctionExpressionDecl(expressionName, declFlags, span, scriptName) {
            _super.call(this, "", "", 131072 /* FunctionExpression */, declFlags, span, scriptName);
            this.functionExpressionName = expressionName;
        }
        PullFunctionExpressionDecl.prototype.getFunctionExpressionName = function () {
            return this.functionExpressionName;
        };
        return PullFunctionExpressionDecl;
    })(PullDecl);
    TypeScript.PullFunctionExpressionDecl = PullFunctionExpressionDecl;

    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.name === this.name) {
                this._decls[this._decls.length] = decl;
            }
        };

        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    })();
    TypeScript.PullDeclGroup = PullDeclGroup;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.globalTyvarID = 0;
    TypeScript.sentinelEmptyArray = [];

    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this.pullSymbolIDString = null;
            this._container = null;
            this.type = null;
            this._declarations = null;
            this.isResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isVarArg = false;
            this.isSpecialized = false;
            this.isBeingSpecialized = false;
            this.rootSymbol = null;
            this._parentAccessorSymbol = null;
            this._enclosingSignature = null;
            this.docComments = null;
            this.isPrinting = false;
            this.ast = null;
            this.name = name;
            this.kind = declKind;
            this.pullSymbolIDString = this.pullSymbolID.toString();
        }
        PullSymbol.prototype.isType = function () {
            return (this.kind & TypeScript.PullElementKind.SomeType) != 0;
        };

        PullSymbol.prototype.isSignature = function () {
            return (this.kind & TypeScript.PullElementKind.SomeSignature) != 0;
        };

        PullSymbol.prototype.isArray = function () {
            return (this.kind & 128 /* Array */) != 0;
        };

        PullSymbol.prototype.isPrimitive = function () {
            return this.kind === 2 /* Primitive */;
        };

        PullSymbol.prototype.isAccessor = function () {
            return false;
        };

        PullSymbol.prototype.isError = function () {
            return false;
        };

        PullSymbol.prototype.isInterface = function () {
            return this.kind === 16 /* Interface */;
        };

        PullSymbol.prototype.isMethod = function () {
            return this.kind === 65536 /* Method */;
        };

        PullSymbol.prototype.isProperty = function () {
            return this.kind === 4096 /* Property */;
        };

        PullSymbol.prototype.isAlias = function () {
            return false;
        };

        PullSymbol.prototype.isContainer = function () {
            return false;
        };

        PullSymbol.prototype.setAccessorSymbol = function (accessor) {
            this._parentAccessorSymbol = accessor;
        };

        PullSymbol.prototype.getAccessorySymbol = function () {
            return this._parentAccessorSymbol;
        };

        PullSymbol.prototype.findAliasedType = function (decls) {
            for (var i = 0; i < decls.length; i++) {
                var childDecls = decls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; j++) {
                    if (childDecls[j].kind === 256 /* TypeAlias */) {
                        var symbol = childDecls[j].getSymbol();
                        if (PullContainerSymbol.usedAsSymbol(symbol, this)) {
                            return symbol;
                        }
                        if (this.rootSymbol && PullContainerSymbol.usedAsSymbol(symbol, this.rootSymbol)) {
                            return symbol;
                        }
                    }
                }
            }

            return null;
        };

        PullSymbol.prototype.getAliasedSymbol = function (scopeSymbol) {
            if (!scopeSymbol) {
                return null;
            }

            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].kind === 32 /* DynamicModule */) {
                var decls = scopePath[scopePath.length - 1].getDeclarations();
                var symbol = this.findAliasedType(decls);
                return symbol;
            }

            return null;
        };

        PullSymbol.prototype.getScopedDynamicModuleAlias = function (scopeSymbol) {
            var aliasSymbol = this.getAliasedSymbol(scopeSymbol);

            if (aliasSymbol) {
                if (aliasSymbol.assignedValue) {
                    return null;
                }

                if (aliasSymbol.assignedType && aliasSymbol.assignedType != aliasSymbol.assignedContainer) {
                    return null;
                }

                if (aliasSymbol.assignedContainer.kind != 32 /* DynamicModule */) {
                    return null;
                }
            }
            return aliasSymbol;
        };

        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (symbol) {
                return symbol.getName();
            }

            return this.name;
        };

        PullSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (symbol) {
                return symbol.getDisplayName();
            }

            var decls = this.getDeclarations();
            return decls.length ? this.getDeclarations()[0].getDisplayName() : this.name;
        };

        PullSymbol.prototype.setIsSpecialized = function () {
            this.isSpecialized = true;
            this.isBeingSpecialized = false;
        };
        PullSymbol.prototype.getIsSpecialized = function () {
            return this.isSpecialized;
        };
        PullSymbol.prototype.currentlyBeingSpecialized = function () {
            return this.isBeingSpecialized;
        };
        PullSymbol.prototype.setIsBeingSpecialized = function () {
            this.isBeingSpecialized = true;
        };
        PullSymbol.prototype.setValueIsBeingSpecialized = function (val) {
            this.isBeingSpecialized = val;
        };

        PullSymbol.prototype.getRootSymbol = function () {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        };
        PullSymbol.prototype.setRootSymbol = function (symbol) {
            this.rootSymbol = symbol;
        };

        PullSymbol.prototype.setIsSynthesized = function (value) {
            if (typeof value === "undefined") { value = true; }
            this.isSynthesized = value;
        };
        PullSymbol.prototype.getIsSynthesized = function () {
            return this.isSynthesized;
        };

        PullSymbol.prototype.setEnclosingSignature = function (signature) {
            this._enclosingSignature = signature;
        };

        PullSymbol.prototype.getEnclosingSignature = function () {
            return this._enclosingSignature;
        };

        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);

            if (this.rootSymbol) {
                return;
            }

            if (!this._declarations) {
                this._declarations = [decl];
            } else {
                this._declarations[this._declarations.length] = decl;
            }
        };

        PullSymbol.prototype.getDeclarations = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }

            if (!this._declarations) {
                this._declarations = [];
            }

            return this._declarations;
        };

        PullSymbol.prototype.setContainer = function (containerSymbol) {
            if (this.rootSymbol) {
                return;
            }

            this._container = containerSymbol;
        };

        PullSymbol.prototype.getContainer = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getContainer();
            }

            return this._container;
        };

        PullSymbol.prototype.setResolved = function () {
            this.isResolved = true;
            this.inResolution = false;
        };

        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };

        PullSymbol.prototype.setUnresolved = function () {
            this.isResolved = false;
            this.inResolution = false;
        };

        PullSymbol.prototype.invalidate = function () {
            this.setUnresolved();
        };

        PullSymbol.prototype.hasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if ((declarations[i].flags & flag) !== 0 /* None */) {
                    return true;
                }
            }
            return false;
        };

        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!((declarations[i].flags & flag) !== 0 /* None */)) {
                    return false;
                }
            }
            return true;
        };

        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = node.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                var nodeKind = node.kind;
                if (nodeKind == 2048 /* Parameter */) {
                    break;
                } else {
                    node = node.getContainer();
                }
            }
            return path;
        };

        PullSymbol.prototype.findCommonAncestorPath = function (b) {
            var aPath = this.pathToRoot();
            if (aPath.length === 1) {
                return aPath;
            }

            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                return aPath;
            }

            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        var aDecl = null;
                        if (i > 0) {
                            var decls = aPath[i - 1].getDeclarations();
                            if (decls.length) {
                                aDecl = decls[0].getParentDecl();
                            }
                        }
                        var bDecl = null;
                        if (j > 0) {
                            var decls = bPath[j - 1].getDeclarations();
                            if (decls.length) {
                                bDecl = decls[0].getParentDecl();
                            }
                        }
                        if (!aDecl || !bDecl || aDecl == bDecl) {
                            commonNodeIndex = i;
                            break;
                        }
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }

            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };

        PullSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var str = this.getNameAndTypeName(scopeSymbol);
            return str;
        };

        PullSymbol.prototype.getNamePartForFullName = function () {
            return this.getDisplayName(null, true);
        };

        PullSymbol.prototype.fullName = function (scopeSymbol) {
            var path = this.pathToRoot();
            var fullName = "";
            var aliasedSymbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.fullName(scopeSymbol);
            }

            for (var i = 1; i < path.length; i++) {
                aliasedSymbol = path[i].getScopedDynamicModuleAlias(scopeSymbol);
                if (aliasedSymbol) {
                    fullName = aliasedSymbol.fullName(scopeSymbol) + "." + fullName;
                    break;
                } else {
                    var scopedName = path[i].getNamePartForFullName();
                    if (path[i].kind == 32 /* DynamicModule */ && !TypeScript.isQuoted(scopedName)) {
                        break;
                    }

                    if (scopedName === "") {
                        break;
                    }

                    fullName = scopedName + "." + fullName;
                }
            }

            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        };

        PullSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            var aliasedSymbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.getScopedName(scopeSymbol);
            }

            for (var i = 1; i < path.length; i++) {
                var kind = path[i].kind;
                if (kind === 4 /* Container */ || kind === 32 /* DynamicModule */) {
                    aliasedSymbol = path[i].getScopedDynamicModuleAlias(scopeSymbol);
                    if (aliasedSymbol) {
                        fullName = aliasedSymbol.getScopedName(scopeSymbol) + "." + fullName;
                        break;
                    } else if (kind === 4 /* Container */) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    } else {
                        var displayName = path[i].getDisplayName();
                        if (TypeScript.isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                } else {
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName);
            return fullName;
        };

        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            var name = this.getScopedName(scopeSymbol, useConstraintInName);
            return TypeScript.MemberName.create(name);
        };

        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };

        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, true, getPrettyTypeName);
                }

                return memberName;
            }
            return TypeScript.MemberName.create("");
        };

        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type && !type.isNamedTypeSymbol() && this.kind != 4096 /* Property */ && this.kind != 1024 /* Variable */ && this.kind != 2048 /* Parameter */) {
                var signatures = type.getCallSignatures();
                if (signatures.length == 1 || (getPrettyTypeName && signatures.length)) {
                    var typeName = new TypeScript.MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                    typeName.addAll(signatureName);
                    return typeName;
                }
            }

            return null;
        };

        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };

        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.type;
            var nameStr = this.getDisplayName(scopeSymbol);
            if (type) {
                nameStr = nameStr + (this.isOptional ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return TypeScript.MemberName.create(nameStr);
        };

        PullSymbol.getTypeParameterString = function (typars, scopeSymbol, useContraintInName) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, undefined, useContraintInName).toString();
        };

        PullSymbol.getTypeParameterStringEx = function (typeParameters, scopeSymbol, getTypeParamMarkerInfo, useContraintInName) {
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = "";

            if (typeParameters && typeParameters.length) {
                builder.add(TypeScript.MemberName.create("<"));

                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(TypeScript.MemberName.create(", "));
                    }

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }

                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, useContraintInName));

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                }

                builder.add(TypeScript.MemberName.create(">"));
            }

            return builder;
        };

        PullSymbol.getIsExternallyVisible = function (symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            } else {
                inIsExternallyVisibleSymbols = [];
            }

            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }
            inIsExternallyVisibleSymbols = inIsExternallyVisibleSymbols.concat(fromIsExternallyVisibleSymbol);

            return symbol.isExternallyVisible(inIsExternallyVisibleSymbols);
        };

        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.kind;
            if (kind === 2 /* Primitive */) {
                return true;
            }

            if (this.rootSymbol) {
                return PullSymbol.getIsExternallyVisible(this.rootSymbol, this, inIsExternallyVisibleSymbols);
            }

            if (this.isType()) {
                var associatedContainerSymbol = this.getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }

            if (this.hasFlag(2 /* Private */)) {
                return false;
            }

            var container = this.getContainer();
            if (container === null) {
                var decls = this.getDeclarations();
                if (decls.length) {
                    var parentDecl = decls[0].getParentDecl();
                    if (parentDecl) {
                        var parentSymbol = parentDecl.getSymbol();
                        if (!parentSymbol || parentDecl.kind == 1 /* Script */) {
                            return true;
                        }

                        return PullSymbol.getIsExternallyVisible(parentSymbol, this, inIsExternallyVisibleSymbols);
                    }
                }

                return true;
            }

            if (container.kind == 32 /* DynamicModule */ || (container.getAssociatedContainerType() && container.getAssociatedContainerType().kind == 32 /* DynamicModule */)) {
                var containerSymbol = container.kind == 32 /* DynamicModule */ ? container : container.getAssociatedContainerType();
                if (PullContainerSymbol.usedAsSymbol(containerSymbol, this)) {
                    return true;
                }
            }

            if (!this.hasFlag(1 /* Exported */) && kind != 4096 /* Property */ && kind != 65536 /* Method */) {
                return false;
            }

            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;

    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
            _super.call(this, "", kind);
            this.parameters = TypeScript.sentinelEmptyArray;
            this.typeParameters = null;
            this.returnType = null;
            this.functionType = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.hasVarArgs = false;
            this.cachedObjectSpecialization = null;
            this.specializationCache = {};
            this.memberTypeParameterNameCache = null;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;
            this.hasBeenChecked = false;
            this.inWrapCheck = false;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return false;
        };

        PullSignatureSymbol.prototype.isGeneric = function () {
            return this.hasAGenericParameter || (this.typeParameters && this.typeParameters.length != 0);
        };

        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (this.parameters == TypeScript.sentinelEmptyArray) {
                this.parameters = [];
            }

            this.parameters[this.parameters.length] = parameter;
            this.hasOptionalParam = isOptional;

            if (!parameter.getEnclosingSignature()) {
                parameter.setEnclosingSignature(this);
            }

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };

        PullSignatureSymbol.prototype.addSpecialization = function (signature, typeArguments) {
            if (typeArguments && typeArguments.length) {
                this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
            }
        };

        PullSignatureSymbol.prototype.getSpecialization = function (typeArguments) {
            if (typeArguments) {
                var sig = this.specializationCache[getIDForTypeSubstitutions(typeArguments)];

                if (sig) {
                    return sig;
                }
            }

            return null;
        };

        PullSignatureSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
            }

            this.typeParameters[this.typeParameters.length] = typeParameter;

            this.memberTypeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullSignatureSymbol.prototype.getTypeParameters = function () {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }

            return this.typeParameters;
        };

        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();

                if (this.typeParameters) {
                    for (var i = 0; i < this.typeParameters.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameters[i].getName()] = this.typeParameters[i];
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        };

        PullSignatureSymbol.prototype.mimicSignature = function (signature, resolver) {
            var typeParameters = signature.getTypeParameters();
            var typeParameter;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    this.addTypeParameter(typeParameters[i]);
                }
            }

            var parameters = signature.parameters;
            var parameter;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].name, 2048 /* Parameter */);
                    parameter.setRootSymbol(parameters[j]);

                    if (parameters[j].isOptional) {
                        parameter.isOptional = true;
                    }
                    if (parameters[j].isVarArg) {
                        parameter.isVarArg = true;
                        this.hasVarArgs = true;
                    }
                    this.addParameter(parameter);
                }
            }

            var returnType = signature.returnType;

            if (!resolver.isTypeArgumentOrWrapper(returnType)) {
                this.returnType = returnType;
            }
        };

        PullSignatureSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this.parameters) {
                var paramType;
                for (var i = 0; i < this.parameters.length; i++) {
                    paramType = this.parameters[i].type;

                    if (paramType && !paramType.isFixed()) {
                        return false;
                    }
                }
            }

            if (this.returnType) {
                if (!this.returnType.isFixed()) {
                    return false;
                }
            }

            return true;
        };

        PullSignatureSymbol.prototype.invalidate = function () {
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;

            _super.prototype.invalidate.call(this);
        };

        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this.stringConstantOverload === undefined) {
                var params = this.parameters;
                this.stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].type;
                    if (paramType && paramType.isPrimitive() && paramType.isStringConstant()) {
                        this.stringConstantOverload = true;
                    }
                }
            }

            return this.stringConstantOverload;
        };

        PullSignatureSymbol.getSignatureTypeMemberName = function (candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };

        PullSignatureSymbol.getSignaturesTypeNameEx = function (signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            if (!signatures) {
                return result;
            }

            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }

            for (var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = TypeScript.getLocalizedText(TypeScript.DiagnosticCode._0_overload_s, [foundDefinition ? len - 2 : len - 1]);
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }

            return result;
        };

        PullSignatureSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false, scopeSymbol, undefined, useConstraintInName).toString();
            return s;
        };

        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol, getParamMarkerInfo, getTypeParamMarkerInfo) {
            var typeParamterBuilder = new TypeScript.MemberNameArray();

            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, true));

            if (brackets) {
                typeParamterBuilder.add(TypeScript.MemberName.create("["));
            } else {
                typeParamterBuilder.add(TypeScript.MemberName.create("("));
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = prefix;

            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            } else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }

            var params = this.parameters;
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].type;
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].isVarArg;
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].isOptional) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }

            if (this.returnType) {
                builder.add(this.returnType.getScopedNameEx(scopeSymbol));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }

            return builder;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;

    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol(name, kind) {
            _super.call(this, name, kind);
            this._members = TypeScript.sentinelEmptyArray;
            this._enclosedMemberTypes = null;
            this._enclosedMemberContainers = null;
            this._typeParameters = null;
            this._typeArguments = null;
            this._containedNonMembers = null;
            this._containedNonMemberTypes = null;
            this._containedNonMemberContainers = null;
            this._specializedVersionsOfThisType = null;
            this._arrayVersionOfThisType = null;
            this._implementedTypes = null;
            this._extendedTypes = null;
            this._typesThatExplicitlyImplementThisType = null;
            this._typesThatExtendThisType = null;
            this._callSignatures = null;
            this._allCallSignatures = null;
            this._constructSignatures = null;
            this._allConstructSignatures = null;
            this._indexSignatures = null;
            this._allIndexSignatures = null;
            this._elementType = null;
            this._memberNameCache = null;
            this._enclosedTypeNameCache = null;
            this._enclosedContainerCache = null;
            this._typeParameterNameCache = null;
            this._containedNonMemberNameCache = null;
            this._containedNonMemberTypeNameCache = null;
            this._containedNonMemberContainerCache = null;
            this._specializedTypeIDCache = null;
            this._hasGenericSignature = false;
            this._hasGenericMember = false;
            this._hasBaseTypeConflict = false;
            this._knownBaseTypeCount = 0;
            this._invalidatedSpecializations = false;
            this._associatedContainerTypeSymbol = null;
            this._constructorMethod = null;
            this._hasDefaultConstructor = false;
            this._functionSymbol = null;
            this.memberWrapsOwnTypeParameter = false;
            this.inMemberTypeNameEx = false;
            this.inSymbolPrivacyCheck = false;
            this.inWrapCheck = false;
            this.type = this;
        }
        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return this.kind == 8 /* Class */ || (this._constructorMethod != null);
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return (this.kind & (33554432 /* ConstructorType */ | 16777216 /* FunctionType */)) != 0;
        };
        PullTypeSymbol.prototype.isConstructor = function () {
            return this.kind == 33554432 /* ConstructorType */;
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeVariable = function () {
            return false;
        };
        PullTypeSymbol.prototype.isError = function () {
            return false;
        };
        PullTypeSymbol.prototype.isEnum = function () {
            return this.kind == 64 /* Enum */;
        };

        PullTypeSymbol.prototype.isObject = function () {
            return TypeScript.hasFlag(this.kind, 128 /* Array */ | 8 /* Class */ | 33554432 /* ConstructorType */ | 64 /* Enum */ | 16777216 /* FunctionType */ | 16 /* Interface */ | 8388608 /* ObjectType */);
        };

        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () {
            return this._knownBaseTypeCount;
        };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () {
            this._knownBaseTypeCount = 0;
        };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () {
            this._knownBaseTypeCount++;
        };

        PullTypeSymbol.prototype.setHasBaseTypeConflict = function () {
            this._hasBaseTypeConflict = true;
        };
        PullTypeSymbol.prototype.hasBaseTypeConflict = function () {
            return this._hasBaseTypeConflict;
        };

        PullTypeSymbol.prototype.setUnresolved = function () {
            _super.prototype.setUnresolved.call(this);

            this._invalidatedSpecializations = false;

            var specializations = this.getKnownSpecializations();

            for (var i = 0; i < specializations.length; i++) {
                specializations[i].setUnresolved();
            }
        };

        PullTypeSymbol.prototype.hasMembers = function () {
            if (this._members != TypeScript.sentinelEmptyArray) {
                return true;
            }

            var parents = this.getExtendedTypes();

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this._hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getHasGenericSignature = function () {
            return this._hasGenericSignature;
        };

        PullTypeSymbol.prototype.setHasGenericMember = function () {
            this._hasGenericMember = true;
        };
        PullTypeSymbol.prototype.getHasGenericMember = function () {
            return this._hasGenericMember;
        };

        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this._associatedContainerTypeSymbol = type;
        };

        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this._associatedContainerTypeSymbol;
        };

        PullTypeSymbol.prototype.getArrayType = function () {
            return this._arrayVersionOfThisType;
        };

        PullTypeSymbol.prototype.getElementType = function () {
            return this._elementType;
        };

        PullTypeSymbol.prototype.setElementType = function (type) {
            this._elementType = type;
        };

        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this._arrayVersionOfThisType = arrayType;
        };

        PullTypeSymbol.prototype.getFunctionSymbol = function () {
            return this._functionSymbol;
        };

        PullTypeSymbol.prototype.setFunctionSymbol = function (symbol) {
            if (symbol) {
                this._functionSymbol = symbol;
            }
        };

        PullTypeSymbol.prototype.addContainedNonMember = function (nonMember) {
            if (!nonMember) {
                return;
            }

            if (!this._containedNonMembers) {
                this._containedNonMembers = [];
            }

            this._containedNonMembers[this._containedNonMembers.length] = nonMember;

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = new TypeScript.BlockIntrinsics();
            }

            this._containedNonMemberNameCache[nonMember.name] = nonMember;
        };

        PullTypeSymbol.prototype.findContainedNonMember = function (name) {
            if (!this._containedNonMemberNameCache) {
                return null;
            }

            return this._containedNonMemberNameCache[name];
        };

        PullTypeSymbol.prototype.findContainedNonMemberType = function (typeName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            if (!this._containedNonMemberTypeNameCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberTypeNameCache[typeName];

            if (nonMemberSymbol && kind != 0 /* None */) {
                nonMemberSymbol = ((nonMemberSymbol.kind & kind) != 0) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        };

        PullTypeSymbol.prototype.findContainedNonMemberContainer = function (containerName, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            if (!this._containedNonMemberContainerCache) {
                return null;
            }

            var nonMemberSymbol = this._containedNonMemberContainerCache[containerName];

            if (nonMemberSymbol && kind != 0 /* None */) {
                nonMemberSymbol = ((nonMemberSymbol.kind & kind) != 0) ? nonMemberSymbol : null;
            }

            return nonMemberSymbol;
        };

        PullTypeSymbol.prototype.addMember = function (memberSymbol) {
            if (!memberSymbol) {
                return;
            }

            memberSymbol.setContainer(this);

            if (!this._memberNameCache) {
                this._memberNameCache = new TypeScript.BlockIntrinsics();
            }

            if (this._members == TypeScript.sentinelEmptyArray) {
                this._members = [];
            }

            this._members[this._members.length] = memberSymbol;
            this._memberNameCache[memberSymbol.name] = memberSymbol;
        };

        PullTypeSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            if (!enclosedType) {
                return;
            }

            enclosedType.setContainer(this);

            if (!this._enclosedTypeNameCache) {
                this._enclosedTypeNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._enclosedMemberTypes) {
                this._enclosedMemberTypes = [];
            }

            this._enclosedMemberTypes[this._enclosedMemberTypes.length] = enclosedType;
            this._enclosedTypeNameCache[enclosedType.name] = enclosedType;
        };

        PullTypeSymbol.prototype.addEnclosedMemberContainer = function (enclosedContainer) {
            if (!enclosedContainer) {
                return;
            }

            enclosedContainer.setContainer(this);

            if (!this._enclosedContainerCache) {
                this._enclosedContainerCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._enclosedMemberContainers) {
                this._enclosedMemberContainers = [];
            }

            this._enclosedMemberContainers[this._enclosedMemberContainers.length] = enclosedContainer;
            this._enclosedContainerCache[enclosedContainer.name] = enclosedContainer;
        };

        PullTypeSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            if (!enclosedNonMember) {
                return;
            }

            enclosedNonMember.setContainer(this);

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._containedNonMembers) {
                this._containedNonMembers = [];
            }

            this._containedNonMembers[this._containedNonMembers.length] = enclosedNonMember;
            this._containedNonMemberNameCache[enclosedNonMember.name] = enclosedNonMember;
        };

        PullTypeSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            if (!enclosedNonMemberType) {
                return;
            }

            enclosedNonMemberType.setContainer(this);

            if (!this._containedNonMemberTypeNameCache) {
                this._containedNonMemberTypeNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._containedNonMemberTypes) {
                this._containedNonMemberTypes = [];
            }

            this._containedNonMemberTypes[this._containedNonMemberTypes.length] = enclosedNonMemberType;
            this._containedNonMemberTypeNameCache[enclosedNonMemberType.name] = enclosedNonMemberType;
        };

        PullTypeSymbol.prototype.addEnclosedNonMemberContainer = function (enclosedNonMemberContainer) {
            if (!enclosedNonMemberContainer) {
                return;
            }

            enclosedNonMemberContainer.setContainer(this);

            if (!this._containedNonMemberContainerCache) {
                this._containedNonMemberContainerCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._containedNonMemberContainers) {
                this._containedNonMemberContainers = [];
            }

            this._containedNonMemberContainers[this._containedNonMemberContainers.length] = enclosedNonMemberContainer;
            this._containedNonMemberContainerCache[enclosedNonMemberContainer.name] = enclosedNonMemberContainer;
        };

        PullTypeSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!typeParameter) {
                return;
            }

            if (!typeParameter.getContainer()) {
                typeParameter.setContainer(this);
            }

            if (!this._typeParameterNameCache) {
                this._typeParameterNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;
            this._typeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullTypeSymbol.prototype.addConstructorTypeParameter = function (typeParameter) {
            this.addTypeParameter(typeParameter);

            var constructSignatures = this.getConstructSignatures();

            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };

        PullTypeSymbol.prototype.getMembers = function () {
            return this._members;
        };

        PullTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            this._hasDefaultConstructor = hasOne;
        };

        PullTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this._hasDefaultConstructor;
        };

        PullTypeSymbol.prototype.getConstructorMethod = function () {
            return this._constructorMethod;
        };

        PullTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this._constructorMethod = constructorMethod;
        };

        PullTypeSymbol.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._typeParameters;
        };

        PullTypeSymbol.prototype.isGeneric = function () {
            return (this._typeParameters && this._typeParameters.length != 0) || this._hasGenericSignature || this._hasGenericMember || (this._typeArguments && this._typeArguments.length) || this.isArray();
        };

        PullTypeSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this._typeParameters && this._typeArguments) {
                if (!this._typeArguments.length || this._typeArguments.length < this._typeParameters.length) {
                    return false;
                }

                for (var i = 0; i < this._typeArguments.length; i++) {
                    if (!this._typeArguments[i].isFixed()) {
                        return false;
                    }
                }

                return true;
            } else if (this._hasGenericMember) {
                var members = this.getMembers();
                var memberType = null;

                for (var i = 0; i < members.length; i++) {
                    memberType = members[i].type;

                    if (memberType && !memberType.isFixed()) {
                        return false;
                    }
                }

                var signatureIsFixed = function (sig) {
                    return sig.isFixed();
                };

                return TypeScript.ArrayUtilities.all(this.getCallSignatures(false), signatureIsFixed) && TypeScript.ArrayUtilities.all(this.getConstructSignatures(false), signatureIsFixed) && TypeScript.ArrayUtilities.all(this.getIndexSignatures(false), signatureIsFixed);
            }

            return false;
        };

        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }

            if (!this._specializedTypeIDCache) {
                this._specializedTypeIDCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._specializedVersionsOfThisType) {
                this._specializedVersionsOfThisType = [];
            }

            this._specializedVersionsOfThisType[this._specializedVersionsOfThisType.length] = specializedVersionOfThisType;

            this._specializedTypeIDCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        };

        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return null;
            }

            if (!this._specializedTypeIDCache) {
                this._specializedTypeIDCache = new TypeScript.BlockIntrinsics();

                return null;
            }

            var specialization = this._specializedTypeIDCache[getIDForTypeSubstitutions(substitutingTypes)];

            if (!specialization) {
                return null;
            }

            return specialization;
        };

        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            if (!this._specializedVersionsOfThisType) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._specializedVersionsOfThisType;
        };

        PullTypeSymbol.prototype.getTypeArguments = function () {
            return this._typeArguments;
        };
        PullTypeSymbol.prototype.setTypeArguments = function (typeArgs) {
            this._typeArguments = typeArgs;
        };

        PullTypeSymbol.prototype.getTypeArgumentsOrTypeParameters = function () {
            return this.getIsSpecialized() ? this.getTypeArguments() : this.getTypeParameters();
        };

        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this._callSignatures) {
                this._callSignatures = [];
            }

            this._callSignatures[this._callSignatures.length] = callSignature;

            if (callSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            callSignature.functionType = this;
        };

        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this._constructSignatures) {
                this._constructSignatures = [];
            }

            this._constructSignatures[this._constructSignatures.length] = constructSignature;

            if (constructSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            constructSignature.functionType = this;
        };

        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this._indexSignatures) {
                this._indexSignatures = [];
            }

            this._indexSignatures[this._indexSignatures.length] = indexSignature;

            if (indexSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            indexSignature.functionType = this;
        };

        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return !!this._callSignatures;
        };

        PullTypeSymbol.prototype.getCallSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._callSignatures || [];
            }

            if (this._allCallSignatures) {
                return this._allCallSignatures;
            }

            var signatures = [];

            if (this._callSignatures) {
                signatures = signatures.concat(this._callSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getCallSignatures());
                }
            }

            this._allCallSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return !!this._constructSignatures;
        };

        PullTypeSymbol.prototype.getConstructSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._constructSignatures || [];
            }

            var signatures = [];

            if (this._constructSignatures) {
                signatures = signatures.concat(this._constructSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes && !(this.kind == 33554432 /* ConstructorType */)) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getConstructSignatures());
                }
            }

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return !!this._indexSignatures;
        };

        PullTypeSymbol.prototype.getIndexSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._indexSignatures || [];
            }

            if (this._allIndexSignatures) {
                return this._allIndexSignatures;
            }

            var signatures = [];

            if (this._indexSignatures) {
                signatures = signatures.concat(this._indexSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getIndexSignatures());
                }
            }

            this._allIndexSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.addImplementedType = function (implementedType) {
            if (!implementedType) {
                return;
            }

            if (!this._implementedTypes) {
                this._implementedTypes = [];
            }

            this._implementedTypes[this._implementedTypes.length] = implementedType;

            implementedType.addTypeThatExplicitlyImplementsThisType(this);
        };

        PullTypeSymbol.prototype.getImplementedTypes = function () {
            if (!this._implementedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._implementedTypes;
        };

        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!extendedType) {
                return;
            }

            if (!this._extendedTypes) {
                this._extendedTypes = [];
            }

            this._extendedTypes[this._extendedTypes.length] = extendedType;

            extendedType.addTypeThatExtendsThisType(this);
        };

        PullTypeSymbol.prototype.getExtendedTypes = function () {
            if (!this._extendedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._extendedTypes;
        };

        PullTypeSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            this._typesThatExtendThisType[this._typesThatExtendThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExtendThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExtendThisType;
        };

        PullTypeSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            this._typesThatExplicitlyImplementThisType[this._typesThatExplicitlyImplementThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExplicitlyImplementThisType;
        };

        PullTypeSymbol.prototype.hasBase = function (potentialBase, visited) {
            if (typeof visited === "undefined") { visited = []; }
            if (this === potentialBase || this.getRootSymbol() === potentialBase || this === potentialBase.getRootSymbol()) {
                return true;
            }

            if (TypeScript.ArrayUtilities.contains(visited, this)) {
                return true;
            }

            visited.push(this);

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, visited)) {
                    return true;
                }
            }

            visited.pop();

            return false;
        };

        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }

            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.kind === 8 /* Class */;
                }
            } else {
                if (!thisIsClass) {
                    return false;
                }
            }

            return !!(baseType.kind & (16 /* Interface */ | 8 /* Class */ | 128 /* Array */));
        };

        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            var memberSymbol = null;

            if (this._memberNameCache) {
                memberSymbol = this._memberNameCache[name];
            }

            if (!lookInParent) {
                return memberSymbol;
            } else if (memberSymbol) {
                return memberSymbol;
            }

            if (!memberSymbol && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    memberSymbol = this._extendedTypes[i].findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            return null;
        };

        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this._enclosedTypeNameCache) {
                return null;
            }

            memberSymbol = this._enclosedTypeNameCache[name];

            if (memberSymbol && kind != 0 /* None */) {
                memberSymbol = ((memberSymbol.kind & kind) != 0) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.findNestedContainer = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this._enclosedContainerCache) {
                return null;
            }

            memberSymbol = this._enclosedContainerCache[name];

            if (memberSymbol && kind != 0 /* None */) {
                memberSymbol = ((memberSymbol.kind & kind) != 0) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisiblity) {
            var allMembers = [];

            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;

            if (this._members != TypeScript.sentinelEmptyArray) {
                for (var i = 0, n = this._members.length; i < n; i++) {
                    var member = this._members[i];
                    if ((member.kind & searchDeclKind) && (memberVisiblity !== 2 /* externallyVisible */ || !member.hasFlag(2 /* Private */))) {
                        allMembers[allMembers.length] = member;
                    }
                }
            }

            if (this._extendedTypes) {
                var extenedMembersVisibility = memberVisiblity !== 0 /* all */ ? 2 /* externallyVisible */ : 0 /* all */;

                for (var i = 0, n = this._extendedTypes.length; i < n; i++) {
                    var extendedMembers = this._extendedTypes[i].getAllMembers(searchDeclKind, extenedMembersVisibility);

                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!(this._memberNameCache && this._memberNameCache[extendedMember.name])) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            if (this.isContainer()) {
                if (this._enclosedMemberTypes) {
                    for (var i = 0; i < this._enclosedMemberTypes.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberTypes[i];
                    }
                }
                if (this._enclosedMemberContainers) {
                    for (var i = 0; i < this._enclosedMemberContainers.length; i++) {
                        allMembers[allMembers.length] = this._enclosedMemberContainers[i];
                    }
                }
            }

            return allMembers;
        };

        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            if (!this._typeParameterNameCache) {
                return null;
            }

            return this._typeParameterNameCache[name];
        };

        PullTypeSymbol.prototype.setResolved = function () {
            _super.prototype.setResolved.call(this);
        };

        PullTypeSymbol.prototype.invalidate = function () {
            if (this._constructorMethod) {
                this._constructorMethod.invalidate();
            }

            this._knownBaseTypeCount = 0;

            _super.prototype.invalidate.call(this);
        };

        PullTypeSymbol.prototype.getNamePartForFullName = function () {
            var name = _super.prototype.getNamePartForFullName.call(this);

            var typars = this.getTypeArgumentsOrTypeParameters();
            var typarString = PullSymbol.getTypeParameterString(typars, this, true);
            return name + typarString;
        };

        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            return this.getScopedNameEx(scopeSymbol, useConstraintInName).toString();
        };

        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            if (this.isArray()) {
                return false;
            }

            var kind = this.kind;
            if (kind === 2 /* Primitive */ || kind === 8 /* Class */ || kind === 4 /* Container */ || kind === 32 /* DynamicModule */ || kind === 256 /* TypeAlias */ || kind === 64 /* Enum */ || kind === 8192 /* TypeParameter */ || ((kind === 16 /* Interface */ || kind === 8388608 /* ObjectType */) && this.name != "")) {
                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getScopedNameEx(scopeSymbol, useConstraintInName).toString();
            return s;
        };

        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            if (this.isArray()) {
                var elementMemberName = this._elementType ? (this._elementType.isArray() || this._elementType.isNamedTypeSymbol() ? this._elementType.getScopedNameEx(scopeSymbol, false, getPrettyTypeName, getTypeParamMarkerInfo) : this._elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName)) : TypeScript.MemberName.create("any");
                return TypeScript.MemberName.create(elementMemberName, "", "[]");
            }

            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = _super.prototype.getScopedName.call(this, scopeSymbol, useConstraintInName);

            var typars = this.getTypeArgumentsOrTypeParameters();
            builder.add(PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName));

            return builder;
        };

        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        };

        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                if (this.inMemberTypeNameEx) {
                    var associatedContainerType = this.getAssociatedContainerType();
                    if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                        var nameForTypeOf = associatedContainerType.getScopedNameEx(scopeSymbol);
                        return TypeScript.MemberName.create(nameForTypeOf, "typeof ", "");
                    } else {
                        return TypeScript.MemberName.create("any");
                    }
                }

                this.inMemberTypeNameEx = true;

                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    if (members[i].kind == 65536 /* Method */ && members[i].type.hasOnlyOverloadCallSignatures()) {
                        var methodCallSignatures = members[i].type.getCallSignatures();
                        var nameStr = members[i].getDisplayName(scopeSymbol) + (members[i].isOptional ? "?" : "");
                        ;
                        var methodMemberNames = PullSignatureSymbol.getSignaturesTypeNameEx(methodCallSignatures, nameStr, false, false, scopeSymbol);
                        allMemberNames.addAll(methodMemberNames);
                    } else {
                        var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                        if (memberTypeName.isArray() && memberTypeName.delim === delim) {
                            allMemberNames.addAll(memberTypeName.entries);
                        } else {
                            allMemberNames.add(memberTypeName);
                        }
                    }
                    curlies = true;
                }

                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                var useShortFormSignature = !curlies && (signatureCount === 1);
                var signatureMemberName;

                if (callSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (constructSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (indexSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                    allMemberNames.prefix = "{ ";
                    allMemberNames.suffix = "}";
                    allMemberNames.delim = delim;
                } else if (allMemberNames.entries.length > 1) {
                    allMemberNames.delim = delim;
                }

                this.inMemberTypeNameEx = false;

                return allMemberNames;
            }

            return TypeScript.MemberName.create("{}");
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;

    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
            _super.call(this, name, 2 /* Primitive */);

            this.isResolved = true;
        }
        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () {
            return false;
        };

        PullPrimitiveTypeSymbol.prototype.isFixed = function () {
            return true;
        };

        PullPrimitiveTypeSymbol.prototype.invalidate = function () {
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;

    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name) {
            _super.call(this, name);
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;

    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(anyType, name) {
            _super.call(this, name);
            this.anyType = anyType;

            this.isResolved = true;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };

        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            return this.anyType.getName(scopeSymbol, useConstraintInName);
        };
        return PullErrorTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;

    var PullContainerSymbol = (function (_super) {
        __extends(PullContainerSymbol, _super);
        function PullContainerSymbol(name, kind) {
            if (typeof kind === "undefined") { kind = 4 /* Container */; }
            _super.call(this, name, kind);
            this.instanceSymbol = null;
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
        }
        PullContainerSymbol.prototype.isContainer = function () {
            return true;
        };

        PullContainerSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };

        PullContainerSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };

        PullContainerSymbol.prototype.invalidate = function () {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };

        PullContainerSymbol.prototype.setExportAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };

        PullContainerSymbol.prototype.getExportAssignedValueSymbol = function () {
            return this.assignedValue;
        };

        PullContainerSymbol.prototype.setExportAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };

        PullContainerSymbol.prototype.getExportAssignedTypeSymbol = function () {
            return this.assignedType;
        };

        PullContainerSymbol.prototype.setExportAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };

        PullContainerSymbol.prototype.getExportAssignedContainerSymbol = function () {
            return this.assignedContainer;
        };

        PullContainerSymbol.prototype.resetExportAssignedSymbols = function () {
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
        };

        PullContainerSymbol.usedAsSymbol = function (containerSymbol, symbol) {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }

            if (!containerSymbol.isAlias() && containerSymbol.type == symbol) {
                return true;
            }

            var moduleSymbol = containerSymbol;
            var valueExportSymbol = moduleSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = moduleSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = moduleSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                return valueExportSymbol == symbol || typeExportSymbol == symbol || containerExportSymbol == symbol || PullContainerSymbol.usedAsSymbol(containerExportSymbol, symbol);
            }

            return false;
        };

        PullContainerSymbol.prototype.getInstanceType = function () {
            return this.instanceSymbol ? this.instanceSymbol.type : null;
        };
        return PullContainerSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerSymbol = PullContainerSymbol;

    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name) {
            _super.call(this, name, 256 /* TypeAlias */);
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
            this.isUsedAsValue = false;
            this.typeUsedExternally = false;
            this.retrievingExportAssignment = false;
        }
        PullTypeAliasSymbol.prototype.isAlias = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.isContainer = function () {
            return true;
        };

        PullTypeAliasSymbol.prototype.setAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedValueSymbol = function () {
            if (this.assignedValue) {
                return this.assignedValue;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedValueSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.setAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedTypeSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedType) {
                if (this.assignedType.isAlias()) {
                    this.retrievingExportAssignment = true;
                    var sym = this.assignedType.getExportAssignedTypeSymbol();
                    this.retrievingExportAssignment = false;
                } else if (this.assignedType != this.assignedContainer) {
                    return this.assignedType;
                }
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this.assignedContainer;
        };

        PullTypeAliasSymbol.prototype.setAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedContainerSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this.assignedContainer;
        };

        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this.assignedType) {
                return this.assignedType.getMembers();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getCallSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getConstructSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getIndexSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this.assignedType) {
                return this.assignedType.findMember(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this.assignedType) {
                return this.assignedType.findNestedType(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedContainer = function (name) {
            if (this.assignedType) {
                return this.assignedType.findNestedContainer(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, memberVisibility) {
            if (this.assignedType) {
                return this.assignedType.getAllMembers(searchDeclKind, memberVisibility);
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.invalidate = function () {
            this.isUsedAsValue = false;

            _super.prototype.invalidate.call(this);
        };
        return PullTypeAliasSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;

    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            _super.apply(this, arguments);
        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () {
            return true;
        };
        return PullDefinitionSignatureSymbol;
    })(PullSignatureSymbol);
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;

    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name, _isFunctionTypeParameter) {
            _super.call(this, name, 8192 /* TypeParameter */);
            this._isFunctionTypeParameter = _isFunctionTypeParameter;
            this._constraint = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.isFunctionTypeParameter = function () {
            return this._isFunctionTypeParameter;
        };

        PullTypeParameterSymbol.prototype.isFixed = function () {
            return false;
        };

        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            this._constraint = constraintType;
        };

        PullTypeParameterSymbol.prototype.getConstraint = function () {
            return this._constraint;
        };

        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };

        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }

            return name;
        };

        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getDisplayName.call(this, scopeSymbol, useConstraintInName);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;

    var PullTypeVariableSymbol = (function (_super) {
        __extends(PullTypeVariableSymbol, _super);
        function PullTypeVariableSymbol(name, isFunctionTypeParameter) {
            _super.call(this, name, isFunctionTypeParameter);
            this.tyvarID = TypeScript.globalTyvarID++;
        }
        PullTypeVariableSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeVariableSymbol.prototype.isTypeVariable = function () {
            return true;
        };
        return PullTypeVariableSymbol;
    })(PullTypeParameterSymbol);
    TypeScript.PullTypeVariableSymbol = PullTypeVariableSymbol;

    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name) {
            _super.call(this, name, 4096 /* Property */);
            this._getterSymbol = null;
            this._setterSymbol = null;
        }
        PullAccessorSymbol.prototype.isAccessor = function () {
            return true;
        };

        PullAccessorSymbol.prototype.setSetter = function (setter) {
            if (!setter) {
                return;
            }

            this._setterSymbol = setter;

            setter.setAccessorSymbol(this);
        };

        PullAccessorSymbol.prototype.getSetter = function () {
            return this._setterSymbol;
        };

        PullAccessorSymbol.prototype.setGetter = function (getter) {
            if (!getter) {
                return;
            }

            this._getterSymbol = getter;

            getter.setAccessorSymbol(this);
        };

        PullAccessorSymbol.prototype.getGetter = function () {
            return this._getterSymbol;
        };

        PullAccessorSymbol.prototype.invalidate = function () {
            if (this._getterSymbol) {
                this._getterSymbol.invalidate();
            }

            if (this._setterSymbol) {
                this._setterSymbol.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };
        return PullAccessorSymbol;
    })(PullSymbol);
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;

    function typeWrapsTypeParameter(type, typeParameter) {
        if (type.isTypeParameter()) {
            return type == typeParameter;
        }

        if (type.inWrapCheck) {
            return false;
        }

        type.inWrapCheck = true;

        var wrapsType = false;

        var typeArguments = type.getTypeArguments();

        if (typeArguments) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeWrapsTypeParameter(typeArguments[i], typeParameter)) {
                    wrapsType = true;
                    break;
                }
            }
        }

        if (!wrapsType) {
            var callSignatures = type.getCallSignatures();
            var constructSignatures = type.getConstructSignatures();
            var indexSignatures = type.getIndexSignatures();

            for (var i = 0; i < callSignatures.length; i++) {
                if (signatureWrapsTypeParameter(callSignatures[i], typeParameter)) {
                    wrapsType = true;
                    break;
                }
            }

            if (!wrapsType) {
                for (var i = 0; i < constructSignatures.length; i++) {
                    if (signatureWrapsTypeParameter(constructSignatures[i], typeParameter)) {
                        wrapsType = true;
                        break;
                    }
                }

                if (!wrapsType) {
                    for (var i = 0; i < indexSignatures.length; i++) {
                        if (signatureWrapsTypeParameter(indexSignatures[i], typeParameter)) {
                            wrapsType = true;
                            break;
                        }
                    }
                }
            }
        }

        if (!wrapsType && (type.kind & (8388608 /* ObjectType */ | 512 /* ObjectLiteral */))) {
            var members = type.getMembers();

            for (var i = 0; i < members.length; i++) {
                if (members[i].type && typeWrapsTypeParameter(members[i].type, typeParameter)) {
                    wrapsType = true;
                    break;
                }
            }
        }

        type.inWrapCheck = false;

        return wrapsType;
    }
    TypeScript.typeWrapsTypeParameter = typeWrapsTypeParameter;

    function signatureWrapsTypeParameter(signature, typeParameter) {
        if (signature.inWrapCheck) {
            return false;
        }

        var wrapsType = false;

        if (signature.parameters) {
            for (var i = 0; i < signature.parameters.length; i++) {
                if (signature.parameters[i].type) {
                    if (typeWrapsTypeParameter(signature.parameters[i].type, typeParameter)) {
                        wrapsType = true;
                        break;
                    }
                }
            }
        }

        if (!wrapsType) {
            if (signature.returnType) {
                wrapsType = typeWrapsTypeParameter(signature.returnType, typeParameter);
            }
        }

        signature.inWrapCheck = false;

        return wrapsType;
    }
    TypeScript.signatureWrapsTypeParameter = signatureWrapsTypeParameter;

    function getRootType(typeToSpecialize) {
        var decl = typeToSpecialize.getDeclarations()[0];

        if (!typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        return typeToSpecialize.kind == 8 /* Class */ || (typeToSpecialize.kind == 16 /* Interface */ && typeToSpecialize.name != "") ? decl.getSymbol().type : typeToSpecialize;
    }
    TypeScript.getRootType = getRootType;

    TypeScript.nSpecializationsCreated = 0;
    TypeScript.nSpecializedSignaturesCreated = 0;

    function shouldSpecializeTypeParameterForTypeParameter(specialization, typeToSpecialize) {
        if (specialization == typeToSpecialize) {
            return false;
        }

        if (!(specialization.isTypeParameter() && typeToSpecialize.isTypeParameter())) {
            return true;
        }

        var parent = specialization.getDeclarations()[0].getParentDecl();
        var targetParent = typeToSpecialize.getDeclarations()[0].getParentDecl();

        if (parent == targetParent) {
            return true;
        }

        while (parent) {
            if (parent.flags & 16 /* Static */) {
                return true;
            }

            if (parent == targetParent) {
                return false;
            }

            parent = parent.getParentDecl();
        }

        return true;
    }
    TypeScript.shouldSpecializeTypeParameterForTypeParameter = shouldSpecializeTypeParameterForTypeParameter;

    function specializeType(typeToSpecialize, typeArguments, resolver, context) {
        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        if (context.recursiveMemberSpecializationDepth == TypeScript.maxRecursiveMemberSpecializationDepth || context.recursiveSignatureSpecializationDepth == TypeScript.maxRecursiveSignatureSpecializationDepth || context.recursiveConstraintSpecializationDepth == TypeScript.maxRecursiveConstraintSpecializationDepth) {
            return resolver.semanticInfoChain.anyTypeSymbol;
        }

        var searchForExistingSpecialization = typeArguments != null;

        if (typeArguments === null || (context.specializingToAny && typeArguments.length) || typeToSpecialize.hasBaseTypeConflict()) {
            typeArguments = [];
        }

        if (typeToSpecialize.isTypeParameter()) {
            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            var substitution = context.findSpecializationForType(typeToSpecialize);

            if (substitution != typeToSpecialize) {
                if (context.isSpecializingSignatureTypeParameters || shouldSpecializeTypeParameterForTypeParameter(substitution, typeToSpecialize)) {
                    return substitution;
                }
            }

            if (typeArguments && typeArguments.length) {
                if (context.isSpecializingSignatureTypeParameters || shouldSpecializeTypeParameterForTypeParameter(typeArguments[0], typeToSpecialize)) {
                    return typeArguments[0];
                }
            }

            return typeToSpecialize;
        }

        if (typeToSpecialize.isArray()) {
            if (typeToSpecialize.currentlyBeingSpecialized()) {
                return typeToSpecialize;
            }

            var newElementType = null;

            if (!context.specializingToAny) {
                var elementType = typeToSpecialize.getElementType();

                newElementType = specializeType(elementType, typeArguments, resolver, context);
            } else {
                newElementType = resolver.semanticInfoChain.anyTypeSymbol;
            }

            var newArrayType = specializeType(resolver.getCachedArrayType(), [newElementType], resolver, context);

            return newArrayType;
        }

        var rootTypeParameters = typeToSpecialize.getTypeParameters();

        if (!context.specializingToAny && searchForExistingSpecialization && (rootTypeParameters.length > typeArguments.length)) {
            searchForExistingSpecialization = false;
        }

        var newType = null;

        var newTypeDecl = typeToSpecialize.getDeclarations()[0];

        var rootType = getRootType(typeToSpecialize);

        var isArray = typeToSpecialize === resolver.getCachedArrayType() || typeToSpecialize.isArray();

        if (searchForExistingSpecialization || context.specializingToAny) {
            if (!typeArguments.length || context.specializingToAny) {
                for (var i = 0; i < rootTypeParameters.length; i++) {
                    typeArguments[i] = resolver.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (isArray) {
                newType = typeArguments[0].getArrayType();
            } else if (typeArguments.length) {
                newType = rootType.getSpecialization(typeArguments);
            }

            if (!newType && !rootTypeParameters.length && context.specializingToAny) {
                newType = rootType.getSpecialization([resolver.semanticInfoChain.anyTypeSymbol]);
            }

            for (var i = 0; i < typeArguments.length; i++) {
                if (!typeArguments[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typeArguments[i], rootTypeParameters[i]))) {
                    typeToSpecialize.memberWrapsOwnTypeParameter = true;
                }
            }
        } else {
            var knownTypeArguments = typeToSpecialize.getTypeArguments();
            var typesToReplace = knownTypeArguments ? knownTypeArguments : rootTypeParameters;
            var declAST;
            var replacementType = null;

            for (var i = 0; i < typesToReplace.length; i++) {
                if (!typesToReplace[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typesToReplace[i], rootTypeParameters[i]))) {
                    typeToSpecialize.memberWrapsOwnTypeParameter = true;
                }

                replacementType = typeToSpecialize.memberWrapsOwnTypeParameter ? typesToReplace[i].getRootSymbol() : typesToReplace[i];

                substitution = specializeType(replacementType, null, resolver, context);

                typeArguments[i] = (substitution != null && !resolver.typesAreIdentical(typesToReplace[i], substitution)) ? substitution : typesToReplace[i];
            }

            newType = rootType.getSpecialization(typeArguments);
        }

        var rootTypeParameters = rootType.getTypeParameters();

        if (rootTypeParameters.length && (rootTypeParameters.length == typeArguments.length)) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeArguments[i] != rootTypeParameters[i]) {
                    break;
                }
            }

            if (i == rootTypeParameters.length) {
                return rootType;
            }
        }

        if (newType) {
            if (newType.isResolved || newType.currentlyBeingSpecialized() || typeToSpecialize.memberWrapsOwnTypeParameter) {
                return newType;
            }
        }

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        if (!newType) {
            TypeScript.nSpecializationsCreated++;

            newType = typeToSpecialize.isClass() ? new PullTypeSymbol(typeToSpecialize.name, 8 /* Class */) : isArray ? new PullTypeSymbol("Array", 128 /* Array */) : typeToSpecialize.isTypeParameter() ? new PullTypeVariableSymbol(typeToSpecialize.name, typeToSpecialize.isFunctionTypeParameter()) : new PullTypeSymbol(typeToSpecialize.name, typeToSpecialize.kind);
            newType.setRootSymbol(rootType);
        }

        newType.setIsBeingSpecialized();

        newType.setTypeArguments(typeArguments);

        rootType.addSpecialization(newType, typeArguments);

        if ((rootType.kind == 8388608 /* ObjectType */) && rootType.getHasGenericMember()) {
            newType.setHasGenericMember();
        }

        if (isArray) {
            newType.setElementType(typeArguments[0]);
            typeArguments[0].setArrayType(newType);
        }

        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return newType;
        }

        var prevCurrentlyBeingSpecialized = typeToSpecialize.currentlyBeingSpecialized();
        if (typeToSpecialize.kind == 33554432 /* ConstructorType */) {
            typeToSpecialize.setIsBeingSpecialized();
        }

        var typeReplacementMap = {};

        for (var i = 0; i < rootTypeParameters.length; i++) {
            if (rootTypeParameters[i] != typeArguments[i]) {
                typeReplacementMap[rootTypeParameters[i].pullSymbolIDString] = typeArguments[i];
            }
        }

        specializeConstraints(newType, rootTypeParameters, typeReplacementMap, resolver, context);

        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        var typeDecl;
        var unitPath;
        var decls = typeToSpecialize.getDeclarations();
        var extendTypeSymbol = null;
        var implementedTypeSymbol = null;

        if (extendedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                var typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);
                var extendsList = typeAST.nodeType() === 14 /* ClassDeclaration */ ? typeAST.extendsList : typeAST.extendsList;

                if (extendsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    for (var j = 0; j < extendsList.members.length; j++) {
                        context.pushTypeSpecializationCache(typeReplacementMap);
                        extendTypeSymbol = resolver.resolveTypeReference(extendsList.members[j], typeDecl, context);
                        resolver.setUnitPath(unitPath);
                        context.popTypeSpecializationCache();

                        newType.addExtendedType(extendTypeSymbol);
                    }
                }
            }
        }

        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();

        if (implementedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                var typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);
                var implementsList = typeAST.nodeType() === 14 /* ClassDeclaration */ ? typeAST.implementsList : null;

                if (implementsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    for (var j = 0; j < implementsList.members.length; j++) {
                        context.pushTypeSpecializationCache(typeReplacementMap);
                        implementedTypeSymbol = resolver.resolveTypeReference(implementsList.members[j], typeDecl, context);
                        resolver.setUnitPath(unitPath);
                        context.popTypeSpecializationCache();

                        newType.addImplementedType(implementedTypeSymbol);
                    }
                }
            }
        }

        var callSignatures = typeToSpecialize.memberWrapsOwnTypeParameter ? rootType.getCallSignatures(false) : typeToSpecialize.getCallSignatures(false);
        var constructSignatures = typeToSpecialize.memberWrapsOwnTypeParameter ? rootType.getConstructSignatures(false) : typeToSpecialize.getConstructSignatures(false);
        var indexSignatures = typeToSpecialize.memberWrapsOwnTypeParameter ? rootType.getIndexSignatures(false) : typeToSpecialize.getIndexSignatures(false);
        var members = typeToSpecialize.memberWrapsOwnTypeParameter ? rootType.getMembers() : typeToSpecialize.getMembers();

        var newSignature;
        var placeHolderSignature;
        var signature;

        var decl = null;
        var declAST = null;
        var parameters;
        var newParameters;
        var returnType = null;
        var prevSpecializationSignature = null;

        for (var i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Call signature for type '" + typeToSpecialize.pullSymbolIDString + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, new TypeScript.PullTypeResolutionContext(resolver, context.typeCheck(), context.typeCheckUnitPath));
                }

                context.recursiveSignatureSpecializationDepth++;

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);

                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;

                newSignature = specializeSignature(newSignature, !context.isSpecializingConstructorMethod, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                context.recursiveSignatureSpecializationDepth--;

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from call");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addCallSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Construct signature for type '" + typeToSpecialize.pullSymbolIDString + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, new TypeScript.PullTypeResolutionContext(resolver, context.typeCheck(), context.typeCheckUnitPath));
                }

                context.recursiveSignatureSpecializationDepth++;

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);

                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;
                newSignature = specializeSignature(newSignature, !context.isSpecializingConstructorMethod, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();
                context.recursiveSignatureSpecializationDepth--;

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from construct");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addConstructSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Index signature for type '" + typeToSpecialize.pullSymbolIDString + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, new TypeScript.PullTypeResolutionContext(resolver, context.typeCheck(), context.typeCheckUnitPath));
                }

                context.recursiveSignatureSpecializationDepth++;

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);

                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;
                newSignature = specializeSignature(newSignature, !context.isSpecializingConstructorMethod, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();
                context.recursiveSignatureSpecializationDepth--;

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from index");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addIndexSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        var field = null;
        var newField = null;

        var fieldType = null;
        var newFieldType = null;
        var replacementType = null;

        var fieldSignatureSymbol = null;

        for (var i = 0; i < members.length; i++) {
            field = members[i];
            field.setIsBeingSpecialized();

            decls = field.getDeclarations();

            newField = new PullSymbol(field.name, field.kind);

            newField.setRootSymbol(field);

            if (field.isOptional) {
                newField.isOptional = true;
            }

            resolver.resolveDeclaredSymbol(field, context);

            fieldType = field.type;

            if (!fieldType) {
                fieldType = newType;
            }

            replacementType = typeReplacementMap[fieldType.pullSymbolIDString];

            if (replacementType) {
                newField.type = replacementType;
            } else {
                if (fieldType.isGeneric() && !fieldType.isFixed()) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(decls[0].getScriptName());

                    context.pushTypeSpecializationCache(typeReplacementMap);

                    context.recursiveMemberSpecializationDepth++;
                    newFieldType = specializeType(fieldType, !fieldType.getIsSpecialized() ? typeArguments : null, resolver, context);
                    context.recursiveMemberSpecializationDepth--;

                    resolver.setUnitPath(unitPath);

                    context.popTypeSpecializationCache();

                    newField.type = newFieldType;
                } else {
                    newField.type = fieldType;
                }
            }
            field.setIsSpecialized();
            newType.addMember(newField);
        }

        if (typeToSpecialize.isClass()) {
            var constructorMethod = typeToSpecialize.getConstructorMethod();

            var prevIsSpecializingConstructorMethod = context.isSpecializingConstructorMethod;
            context.isSpecializingConstructorMethod = true;

            resolver.resolveDeclaredSymbol(constructorMethod, context);

            var newConstructorMethod = new PullSymbol(constructorMethod.name, 32768 /* ConstructorMethod */);
            var newConstructorType = specializeType(constructorMethod.type, typeArguments, resolver, context);

            context.isSpecializingConstructorMethod = prevIsSpecializingConstructorMethod;

            newConstructorMethod.type = newConstructorType;

            var constructorDecls = constructorMethod.getDeclarations();

            newConstructorMethod.setRootSymbol(constructorMethod);

            newConstructorType.setAssociatedContainerType(newType);

            newType.setConstructorMethod(newConstructorMethod);
        }

        newType.setIsSpecialized();

        newType.setResolved();
        typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
        context.inSpecialization = prevInSpecialization;
        return newType;
    }
    TypeScript.specializeType = specializeType;

    function specializeConstraints(newType, rootTypeParameters, typeReplacementMap, resolver, context) {
        for (var i = 0; i < rootTypeParameters.length; i++) {
            var newTypeParameter = rootTypeParameters[i];
            var constraint = newTypeParameter.getConstraint();
            if (constraint) {
                var newConstraint = typeReplacementMap[constraint.pullSymbolIDString];

                if (!newConstraint && !constraint.isFixed()) {
                    var constraintDecl = constraint.getDeclarations()[0];
                    var unitPath = resolver.getUnitPath();

                    resolver.setUnitPath(constraintDecl.getScriptName());
                    context.pushTypeSpecializationCache(typeReplacementMap);
                    context.recursiveConstraintSpecializationDepth++;

                    newConstraint = specializeType(constraint, null, resolver, context);

                    context.recursiveConstraintSpecializationDepth--;
                    resolver.setUnitPath(unitPath);
                    context.popTypeSpecializationCache();
                }

                if (newConstraint) {
                    newTypeParameter = new PullTypeParameterSymbol(newTypeParameter.name, false);
                    newTypeParameter.setRootSymbol(rootTypeParameters[i]);
                    newTypeParameter.setConstraint(newConstraint);
                }
            }
            newType.addTypeParameter(newTypeParameter);
        }
    }
    TypeScript.specializeConstraints = specializeConstraints;

    function specializeSignature(signature, skipLocalTypeParameters, typeReplacementMap, typeArguments, resolver, enclosingDecl, context, ast) {
        if (signature.currentlyBeingSpecialized()) {
            return signature;
        }

        if (!signature.isResolved && !signature.inResolution) {
            resolver.resolveDeclaredSymbol(signature, context);
        }

        var newSignature = signature.getSpecialization(typeArguments);

        if (newSignature) {
            return newSignature;
        }

        signature.setIsBeingSpecialized();

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        newSignature = new PullSignatureSymbol(signature.kind);
        TypeScript.nSpecializedSignaturesCreated++;
        newSignature.setRootSymbol(signature);

        if (signature.hasVarArgs) {
            newSignature.hasVarArgs = true;
        }

        if (signature.hasAGenericParameter) {
            newSignature.hasAGenericParameter = true;
        }

        signature.addSpecialization(newSignature, typeArguments);

        var parameters = signature.parameters;
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.returnType;

        if (!returnType) {
            returnType = resolver.semanticInfoChain.anyTypeSymbol;
        }

        for (var i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }

        if (signature.hasAGenericParameter) {
            newSignature.hasAGenericParameter = true;
        }

        var newParameter;
        var newParameterType;
        var newParameterElementType;
        var parameterType;
        var replacementParameterType;
        var localTypeParameters = new TypeScript.BlockIntrinsics();
        var localSkipMap = null;

        if (skipLocalTypeParameters) {
            for (var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
                if (!localSkipMap) {
                    localSkipMap = {};
                }

                localSkipMap[typeParameters[i].pullSymbolIDString] = typeParameters[i];
            }
        }

        context.pushTypeSpecializationCache(typeReplacementMap);

        if (skipLocalTypeParameters && localSkipMap) {
            context.pushTypeSpecializationCache(localSkipMap);
        }
        var newReturnType = (!localTypeParameters[returnType.name]) ? specializeType(returnType, null, resolver, context) : returnType;
        if (skipLocalTypeParameters && localSkipMap) {
            context.popTypeSpecializationCache();
        }
        context.popTypeSpecializationCache();

        newSignature.returnType = newReturnType;

        for (var k = 0; k < parameters.length; k++) {
            resolver.resolveDeclaredSymbol(parameters[k], context);

            newParameter = new PullSymbol(parameters[k].name, parameters[k].kind);
            newParameter.setRootSymbol(parameters[k]);

            parameterType = parameters[k].type;

            context.pushTypeSpecializationCache(typeReplacementMap);
            if (skipLocalTypeParameters && localSkipMap) {
                context.pushTypeSpecializationCache(localSkipMap);
            }
            newParameterType = !localTypeParameters[parameterType.name] ? specializeType(parameterType, null, resolver, context) : parameterType;
            if (skipLocalTypeParameters && localSkipMap) {
                context.popTypeSpecializationCache();
            }
            context.popTypeSpecializationCache();

            if (parameters[k].isOptional) {
                newParameter.isOptional = true;
            }

            if (parameters[k].isVarArg) {
                newParameter.isVarArg = true;
                newSignature.hasVarArgs = true;
            }

            if (resolver.isTypeArgumentOrWrapper(newParameterType)) {
                newSignature.hasAGenericParameter = true;
            }

            newParameter.type = newParameterType;
            newSignature.addParameter(newParameter, newParameter.isOptional);
        }

        signature.setIsSpecialized();

        context.inSpecialization = prevInSpecialization;

        return newSignature;
    }
    TypeScript.specializeSignature = specializeSignature;

    function getIDForTypeSubstitutions(types) {
        var substitution = "";
        var members = null;

        for (var i = 0; i < types.length; i++) {
            if (types[i].kind != 8388608 /* ObjectType */) {
                substitution += types[i].pullSymbolIDString + "#";
            } else {
                var structure = getIDForTypeSubstitutionsFromObjectType(types[i]);

                if (structure) {
                    substitution += structure;
                } else {
                    substitution += types[i].pullSymbolIDString + "#";
                }
            }
        }

        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;

    function getIDForTypeSubstitutionsFromObjectType(type) {
        var structure = "";

        if (type.isResolved) {
            var members = type.getMembers();
            if (members && members.length) {
                for (var j = 0; j < members.length; j++) {
                    structure += members[j].name + "@" + getIDForTypeSubstitutions([members[j].type]);
                }
            }

            var callSignatures = type.getCallSignatures();
            if (callSignatures && callSignatures.length) {
                for (var j = 0; j < callSignatures.length; j++) {
                    structure += getIDForTypeSubstitutionFromSignature(callSignatures[j]);
                }
            }

            var constructSignatures = type.getConstructSignatures();
            if (constructSignatures && constructSignatures.length) {
                for (var j = 0; j < constructSignatures.length; j++) {
                    structure += "new" + getIDForTypeSubstitutionFromSignature(constructSignatures[j]);
                }
            }

            var indexSignatures = type.getIndexSignatures();
            if (indexSignatures && indexSignatures.length) {
                for (var j = 0; j < indexSignatures.length; j++) {
                    structure += "[]" + getIDForTypeSubstitutionFromSignature(indexSignatures[j]);
                }
            }
        }

        if (structure !== "") {
            return "{" + structure + "}";
        }

        return null;
    }

    function getIDForTypeSubstitutionFromSignature(signature) {
        var structure = "(";
        var parameters = signature.parameters;
        if (parameters && parameters.length) {
            for (var k = 0; k < parameters.length; k++) {
                structure += parameters[k].name + "@" + getIDForTypeSubstitutions([parameters[k].type]);
            }
        }

        structure += ")" + getIDForTypeSubstitutions([signature.returnType]);
        return structure;
    }

    (function (GetAllMembersVisiblity) {
        GetAllMembersVisiblity[GetAllMembersVisiblity["all"] = 0] = "all";

        GetAllMembersVisiblity[GetAllMembersVisiblity["internallyVisible"] = 1] = "internallyVisible";

        GetAllMembersVisiblity[GetAllMembersVisiblity["externallyVisible"] = 2] = "externallyVisible";
    })(TypeScript.GetAllMembersVisiblity || (TypeScript.GetAllMembersVisiblity = {}));
    var GetAllMembersVisiblity = TypeScript.GetAllMembersVisiblity;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBindingContext = (function () {
        function PullSymbolBindingContext(semanticInfoChain, scriptName) {
            this.semanticInfoChain = semanticInfoChain;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.declPath = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }
        PullSymbolBindingContext.prototype.getParent = function (n) {
            if (typeof n === "undefined") { n = 0; }
            return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null;
        };
        PullSymbolBindingContext.prototype.getDeclPath = function () {
            return this.declPath;
        };

        PullSymbolBindingContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.name;
            }
        };

        PullSymbolBindingContext.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        return PullSymbolBindingContext;
    })();
    TypeScript.PullSymbolBindingContext = PullSymbolBindingContext;

    TypeScript.time_in_findSymbol = 0;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;

    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext() {
            this.inferenceCache = {};
            this.candidateCache = {};
        }
        ArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            var comboID = objectType.pullSymbolIDString + "#" + parameterType.pullSymbolIDString;

            if (this.inferenceCache[comboID]) {
                return true;
            } else {
                this.inferenceCache[comboID] = true;
                return false;
            }
        };

        ArgumentInferenceContext.prototype.resetRelationshipCache = function () {
            this.inferenceCache = {};
        };

        ArgumentInferenceContext.prototype.addInferenceRoot = function (param) {
            var info = this.candidateCache[param.pullSymbolIDString];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.pullSymbolIDString] = info;
            }
        };

        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            return this.candidateCache[param.pullSymbolIDString];
        };

        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);

            if (info) {
                if (candidate) {
                    info.addCandidate(candidate);
                }

                if (!info.isFixed) {
                    info.isFixed = fix;
                }
            }
        };

        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            var info;
            var val;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                for (var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.pullSymbolIDString] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }

            return inferenceCandidates;
        };

        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, enclosingDecl, context) {
            var info = null;

            var collection;

            var bestCommonType;

            var results = [];

            var unfit = false;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                if (!info.inferenceCandidates.length) {
                    results[results.length] = { param: info.typeParameter, type: resolver.semanticInfoChain.anyTypeSymbol };
                    continue;
                }

                collection = {
                    getLength: function () {
                        return info.inferenceCandidates.length;
                    },
                    getTypeAtIndex: function (index) {
                        return info.inferenceCandidates[index].type;
                    }
                };

                bestCommonType = resolver.widenType(null, resolver.findBestCommonType(info.inferenceCandidates[0], collection, context, new TypeScript.TypeComparisonInfo()), enclosingDecl, context);

                if (!bestCommonType) {
                    unfit = true;
                } else {
                    for (var i = 0; i < results.length; i++) {
                        if (results[i].type == info.typeParameter) {
                            results[i].type = bestCommonType;
                        }
                    }
                }

                results[results.length] = { param: info.typeParameter, type: bestCommonType };
            }

            return { results: results, unfit: unfit };
        };
        return ArgumentInferenceContext;
    })();
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;

    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.hasProvisionalErrors = false;
            this.symbolASTMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };

        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        };

        PullContextualTypeContext.prototype.setSymbolForAST = function (ast, symbol) {
            this.astSymbolMap.link(ast.astIDString, symbol);
            this.symbolASTMap.link(symbol.pullSymbolIDString, ast);
        };

        PullContextualTypeContext.prototype.getASTForSymbol = function (symbol) {
            return this.symbolASTMap.read(symbol.pullSymbolIDString);
        };

        PullContextualTypeContext.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap.read(ast.astIDString);
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;

    TypeScript.maxRecursiveMemberSpecializationDepth = 32;
    TypeScript.maxRecursiveSignatureSpecializationDepth = 8;
    TypeScript.maxRecursiveConstraintSpecializationDepth = 32;

    var JumpRecord = (function () {
        function JumpRecord(breakableLabels, continuableLabels, inIterationStatement, inSwitchStatement) {
            if (typeof breakableLabels === "undefined") { breakableLabels = []; }
            if (typeof continuableLabels === "undefined") { continuableLabels = []; }
            if (typeof inIterationStatement === "undefined") { inIterationStatement = false; }
            if (typeof inSwitchStatement === "undefined") { inSwitchStatement = false; }
            this.breakableLabels = breakableLabels;
            this.continuableLabels = continuableLabels;
            this.inIterationStatement = inIterationStatement;
            this.inSwitchStatement = inSwitchStatement;
        }
        return JumpRecord;
    })();
    TypeScript.JumpRecord = JumpRecord;

    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext(resolver, inTypeCheck, typeCheckUnitPath) {
            if (typeof inTypeCheck === "undefined") { inTypeCheck = false; }
            this.resolver = resolver;
            this.inTypeCheck = inTypeCheck;
            this.typeCheckUnitPath = typeCheckUnitPath;
            this.contextStack = [];
            this.typeSpecializationStack = [];
            this.genericASTResolutionStack = [];
            this.enclosingFunctionParameterIndexStack = [];
            this.currentClassDeclaration = null;
            this.jumpRecordStack = [new JumpRecord()];
            this.resolvingTypeReference = false;
            this.resolvingNamespaceMemberAccess = false;
            this.resolvingTypeQueryExpression = false;
            this.resolveAggressively = false;
            this.canUseTypeSymbol = false;
            this.specializingToAny = false;
            this.isResolvingClassExtendedType = false;
            this.isSpecializingSignatureTypeParameters = false;
            this.isSpecializingConstructorMethod = false;
            this.isComparingSpecializedSignatures = false;
            this.isResolvingSuperConstructorCallArgument = false;
            this.inConstructorArguments = false;
            this.isInStaticInitializer = false;
            this.resolvingTypeNameAsNameExpression = false;
            this.recursiveMemberSpecializationDepth = 0;
            this.recursiveSignatureSpecializationDepth = 0;
            this.recursiveConstraintSpecializationDepth = 0;
            this.inSpecialization = false;
            this.inBaseTypeResolution = false;
        }
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };

        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            if (tc.hasProvisionalErrors && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].hasProvisionalErrors = true;
            }

            return tc;
        };

        PullTypeResolutionContext.prototype.currentJumpRecord = function () {
            return TypeScript.ArrayUtilities.last(this.jumpRecordStack);
        };

        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;

            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.pullSymbolIDString];

                        if (substitution) {
                            break;
                        }
                    }
                }
            }

            return substitution;
        };

        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];

            if (context) {
                var type = context.contextualType;

                if (!type) {
                    return null;
                }

                if (type.isTypeParameter() && type.getConstraint()) {
                    type = type.getConstraint();
                }

                var substitution = this.findSubstitution(type);

                return substitution ? substitution : type;
            }

            return null;
        };

        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };

        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () {
            return this.inBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };

        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);

            symbol.type = substitution ? substitution : type;

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };

        PullTypeResolutionContext.prototype.getTypeSpecializationStack = function () {
            return this.typeSpecializationStack;
        };

        PullTypeResolutionContext.prototype.setTypeSpecializationStack = function (newStack) {
            this.typeSpecializationStack = newStack;
        };

        PullTypeResolutionContext.prototype.pushTypeSpecializationCache = function (cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        };

        PullTypeResolutionContext.prototype.popTypeSpecializationCache = function () {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        };

        PullTypeResolutionContext.prototype.findSpecializationForType = function (type) {
            var specialization = null;

            for (var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.pullSymbolIDString];

                if (specialization) {
                    return specialization;
                }
            }

            return type;
        };

        PullTypeResolutionContext.prototype.postError = function (fileName, offset, length, diagnosticKey, arguments) {
            if (typeof arguments === "undefined") { arguments = null; }
            var diagnostic = new TypeScript.Diagnostic(fileName, offset, length, diagnosticKey, arguments);
            this.postDiagnostic(diagnostic);
        };

        PullTypeResolutionContext.prototype.postDiagnostic = function (diagnostic) {
            if (diagnostic) {
                if (!this.inSpecialization) {
                    if (this.inProvisionalResolution()) {
                        (this.contextStack[this.contextStack.length - 1]).hasProvisionalErrors = true;
                    } else if (this.inTypeCheck && this.resolver) {
                        this.resolver.currentUnit.addDiagnostic(diagnostic);
                    }
                }
            }
        };

        PullTypeResolutionContext.prototype.typeCheck = function () {
            return this.inTypeCheck && !this.inSpecialization && !this.inProvisionalResolution();
        };

        PullTypeResolutionContext.prototype.startResolvingTypeArguments = function (ast) {
            this.genericASTResolutionStack[this.genericASTResolutionStack.length] = ast;
        };

        PullTypeResolutionContext.prototype.isResolvingTypeArguments = function (ast) {
            for (var i = 0; i < this.genericASTResolutionStack.length; i++) {
                if (this.genericASTResolutionStack[i].astID === ast.astID) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolutionContext.prototype.doneResolvingTypeArguments = function () {
            this.genericASTResolutionStack.length--;
        };

        PullTypeResolutionContext.prototype.pushParameterIndexContext = function (enclosingFunction) {
            this.enclosingFunctionParameterIndexStack.push({
                enclosingFunction: enclosingFunction,
                index: 0
            });
        };

        PullTypeResolutionContext.prototype.popParameterIndexContext = function () {
            this.enclosingFunctionParameterIndexStack.pop();
        };

        PullTypeResolutionContext.prototype.incrementParameterIndex = function () {
            this.enclosingFunctionParameterIndexStack[this.enclosingFunctionParameterIndexStack.length - 1].index++;
        };

        PullTypeResolutionContext.prototype.getCurrentParameterIndexForFunction = function (enclosingFunction) {
            for (var i = this.enclosingFunctionParameterIndexStack.length - 1; i >= 0; i--) {
                if (this.enclosingFunctionParameterIndexStack[i].enclosingFunction === enclosingFunction) {
                    return this.enclosingFunctionParameterIndexStack[i].index;
                }
            }

            return -1;
        };

        PullTypeResolutionContext.prototype.setSymbolForAST = function (ast, symbol) {
            this.contextStack[this.contextStack.length - 1].setSymbolForAST(ast, symbol);
        };

        PullTypeResolutionContext.prototype.getASTForSymbol = function (symbol) {
            for (var i = this.contextStack.length - 1; i >= 0; i--) {
                var typeContext = this.contextStack[i];
                if (!typeContext.provisional) {
                    break;
                }

                var ast = typeContext.getASTForSymbol(symbol);
                if (ast) {
                    return ast;
                }
            }

            return null;
        };

        PullTypeResolutionContext.prototype.getSymbolForAST = function (ast) {
            for (var i = this.contextStack.length - 1; i >= 0; i--) {
                var typeContext = this.contextStack[i];
                if (!typeContext.provisional) {
                    break;
                }

                var symbol = typeContext.getSymbolForAST(ast);
                if (symbol) {
                    return symbol;
                }
            }

            return null;
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.targetTypeSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
        }
        return PullAdditionalCallResolutionData;
    })();
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;

    var PullAdditionalObjectLiteralResolutionData = (function () {
        function PullAdditionalObjectLiteralResolutionData() {
            this.membersContextTypeSymbols = null;
        }
        return PullAdditionalObjectLiteralResolutionData;
    })();
    TypeScript.PullAdditionalObjectLiteralResolutionData = PullAdditionalObjectLiteralResolutionData;

    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain, unitPath, inTypeCheck) {
            if (typeof inTypeCheck === "undefined") { inTypeCheck = false; }
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.unitPath = unitPath;
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;
            this.seenSuperConstructorCall = false;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.currentUnit = null;
            this.cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", 1024 /* Variable */);
            this.cachedFunctionArgumentsSymbol.type = this.cachedIArgumentsInterfaceType() ? this.cachedIArgumentsInterfaceType() : this.semanticInfoChain.anyTypeSymbol;
            this.cachedFunctionArgumentsSymbol.setResolved();

            var functionArgumentsDecl = new TypeScript.PullDecl("arguments", "arguments", 2048 /* Parameter */, 0 /* None */, new TypeScript.TextSpan(0, 0), unitPath);
            functionArgumentsDecl.setSymbol(this.cachedFunctionArgumentsSymbol);
            this.cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }
        PullTypeResolver.prototype.cleanCachedGlobals = function () {
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;

            this.identicalCache = {};
            this.subtypeCache = {};
            this.assignableCache = {};
        };

        PullTypeResolver.prototype.cachedArrayInterfaceType = function () {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], 16 /* Interface */);
            }

            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedArrayInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedArrayInterfaceType;
        };

        PullTypeResolver.prototype.getCachedArrayType = function () {
            return this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.cachedNumberInterfaceType = function () {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], 16 /* Interface */);
            }

            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedNumberInterfaceType;
        };

        PullTypeResolver.prototype.cachedStringInterfaceType = function () {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], 16 /* Interface */);
            }

            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedStringInterfaceType;
        };

        PullTypeResolver.prototype.cachedBooleanInterfaceType = function () {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], 16 /* Interface */);
            }

            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedBooleanInterfaceType;
        };

        PullTypeResolver.prototype.cachedObjectInterfaceType = function () {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], 16 /* Interface */);
            }

            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedObjectInterfaceType;
        };

        PullTypeResolver.prototype.cachedFunctionInterfaceType = function () {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], 16 /* Interface */);
            }

            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedFunctionInterfaceType;
        };

        PullTypeResolver.prototype.cachedIArgumentsInterfaceType = function () {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], 16 /* Interface */);
            }

            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedIArgumentsInterfaceType;
        };

        PullTypeResolver.prototype.cachedRegExpInterfaceType = function () {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], 16 /* Interface */);
            }

            if (this._cachedRegExpInterfaceType && !this._cachedRegExpInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, new TypeScript.PullTypeResolutionContext(this));
            }

            return this._cachedRegExpInterfaceType;
        };

        PullTypeResolver.prototype.getUnitPath = function () {
            return this.unitPath;
        };

        PullTypeResolver.prototype.setUnitPath = function (unitPath) {
            this.unitPath = unitPath;

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        };

        PullTypeResolver.prototype.setTypeChecked = function (ast, context) {
            if (!context || !context.inProvisionalResolution()) {
                ast.typeCheckPhase = PullTypeResolver.globalTypeCheckPhase;
            }
        };

        PullTypeResolver.prototype.canTypeCheckAST = function (ast, context) {
            return ast.typeCheckPhase !== PullTypeResolver.globalTypeCheckPhase && context && context.typeCheck() && this.unitPath == context.typeCheckUnitPath;
        };

        PullTypeResolver.prototype.getDeclForAST = function (ast) {
            return this.semanticInfoChain.getDeclForAST(ast, this.unitPath);
        };

        PullTypeResolver.prototype.setSymbolForAST = function (ast, symbol, context) {
            if (context && context.inProvisionalResolution()) {
                context.setSymbolForAST(ast, symbol);
            } else {
                this.semanticInfoChain.setSymbolForAST(ast, symbol, this.unitPath);
            }
        };

        PullTypeResolver.prototype.getSymbolForAST = function (ast, context) {
            var symbol = this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);

            if (!symbol) {
                if (context && context.inProvisionalResolution()) {
                    symbol = context.getSymbolForAST(ast);
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.getASTForSymbol = function (symbol, context) {
            var ast = this.semanticInfoChain.getASTForSymbol(symbol, this.unitPath);

            if (!ast) {
                if (context && context.inProvisionalResolution()) {
                    ast = context.getASTForSymbol(symbol);
                }
            }

            return ast;
        };

        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };

        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (name) {
            if (typeof name === "undefined") { name = null; }
            return new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, name);
        };

        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = TypeScript.getPathToDecl(decl);

            if (!declPath.length) {
                return null;
            } else if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };

        PullTypeResolver.prototype.getExportedMemberSymbol = function (symbol, parent) {
            if (!(symbol.kind & (65536 /* Method */ | 4096 /* Property */))) {
                var isContainer = (parent.kind & (4 /* Container */ | 32 /* DynamicModule */)) != 0;
                var containerType = !isContainer ? parent.getAssociatedContainerType() : parent;

                if (isContainer && containerType) {
                    if (symbol.hasFlag(1 /* Exported */)) {
                        return symbol;
                    }

                    return null;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.getMemberSymbol = function (symbolName, declSearchKind, parent) {
            var member = null;

            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName);
            } else if (declSearchKind & TypeScript.PullElementKind.SomeType) {
                member = parent.findNestedType(symbolName);
            } else if (declSearchKind & TypeScript.PullElementKind.SomeContainer) {
                member = parent.findNestedContainer(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var containerType = parent.getAssociatedContainerType();

            if (containerType) {
                if (containerType.isClass()) {
                    return null;
                }

                parent = containerType;

                if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                    member = parent.findMember(symbolName);
                } else if (declSearchKind & TypeScript.PullElementKind.SomeType) {
                    member = parent.findNestedType(symbolName);
                } else if (declSearchKind & TypeScript.PullElementKind.SomeContainer) {
                    member = parent.findNestedContainer(symbolName);
                }

                if (member) {
                    return this.getExportedMemberSymbol(member, parent);
                }
            }

            if (parent.kind & TypeScript.PullElementKind.SomeContainer) {
                var typeDeclarations = parent.getDeclarations();
                var childDecls = null;

                for (var j = 0; j < typeDeclarations.length; j++) {
                    childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        member = childDecls[0].getSymbol();

                        if (!member) {
                            member = childDecls[0].getSignatureSymbol();
                        }
                        return this.getExportedMemberSymbol(member, parent);
                    }

                    if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0 || (declSearchKind & TypeScript.PullElementKind.SomeValue) != 0) {
                        childDecls = typeDeclarations[j].searchChildDecls(symbolName, 256 /* TypeAlias */);
                        if (childDecls.length && childDecls[0].kind == 256 /* TypeAlias */) {
                            var aliasSymbol = this.getExportedMemberSymbol(childDecls[0].getSymbol(), parent);
                            if (aliasSymbol) {
                                if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0) {
                                    var typeSymbol = aliasSymbol.getExportAssignedTypeSymbol();
                                    if (typeSymbol) {
                                        return typeSymbol;
                                    }
                                } else {
                                    var valueSymbol = aliasSymbol.getExportAssignedValueSymbol();
                                    if (valueSymbol) {
                                        return valueSymbol;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;

            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            var childSymbol = null;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                if (decl.flags & 2097152 /* DeclaredInAWithBlock */) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                if (pathDeclKind & (4 /* Container */ | 32 /* DynamicModule */)) {
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        instanceSymbol = decl.getSymbol().getInstanceSymbol();

                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }

                        if (instanceSymbol) {
                            instanceType = instanceSymbol.type;

                            childSymbol = this.getMemberSymbol(symbolName, declSearchKind, instanceType);

                            if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.hasFlag(16 /* Static */)) {
                                return childSymbol;
                            }
                        }

                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    declSymbol = decl.getSymbol().type;

                    var childSymbol = this.getMemberSymbol(symbolName, declSearchKind, declSymbol);

                    if (childSymbol && (childSymbol.kind & declSearchKind) && !childSymbol.hasFlag(16 /* Static */)) {
                        return childSymbol;
                    }
                } else if ((declSearchKind & (TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer)) || !(pathDeclKind & 8 /* Class */)) {
                    var candidateSymbol = null;

                    if (pathDeclKind === 131072 /* FunctionExpression */ && symbolName === decl.getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol();
                    }

                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        if (decl.kind & TypeScript.PullElementKind.SomeFunction) {
                            decl.ensureSymbolIsBound();
                        }
                        return childDecls[0].getSymbol();
                    }

                    if (candidateSymbol) {
                        return candidateSymbol;
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }
                    }
                }
            }

            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);

            return symbol;
        };

        PullTypeResolver.prototype.getVisibleDeclsFromDeclPath = function (declPath, declSearchKind) {
            var result = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                var declKind = decl.kind;

                if (declKind !== 8 /* Class */ && declKind !== 16 /* Interface */) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }

                switch (declKind) {
                    case 4 /* Container */:
                    case 32 /* DynamicModule */:
                        var otherDecls = this.semanticInfoChain.findDeclsFromPath(declPath.slice(0, i + 1), TypeScript.PullElementKind.SomeContainer);
                        for (var j = 0, m = otherDecls.length; j < m; j++) {
                            var otherDecl = otherDecls[j];
                            if (otherDecl === decl) {
                                continue;
                            }

                            var otherDeclChildren = otherDecl.getChildDecls();
                            for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                var otherDeclChild = otherDeclChildren[k];
                                if ((otherDeclChild.flags & 1 /* Exported */) && (otherDeclChild.kind & declSearchKind)) {
                                    result.push(otherDeclChild);
                                }
                            }
                        }

                        break;

                    case 8 /* Class */:
                    case 16 /* Interface */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;

                    case 131072 /* FunctionExpression */:
                        var functionExpressionName = decl.getFunctionExpressionName();
                        if (functionExpressionName) {
                            result.push(decl);
                        }

                    case 16384 /* Function */:
                    case 32768 /* ConstructorMethod */:
                    case 65536 /* Method */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;
                }
            }

            var units = this.semanticInfoChain.units;
            for (var i = 0, n = units.length; i < n; i++) {
                var unit = units[i];
                if (unit === this.currentUnit && declPath.length != 0) {
                    continue;
                }

                if (!unit.isExternalModule()) {
                    var topLevelDecl = unit.getTopLevelDecl();
                    this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result);
                }
            }

            return result;
        };

        PullTypeResolver.prototype.addFilteredDecls = function (decls, declSearchKind, result) {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.kind & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.getVisibleDecls = function (enclosingDecl, context) {
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        };

        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            var members = contextualTypeSymbol.getAllMembers(declSearchKind, 2 /* externallyVisible */);

            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }

            return members;
        };

        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            var prevResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.canUseTypeSymbol = true;
            context.resolvingNamespaceMemberAccess = true;
            var lhs = this.resolveAST(expression, false, enclosingDecl, context);
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            context.resolvingNamespaceMemberAccess = prevResolvingNamespaceMemberAccess;

            if (context.resolvingTypeReference && (lhs.kind === 8 /* Class */ || lhs.kind === 16 /* Interface */)) {
                return null;
            }

            var lhsType = lhs.type;
            if (!lhsType) {
                return null;
            }

            this.resolveDeclaredSymbol(lhsType, context);

            if (lhsType.isContainer() && lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }

            var memberVisibilty = 2 /* externallyVisible */;
            var containerSymbol = lhsType;
            if (containerSymbol.kind === 33554432 /* ConstructorType */) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].returnType;
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = TypeScript.getPathToDecl(enclosingDecl);
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (TypeScript.ArrayUtilities.contains(declPath, declaration)) {
                            memberVisibilty = 1 /* internallyVisible */;
                            break;
                        }
                    }
                }
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            var members = [];

            if (lhsType.isContainer()) {
                var exportedAssignedContainerSymbol = lhsType.getExportAssignedContainerSymbol();
                if (exportedAssignedContainerSymbol) {
                    lhsType = exportedAssignedContainerSymbol;
                }
            }

            if (lhsType.isTypeParameter()) {
                var constraint = lhsType.getConstraint();

                if (constraint) {
                    lhsType = constraint;
                    members = lhsType.getAllMembers(declSearchKind, 2 /* externallyVisible */);
                }
            } else {
                if (lhs.kind == 67108864 /* EnumMember */) {
                    lhsType = this.semanticInfoChain.numberTypeSymbol;
                }

                if (lhsType === this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                    lhsType = this.cachedNumberInterfaceType();
                } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                    lhsType = this.cachedStringInterfaceType();
                } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                    lhsType = this.cachedBooleanInterfaceType();
                }

                if (!lhsType.isResolved) {
                    var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);

                    if (potentiallySpecializedType != lhsType) {
                        if (!lhs.isType()) {
                            context.setTypeInContext(lhs, potentiallySpecializedType);
                        }

                        lhsType = potentiallySpecializedType;
                    }
                }

                members = lhsType.getAllMembers(declSearchKind, memberVisibilty);

                if (lhsType.isContainer()) {
                    var associatedInstance = lhsType.getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;
                        this.resolveDeclaredSymbol(instanceType, context);
                        var instanceMembers = instanceType.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(instanceMembers);

                        if (instanceType.isConstructor()) {
                            members.push(this.createPrototypeSymbol(instanceType));
                        }
                    }

                    var exportedContainer = lhsType.getExportAssignedContainerSymbol();
                    if (exportedContainer) {
                        var exportedContainerMembers = exportedContainer.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(exportedContainerMembers);
                    }
                } else if (lhsType.isConstructor()) {
                    members.push(this.createPrototypeSymbol(lhsType));
                } else {
                    var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        var containerType = associatedContainerSymbol.type;
                        this.resolveDeclaredSymbol(containerType, context);
                        var containerMembers = containerType.getAllMembers(declSearchKind, memberVisibilty);
                        members = members.concat(containerMembers);
                    }
                }
            }

            if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, 2 /* externallyVisible */));
            }

            return members;
        };

        PullTypeResolver.prototype.createPrototypeSymbol = function (constructorTypeSymbol) {
            var prototypeStr = "prototype";
            var prototypeSymbol = new TypeScript.PullSymbol(prototypeStr, 4096 /* Property */);
            var parentDecl = constructorTypeSymbol.getDeclarations()[0];
            var prototypeDecl = new TypeScript.PullDecl(prototypeStr, prototypeStr, parentDecl.kind, parentDecl.flags, parentDecl.getSpan(), parentDecl.getScriptName());

            this.currentUnit.addSynthesizedDecl(prototypeDecl);

            prototypeDecl.setParentDecl(parentDecl);
            prototypeSymbol.addDeclaration(prototypeDecl);
            prototypeSymbol.type = constructorTypeSymbol.getAssociatedContainerType();
            prototypeSymbol.isResolved = true;

            return prototypeSymbol;
        };

        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };

        PullTypeResolver.prototype.isNumberOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.numberTypeSymbol) || (this.cachedNumberInterfaceType() && type === this.cachedNumberInterfaceType());
        };

        PullTypeResolver.prototype.isTypeArgumentOrWrapper = function (type) {
            if (!type) {
                return false;
            }

            if (!type.isGeneric()) {
                return false;
            }

            if (type.isTypeParameter()) {
                return true;
            }

            if (type.isArray()) {
                return this.isTypeArgumentOrWrapper(type.getElementType());
            }

            var typeArguments = type.getTypeArguments();

            if (typeArguments) {
                for (var i = 0; i < typeArguments.length; i++) {
                    if (this.isTypeArgumentOrWrapper(typeArguments[i])) {
                        return true;
                    }
                }
            } else {
                return true;
            }

            if (type.kind & (512 /* ObjectLiteral */ | 8388608 /* ObjectType */)) {
                return type.getHasGenericMember();
            }

            return false;
        };

        PullTypeResolver.prototype.resolveExternalModuleReference = function (idText, currentFileName) {
            var originalIdText = idText;
            var symbol = null;

            if (TypeScript.isRelative(originalIdText)) {
                var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                symbol = this.semanticInfoChain.findExternalModule(path + idText);
            } else {
                idText = originalIdText;

                symbol = this.semanticInfoChain.findAmbientExternalModuleInGlobalContext(TypeScript.quoteStr(originalIdText));

                if (!symbol) {
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));

                    while (symbol === null && path != "") {
                        symbol = this.semanticInfoChain.findExternalModule(path + idText);
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, context) {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }

            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = false;

            var savedIsInStaticInitializer = context.isInStaticInitializer;
            context.isInStaticInitializer = false;

            var savedIsResolvingSuperConstructorCallArgument = context.isResolvingSuperConstructorCallArgument;
            context.isResolvingSuperConstructorCallArgument = false;

            var savedInConstructorArguments = context.inConstructorArguments;
            context.inConstructorArguments = false;

            var savedResolvingTypeNameAsNameExpression = context.resolvingTypeNameAsNameExpression;
            context.resolvingTypeNameAsNameExpression = false;

            var savedTypeSpecializationStack = context.getTypeSpecializationStack();
            context.setTypeSpecializationStack([]);

            var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.resolvingNamespaceMemberAccess = false;

            var savedCurrentClassDeclaration = context.currentClassDeclaration;
            context.currentClassDeclaration = null;

            var result = this.resolveDeclaredSymbolWorker(symbol, context);

            context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;
            context.setTypeSpecializationStack(savedTypeSpecializationStack);
            context.resolvingTypeNameAsNameExpression = savedResolvingTypeNameAsNameExpression;
            context.inConstructorArguments = savedInConstructorArguments;
            context.isResolvingSuperConstructorCallArgument = savedIsResolvingSuperConstructorCallArgument;
            context.isInStaticInitializer = savedIsInStaticInitializer;
            context.resolvingTypeReference = savedResolvingTypeReference;
            context.currentClassDeclaration = savedCurrentClassDeclaration;

            return result;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbolWorker = function (symbol, context) {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }

            if (symbol.inResolution) {
                if (!symbol.currentlyBeingSpecialized()) {
                    if (!symbol.type && !symbol.isType()) {
                        symbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }

                    return symbol;
                }
            }

            var thisUnit = this.unitPath;

            var decls = symbol.getDeclarations();

            var ast = null;

            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];

                ast = this.semanticInfoChain.getASTForDecl(decl);

                if (!ast || ast.nodeType() === 83 /* Member */) {
                    this.setUnitPath(thisUnit);
                    return symbol;
                }

                this.setUnitPath(decl.getScriptName());
                var resolvedSymbol = this.resolveAST(ast, false, this.getEnclosingDecl(decl), context);

                if (decl.kind == 2048 /* Parameter */ && !symbol.isResolved && !symbol.type && resolvedSymbol && symbol.hasFlag(8388608 /* PropertyParameter */ | 67108864 /* ConstructorParameter */)) {
                    symbol.type = resolvedSymbol.type;
                    symbol.setResolved();
                }
            }

            var typeArgs = symbol.isType() ? symbol.getTypeArguments() : null;

            if (typeArgs && typeArgs.length) {
                var typeParameters = symbol.getTypeParameters();
                var typeCache = {};

                for (var i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].pullSymbolIDString] = typeArgs[i];
                }

                context.pushTypeSpecializationCache(typeCache);
                var rootType = TypeScript.getRootType(symbol.type);

                var specializedSymbol = TypeScript.specializeType(rootType, typeArgs, this, context);

                context.popTypeSpecializationCache();

                symbol = specializedSymbol;
            }

            this.setUnitPath(thisUnit);

            return symbol;
        };

        PullTypeResolver.prototype.resolveOtherDeclarations = function (ast, context) {
            var resolvedDecl = this.getDeclForAST(ast);
            var symbol = resolvedDecl.getSymbol();

            var allDecls = symbol.getDeclarations();
            for (var i = 0; i < allDecls.length; i++) {
                var currentDecl = allDecls[i];
                var astForCurrentDecl = this.getASTForDecl(currentDecl);
                if (astForCurrentDecl != ast) {
                    var unitPath = this.unitPath;
                    this.setUnitPath(currentDecl.getScriptName());
                    this.resolveAST(astForCurrentDecl, false, this.getEnclosingDecl(currentDecl), context);
                    this.setUnitPath(unitPath);
                }
            }
        };

        PullTypeResolver.prototype.resolveScript = function (script, enclosingDecl, context) {
            this.resolveAST(script.moduleElements, false, enclosingDecl, context);

            if (this.canTypeCheckAST(script, context)) {
                this.typeCheckScript(script, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckScript = function (script, enclosingDecl, context) {
            this.typeCheckAST(script.moduleElements, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var containerDecl = this.getDeclForAST(ast);
            var containerSymbol = containerDecl.getSymbol();

            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;

            var containerDecls = containerSymbol.getDeclarations();

            for (var i = 0; i < containerDecls.length; i++) {
                var childDecls = containerDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            var members = ast.members.members;

            if (containerDecl.kind != 64 /* Enum */) {
                var instanceSymbol = containerSymbol.getInstanceSymbol();

                if (instanceSymbol) {
                    this.resolveDeclaredSymbol(instanceSymbol, context);
                }

                for (var i = 0; i < members.length; i++) {
                    if (members[i].nodeType() == 90 /* ExportAssignment */) {
                        this.resolveExportAssignmentStatement(members[i], containerDecl, context);
                        break;
                    }
                }
            }

            containerSymbol.setResolved();

            this.resolveOtherDeclarations(ast, context);

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckModuleDeclaration(ast, context);
            }

            return containerSymbol;
        };

        PullTypeResolver.prototype.typeCheckModuleDeclaration = function (ast, context) {
            this.setTypeChecked(ast, context);

            var containerDecl = this.getDeclForAST(ast);
            this.resolveAST(ast.members, false, containerDecl, context);
            this.validateVariableDeclarationGroups(containerDecl, context);

            if (TypeScript.isRelative(TypeScript.stripStartAndEndQuotes(ast.name.actualText))) {
                this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), ast.name.minChar, ast.name.getLength(), TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_specify_relative_module_name));
            }
        };

        PullTypeResolver.prototype.isTypeRefWithoutTypeArgs = function (typeRef) {
            if (typeRef.nodeType() != 11 /* TypeRef */) {
                return false;
            }

            if (typeRef.term.nodeType() == 22 /* Name */) {
                return true;
            } else if (typeRef.term.nodeType() == 34 /* MemberAccessExpression */) {
                var binex = typeRef.term;

                if (binex.operand2.nodeType() == 22 /* Name */) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (classOrInterface, name, extendsList, implementsList, context) {
            var _this = this;
            var typeDecl = this.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclIsClass = classOrInterface.nodeType() === 14 /* ClassDeclaration */;
            var hasVisited = this.getSymbolForAST(classOrInterface, context) != null;

            if ((typeDeclSymbol.isResolved && hasVisited) || (typeDeclSymbol.inResolution && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }

            var wasResolving = typeDeclSymbol.inResolution;
            typeDeclSymbol.startResolving();

            if (!typeDeclSymbol.isResolved) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], context);
                }
            }

            var typeRefDecls = typeDeclSymbol.getDeclarations();

            for (var i = 0; i < typeRefDecls.length; i++) {
                var childDecls = typeRefDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            var wasInBaseTypeResolution = context.startBaseTypeResolution();

            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }

            if (extendsList) {
                var savedIsResolvingClassExtendedType = context.isResolvingClassExtendedType;
                if (typeDeclIsClass) {
                    context.isResolvingClassExtendedType = true;
                }

                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < extendsList.members.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(extendsList.members[i], typeDecl, context);

                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        this.setSymbolForAST(extendsList.members[i], parentType, null);

                        if (!typeDeclSymbol.hasBase(parentType) && !parentType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addExtendedType(parentType);

                            var specializations = typeDeclSymbol.getKnownSpecializations();

                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    } else if (parentType && !this.getSymbolForAST(extendsList.members[i], context)) {
                        this.setSymbolForAST(extendsList.members[i], parentType, null);
                    }
                }

                context.isResolvingClassExtendedType = savedIsResolvingClassExtendedType;
            }

            if (implementsList && typeDeclIsClass) {
                var extendsCount = extendsList ? extendsList.members.length : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < implementsList.members.length); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedTypeAST = implementsList.members[i - extendsCount];
                    var implementedType = this.resolveTypeReference(implementedTypeAST, typeDecl, context);

                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        this.setSymbolForAST(implementsList.members[i - extendsCount], implementedType, null);

                        if (!typeDeclSymbol.hasBase(implementedType) && !implementedType.hasBase(typeDeclSymbol)) {
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    } else if (implementedType && !this.getSymbolForAST(implementsList.members[i - extendsCount], context)) {
                        this.setSymbolForAST(implementsList.members[i - extendsCount], implementedType, null);
                    }
                }
            }

            context.doneBaseTypeResolution(wasInBaseTypeResolution);

            if (wasInBaseTypeResolution) {
                typeDeclSymbol.inResolution = false;

                PullTypeResolver.typeCheckCallBacks.push(function (context) {
                    var currentUnitPath = _this.unitPath;
                    _this.setUnitPath(typeDecl.getScriptName());

                    if (classOrInterface.nodeType() == 14 /* ClassDeclaration */) {
                        _this.resolveClassDeclaration(classOrInterface, context);
                    } else {
                        _this.resolveInterfaceDeclaration(classOrInterface, context);
                    }

                    _this.setUnitPath(currentUnitPath);
                });

                return typeDeclSymbol;
            }

            if (!typeDeclSymbol.isResolved) {
                if (TypeScript.globalBinder) {
                    TypeScript.globalBinder.resetTypeParameterCache();
                }

                if (!typeDeclIsClass) {
                    var callSignatures = typeDeclSymbol.getCallSignatures();
                    for (var i = 0; i < callSignatures.length; i++) {
                        this.resolveDeclaredSymbol(callSignatures[i], context);
                    }

                    var constructSignatures = typeDeclSymbol.getConstructSignatures();
                    for (var i = 0; i < constructSignatures.length; i++) {
                        this.resolveDeclaredSymbol(constructSignatures[i], context);
                    }

                    var indexSignatures = typeDeclSymbol.getIndexSignatures();
                    for (var i = 0; i < indexSignatures.length; i++) {
                        this.resolveDeclaredSymbol(indexSignatures[i], context);
                    }
                }
            }

            this.setSymbolForAST(name, typeDeclSymbol, context);
            this.setSymbolForAST(classOrInterface, typeDeclSymbol, context);

            typeDeclSymbol.setResolved();

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            context.currentClassDeclaration = classDeclAST;
            var result = this.resolveClassDeclarationWorker(classDeclAST, context);
            context.currentClassDeclaration = null;

            return result;
        };

        PullTypeResolver.prototype.resolveClassDeclarationWorker = function (classDeclAST, context) {
            var classDecl = this.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            if (!classDeclSymbol.isResolved) {
                this.resolveReferenceTypeDeclaration(classDeclAST, classDeclAST.name, classDeclAST.extendsList, classDeclAST.implementsList, context);

                var constructorMethod = classDeclSymbol.getConstructorMethod();
                var extendedTypes = classDeclSymbol.getExtendedTypes();
                var parentType = extendedTypes.length ? extendedTypes[0] : null;

                if (constructorMethod) {
                    var constructorTypeSymbol = constructorMethod.type;

                    var constructSignatures = constructorTypeSymbol.getConstructSignatures();

                    if (!constructSignatures.length) {
                        var constructorSignature;

                        var parentConstructor = parentType ? parentType.getConstructorMethod() : null;

                        if (parentConstructor) {
                            var parentConstructorType = parentConstructor.type;
                            var parentConstructSignatures = parentConstructorType.getConstructSignatures();

                            var parentConstructSignature;
                            var parentParameters;

                            if (!parentConstructSignatures.length) {
                                parentConstructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                                parentConstructSignature.returnType = parentType;
                                parentConstructorType.addConstructSignature(parentConstructSignature);
                                parentConstructSignature.addDeclaration(parentType.getDeclarations()[0]);

                                var parentTypeParameters = parentConstructorType.getTypeParameters();

                                for (var i = 0; i < parentTypeParameters.length; i++) {
                                    parentConstructSignature.addTypeParameter(parentTypeParameters[i]);
                                }

                                parentConstructSignatures = [parentConstructSignature];
                            }

                            for (var i = 0; i < parentConstructSignatures.length; i++) {
                                parentConstructSignature = parentConstructSignatures[i];
                                parentParameters = parentConstructSignature.parameters;

                                constructorSignature = parentConstructSignature.isDefinition() ? new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                                constructorSignature.returnType = classDeclSymbol;

                                for (var j = 0; j < parentParameters.length; j++) {
                                    constructorSignature.addParameter(parentParameters[j], parentParameters[j].isOptional);
                                }

                                var typeParameters = constructorTypeSymbol.getTypeParameters();

                                for (var j = 0; j < typeParameters.length; j++) {
                                    constructorSignature.addTypeParameter(typeParameters[j]);
                                }

                                constructorTypeSymbol.addConstructSignature(constructorSignature);
                                constructorSignature.addDeclaration(classDecl);
                            }
                        } else {
                            constructorSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                            constructorSignature.returnType = classDeclSymbol;
                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);

                            var typeParameters = constructorTypeSymbol.getTypeParameters();

                            for (var i = 0; i < typeParameters.length; i++) {
                                constructorSignature.addTypeParameter(typeParameters[i]);
                            }
                        }
                    }

                    if (!classDeclSymbol.isResolved) {
                        return classDeclSymbol;
                    }

                    if (parentType) {
                        var parentConstructorSymbol = parentType.getConstructorMethod();

                        if (parentConstructorSymbol) {
                            var parentConstructorTypeSymbol = parentConstructorSymbol.type;

                            if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                                constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                            }
                        }
                    }
                }

                this.resolveOtherDeclarations(classDeclAST, context);
            }

            if (this.canTypeCheckAST(classDeclAST, context)) {
                this.typeCheckClassDeclaration(classDeclAST, context);
            }

            return classDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckTypeParametersOfTypeDeclaration = function (classOrInterface, context) {
            var _this = this;
            var typeDecl = this.getDeclForAST(classOrInterface);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
            for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                this.checkSymbolPrivacy(typeDeclSymbol, typeDeclTypeParameters[i], function (symbol) {
                    return _this.typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface, i, typeDeclTypeParameters[i], symbol, context);
                });
            }
        };

        PullTypeResolver.prototype.typeCheckClassDeclaration = function (classDeclAST, context) {
            this.setTypeChecked(classDeclAST, context);

            var classDecl = this.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();

            if ((!classDeclSymbol.getContainer() || classDeclSymbol.getContainer().kind == 32 /* DynamicModule */) && classDeclAST.name.text() == "_this") {
                PullTypeResolver.postTypeCheckWorkitems.push({ ast: classDeclAST, enclosingDecl: this.getEnclosingDecl(classDecl) });
            }

            this.resolveAST(classDeclAST.members, false, classDecl, context);

            this.typeCheckTypeParametersOfTypeDeclaration(classDeclAST, context);
            this.typeCheckBases(classDeclAST, classDeclAST.name, classDeclAST.extendsList, classDeclAST.implementsList, classDeclSymbol, this.getEnclosingDecl(classDecl), context);

            if (!classDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classDeclSymbol, classDecl, context);
            }

            var classConstructorTypeSymbol = classDeclSymbol.getConstructorMethod().type;
            if (!classConstructorTypeSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classConstructorTypeSymbol, classDecl, context);
            }
        };

        PullTypeResolver.prototype.postTypeCheckClassDeclaration = function (classDeclAST, enclosingDecl, context) {
            this.checkThisCaptureVariableCollides(classDeclAST, true, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveTypeSymbolSignatures = function (typeSymbol, context) {
            var callSignatures = typeSymbol.getCallSignatures();
            for (var i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], context);
            }

            var constructSignatures = typeSymbol.getConstructSignatures();
            for (var i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], context);
            }

            var indexSignatures = typeSymbol.getIndexSignatures();
            for (var i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], context);
            }
        };

        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.resolveReferenceTypeDeclaration(interfaceDeclAST, interfaceDeclAST.name, interfaceDeclAST.extendsList, null, context);

            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();

            this.resolveTypeSymbolSignatures(interfaceDeclSymbol, context);

            if (interfaceDeclSymbol.isResolved) {
                this.resolveOtherDeclarations(interfaceDeclAST, context);

                if (this.canTypeCheckAST(interfaceDeclAST, context)) {
                    this.typeCheckInterfaceDeclaration(interfaceDeclAST, context);
                }
            }

            return interfaceDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckInterfaceDeclaration = function (interfaceDeclAST, context) {
            this.setTypeChecked(interfaceDeclAST, context);

            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();

            this.resolveAST(interfaceDeclAST.members, false, interfaceDecl, context);

            this.typeCheckTypeParametersOfTypeDeclaration(interfaceDeclAST, context);
            this.typeCheckBases(interfaceDeclAST, interfaceDeclAST.name, interfaceDeclAST.extendsList, null, interfaceDeclSymbol, this.getEnclosingDecl(interfaceDecl), context);

            if (!interfaceDeclSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceDeclSymbol, interfaceDecl, context);
            }
        };

        PullTypeResolver.prototype.filterSymbol = function (symbol, kind, enclosingDecl, context) {
            if (symbol) {
                if (symbol.kind & kind) {
                    return symbol;
                }

                if (symbol.isAlias()) {
                    this.resolveDeclaredSymbol(symbol, context);

                    var alias = symbol;
                    if (kind & TypeScript.PullElementKind.SomeContainer) {
                        return alias.getExportAssignedContainerSymbol();
                    } else if (kind & TypeScript.PullElementKind.SomeType) {
                        return alias.getExportAssignedTypeSymbol();
                    } else if (kind & TypeScript.PullElementKind.SomeValue) {
                        return alias.getExportAssignedValueSymbol();
                    }
                }
            }
            return null;
        };

        PullTypeResolver.prototype.getMemberSymbolOfKind = function (symbolName, kind, pullTypeSymbol, enclosingDecl, context) {
            var symbol = this.getMemberSymbol(symbolName, kind, pullTypeSymbol);

            return this.filterSymbol(symbol, kind, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveIdentifierOfInternalModuleReference = function (importDecl, identifier, moduleSymbol, enclosingDecl, context) {
            if (identifier.isMissing()) {
                return null;
            }

            var moduleTypeSymbol = moduleSymbol.type;
            var rhsName = identifier.text();
            var containerSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeContainer, moduleTypeSymbol, enclosingDecl, context);
            var valueSymbol = null;
            var typeSymbol = null;

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind == 256 /* TypeAlias */) {
                this.resolveDeclaredSymbol(containerSymbol, context);
                var aliasedAssignedValue = containerSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = containerSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = containerSymbol.getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), identifier.minChar, identifier.getLength(), TypeScript.DiagnosticCode.Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules));
                return null;
            }

            if (!valueSymbol) {
                if (moduleTypeSymbol.getInstanceSymbol()) {
                    valueSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeValue, moduleTypeSymbol.getInstanceSymbol().type, enclosingDecl, context);
                }
            }

            if (!typeSymbol) {
                typeSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeType, moduleTypeSymbol, enclosingDecl, context);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), identifier.minChar, identifier.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0_in_module_1, [rhsName, moduleSymbol.toString()]));
                return null;
            }

            if (!typeSymbol && containerSymbol) {
                typeSymbol = containerSymbol;
            }

            return {
                valueSymbol: valueSymbol,
                typeSymbol: typeSymbol,
                containerSymbol: containerSymbol
            };
        };

        PullTypeResolver.prototype.resolveModuleReference = function (importDecl, moduleNameExpr, enclosingDecl, context, declPath) {
            TypeScript.CompilerDiagnostics.assert(moduleNameExpr.nodeType() == 34 /* MemberAccessExpression */ || moduleNameExpr.nodeType() == 22 /* Name */, "resolving module reference should always be either name or member reference");

            var moduleSymbol = null;
            var moduleName;

            if (moduleNameExpr.nodeType() == 34 /* MemberAccessExpression */) {
                var dottedNameAST = moduleNameExpr;
                var moduleContainer = this.resolveModuleReference(importDecl, dottedNameAST.operand1, enclosingDecl, context, declPath);
                if (moduleContainer) {
                    moduleName = dottedNameAST.operand2.text();
                    moduleSymbol = this.getMemberSymbolOfKind(moduleName, 4 /* Container */, moduleContainer.type, enclosingDecl, context);
                    if (!moduleSymbol) {
                        this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.Could_not_find_module_0_in_module_1, [moduleName, moduleContainer.toString()]));
                    }
                }
            } else if (!moduleNameExpr.isMissing()) {
                moduleName = moduleNameExpr.text();
                moduleSymbol = this.filterSymbol(this.getSymbolFromDeclPath(moduleName, declPath, 4 /* Container */), 4 /* Container */, enclosingDecl, context);
                if (moduleSymbol) {
                    this.setSymbolForAST(moduleNameExpr, moduleSymbol, null);
                } else {
                    this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), moduleNameExpr.minChar, moduleNameExpr.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_module_reference_0, [moduleName]));
                }
            }

            return moduleSymbol;
        };

        PullTypeResolver.prototype.resolveInternalModuleReference = function (importStatementAST, context) {
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);

            var aliasExpr = importStatementAST.alias.nodeType() == 11 /* TypeRef */ ? importStatementAST.alias.term : importStatementAST.alias;
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];
            var aliasedType = null;

            if (aliasExpr.nodeType() == 22 /* Name */) {
                var moduleSymbol = this.resolveModuleReference(importDecl, aliasExpr, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    aliasedType = moduleSymbol.type;
                    if (aliasedType.hasFlag(32768 /* InitializedModule */)) {
                        var moduleName = aliasExpr.text();
                        var valueSymbol = this.getSymbolFromDeclPath(moduleName, declPath, TypeScript.PullElementKind.SomeValue);
                        var instanceSymbol = aliasedType.getInstanceSymbol();
                        if (valueSymbol && (instanceSymbol != valueSymbol || valueSymbol.type == aliasedType)) {
                            context.postError(this.unitPath, aliasExpr.minChar, aliasExpr.getLength(), TypeScript.DiagnosticCode.Internal_module_reference_0_in_import_declaration_doesn_t_reference_module_instance_for_1, [aliasExpr.actualText, moduleSymbol.type.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]);
                        }
                    }
                } else {
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (aliasExpr.nodeType() == 34 /* MemberAccessExpression */) {
                var importDeclSymbol = importDecl.getSymbol();
                var dottedNameAST = aliasExpr;
                var moduleSymbol = this.resolveModuleReference(importDecl, dottedNameAST.operand1, enclosingDecl, context, declPath);
                if (moduleSymbol) {
                    var identifierResolution = this.resolveIdentifierOfInternalModuleReference(importDecl, dottedNameAST.operand2, moduleSymbol, enclosingDecl, context);
                    if (identifierResolution) {
                        importDeclSymbol.setAssignedValueSymbol(identifierResolution.valueSymbol);
                        importDeclSymbol.setAssignedTypeSymbol(identifierResolution.typeSymbol);
                        importDeclSymbol.setAssignedContainerSymbol(identifierResolution.containerSymbol);
                        if (identifierResolution.valueSymbol) {
                            importDeclSymbol.isUsedAsValue = true;
                        }
                        return null;
                    }
                }

                importDeclSymbol.setAssignedTypeSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            return aliasedType;
        };

        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();

            var aliasedType = null;

            if (importDeclSymbol.isResolved) {
                return importDeclSymbol;
            }

            importDeclSymbol.startResolving();

            if (importStatementAST.isExternalImportDeclaration()) {
                var modPath = importStatementAST.alias.text();
                var declPath = TypeScript.getPathToDecl(enclosingDecl);

                aliasedType = this.resolveExternalModuleReference(modPath, importDecl.getScriptName());

                if (!aliasedType) {
                    this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_external_module_0, [importStatementAST.alias.actualText]));
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                aliasedType = this.resolveInternalModuleReference(importStatementAST, context);
            }

            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type));
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                } else if (aliasedType.getExportAssignedValueSymbol()) {
                    importDeclSymbol.isUsedAsValue = true;
                }

                if (aliasedType.isContainer()) {
                    importDeclSymbol.setAssignedContainerSymbol(aliasedType);
                }
                importDeclSymbol.setAssignedTypeSymbol(aliasedType);

                this.setSymbolForAST(importStatementAST.alias, aliasedType, null);
            }

            importDeclSymbol.setResolved();

            this.resolveDeclaredSymbol(importDeclSymbol.assignedValue, context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedType, context);
            this.resolveDeclaredSymbol(importDeclSymbol.assignedContainer, context);

            if (this.canTypeCheckAST(importStatementAST, context)) {
                this.typeCheckImportDeclaration(importStatementAST, context);
            }

            return importDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckImportDeclaration = function (importStatementAST, context) {
            var _this = this;
            this.setTypeChecked(importStatementAST, context);

            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();

            if (importStatementAST.isExternalImportDeclaration()) {
                if (this.compilationSettings.noResolve) {
                    context.postError(this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set, null);
                }

                var modPath = importStatementAST.alias.text();
                if (enclosingDecl.kind === 32 /* DynamicModule */) {
                    var ast = this.getASTForDecl(enclosingDecl);
                    if (ast.nodeType() === 17 /* ModuleDeclaration */ && ast.endingToken) {
                        if (TypeScript.isRelative(modPath)) {
                            context.postError(this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name, null);
                        }
                    }
                }
            }

            var checkPrivacy;
            if (importStatementAST.isExternalImportDeclaration()) {
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var container = containerSymbol ? containerSymbol.getContainer() : null;
                if (container && container.kind == 32 /* DynamicModule */) {
                    checkPrivacy = true;
                }
            } else {
                checkPrivacy = true;
            }

            if (checkPrivacy) {
                var typeSymbol = importDeclSymbol.getExportAssignedTypeSymbol();
                var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                var valueSymbol = importDeclSymbol.getExportAssignedValueSymbol();

                this.checkSymbolPrivacy(importDeclSymbol, containerSymbol, function (symbol) {
                    var messageCode = TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1;
                    var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                    context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments);
                });

                if (typeSymbol != containerSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, typeSymbol, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1;

                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                        context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments);
                    });
                }

                if (valueSymbol) {
                    this.checkSymbolPrivacy(importDeclSymbol, valueSymbol.type, function (symbol) {
                        var messageCode = symbol.isContainer() && !symbol.isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                        context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments);
                    });
                }
            }
        };

        PullTypeResolver.prototype.resolveExportAssignmentStatement = function (exportAssignmentAST, enclosingDecl, context) {
            if (exportAssignmentAST.id.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var id = exportAssignmentAST.id.text();
            var valueSymbol = null;
            var typeSymbol = null;
            var containerSymbol = null;

            var parentSymbol = enclosingDecl.getSymbol();

            if (!parentSymbol.isType() && parentSymbol.isContainer()) {
                this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Export_assignments_may_only_be_used_at_the_top_level_of_external_modules));
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = enclosingDecl !== null ? [enclosingDecl] : [];

            containerSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeContainer);

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind == 256 /* TypeAlias */) {
                this.resolveDeclaredSymbol(containerSymbol, context);

                var aliasedAssignedValue = containerSymbol.getExportAssignedValueSymbol();
                var aliasedAssignedType = containerSymbol.getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = containerSymbol.getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                this.currentUnit.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules));
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                context.postError(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [id]);
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (valueSymbol) {
                parentSymbol.setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                parentSymbol.setExportAssignedTypeSymbol(typeSymbol);
            }
            if (containerSymbol) {
                parentSymbol.setExportAssignedContainerSymbol(containerSymbol);
            }

            this.resolveDeclaredSymbol(valueSymbol, context);
            this.resolveDeclaredSymbol(typeSymbol, context);
            this.resolveDeclaredSymbol(containerSymbol, context);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignature = function (funcDeclAST, enclosingDecl, context) {
            var funcDeclSymbol = null;

            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (!functionDecl) {
                var declCollectionContext = new TypeScript.DeclCollectionContext(this.currentUnit, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);
                this.currentUnit.addSynthesizedDecl(functionDecl);
            }

            if (!functionDecl.hasSymbol()) {
                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                if (functionDecl.kind === 33554432 /* ConstructorType */) {
                    binder.bindConstructorTypeDeclarationToPullSymbol(functionDecl);
                } else {
                    binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                }
            }

            funcDeclSymbol = functionDecl.getSymbol();

            var signature = funcDeclSymbol.kind === 33554432 /* ConstructorType */ ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            if (funcDeclAST.returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, functionDecl, context);

                if (this.isTypeArgumentOrWrapper(signature.returnType)) {
                    signature.hasAGenericParameter = true;

                    if (funcDeclSymbol) {
                        funcDeclSymbol.type.setHasGenericSignature();
                    }
                }
            }

            if (funcDeclAST.typeParameters) {
                for (var i = 0; i < funcDeclAST.typeParameters.members.length; i++) {
                    this.resolveTypeParameterDeclaration(funcDeclAST.typeParameters.members[i], context);
                }
            }

            if (funcDeclAST.parameters) {
                for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(funcDeclAST.parameters.members[i], signature, functionDecl, context);
                }
            }

            if (funcDeclSymbol && signature.hasAGenericParameter) {
                funcDeclSymbol.type.setHasGenericSignature();
            }

            if (signature.hasAGenericParameter) {
                if (funcDeclSymbol) {
                    funcDeclSymbol.type.setHasGenericSignature();
                }
            }

            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.setTypeChecked(funcDeclAST, context);
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, signature, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);

                if (paramSymbol.isVarArg && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null);
                    typeRef = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(paramSymbol, typeRef);

                if (this.isTypeArgumentOrWrapper(typeRef)) {
                    signature.hasAGenericParameter = true;
                }
            } else {
                if (paramSymbol.isVarArg && paramSymbol.type) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, TypeScript.specializeType(this.cachedArrayInterfaceType(), [paramSymbol.type], this, context));
                    } else {
                        context.setTypeInContext(paramSymbol, paramSymbol.type);
                    }
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);

                    if (this.compilationSettings.noImplicitAny) {
                        context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_function_type_implicitly_has_an_any_type, [argDeclAST.id.actualText]);
                    }
                }
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();
            var contextualType = contextParam && contextParam.type;
            var isImplicitAny = false;

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);

                if (paramSymbol.isVarArg && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null);
                    typeRef = this.getNewErrorTypeSymbol();
                }

                contextualType = typeRef || contextualType;
            }
            if (contextualType) {
                context.setTypeInContext(paramSymbol, contextualType);
            } else if (paramSymbol.isVarArg && this.cachedArrayInterfaceType()) {
                context.setTypeInContext(paramSymbol, TypeScript.specializeType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol], this, context));
                isImplicitAny = true;
            }

            var canTypeCheckAST = this.canTypeCheckAST(argDeclAST, context);
            if (argDeclAST.init && (canTypeCheckAST || !contextualType)) {
                if (contextualType) {
                    context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                }

                var initExprSymbol = this.resolveAST(argDeclAST.init, contextualType != null, enclosingDecl, context);

                if (contextualType) {
                    context.popContextualType();
                }

                if (!initExprSymbol || !initExprSymbol.type) {
                    context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [argDeclAST.id.actualText]);

                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(paramSymbol.name));
                    }
                } else {
                    var initTypeSymbol = this.getInstanceTypeForAssignment(argDeclAST, initExprSymbol.type, enclosingDecl, context);
                    if (!contextualType) {
                        context.setTypeInContext(paramSymbol, this.widenType(argDeclAST.init, initTypeSymbol, enclosingDecl, context));
                        isImplicitAny = initTypeSymbol !== paramSymbol.type;
                    } else {
                        var comparisonInfo = new TypeComparisonInfo();

                        var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, contextualType, context, comparisonInfo);

                        if (!isAssignable) {
                            if (comparisonInfo.message) {
                                context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(), contextualType.toString(), comparisonInfo.message]);
                            } else {
                                context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(), contextualType.toString()]);
                            }
                        }
                    }
                }
            }

            if (!contextualType && !paramSymbol.isVarArg && !initTypeSymbol) {
                context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                isImplicitAny = true;
            }

            if (isImplicitAny && this.compilationSettings.noImplicitAny) {
                var functionExpressionName = paramDecl.getParentDecl().getFunctionExpressionName();
                if (functionExpressionName) {
                    context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [argDeclAST.id.actualText, functionExpressionName]);
                } else {
                    context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_lambda_function_implicitly_has_an_any_type, [argDeclAST.id.actualText]);
                }
            }

            if (canTypeCheckAST) {
                this.checkNameForCompilerGeneratedDeclarationCollision(argDeclAST, true, argDeclAST.id, enclosingDecl, context);
            }
            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.checkNameForCompilerGeneratedDeclarationCollision = function (astWithName, isDeclaration, name, enclosingDecl, context) {
            var nameText = name.text();
            if (nameText == "_this") {
                PullTypeResolver.postTypeCheckWorkitems.push({ ast: astWithName, enclosingDecl: enclosingDecl });
            } else if (nameText == "_super") {
                this.checkSuperCaptureVariableCollides(astWithName, isDeclaration, enclosingDecl, context);
            }
        };

        PullTypeResolver.prototype.resolveObjectTypeTypeReference = function (objectType, enclosingDecl, context) {
            var interfaceSymbol = null;

            var interfaceDecl = this.getDeclForAST(objectType);

            if (!interfaceDecl) {
                var declCollectionContext = new TypeScript.DeclCollectionContext(this.currentUnit, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(objectType, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var interfaceDecl = this.getDeclForAST(objectType);
                this.currentUnit.addSynthesizedDecl(interfaceDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);

                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);
            }

            interfaceSymbol = interfaceDecl.getSymbol();

            if (objectType.members) {
                var memberDecl = null;
                var memberSymbol = null;
                var memberType = null;
                var typeMembers = objectType.members;

                for (var i = 0; i < typeMembers.members.length; i++) {
                    memberDecl = this.getDeclForAST(typeMembers.members[i]);
                    memberSymbol = (memberDecl.kind & TypeScript.PullElementKind.SomeSignature) ? memberDecl.getSignatureSymbol() : memberDecl.getSymbol();

                    this.resolveAST(typeMembers.members[i], false, enclosingDecl, context);

                    memberType = memberSymbol.type;

                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && memberSymbol.isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }

            interfaceSymbol.setResolved();

            if (this.canTypeCheckAST(objectType, context)) {
                this.typeCheckObjectTypeTypeReference(objectType, context);
            }

            return interfaceSymbol;
        };

        PullTypeResolver.prototype.typeCheckInterfaceTypeReference = function (interfaceDeclAST, context) {
            this.setTypeChecked(interfaceDeclAST, context);
            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceSymbol = interfaceDecl.getSymbol();
            if (!interfaceSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceSymbol, interfaceDecl, context);
            }
        };

        PullTypeResolver.prototype.typeCheckObjectTypeTypeReference = function (objectType, context) {
            this.setTypeChecked(objectType, context);
            var objectTypeDecl = this.getDeclForAST(objectType);
            var objectTypeSymbol = objectTypeDecl.getSymbol();

            this.typeCheckMembersAgainstIndexer(objectTypeSymbol, objectTypeDecl, context);
        };

        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, enclosingDecl, context) {
            if (typeRef === null) {
                return null;
            }

            var aliasType = null;
            var type = this.computeTypeReferenceSymbol(typeRef, enclosingDecl, context);

            if (type.kind == 4 /* Container */) {
                var container = type;
                var instanceSymbol = container.getInstanceSymbol();

                if (instanceSymbol && (instanceSymbol.hasFlag(16384 /* ClassConstructorVariable */) || instanceSymbol.kind == 32768 /* ConstructorMethod */)) {
                    type = instanceSymbol.type.getAssociatedContainerType();
                }
            }

            if (type && type.isAlias()) {
                aliasType = type;
                type = aliasType.getExportAssignedTypeSymbol();
            }

            if (type && !type.isGeneric()) {
                if (aliasType) {
                    this.currentUnit.setAliasSymbolForAST(typeRef, aliasType);
                }
            }

            if (type && !type.isError()) {
                if ((type.kind & TypeScript.PullElementKind.SomeType) === 0) {
                    if (type.kind & TypeScript.PullElementKind.SomeContainer) {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Type_reference_cannot_refer_to_container_0, [aliasType ? aliasType.toString() : type.toString()]);
                    } else {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Type_reference_must_refer_to_type, null);
                    }
                }
            }

            if (this.canTypeCheckAST(typeRef, context)) {
                this.setTypeChecked(typeRef, context);
            }

            return type;
        };

        PullTypeResolver.prototype.computeTypeReferenceSymbol = function (typeRef, enclosingDecl, context) {
            var typeDeclSymbol = null;
            var typeSymbol = null;

            if (typeRef.term.nodeType() === 22 /* Name */) {
                var prevResolvingTypeReference = context.resolvingTypeReference;
                context.resolvingTypeReference = true;
                typeSymbol = this.resolveTypeNameExpression(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;

                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType() === 13 /* FunctionDeclaration */) {
                typeDeclSymbol = this.resolveFunctionTypeSignature(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType() === 16 /* ObjectType */) {
                typeDeclSymbol = this.resolveObjectTypeTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType() === 10 /* GenericType */) {
                typeSymbol = this.resolveGenericTypeReference(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;
            } else if (typeRef.term.nodeType() === 34 /* MemberAccessExpression */) {
                var dottedName = typeRef.term;

                prevResolvingTypeReference = context.resolvingTypeReference;
                var prevResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
                context.resolvingNamespaceMemberAccess = false;
                context.resolvingTypeReference = true;
                typeSymbol = this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;
                context.resolvingNamespaceMemberAccess = prevResolvingNamespaceMemberAccess;
                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType() === 5 /* StringLiteral */) {
                var stringConstantAST = typeRef.term;
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol(stringConstantAST.actualText);
                var decl = new TypeScript.PullDecl(stringConstantAST.actualText, stringConstantAST.actualText, typeDeclSymbol.kind, null, new TypeScript.TextSpan(stringConstantAST.minChar, stringConstantAST.getLength()), enclosingDecl.getScriptName());
                this.currentUnit.addSynthesizedDecl(decl);
                typeDeclSymbol.addDeclaration(decl);
            } else if (typeRef.term.nodeType() === 12 /* TypeQuery */) {
                var typeQuery = typeRef.term;

                var typeQueryTerm = typeQuery.name;
                if (typeQueryTerm.nodeType() === 11 /* TypeRef */) {
                    typeQueryTerm = typeQueryTerm.term;
                }

                var savedResolvingTypeReference = context.resolvingTypeReference;
                context.resolvingTypeReference = false;
                var savedResolvingTypeQueryExpression = context.resolvingTypeQueryExpression;
                context.resolvingTypeQueryExpression = true;
                var valueSymbol = this.resolveAST(typeQueryTerm, false, enclosingDecl, context);
                context.resolvingTypeQueryExpression = savedResolvingTypeQueryExpression;
                context.resolvingTypeReference = savedResolvingTypeReference;

                if (valueSymbol && valueSymbol.isAlias()) {
                    if (valueSymbol.assignedValue) {
                        valueSymbol = valueSymbol.assignedValue;
                    } else {
                        var containerSymbol = valueSymbol.getExportAssignedContainerSymbol();
                        valueSymbol = (containerSymbol && containerSymbol.isContainer() && !containerSymbol.isEnum()) ? containerSymbol.getInstanceSymbol() : null;
                    }
                }

                if (valueSymbol) {
                    typeDeclSymbol = valueSymbol.type;
                } else {
                    typeDeclSymbol = this.getNewErrorTypeSymbol();
                }
            }

            if (!typeDeclSymbol) {
                context.postError(this.unitPath, typeRef.term.minChar, typeRef.term.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type, null);
                return this.getNewErrorTypeSymbol();
            }

            if (typeDeclSymbol.isError()) {
                return typeDeclSymbol;
            }

            if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeDeclSymbol, typeRef, context)) {
                context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments, null);
                typeDeclSymbol = this.specializeTypeToAny(typeDeclSymbol, enclosingDecl, context);
            }

            if (typeRef.arrayCount) {
                var arraySymbol = typeDeclSymbol.getArrayType();

                if (!arraySymbol) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), context);

                    arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [typeDeclSymbol], this, context);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (typeRef.arrayCount > 1) {
                    for (var arity = typeRef.arrayCount - 1; arity > 0; arity--) {
                        var existingArraySymbol = arraySymbol.getArrayType();

                        if (!existingArraySymbol) {
                            arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [arraySymbol], this, context);
                        } else {
                            arraySymbol = existingArraySymbol;
                        }
                    }
                }

                typeDeclSymbol = arraySymbol;
            }

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.genericTypeIsUsedWithoutRequiredTypeArguments = function (typeSymbol, typeReference, context) {
            return typeSymbol.isNamedTypeSymbol() && typeSymbol.isGeneric() && !typeSymbol.isTypeParameter() && (typeSymbol.isResolved || (typeSymbol.inResolution && !context.inSpecialization)) && !typeSymbol.getIsSpecialized() && typeSymbol.getTypeParameters().length && typeSymbol.getTypeArguments() == null && this.isTypeRefWithoutTypeArgs(typeReference);
        };

        PullTypeResolver.prototype.resolveVariableDeclarator = function (varDecl, context, enclosingDecl) {
            return this.resolveVariableDeclaratorOrParameter(varDecl, varDecl.id, varDecl.typeExpr, varDecl.init, context, enclosingDecl);
        };

        PullTypeResolver.prototype.resolveParameter = function (parameter, context, enclosingDecl) {
            return this.resolveVariableDeclaratorOrParameter(parameter, parameter.id, parameter.typeExpr, parameter.init, context, enclosingDecl);
        };

        PullTypeResolver.prototype.resolveVariableDeclaratorOrParameter = function (varDeclOrParameter, name, typeExpr, init, context, enclosingDecl) {
            var decl = this.getDeclForAST(varDeclOrParameter);

            if (enclosingDecl && decl.kind == 2048 /* Parameter */) {
                enclosingDecl.ensureSymbolIsBound();
            }

            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;

            if (declSymbol.isResolved) {
                var declType = declSymbol.type;
                var valDecl = decl.getValueDecl();

                if (valDecl) {
                    var valSymbol = valDecl.getSymbol();

                    if (valSymbol && !valSymbol.isResolved) {
                        valSymbol.type = declType;
                        valSymbol.setResolved();
                    }
                }
            } else {
                if (declSymbol.inResolution) {
                    if (!context.inSpecialization) {
                        declSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                        declSymbol.setResolved();
                        return declSymbol;
                    }
                }

                if (declSymbol.type && declSymbol.type.isError()) {
                    return declSymbol;
                }

                declSymbol.startResolving();

                var typeExprSymbol = null;
                var inConstructorArgumentList = context.inConstructorArguments;
                context.inConstructorArguments = false;

                typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context, enclosingDecl);

                if (!typeExpr) {
                    this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, enclosingDecl, typeExprSymbol);
                }

                if (!(typeExpr || init)) {
                    var defaultType = this.semanticInfoChain.anyTypeSymbol;

                    if (declSymbol.isVarArg) {
                        defaultType = TypeScript.specializeType(this.cachedArrayInterfaceType(), [defaultType], this, context);
                    }

                    context.setTypeInContext(declSymbol, defaultType);

                    if (declParameterSymbol) {
                        declParameterSymbol.type = defaultType;
                    }
                }
                declSymbol.setResolved();

                if (declParameterSymbol) {
                    declParameterSymbol.setResolved();
                }
            }

            if (this.canTypeCheckAST(varDeclOrParameter, context)) {
                this.typeCheckVariableDeclaratorOrParameter(varDeclOrParameter, name, typeExpr, init, context, enclosingDecl);
            }

            return declSymbol;
        };

        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclarationTypeExpr = function (varDeclOrParameter, name, typeExpr, context, enclosingDecl) {
            if (!typeExpr) {
                return null;
            }

            var decl = this.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

            var typeExprSymbol = this.resolveTypeReference(typeExpr, wrapperDecl, context);

            if (!typeExprSymbol) {
                context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.actualText]);
                declSymbol.type = this.getNewErrorTypeSymbol();

                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            } else if (typeExprSymbol.isError()) {
                context.setTypeInContext(declSymbol, typeExprSymbol);
                if (declParameterSymbol) {
                    context.setTypeInContext(declParameterSymbol, typeExprSymbol);
                }
            } else {
                if (typeExprSymbol == this.semanticInfoChain.anyTypeSymbol) {
                    decl.setFlag(16777216 /* IsAnnotatedWithAny */);
                }

                if (typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        typeExprSymbol = typeExprSymbol.type;

                        if (typeExprSymbol.isAlias()) {
                            typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                        }

                        if (typeExprSymbol && typeExprSymbol.isContainer() && !typeExprSymbol.isEnum()) {
                            var instanceSymbol = typeExprSymbol.getInstanceSymbol();

                            if (!instanceSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceSymbol)) {
                                typeExprSymbol = this.getNewErrorTypeSymbol();
                            } else {
                                typeExprSymbol = instanceSymbol.type;
                            }
                        }
                    }
                } else if (declSymbol.isVarArg && !(typeExprSymbol.isArray() || typeExprSymbol == this.cachedArrayInterfaceType())) {
                    context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null);
                    typeExprSymbol = this.getNewErrorTypeSymbol();
                }

                context.setTypeInContext(declSymbol, typeExprSymbol);

                if (declParameterSymbol) {
                    declParameterSymbol.type = typeExprSymbol;
                }

                if (typeExprSymbol.kind == 16777216 /* FunctionType */) {
                    typeExprSymbol.setFunctionSymbol(declSymbol);
                }

                if (varDeclOrParameter.nodeType() === 21 /* Parameter */ && enclosingDecl && ((typeExprSymbol.isGeneric() && !typeExprSymbol.isArray()) || this.isTypeArgumentOrWrapper(typeExprSymbol))) {
                    var signature = enclosingDecl.getSpecializingSignatureSymbol();

                    if (signature) {
                        signature.hasAGenericParameter = true;
                    }
                }
            }

            return typeExprSymbol;
        };

        PullTypeResolver.prototype.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr = function (varDeclOrParameter, name, typeExpr, init, context, enclosingDecl, typeExprSymbol) {
            if (!init) {
                return null;
            }

            if (typeExprSymbol) {
                context.pushContextualType(typeExprSymbol, context.inProvisionalResolution(), null);
            }

            var decl = this.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

            var inConstructorArgumentList = context.inConstructorArguments;
            context.inConstructorArguments = inConstructorArgumentList || (decl.flags & 8388608 /* PropertyParameter */) !== 0;
            context.isInStaticInitializer = (decl.flags & 16 /* Static */) != 0;
            var initExprSymbol = this.resolveAST(init, typeExprSymbol != null, wrapperDecl, context);
            context.isInStaticInitializer = false;
            context.inConstructorArguments = inConstructorArgumentList;

            if (typeExprSymbol) {
                context.popContextualType();
            }

            if (!initExprSymbol) {
                context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [name.actualText]);

                if (!typeExpr) {
                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol());

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            } else {
                var initTypeSymbol = initExprSymbol.type;
                var widenedInitTypeSymbol = this.widenType(init, initTypeSymbol, enclosingDecl, context);

                if (!typeExpr) {
                    context.setTypeInContext(declSymbol, widenedInitTypeSymbol);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, widenedInitTypeSymbol);
                    }

                    if (this.compilationSettings.noImplicitAny) {
                        if ((widenedInitTypeSymbol != initTypeSymbol) && (widenedInitTypeSymbol == this.semanticInfoChain.anyTypeSymbol)) {
                            context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.actualText]);
                        }
                    }
                }
            }

            return widenedInitTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckVariableDeclarator = function (varDecl, context, enclosingDecl) {
            this.typeCheckVariableDeclaratorOrParameter(varDecl, varDecl.id, varDecl.typeExpr, varDecl.init, context, enclosingDecl);
        };

        PullTypeResolver.prototype.typeCheckParameter = function (parameter, context, enclosingDecl) {
            this.typeCheckVariableDeclaratorOrParameter(parameter, parameter.id, parameter.typeExpr, parameter.init, context, enclosingDecl);
        };

        PullTypeResolver.prototype.typeCheckVariableDeclaratorOrParameter = function (varDeclOrParameter, name, typeExpr, init, context, enclosingDecl) {
            var _this = this;
            this.setTypeChecked(varDeclOrParameter, context);

            var decl = this.getDeclForAST(varDeclOrParameter);
            var declSymbol = decl.getSymbol();

            var typeExprSymbol = this.resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter, name, typeExpr, context, enclosingDecl);

            var initTypeSymbol = this.resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter, name, typeExpr, init, context, enclosingDecl, typeExprSymbol);

            if (typeExpr || init) {
                if (typeExprSymbol && typeExprSymbol.isAlias()) {
                    typeExprSymbol = typeExprSymbol.getExportAssignedTypeSymbol();
                }

                if (typeExprSymbol && typeExprSymbol.kind === 32 /* DynamicModule */) {
                    var exportedTypeSymbol = typeExprSymbol.getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        var instanceTypeSymbol = typeExprSymbol.getInstanceType();

                        if (!instanceTypeSymbol) {
                            context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [typeExprSymbol.toString()]);
                            typeExprSymbol = null;
                        } else {
                            typeExprSymbol = instanceTypeSymbol;
                        }
                    }
                }

                initTypeSymbol = this.getInstanceTypeForAssignment(varDeclOrParameter, initTypeSymbol, enclosingDecl, context);

                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();

                    var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, context, comparisonInfo);

                    if (!isAssignable) {
                        if (comparisonInfo.message) {
                            context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(), typeExprSymbol.toString(), comparisonInfo.message]);
                        } else {
                            context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(), typeExprSymbol.toString()]);
                        }
                    }
                }
            } else if (this.compilationSettings.noImplicitAny && !TypeScript.hasFlag(varDeclOrParameter.getVarFlags(), 16384 /* ForInVariable */)) {
                var wrapperDecl = this.getEnclosingDecl(decl);
                wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

                if ((wrapperDecl.kind === 16384 /* Function */ || wrapperDecl.kind === 32768 /* ConstructorMethod */ || wrapperDecl.kind === 2097152 /* ConstructSignature */)) {
                    context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.actualText, enclosingDecl.name]);
                } else if (wrapperDecl.kind === 65536 /* Method */) {
                    var parentDecl = wrapperDecl.getParentDecl();

                    if (!TypeScript.hasFlag(parentDecl.flags, 8 /* Ambient */)) {
                        context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.actualText, enclosingDecl.name]);
                    } else if (TypeScript.hasFlag(parentDecl.flags, 8 /* Ambient */) && !TypeScript.hasFlag(wrapperDecl.flags, 2 /* Private */)) {
                        context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [name.actualText, enclosingDecl.name]);
                    }
                } else if (wrapperDecl.kind === 8388608 /* ObjectType */) {
                    context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Member_0_of_object_type_implicitly_has_an_any_type, [name.actualText]);
                } else if (wrapperDecl.kind !== 1073741824 /* CatchBlock */) {
                    if (!TypeScript.hasFlag(wrapperDecl.flags, 8 /* Ambient */)) {
                        context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.actualText]);
                    } else if (TypeScript.hasFlag(wrapperDecl.flags, 8 /* Ambient */) && !TypeScript.hasFlag(varDeclOrParameter.getVarFlags(), 2 /* Private */)) {
                        context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [name.actualText]);
                    }
                }
            }

            if (init && varDeclOrParameter.nodeType() === 21 /* Parameter */) {
                var containerSignature = enclosingDecl.getSignatureSymbol();
                if (containerSignature && !containerSignature.isDefinition()) {
                    context.postError(this.unitPath, varDeclOrParameter.minChar, varDeclOrParameter.getLength(), TypeScript.DiagnosticCode.Default_arguments_are_not_allowed_in_an_overload_parameter, null);
                }
            }
            if (declSymbol.kind != 2048 /* Parameter */ && (declSymbol.kind != 4096 /* Property */ || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkSymbolPrivacy(declSymbol, declSymbol.type, function (symbol) {
                    return _this.variablePrivacyErrorReporter(declSymbol, symbol, context);
                });
            }

            if (declSymbol.kind != 4096 /* Property */) {
                this.checkNameForCompilerGeneratedDeclarationCollision(varDeclOrParameter, true, name, enclosingDecl, context);
            }
        };

        PullTypeResolver.prototype.checkSuperCaptureVariableCollides = function (superAST, isDeclaration, enclosingDecl, context) {
            var declPath = TypeScript.getPathToDecl(enclosingDecl);

            var classSymbol = this.getContextualClassSymbolForEnclosingDecl(enclosingDecl, context);

            if (classSymbol) {
                this.resolveDeclaredSymbol(classSymbol, context);

                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    context.postError(this.unitPath, superAST.minChar, superAST.getLength(), isDeclaration ? TypeScript.DiagnosticCode.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference : TypeScript.DiagnosticCode.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference, null);
                }
            }
        };

        PullTypeResolver.prototype.checkThisCaptureVariableCollides = function (_thisAST, isDeclaration, enclosingDecl, context) {
            var declPath = TypeScript.getPathToDecl(enclosingDecl);

            for (var i = declPath.length - 1; i >= 0; i--) {
                var decl = declPath[i];
                var declKind = decl.kind;
                if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(decl.flags, 8192 /* FatArrow */)) {
                    continue;
                }

                if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                    if (TypeScript.hasFlag(decl.flags, 262144 /* MustCaptureThis */)) {
                        context.postError(this.unitPath, _thisAST.minChar, _thisAST.getLength(), isDeclaration ? TypeScript.DiagnosticCode.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference : TypeScript.DiagnosticCode.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference, null);
                    }
                    break;
                }
            }
        };

        PullTypeResolver.prototype.postTypeCheckVariableDeclaratorOrParameter = function (varDeclOrParameter, enclosingDecl, context) {
            this.checkThisCaptureVariableCollides(varDeclOrParameter, true, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();

            if (typeParameterSymbol.isResolved || typeParameterSymbol.inResolution) {
                if (typeParameterSymbol.isResolved && this.canTypeCheckAST(typeParameterAST, context)) {
                    this.typeCheckTypeParameterDeclaration(typeParameterAST, context);
                }
                return typeParameterSymbol;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var enclosingDecl = this.getEnclosingDecl(typeParameterDecl);
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint, enclosingDecl, context);

                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();

            if (this.canTypeCheckAST(typeParameterAST, context)) {
                this.setTypeChecked(typeParameterAST, context);
            }

            return typeParameterSymbol;
        };

        PullTypeResolver.prototype.typeCheckTypeParameterDeclaration = function (typeParameterAST, context) {
            this.setTypeChecked(typeParameterAST, context);

            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var enclosingDecl = this.getEnclosingDecl(typeParameterDecl);
            this.resolveTypeReference(typeParameterAST.constraint, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, block, signature, useContextualType, enclosingDecl, context) {
            var _this = this;
            var returnStatements = [];

            var enclosingDeclStack = [enclosingDecl];

            var preFindReturnExpressionTypes = function (ast, walker) {
                var go = true;

                switch (ast.nodeType()) {
                    case 13 /* FunctionDeclaration */:
                    case 82 /* ArrowFunctionExpression */:
                        go = false;
                        break;

                    case 96 /* ReturnStatement */:
                        var returnStatement = ast;
                        enclosingDecl.setFlag(4194304 /* HasReturnStatement */);
                        returnStatements[returnStatements.length] = { returnStatement: returnStatement, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] };
                        go = false;
                        break;

                    case 104 /* CatchClause */:
                    case 102 /* WithStatement */:
                        enclosingDeclStack[enclosingDeclStack.length] = _this.getDeclForAST(ast);
                        break;

                    default:
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            };

            var postFindReturnExpressionEnclosingDecls = function (ast, walker) {
                switch (ast.nodeType()) {
                    case 104 /* CatchClause */:
                    case 102 /* WithStatement */:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }

                walker.options.goChildren = true;

                return ast;
            };

            TypeScript.getAstWalkerFactory().walk(block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);

            if (!returnStatements.length) {
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
            } else {
                var returnExpressionSymbols = [];
                var returnExpressions = [];

                for (var i = 0; i < returnStatements.length; i++) {
                    var returnExpression = returnStatements[i].returnStatement.returnExpression;
                    if (returnExpression) {
                        var returnType = this.resolveAST(returnExpression, useContextualType, returnStatements[i].enclosingDecl, context).type;

                        if (returnType.isError()) {
                            signature.returnType = returnType;
                            return;
                        } else {
                            this.setSymbolForAST(returnStatements[i].returnStatement, returnType, context);
                        }

                        returnExpressionSymbols.push(returnType);
                        returnExpressions.push(returnExpression);
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].type;
                        }
                    };

                    var bestCommonReturnType = this.findBestCommonType(returnExpressionSymbols[0], collection, context, new TypeComparisonInfo());
                    var returnType = bestCommonReturnType;
                    var returnExpression = returnExpressions[returnExpressionSymbols.indexOf(returnType)];

                    if (useContextualType && returnType == this.semanticInfoChain.anyTypeSymbol) {
                        var contextualType = context.getContextualType();

                        if (contextualType) {
                            returnType = contextualType;
                        }
                    }

                    var functionDecl = this.getDeclForAST(funcDeclAST);
                    var functionSymbol = functionDecl.getSymbol();

                    if (returnType) {
                        var previousReturnType = returnType;
                        var newReturnType = this.widenType(returnExpression, returnType, enclosingDecl, context);
                        signature.returnType = newReturnType;

                        if (!TypeScript.ArrayUtilities.contains(returnExpressionSymbols, bestCommonReturnType)) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions, null);
                        }

                        if (this.compilationSettings.noImplicitAny) {
                            if (previousReturnType !== newReturnType && newReturnType === this.semanticInfoChain.anyTypeSymbol) {
                                var functionName = enclosingDecl.name;
                                if (functionName == "") {
                                    functionName = enclosingDecl.getFunctionExpressionName();
                                }

                                if (functionName != "") {
                                    context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionName]);
                                } else {
                                    context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, null);
                                }
                            }
                        }
                    }

                    if (!functionSymbol.type && functionSymbol.isAccessor()) {
                        functionSymbol.type = signature.returnType;
                    }

                    if (this.isTypeArgumentOrWrapper(returnType) && functionSymbol) {
                        functionSymbol.type.setHasGenericSignature();
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckFunctionDeclaration = function (funcDeclAST, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.getDeclForAST(funcDeclAST);

            if (funcDeclAST.typeParameters) {
                for (var i = 0; i < funcDeclAST.typeParameters.members.length; i++) {
                    this.resolveTypeParameterDeclaration(funcDeclAST.typeParameters.members[i], context);
                }
            }

            if (funcDeclAST.parameters) {
                var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */);
                var prevInConstructorArguments = context.inConstructorArguments;
                context.inConstructorArguments = isConstructor;
                var hasDefaultArgs = (funcDecl.flags & 33554432 /* HasDefaultArgs */) !== 0;
                if (hasDefaultArgs) {
                    context.pushParameterIndexContext(funcDeclAST);
                }
                for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                    this.resolveAST(funcDeclAST.parameters.members[i], false, funcDecl, context);
                    if (hasDefaultArgs) {
                        context.incrementParameterIndex();
                    }
                }
                if (hasDefaultArgs) {
                    context.popParameterIndexContext();
                }
                context.inConstructorArguments = prevInConstructorArguments;
            }

            var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
            this.seenSuperConstructorCall = false;
            this.resolveAST(funcDeclAST.block, false, funcDecl, context);
            var enclosingDecl = this.getEnclosingDecl(funcDecl);
            if (funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */)) {
                if (funcDecl.getSignatureSymbol() && funcDecl.getSignatureSymbol().isDefinition() && this.enclosingClassIsDerived(funcDecl)) {
                    if (!this.seenSuperConstructorCall) {
                        context.postError(this.unitPath, funcDeclAST.minChar, 11, TypeScript.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call, null);
                    } else if (this.superCallMustBeFirstStatementInConstructor(funcDecl, enclosingDecl)) {
                        var firstStatement = this.getFirstStatementFromFunctionDeclAST(funcDeclAST);
                        if (!firstStatement || !this.isSuperCallNode(firstStatement)) {
                            context.postError(this.unitPath, funcDeclAST.minChar, 11, TypeScript.DiagnosticCode.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties, null);
                        }
                    }
                }
            }
            this.seenSuperConstructorCall = prevSeenSuperConstructorCall;
            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, context);

            this.validateVariableDeclarationGroups(funcDecl, context);

            this.checkFunctionTypePrivacy(funcDeclAST, context);

            var signature = funcDecl.getSpecializingSignatureSymbol();
            if (!TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 4096 /* IndexerMember */)) {
                var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

                if (!funcDeclAST.isConstructor && !TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */) && funcDeclAST.block && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                    var isVoidOrAny = this.isAnyOrEquivalent(signature.returnType) || signature.returnType === this.semanticInfoChain.voidTypeSymbol;

                    if (!isVoidOrAny && !(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType() === 98 /* ThrowStatement */)) {
                        var funcName = funcDecl.getDisplayName();
                        funcName = funcName ? funcName : "expression";

                        context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName]);
                    }
                }
            }

            if (funcDecl.kind == 16384 /* Function */) {
                var funcNameText = funcDeclAST.name.text();
                if (funcNameText == "_super") {
                    this.checkSuperCaptureVariableCollides(funcDeclAST, true, enclosingDecl, context);
                }
            }

            PullTypeResolver.typeCheckCallBacks.push(function (context) {
                var currentUnitPath = _this.unitPath;
                _this.setUnitPath(funcDecl.getScriptName());

                if (!TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 4096 /* IndexerMember */)) {
                    _this.typeCheckFunctionOverloads(funcDeclAST, context);
                } else {
                    var parentSymbol = funcDecl.getSignatureSymbol().getContainer();
                    var allIndexSignatures = _this.getBothKindsOfIndexSignatures(parentSymbol, context);
                    var stringIndexSignature = allIndexSignatures.stringSignature;
                    var numberIndexSignature = allIndexSignatures.numericSignature;
                    var isNumericIndexer = numberIndexSignature === signature;

                    if (numberIndexSignature && stringIndexSignature && (isNumericIndexer || stringIndexSignature.getDeclarations()[0].getParentDecl() !== numberIndexSignature.getDeclarations()[0].getParentDecl())) {
                        var comparisonInfo = new TypeComparisonInfo();
                        var resolutionContext = new TypeScript.PullTypeResolutionContext(_this);
                        if (!_this.sourceIsSubtypeOfTarget(numberIndexSignature.returnType, stringIndexSignature.returnType, resolutionContext, comparisonInfo)) {
                            if (comparisonInfo.message) {
                                context.postError(_this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2, [numberIndexSignature.returnType.toString(), stringIndexSignature.returnType.toString(), comparisonInfo.message]);
                            } else {
                                context.postError(_this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1, [numberIndexSignature.returnType.toString(), stringIndexSignature.returnType.toString()]);
                            }
                        }
                    }

                    var allMembers = parentSymbol.type.getAllMembers(TypeScript.PullElementKind.All, 0 /* all */);
                    for (var i = 0; i < allMembers.length; i++) {
                        var name = allMembers[i].name;
                        if (name) {
                            if (!allMembers[i].isResolved) {
                                _this.resolveDeclaredSymbol(allMembers[i], context);
                            }

                            if (parentSymbol !== allMembers[i].getContainer()) {
                                var isMemberNumeric = TypeScript.PullHelpers.isNameNumeric(name);
                                var indexerKindMatchesMemberNameKind = isNumericIndexer === isMemberNumeric;
                                var onlyStringIndexerIsPresent = !numberIndexSignature;

                                if (indexerKindMatchesMemberNameKind || onlyStringIndexerIsPresent) {
                                    _this.checkThatMemberIsSubtypeOfIndexer(allMembers[i], signature, funcDeclAST, context, enclosingDecl, isNumericIndexer);
                                }
                            }
                        }
                    }
                }

                _this.setUnitPath(currentUnitPath);
            });
        };

        PullTypeResolver.prototype.resolveReturnTypeAnnotationOfFunctionDeclaration = function (funcDeclAST, context) {
            var returnTypeSymbol = null;

            if (funcDeclAST.returnTypeAnnotation) {
                var funcDecl = this.getDeclForAST(funcDeclAST);

                returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context);

                if (!returnTypeSymbol) {
                    context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null);
                } else {
                    var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */);
                    if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                        context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void, null);
                    }
                }
            }

            return returnTypeSymbol;
        };

        PullTypeResolver.prototype.resolveAnyFunctionDeclaration = function (funcDecl, inContextuallyTypedAssignment, enclosingDecl, context) {
            context.jumpRecordStack.push(new TypeScript.JumpRecord());

            var result;
            if (funcDecl.isGetAccessor()) {
                result = this.resolveGetAccessorDeclaration(funcDecl, context);
            } else if (funcDecl.isSetAccessor()) {
                result = this.resolveSetAccessorDeclaration(funcDecl, context);
            } else if (inContextuallyTypedAssignment || (funcDecl.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDecl.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                result = this.resolveAnyFunctionExpression(funcDecl, funcDecl.typeParameters, funcDecl.parameters, funcDecl.returnTypeAnnotation, funcDecl.block, inContextuallyTypedAssignment, enclosingDecl, context);
            } else {
                result = this.resolveFunctionDeclaration(funcDecl, context);
            }

            context.jumpRecordStack.pop();

            return result;
        };

        PullTypeResolver.prototype.resolveArrowFunctionExpression = function (funcDecl, inContextuallyTypedAssignment, enclosingDecl, context) {
            return this.resolveAnyFunctionExpression(funcDecl, funcDecl.typeParameters, funcDecl.parameters, funcDecl.returnTypeAnnotation, funcDecl.block, inContextuallyTypedAssignment, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol();

            var signature = funcDecl.getSpecializingSignatureSymbol();

            var hadError = false;

            var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */);

            if (signature) {
                if (signature.isResolved) {
                    if (this.canTypeCheckAST(funcDeclAST, context)) {
                        this.typeCheckFunctionDeclaration(funcDeclAST, context);
                    }
                    return funcSymbol;
                }

                if (isConstructor && !signature.inResolution) {
                    var classAST = context.currentClassDeclaration;

                    if (classAST) {
                        var classDecl = this.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, context);
                        }
                    }
                }

                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    if (funcDeclAST.returnTypeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context);
                        if (!returnTypeSymbol) {
                            context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null);
                            signature.returnType = this.getNewErrorTypeSymbol();
                            hadError = true;
                        } else {
                            if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                                signature.hasAGenericParameter = true;
                                if (funcSymbol) {
                                    funcSymbol.type.setHasGenericSignature();
                                }
                            }
                            signature.returnType = returnTypeSymbol;

                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void, null);
                            }
                        }
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                if (funcDeclAST.typeParameters) {
                    for (var i = 0; i < funcDeclAST.typeParameters.members.length; i++) {
                        this.resolveTypeParameterDeclaration(funcDeclAST.typeParameters.members[i], context);
                    }
                }

                if (funcDeclAST.parameters) {
                    var prevInConstructorArguments = context.inConstructorArguments;
                    var prevInTypeCheck = context.inTypeCheck;
                    context.inConstructorArguments = isConstructor;
                    context.inTypeCheck = false;
                    var hasDefaultArgs = (funcDecl.flags & 33554432 /* HasDefaultArgs */) !== 0;
                    if (hasDefaultArgs) {
                        context.pushParameterIndexContext(funcDeclAST);
                    }
                    for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                        this.resolveParameter(funcDeclAST.parameters.members[i], context, funcDecl);
                        if (hasDefaultArgs) {
                            context.incrementParameterIndex();
                        }
                    }
                    if (hasDefaultArgs) {
                        context.popParameterIndexContext();
                    }
                    context.inConstructorArguments = prevInConstructorArguments;
                    context.inTypeCheck = prevInTypeCheck;
                }

                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.type.setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var prevReturnTypeSymbol = signature.returnType;

                    returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();
                        hadError = true;
                    } else if (!(this.isTypeArgumentOrWrapper(returnTypeSymbol) && prevReturnTypeSymbol && !this.isTypeArgumentOrWrapper(prevReturnTypeSymbol))) {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.hasAGenericParameter = true;

                            if (funcSymbol) {
                                funcSymbol.type.setHasGenericSignature();
                            }
                        }

                        signature.returnType = returnTypeSymbol;
                    }
                } else if (!funcDeclAST.isConstructor && !funcDeclAST.isConstructMember()) {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                        var parentDeclFlags = 0 /* None */;
                        if (TypeScript.hasFlag(funcDecl.kind, 65536 /* Method */) || TypeScript.hasFlag(funcDecl.kind, 32768 /* ConstructorMethod */)) {
                            var parentDecl = funcDecl.getParentDecl();
                            parentDeclFlags = parentDecl.flags;
                        }

                        if (this.compilationSettings.noImplicitAny && (!TypeScript.hasFlag(parentDeclFlags, 8 /* Ambient */) || (TypeScript.hasFlag(parentDeclFlags, 8 /* Ambient */) && !TypeScript.hasFlag(funcDecl.flags, 2 /* Private */)))) {
                            var funcDeclASTName = funcDeclAST.name;
                            if (funcDeclASTName) {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclASTName.actualText]);
                            } else {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, null);
                            }
                        }
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, funcDeclAST.block, signature, false, funcDecl, context);
                    }
                } else if (funcDeclAST.isConstructMember()) {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, null);
                        }
                    }
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (funcSymbol) {
                this.resolveOtherDeclarations(funcDeclAST, context);
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckFunctionDeclaration(funcDeclAST, context);
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.type;

            var signature = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (!accessorSymbol.type) {
                        accessorSymbol.type = signature.returnType;
                    }
                    return accessorSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    if (!accessorSymbol.type) {
                        accessorSymbol.type = signature.returnType;
                    }

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.parameters) {
                    for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                        this.resolveParameter(funcDeclAST.parameters.members[i], context, funcDecl);
                    }
                }

                if (signature.hasAGenericParameter) {
                    if (getterSymbol) {
                        getterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, context);

                    if (!returnTypeSymbol) {
                        signature.returnType = this.getNewErrorTypeSymbol();

                        hadError = true;
                    } else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.hasAGenericParameter = true;

                            if (getterSymbol) {
                                getterTypeSymbol.setHasGenericSignature();
                            }
                        }

                        signature.returnType = returnTypeSymbol;
                    }
                } else {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, funcDeclAST.block, signature, false, funcDecl, context);
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var accessorType = signature.returnType;

            var setter = accessorSymbol.getSetter();

            if (setter) {
                var setterType = setter.type;
                var setterSig = setterType.getCallSignatures()[0];

                if (setterSig.isResolved) {
                    var setterParameters = setterSig.parameters;

                    if (setterParameters.length) {
                        var setterParameter = setterParameters[0];
                        var setterParameterType = setterParameter.type;

                        if (!this.typesAreIdentical(accessorType, setterParameterType)) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type, null);
                            accessorSymbol.type = this.getNewErrorTypeSymbol();
                        }
                    }
                } else {
                    accessorSymbol.type = accessorType;
                }
            } else {
                accessorSymbol.type = accessorType;
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckGetAccessorDeclaration(funcDeclAST, context);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.typeCheckGetAccessorDeclaration = function (funcDeclAST, context) {
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            if (funcDeclAST.parameters) {
                for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                    this.resolveParameter(funcDeclAST.parameters.members[i], context, funcDecl);
                }
            }

            this.resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST, context);

            var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
            this.seenSuperConstructorCall = false;
            this.resolveAST(funcDeclAST.block, false, funcDecl, context);
            this.seenSuperConstructorCall = prevSeenSuperConstructorCall;

            this.validateVariableDeclarationGroups(funcDecl, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

            var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = !isGetter;

            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            var funcNameAST = funcDeclAST.name;

            if (!hasReturn) {
                if (!(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType() === 98 /* ThrowStatement */)) {
                    context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getters_must_return_a_value, null);
                }
            }

            if (getter && setter) {
                var getterDecl = getter.getDeclarations()[0];
                var setterDecl = setter.getDeclarations()[0];

                var getterIsPrivate = getterDecl.flags & 2 /* Private */;
                var setterIsPrivate = setterDecl.flags & 2 /* Private */;

                if (getterIsPrivate != setterIsPrivate) {
                    context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility, null);
                }
            }

            this.checkFunctionTypePrivacy(funcDeclAST, context);
        };

        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.type;

            var signature = funcDecl.getSpecializingSignatureSymbol();

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    if (!accessorSymbol.type) {
                        accessorSymbol.type = signature.parameters[0].type;
                    }
                    return accessorSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    if (!accessorSymbol.type) {
                        accessorSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.parameters) {
                    for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                        this.resolveParameter(funcDeclAST.parameters.members[i], context, funcDecl);
                    }
                }

                if (signature.hasAGenericParameter) {
                    if (setterSymbol) {
                        setterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var parameters = signature.parameters;

            var getter = accessorSymbol.getGetter();

            var accessorType = parameters.length ? parameters[0].type : getter ? getter.type : this.semanticInfoChain.undefinedTypeSymbol;

            if (getter) {
                var getterType = getter.type;
                var getterSig = getterType.getCallSignatures()[0];

                if (accessorType == this.semanticInfoChain.undefinedTypeSymbol) {
                    accessorType = getterType;
                }

                if (getterSig.isResolved) {
                    var getterReturnType = getterSig.returnType;

                    if (!this.typesAreIdentical(accessorType, getterReturnType)) {
                        if (this.isAnyOrEquivalent(accessorType)) {
                            accessorSymbol.type = getterReturnType;
                            if (!accessorType.isError()) {
                                parameters[0].type = getterReturnType;
                            }
                        } else {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type, null);
                            accessorSymbol.type = this.getNewErrorTypeSymbol();
                        }
                    }
                } else {
                    accessorSymbol.type = accessorType;
                }
            } else {
                accessorSymbol.type = accessorType;

                if (this.compilationSettings.noImplicitAny) {
                    if (accessorSymbol.type == this.semanticInfoChain.anyTypeSymbol) {
                        context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclAST.name.actualText]);
                    }
                }
            }

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckSetAccessorDeclaration(funcDeclAST, context);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.typeCheckSetAccessorDeclaration = function (funcDeclAST, context) {
            this.setTypeChecked(funcDeclAST, context);

            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            if (funcDeclAST.parameters) {
                for (var i = 0; i < funcDeclAST.parameters.members.length; i++) {
                    this.resolveParameter(funcDeclAST.parameters.members[i], context, funcDecl);
                }
            }

            var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
            this.seenSuperConstructorCall = false;
            this.resolveAST(funcDeclAST.block, false, funcDecl, context);
            this.seenSuperConstructorCall = prevSeenSuperConstructorCall;

            this.validateVariableDeclarationGroups(funcDecl, context);

            var enclosingDecl = this.getEnclosingDecl(funcDecl);

            var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

            var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = !isGetter;

            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            var funcNameAST = funcDeclAST.name;

            if (getter && setter) {
                var getterDecl = getter.getDeclarations()[0];
                var setterDecl = setter.getDeclarations()[0];

                var getterIsPrivate = getterDecl.flags & 2 /* Private */;
                var setterIsPrivate = setterDecl.flags & 2 /* Private */;

                if (getterIsPrivate != setterIsPrivate) {
                    context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility, null);
                }
            }

            this.checkFunctionTypePrivacy(funcDeclAST, context);
        };

        PullTypeResolver.prototype.resolveList = function (list, enclosingDecl, context) {
            if (this.canTypeCheckAST(list, context)) {
                this.setTypeChecked(list, context);

                for (var i = 0; i < list.members.length; i++) {
                    this.resolveAST(list.members[i], false, enclosingDecl, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVoidExpression = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckVoidExpression(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.undefinedTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckVoidExpression = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.operand, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveLogicalOperation = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLogicalOperation(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckLogicalOperation = function (binex, enclosingDecl, context) {
            this.setTypeChecked(binex, context);

            var leftType = this.resolveAST(binex.operand1, false, enclosingDecl, context).type;
            var rightType = this.resolveAST(binex.operand2, false, enclosingDecl, context).type;

            var comparisonInfo = new TypeComparisonInfo();
            if (!this.sourceIsAssignableToTarget(leftType, rightType, context, comparisonInfo) && !this.sourceIsAssignableToTarget(rightType, leftType, context, comparisonInfo)) {
                context.postError(this.unitPath, binex.minChar, binex.getLength(), TypeScript.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, [TypeScript.BinaryExpression.getTextForBinaryToken(binex.nodeType()), leftType.toString(), rightType.toString()]);
            }
        };

        PullTypeResolver.prototype.resolveUnaryLogicalOperation = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckUnaryLogicalOperation(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckUnaryLogicalOperation = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.operand, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveUnaryArithmeticOperation = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckUnaryArithmeticOperation(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.isAnyOrNumberOrEnum = function (type) {
            return this.isAnyOrEquivalent(type) || type === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(type);
        };

        PullTypeResolver.prototype.typeCheckUnaryArithmeticOperation = function (unaryExpression, enclosingDecl, context) {
            this.setTypeChecked(unaryExpression, context);

            var nodeType = unaryExpression.nodeType();
            var expression = this.resolveAST(unaryExpression.operand, false, enclosingDecl, context);

            if (nodeType == 28 /* PlusExpression */ || nodeType == 29 /* NegateExpression */ || nodeType == 74 /* BitwiseNotExpression */) {
                return;
            }

            TypeScript.Debug.assert(nodeType === 78 /* PostIncrementExpression */ || nodeType === 76 /* PreIncrementExpression */ || nodeType === 79 /* PostDecrementExpression */ || nodeType === 77 /* PreDecrementExpression */);

            var operandType = expression.type;
            if (!this.isAnyOrNumberOrEnum(operandType)) {
                context.postError(this.unitPath, unaryExpression.operand.minChar, unaryExpression.operand.getLength(), TypeScript.DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type, null);
            }

            if (!this.isReference(unaryExpression.operand, expression)) {
                context.postError(this.unitPath, unaryExpression.operand.minChar, unaryExpression.operand.getLength(), TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, null);
            }
        };

        PullTypeResolver.prototype.resolveBinaryArithmeticExpression = function (binaryExpression, enclosingDecl, context) {
            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.typeCheckBinaryArithmeticExpression(binaryExpression, enclosingDecl, context);
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckBinaryArithmeticExpression = function (binaryExpression, enclosingDecl, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsSymbol = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);

            var lhsType = lhsSymbol.type;
            var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

            if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                lhsType = rhsType;
            }

            if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                rhsType = lhsType;
            }

            var lhsIsFit = this.isAnyOrNumberOrEnum(lhsType);
            var rhsIsFit = this.isAnyOrNumberOrEnum(rhsType);

            if (!rhsIsFit) {
                context.postError(this.unitPath, binaryExpression.operand2.minChar, binaryExpression.operand2.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type, null);
            }

            if (!lhsIsFit) {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type, null);
            }

            if (lhsIsFit && rhsIsFit) {
                switch (binaryExpression.nodeType()) {
                    case 49 /* LeftShiftAssignmentExpression */:
                    case 50 /* SignedRightShiftAssignmentExpression */:
                    case 51 /* UnsignedRightShiftAssignmentExpression */:
                    case 42 /* SubtractAssignmentExpression */:
                    case 44 /* MultiplyAssignmentExpression */:
                    case 43 /* DivideAssignmentExpression */:
                    case 45 /* ModuloAssignmentExpression */:
                    case 48 /* OrAssignmentExpression */:
                    case 46 /* AndAssignmentExpression */:
                    case 47 /* ExclusiveOrAssignmentExpression */:
                        if (!this.isReference(binaryExpression.operand1, lhsSymbol)) {
                            context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null);
                        }

                        this.checkAssignability(binaryExpression.operand1, rhsType, lhsType, enclosingDecl, context);
                }
            }
        };

        PullTypeResolver.prototype.resolveTypeOfExpression = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckTypeOfExpression(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.stringTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckTypeOfExpression = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.operand, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveThrowStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckThrowStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckThrowStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.expression, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveDeleteExpression = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckDeleteExpression(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckDeleteExpression = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            this.resolveAST(ast.operand, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveInstanceOfExpression = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInstanceOfExpression(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckInstanceOfExpression = function (binaryExpression, enclosingDecl, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsType = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type;
            var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

            var isValidLHS = this.isAnyOrEquivalent(lhsType) || lhsType.isObject() || lhsType.isTypeParameter();
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || this.typeIsSubtypeOfFunction(rhsType, context);

            if (!isValidLHS) {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter, null);
            }

            if (!isValidRHS) {
                context.postError(this.unitPath, binaryExpression.operand2.minChar, binaryExpression.operand2.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type, null);
            }
        };

        PullTypeResolver.prototype.resolveCommaExpression = function (commaExpression, enclosingDecl, context) {
            var rhsType = this.resolveAST(commaExpression.operand2, false, enclosingDecl, context).type;

            if (this.canTypeCheckAST(commaExpression, context)) {
                this.typeCheckCommaExpression(commaExpression, enclosingDecl, context);
            }

            return rhsType;
        };

        PullTypeResolver.prototype.typeCheckCommaExpression = function (commaExpression, enclosingDecl, context) {
            this.setTypeChecked(commaExpression, context);

            this.resolveAST(commaExpression.operand1, false, enclosingDecl, context);
            this.resolveAST(commaExpression.operand2, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveInExpression = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckInExpression(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckInExpression = function (binaryExpression, enclosingDecl, context) {
            this.setTypeChecked(binaryExpression, context);

            var lhsType = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type;
            var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

            var isStringAnyOrNumber = lhsType.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(lhsType.type);
            var isValidRHS = this.isAnyOrEquivalent(rhsType) || rhsType.isObject() || rhsType.isTypeParameter();

            if (!isStringAnyOrNumber) {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_in_expression_must_be_of_types_string_or_any);
            }

            if (!isValidRHS) {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
        };

        PullTypeResolver.prototype.resolveForStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckForStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckForStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.init, false, enclosingDecl, context);
            this.resolveAST(ast.cond, false, enclosingDecl, context);
            this.resolveAST(ast.incr, false, enclosingDecl, context);

            var jumpRecord = context.currentJumpRecord();
            var savedInIterationStatement = jumpRecord.inIterationStatement;
            jumpRecord.inIterationStatement = true;
            this.resolveAST(ast.body, false, enclosingDecl, context);
            jumpRecord.inIterationStatement = savedInIterationStatement;
        };

        PullTypeResolver.prototype.resolveForInStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckForInStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckForInStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            var forInStatement = ast;

            var rhsType = this.resolveAST(forInStatement.obj, false, enclosingDecl, context).type;
            var lval = forInStatement.lval;

            if (lval.nodeType() === 20 /* VariableDeclaration */) {
                var declaration = forInStatement.lval;
                var varDecl = declaration.declarators.members[0];

                if (varDecl.typeExpr) {
                    context.postError(this.unitPath, lval.minChar, lval.getLength(), TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation, null);
                }
            }

            var varSym = this.resolveAST(forInStatement.lval, false, enclosingDecl, context);

            if (lval.nodeType() === 20 /* VariableDeclaration */) {
                varSym = this.getSymbolForAST(forInStatement.lval.declarators.members[0], context);
            }

            var isStringOrNumber = varSym.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(varSym.type);

            var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());

            if (!isStringOrNumber) {
                context.postError(this.unitPath, lval.minChar, lval.getLength(), TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any, null);
            }

            if (!isValidRHS) {
                context.postError(this.unitPath, forInStatement.obj.minChar, forInStatement.obj.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter, null);
            }

            var jumpRecord = context.currentJumpRecord();
            var savedInIterationStatement = jumpRecord.inIterationStatement;
            jumpRecord.inIterationStatement = true;
            this.resolveAST(forInStatement.body, false, enclosingDecl, context);
            jumpRecord.inIterationStatement = savedInIterationStatement;
        };

        PullTypeResolver.prototype.resolveWhileStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWhileStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckWhileStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.cond, false, enclosingDecl, context);

            var jumpRecord = context.currentJumpRecord();
            var savedInIterationStatement = jumpRecord.inIterationStatement;
            jumpRecord.inIterationStatement = true;
            this.resolveAST(ast.body, false, enclosingDecl, context);
            jumpRecord.inIterationStatement = savedInIterationStatement;
        };

        PullTypeResolver.prototype.resolveDoStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckDoStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckDoStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.cond, false, enclosingDecl, context);

            var jumpRecord = context.currentJumpRecord();
            var savedInIterationStatement = jumpRecord.inIterationStatement;
            jumpRecord.inIterationStatement = true;
            this.resolveAST(ast.body, false, enclosingDecl, context);
            jumpRecord.inIterationStatement = savedInIterationStatement;
        };

        PullTypeResolver.prototype.resolveIfStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckIfStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckIfStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.cond, false, enclosingDecl, context);
            this.resolveAST(ast.thenBod, false, enclosingDecl, context);
            this.resolveAST(ast.elseBod, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveBlock = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.statements, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.declaration, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableDeclarationList = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.setTypeChecked(ast, context);
                this.resolveAST(ast.declarators, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveWithStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckWithStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckWithStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            var withStatement = ast;
            context.postError(this.unitPath, withStatement.expr.minChar, withStatement.expr.getLength(), TypeScript.DiagnosticCode.All_symbols_within_a_with_block_will_be_resolved_to_any, null);
        };

        PullTypeResolver.prototype.resolveTryStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckTryStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckTryStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            var tryStatement = ast;

            this.resolveAST(tryStatement.tryBody, false, enclosingDecl, context);
            this.resolveAST(tryStatement.catchClause, false, enclosingDecl, context);
            this.resolveAST(tryStatement.finallyBody, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveCatchClause = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckCatchClause(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckCatchClause = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);
            var catchDecl = this.getDeclForAST(ast);
            this.resolveAST(ast.body, false, catchDecl, context);
            this.validateVariableDeclarationGroups(catchDecl, context);
        };

        PullTypeResolver.prototype.resolveReturnStatement = function (ast, enclosingDecl, context) {
            var parentDecl = enclosingDecl;
            var returnAST = ast;
            var returnExpr = returnAST.returnExpression;

            var returnType = this.getSymbolForAST(ast, context);
            var canTypeCheckAST = this.canTypeCheckAST(ast, context);
            var inContextuallyTypedAssignment = false;
            if (!returnType || canTypeCheckAST) {
                while (parentDecl) {
                    if (parentDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                        parentDecl.setFlag(4194304 /* HasReturnStatement */);
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                var inContextuallyTypedAssignment = false;
                var enclosingDeclAST;

                if (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                    enclosingDeclAST = this.getASTForDecl(enclosingDecl);
                    if (enclosingDeclAST.returnTypeAnnotation) {
                        var returnTypeAnnotationSymbol = this.resolveTypeReference(enclosingDeclAST.returnTypeAnnotation, enclosingDecl, context);
                        if (returnTypeAnnotationSymbol) {
                            inContextuallyTypedAssignment = true;
                            context.pushContextualType(returnTypeAnnotationSymbol, context.inProvisionalResolution(), null);
                        }
                    } else {
                        var currentContextualType = context.getContextualType();
                        if (currentContextualType && currentContextualType.isFunction()) {
                            var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                            var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                            if (currentContextualTypeReturnTypeSymbol) {
                                inContextuallyTypedAssignment = true;
                                context.pushContextualType(currentContextualTypeReturnTypeSymbol, context.inProvisionalResolution(), null);
                            }
                        }
                    }
                }

                var resolvedReturnType = returnExpr ? this.resolveAST(returnExpr, inContextuallyTypedAssignment, enclosingDecl, context).type : this.semanticInfoChain.voidTypeSymbol;
                if (inContextuallyTypedAssignment) {
                    context.popContextualType();
                }

                if (!returnType) {
                    returnType = resolvedReturnType;
                    this.setSymbolForAST(ast, resolvedReturnType, context);
                }

                if (returnExpr && canTypeCheckAST) {
                    this.setTypeChecked(ast, context);

                    if (parentDecl && parentDecl.kind === 32768 /* ConstructorMethod */) {
                        var classDecl = parentDecl.getParentDecl();
                        if (classDecl) {
                            var classSymbol = classDecl.getSymbol();
                            this.resolveDeclaredSymbol(classSymbol, context);

                            var comparisonInfo = new TypeComparisonInfo();
                            var isAssignable = this.sourceIsAssignableToTarget(resolvedReturnType, classSymbol.type, context, comparisonInfo);
                            if (!isAssignable) {
                                context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class, null);
                            }
                        }
                    }

                    if (enclosingDecl.kind === 524288 /* SetAccessor */) {
                        context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Setters_cannot_return_a_value, null);
                    }

                    if (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                        var enclosingDeclAST = this.getASTForDecl(enclosingDecl);

                        if (enclosingDeclAST.returnTypeAnnotation) {
                            var signatureSymbol = enclosingDecl.getSignatureSymbol();
                            var sigReturnType = signatureSymbol.returnType;

                            if (resolvedReturnType && sigReturnType) {
                                var comparisonInfo = new TypeComparisonInfo();
                                var upperBound = null;

                                if (resolvedReturnType.isTypeParameter()) {
                                    upperBound = resolvedReturnType.getConstraint();

                                    if (upperBound) {
                                        resolvedReturnType = upperBound;
                                    }
                                }

                                if (sigReturnType.isTypeParameter()) {
                                    upperBound = sigReturnType.getConstraint();

                                    if (upperBound) {
                                        sigReturnType = upperBound;
                                    }
                                }

                                this.resolveDeclaredSymbol(resolvedReturnType, context);
                                this.resolveDeclaredSymbol(sigReturnType, context);

                                var isAssignable = this.sourceIsAssignableToTarget(resolvedReturnType, sigReturnType, context, comparisonInfo);

                                if (!isAssignable) {
                                    if (comparisonInfo.message) {
                                        context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [resolvedReturnType.toString(), sigReturnType.toString(), comparisonInfo.message]);
                                    } else {
                                        context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [resolvedReturnType.toString(), sigReturnType.toString()]);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveSwitchStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSwitchStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckSwitchStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            var switchStatement = ast;

            var expressionType = this.resolveAST(switchStatement.val, false, enclosingDecl, context).type;

            var jumpRecord = context.currentJumpRecord();
            var savedInSwitchStatement = jumpRecord.inSwitchStatement;
            jumpRecord.inSwitchStatement = true;

            this.resolveAST(switchStatement.caseList, false, enclosingDecl, context);
            this.resolveAST(switchStatement.defaultCase, false, enclosingDecl, context);

            jumpRecord.inSwitchStatement = savedInSwitchStatement;

            if (switchStatement.caseList && switchStatement.caseList.members) {
                for (var i = 0, n = switchStatement.caseList.members.length; i < n; i++) {
                    var caseClause = switchStatement.caseList.members[i];
                    if (caseClause !== switchStatement.defaultCase) {
                        var caseClauseExpressionType = this.resolveAST(caseClause.expr, false, enclosingDecl, context).type;

                        var comparisonInfo = new TypeComparisonInfo();
                        if (!this.sourceIsAssignableToTarget(expressionType, caseClauseExpressionType, context, comparisonInfo) && !this.sourceIsAssignableToTarget(caseClauseExpressionType, expressionType, context, comparisonInfo)) {
                            if (comparisonInfo.message) {
                                context.postError(this.unitPath, caseClause.expr.minChar, caseClause.expr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [caseClauseExpressionType.toString(), expressionType.toString(), comparisonInfo.message]);
                            } else {
                                context.postError(this.unitPath, caseClause.expr.minChar, caseClause.expr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [caseClauseExpressionType.toString(), expressionType.toString()]);
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveCaseClause = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckCaseClause(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckCaseClause = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.expr, false, enclosingDecl, context);
            this.resolveAST(ast.body, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveLabeledStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckLabeledStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckLabeledStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            var labelIdentifier = ast.identifier.text();
            var jumpRecord = context.currentJumpRecord();

            var breakableLabels = jumpRecord.breakableLabels;
            var continuableLabels = jumpRecord.continuableLabels;

            if (TypeScript.ArrayUtilities.contains(breakableLabels, labelIdentifier)) {
                context.postError(this.unitPath, ast.identifier.minChar, ast.identifier.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [labelIdentifier]);
            }

            breakableLabels.push(labelIdentifier);

            var isContinuableLabel = this.labelIsOnContinuableConstruct(ast.statement);
            if (isContinuableLabel) {
                continuableLabels.push(labelIdentifier);
            }

            this.resolveAST(ast.statement, false, enclosingDecl, context);

            breakableLabels.pop();

            if (isContinuableLabel) {
                continuableLabels.pop();
            }
        };

        PullTypeResolver.prototype.labelIsOnContinuableConstruct = function (statement) {
            switch (statement.nodeType()) {
                case 95 /* LabeledStatement */:
                    return this.labelIsOnContinuableConstruct(statement.statement);

                case 101 /* WhileStatement */:
                case 93 /* ForStatement */:
                case 92 /* ForInStatement */:
                case 88 /* DoStatement */:
                    return true;

                default:
                    return false;
            }
        };

        PullTypeResolver.prototype.resolveContinueStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckContinueStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckContinueStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            var jumpRecord = context.currentJumpRecord();
            if (!jumpRecord.inIterationStatement) {
                context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
            } else if (ast.target) {
                var continuableLabels = jumpRecord.continuableLabels;

                if (!TypeScript.ArrayUtilities.contains(continuableLabels, ast.target)) {
                    if (TypeScript.ArrayUtilities.any(context.jumpRecordStack, function (jr) {
                        return TypeScript.ArrayUtilities.contains(jr.continuableLabels, ast.target);
                    })) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    } else {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveBreakStatement = function (ast, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckBreakStatement(ast, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckBreakStatement = function (ast, context) {
            this.setTypeChecked(ast, context);

            var jumpRecord = context.currentJumpRecord();
            if (ast.target) {
                var breakableLabels = jumpRecord.breakableLabels;

                if (!TypeScript.ArrayUtilities.contains(breakableLabels, ast.target)) {
                    if (TypeScript.ArrayUtilities.any(context.jumpRecordStack, function (jr) {
                        return TypeScript.ArrayUtilities.contains(jr.breakableLabels, ast.target);
                    })) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    } else {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                }
            } else if (!jumpRecord.inIterationStatement && !jumpRecord.inSwitchStatement) {
                context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
            }
        };

        PullTypeResolver.prototype.resolveAST = function (ast, inContextuallyTypedAssignment, enclosingDecl, context, specializingSignature) {
            if (typeof specializingSignature === "undefined") { specializingSignature = false; }
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;

            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (!ast) {
                return;
            }

            var symbol = specializingSignature ? null : this.getSymbolForAST(ast, context);
            if (symbol && symbol.isResolved) {
                this.typeCheckAST(ast, inContextuallyTypedAssignment, enclosingDecl, context);
                return symbol;
            }

            var nodeType = ast.nodeType();

            switch (nodeType) {
                case 1 /* List */:
                    return this.resolveList(ast, enclosingDecl, context);

                case 2 /* Script */:
                    return this.resolveScript(ast, enclosingDecl, context);

                case 17 /* ModuleDeclaration */:
                    return this.resolveModuleDeclaration(ast, context);

                case 15 /* InterfaceDeclaration */:
                    return this.resolveInterfaceDeclaration(ast, context);

                case 14 /* ClassDeclaration */:
                    return this.resolveClassDeclaration(ast, context);

                case 20 /* VariableDeclaration */:
                    return this.resolveVariableDeclarationList(ast, enclosingDecl, context);

                case 19 /* VariableDeclarator */:
                    return this.resolveVariableDeclarator(ast, context, enclosingDecl);

                case 21 /* Parameter */:
                    return this.resolveParameter(ast, context, enclosingDecl);

                case 9 /* TypeParameter */:
                    return this.resolveTypeParameterDeclaration(ast, context);

                case 18 /* ImportDeclaration */:
                    return this.resolveImportDeclaration(ast, context);

                case 24 /* ObjectLiteralExpression */:
                    return this.resolveObjectLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 22 /* Name */:
                    if (context.resolvingTypeReference) {
                        return this.resolveTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(ast, enclosingDecl, context);
                    }

                case 34 /* MemberAccessExpression */:
                    if (context.resolvingTypeReference) {
                        return this.resolveDottedTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(ast, enclosingDecl, context);
                    }

                case 13 /* FunctionDeclaration */:
                    return this.resolveAnyFunctionDeclaration(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 82 /* ArrowFunctionExpression */:
                    return this.resolveArrowFunctionExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 23 /* ArrayLiteralExpression */:
                    return this.resolveArrayLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 31 /* ThisExpression */:
                    return this.resolveThisExpression(ast, enclosingDecl, context);

                case 32 /* SuperExpression */:
                    return this.resolveSuperExpression(ast, enclosingDecl, context);

                case 38 /* InvocationExpression */:
                    return this.resolveInvocationExpression(ast, enclosingDecl, context);

                case 39 /* ObjectCreationExpression */:
                    return this.resolveObjectCreationExpression(ast, enclosingDecl, context);

                case 80 /* CastExpression */:
                    return this.resolveCastExpression(ast, enclosingDecl, context);

                case 11 /* TypeRef */:
                    return this.resolveTypeReference(ast, enclosingDecl, context);

                case 90 /* ExportAssignment */:
                    return this.resolveExportAssignmentStatement(ast, enclosingDecl, context);

                case 7 /* NumericLiteral */:
                    return this.semanticInfoChain.numberTypeSymbol;
                case 5 /* StringLiteral */:
                    return this.semanticInfoChain.stringTypeSymbol;
                case 8 /* NullLiteral */:
                    return this.semanticInfoChain.nullTypeSymbol;
                case 3 /* TrueLiteral */:
                case 4 /* FalseLiteral */:
                    return this.semanticInfoChain.booleanTypeSymbol;

                case 26 /* VoidExpression */:
                    return this.resolveVoidExpression(ast, enclosingDecl, context);

                case 40 /* AssignmentExpression */:
                    return this.resolveAssignmentExpression(ast, enclosingDecl, context);

                case 75 /* LogicalNotExpression */:
                    return this.resolveUnaryLogicalOperation(ast, enclosingDecl, context);

                case 59 /* NotEqualsWithTypeConversionExpression */:
                case 58 /* EqualsWithTypeConversionExpression */:
                case 60 /* EqualsExpression */:
                case 61 /* NotEqualsExpression */:
                case 62 /* LessThanExpression */:
                case 63 /* LessThanOrEqualExpression */:
                case 65 /* GreaterThanOrEqualExpression */:
                case 64 /* GreaterThanExpression */:
                    return this.resolveLogicalOperation(ast, enclosingDecl, context);

                case 66 /* AddExpression */:
                case 41 /* AddAssignmentExpression */:
                    return this.resolveBinaryAdditionOperation(ast, enclosingDecl, context);

                case 28 /* PlusExpression */:
                case 29 /* NegateExpression */:
                case 74 /* BitwiseNotExpression */:
                case 78 /* PostIncrementExpression */:
                case 76 /* PreIncrementExpression */:
                case 79 /* PostDecrementExpression */:
                case 77 /* PreDecrementExpression */:
                    return this.resolveUnaryArithmeticOperation(ast, enclosingDecl, context);

                case 67 /* SubtractExpression */:
                case 68 /* MultiplyExpression */:
                case 69 /* DivideExpression */:
                case 70 /* ModuloExpression */:
                case 55 /* BitwiseOrExpression */:
                case 57 /* BitwiseAndExpression */:
                case 71 /* LeftShiftExpression */:
                case 72 /* SignedRightShiftExpression */:
                case 73 /* UnsignedRightShiftExpression */:
                case 56 /* BitwiseExclusiveOrExpression */:
                case 47 /* ExclusiveOrAssignmentExpression */:
                case 49 /* LeftShiftAssignmentExpression */:
                case 50 /* SignedRightShiftAssignmentExpression */:
                case 51 /* UnsignedRightShiftAssignmentExpression */:
                case 42 /* SubtractAssignmentExpression */:
                case 44 /* MultiplyAssignmentExpression */:
                case 43 /* DivideAssignmentExpression */:
                case 45 /* ModuloAssignmentExpression */:
                case 48 /* OrAssignmentExpression */:
                case 46 /* AndAssignmentExpression */:
                    return this.resolveBinaryArithmeticExpression(ast, enclosingDecl, context);

                case 37 /* ElementAccessExpression */:
                    return this.resolveIndexExpression(ast, enclosingDecl, context);

                case 53 /* LogicalOrExpression */:
                    return this.resolveLogicalOrExpression(ast, enclosingDecl, context);

                case 54 /* LogicalAndExpression */:
                    return this.resolveLogicalAndExpression(ast, enclosingDecl, context);

                case 36 /* TypeOfExpression */:
                    return this.resolveTypeOfExpression(ast, enclosingDecl, context);

                case 98 /* ThrowStatement */:
                    return this.resolveThrowStatement(ast, enclosingDecl, context);

                case 30 /* DeleteExpression */:
                    return this.resolveDeleteExpression(ast, enclosingDecl, context);

                case 52 /* ConditionalExpression */:
                    return this.resolveConditionalExpression(ast, enclosingDecl, context);

                case 6 /* RegularExpressionLiteral */:
                    return this.resolveRegularExpressionLiteral();

                case 81 /* ParenthesizedExpression */:
                    return this.resolveParenthesizedExpression(ast, enclosingDecl, context);

                case 91 /* ExpressionStatement */:
                    return this.resolveExpressionStatement(ast, enclosingDecl, context);

                case 35 /* InstanceOfExpression */:
                    return this.resolveInstanceOfExpression(ast, enclosingDecl, context);

                case 27 /* CommaExpression */:
                    return this.resolveCommaExpression(ast, enclosingDecl, context);

                case 33 /* InExpression */:
                    return this.resolveInExpression(ast, enclosingDecl, context);

                case 93 /* ForStatement */:
                    return this.resolveForStatement(ast, enclosingDecl, context);

                case 92 /* ForInStatement */:
                    return this.resolveForInStatement(ast, enclosingDecl, context);

                case 101 /* WhileStatement */:
                    return this.resolveWhileStatement(ast, enclosingDecl, context);

                case 88 /* DoStatement */:
                    return this.resolveDoStatement(ast, enclosingDecl, context);

                case 94 /* IfStatement */:
                    return this.resolveIfStatement(ast, enclosingDecl, context);

                case 84 /* Block */:
                    return this.resolveBlock(ast, enclosingDecl, context);

                case 100 /* VariableStatement */:
                    return this.resolveVariableStatement(ast, enclosingDecl, context);

                case 102 /* WithStatement */:
                    return this.resolveWithStatement(ast, enclosingDecl, context);

                case 99 /* TryStatement */:
                    return this.resolveTryStatement(ast, enclosingDecl, context);

                case 104 /* CatchClause */:
                    return this.resolveCatchClause(ast, enclosingDecl, context);

                case 96 /* ReturnStatement */:
                    return this.resolveReturnStatement(ast, enclosingDecl, context);

                case 97 /* SwitchStatement */:
                    return this.resolveSwitchStatement(ast, enclosingDecl, context);

                case 86 /* ContinueStatement */:
                    return this.resolveContinueStatement(ast, context);

                case 85 /* BreakStatement */:
                    return this.resolveBreakStatement(ast, context);

                case 103 /* CaseClause */:
                    return this.resolveCaseClause(ast, enclosingDecl, context);

                case 95 /* LabeledStatement */:
                    return this.resolveLabeledStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckAST = function (ast, inContextuallyTypedAssignment, enclosingDecl, context) {
            if (!this.canTypeCheckAST(ast, context)) {
                return;
            }

            var nodeType = ast.nodeType();
            switch (nodeType) {
                case 2 /* Script */:
                    return;

                case 17 /* ModuleDeclaration */:
                    this.typeCheckModuleDeclaration(ast, context);
                    return;

                case 15 /* InterfaceDeclaration */:
                    this.typeCheckInterfaceDeclaration(ast, context);
                    return;

                case 14 /* ClassDeclaration */:
                    this.typeCheckClassDeclaration(ast, context);
                    return;

                case 19 /* VariableDeclarator */:
                    this.typeCheckVariableDeclarator(ast, context, enclosingDecl);
                    return;

                case 21 /* Parameter */:
                    this.typeCheckParameter(ast, context, enclosingDecl);
                    return;

                case 9 /* TypeParameter */:
                    this.typeCheckTypeParameterDeclaration(ast, context);
                    return;

                case 18 /* ImportDeclaration */:
                    this.typeCheckImportDeclaration(ast, context);
                    return;

                case 24 /* ObjectLiteralExpression */:
                    this.resolveObjectLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);
                    return;

                case 10 /* GenericType */:
                    this.resolveGenericTypeReference(ast, enclosingDecl, context);
                    return;

                case 22 /* Name */:
                    if (context.resolvingTypeReference) {
                        this.resolveTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        this.resolveNameExpression(ast, enclosingDecl, context);
                    }
                    return;

                case 34 /* MemberAccessExpression */:
                    if (context.resolvingTypeReference) {
                        this.resolveDottedTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        this.resolveDottedNameExpression(ast, enclosingDecl, context);
                    }
                    return;

                case 13 /* FunctionDeclaration */: {
                    var funcDecl = ast;
                    if (funcDecl.isGetAccessor()) {
                        this.typeCheckGetAccessorDeclaration(funcDecl, context);
                    } else if (funcDecl.isSetAccessor()) {
                        this.typeCheckSetAccessorDeclaration(funcDecl, context);
                    } else if (inContextuallyTypedAssignment || (funcDecl.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDecl.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                        this.typeCheckAnyFunctionExpression(funcDecl, funcDecl.typeParameters, funcDecl.returnTypeAnnotation, funcDecl.block, context);
                    } else {
                        this.typeCheckFunctionDeclaration(funcDecl, context);
                    }
                    return;
                }

                case 82 /* ArrowFunctionExpression */:
                    this.typeCheckArrowFunctionExpression(ast, context);
                    return;

                case 23 /* ArrayLiteralExpression */:
                    this.resolveArrayLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);
                    return;

                case 31 /* ThisExpression */:
                    this.typeCheckThisExpression(ast, enclosingDecl, context);
                    return;

                case 32 /* SuperExpression */:
                    this.typeCheckSuperExpression(ast, enclosingDecl, context);
                    return;

                case 38 /* InvocationExpression */:
                    this.typeCheckInvocationExpression(ast, enclosingDecl, context);
                    return;

                case 39 /* ObjectCreationExpression */:
                    this.typeCheckObjectCreationExpression(ast, enclosingDecl, context);
                    return;

                case 80 /* CastExpression */:
                    this.typeCheckCastExpression(ast, enclosingDecl, context);
                    return;

                case 11 /* TypeRef */:
                    this.resolveTypeReference(ast, enclosingDecl, context);
                    return;

                case 26 /* VoidExpression */:
                    this.typeCheckVoidExpression(ast, enclosingDecl, context);
                    return;

                case 75 /* LogicalNotExpression */:
                    this.typeCheckUnaryLogicalOperation(ast, enclosingDecl, context);
                    return;

                case 59 /* NotEqualsWithTypeConversionExpression */:
                case 58 /* EqualsWithTypeConversionExpression */:
                case 60 /* EqualsExpression */:
                case 61 /* NotEqualsExpression */:
                case 62 /* LessThanExpression */:
                case 63 /* LessThanOrEqualExpression */:
                case 65 /* GreaterThanOrEqualExpression */:
                case 64 /* GreaterThanExpression */:
                    this.typeCheckLogicalOperation(ast, enclosingDecl, context);
                    return;

                case 28 /* PlusExpression */:
                case 29 /* NegateExpression */:
                case 74 /* BitwiseNotExpression */:
                case 78 /* PostIncrementExpression */:
                case 76 /* PreIncrementExpression */:
                case 79 /* PostDecrementExpression */:
                case 77 /* PreDecrementExpression */:
                    this.typeCheckUnaryArithmeticOperation(ast, enclosingDecl, context);
                    return;

                case 67 /* SubtractExpression */:
                case 68 /* MultiplyExpression */:
                case 69 /* DivideExpression */:
                case 70 /* ModuloExpression */:
                case 55 /* BitwiseOrExpression */:
                case 57 /* BitwiseAndExpression */:
                case 71 /* LeftShiftExpression */:
                case 72 /* SignedRightShiftExpression */:
                case 73 /* UnsignedRightShiftExpression */:
                case 56 /* BitwiseExclusiveOrExpression */:
                case 47 /* ExclusiveOrAssignmentExpression */:
                case 49 /* LeftShiftAssignmentExpression */:
                case 50 /* SignedRightShiftAssignmentExpression */:
                case 51 /* UnsignedRightShiftAssignmentExpression */:
                case 42 /* SubtractAssignmentExpression */:
                case 44 /* MultiplyAssignmentExpression */:
                case 43 /* DivideAssignmentExpression */:
                case 45 /* ModuloAssignmentExpression */:
                case 48 /* OrAssignmentExpression */:
                case 46 /* AndAssignmentExpression */:
                    this.typeCheckBinaryArithmeticExpression(ast, enclosingDecl, context);
                    return;

                case 37 /* ElementAccessExpression */:
                    this.typeCheckIndexExpression(ast, enclosingDecl, context);
                    return;

                case 53 /* LogicalOrExpression */:
                    this.typeCheckLogicalOrExpression(ast, enclosingDecl, context);
                    return;

                case 36 /* TypeOfExpression */:
                    this.typeCheckTypeOfExpression(ast, enclosingDecl, context);
                    return;

                case 98 /* ThrowStatement */:
                    this.typeCheckThrowStatement(ast, enclosingDecl, context);
                    return;

                case 30 /* DeleteExpression */:
                    this.typeCheckDeleteExpression(ast, enclosingDecl, context);
                    return;

                case 52 /* ConditionalExpression */:
                    this.typeCheckConditionalExpression(ast, enclosingDecl, context);
                    return;

                case 35 /* InstanceOfExpression */:
                    this.typeCheckInstanceOfExpression(ast, enclosingDecl, context);
                    return;

                case 27 /* CommaExpression */:
                    this.typeCheckCommaExpression(ast, enclosingDecl, context);
                    return;

                case 33 /* InExpression */:
                    this.typeCheckInExpression(ast, enclosingDecl, context);
                    return;

                case 93 /* ForStatement */:
                    this.typeCheckForStatement(ast, enclosingDecl, context);
                    return;

                case 92 /* ForInStatement */:
                    this.typeCheckForInStatement(ast, enclosingDecl, context);
                    return;

                case 101 /* WhileStatement */:
                    this.typeCheckWhileStatement(ast, enclosingDecl, context);
                    return;

                case 88 /* DoStatement */:
                    this.typeCheckDoStatement(ast, enclosingDecl, context);
                    return;

                case 94 /* IfStatement */:
                    this.typeCheckIfStatement(ast, enclosingDecl, context);
                    return;

                case 102 /* WithStatement */:
                    this.typeCheckWithStatement(ast, enclosingDecl, context);
                    return;

                case 99 /* TryStatement */:
                    this.typeCheckTryStatement(ast, enclosingDecl, context);
                    return;

                case 104 /* CatchClause */:
                    this.typeCheckCatchClause(ast, enclosingDecl, context);
                    return;

                case 96 /* ReturnStatement */:
                    this.resolveReturnStatement(ast, enclosingDecl, context);
                    return;

                case 97 /* SwitchStatement */:
                    this.typeCheckSwitchStatement(ast, enclosingDecl, context);
                    return;

                case 103 /* CaseClause */:
                    this.typeCheckCaseClause(ast, enclosingDecl, context);
                    return;

                default:
                    TypeScript.Debug.assert(false, "Implement typeCheck clause if symbol is cached");
            }
        };

        PullTypeResolver.prototype.processPostTypeCheckWorkItems = function (context) {
            while (PullTypeResolver.postTypeCheckWorkitems.length) {
                var workItem = PullTypeResolver.postTypeCheckWorkitems.pop();
                this.postTypeCheck(workItem.ast, workItem.enclosingDecl, context);
            }
        };

        PullTypeResolver.prototype.postTypeCheck = function (ast, enclosingDecl, context) {
            var nodeType = ast.nodeType();

            switch (nodeType) {
                case 21 /* Parameter */:
                case 19 /* VariableDeclarator */:
                    this.postTypeCheckVariableDeclaratorOrParameter(ast, enclosingDecl, context);
                    return;

                case 14 /* ClassDeclaration */:
                    this.postTypeCheckClassDeclaration(ast, enclosingDecl, context);
                    return;

                case 22 /* Name */:
                    this.postTypeCheckNameExpression(ast, enclosingDecl, context);
                    return;

                default:
                    TypeScript.Debug.assert(false, "Implement postTypeCheck clause to handle the postTypeCheck work");
            }
        };

        PullTypeResolver.prototype.resolveRegularExpressionLiteral = function () {
            if (this.cachedRegExpInterfaceType()) {
                return this.cachedRegExpInterfaceType();
            } else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        };

        PullTypeResolver.prototype.resolveNameSymbol = function (nameSymbol, context) {
            if (nameSymbol && !context.canUseTypeSymbol && nameSymbol != this.semanticInfoChain.undefinedTypeSymbol && nameSymbol != this.semanticInfoChain.nullTypeSymbol && (nameSymbol.isPrimitive() || !(nameSymbol.kind & TypeScript.PullElementKind.SomeValue))) {
                var valueSymbol = nameSymbol.isAlias() ? nameSymbol.getExportAssignedValueSymbol() : null;
                if (valueSymbol) {
                    nameSymbol = valueSymbol;
                } else {
                    nameSymbol = null;
                }
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.postTypeCheckNameExpression = function (nameAST, enclosingDecl, context) {
            this.checkThisCaptureVariableCollides(nameAST, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.typeCheckNameExpression = function (nameAST, enclosingDecl, context) {
            this.setTypeChecked(nameAST, context);
            this.checkNameForCompilerGeneratedDeclarationCollision(nameAST, false, nameAST, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, enclosingDecl, context) {
            var nameSymbol = this.getSymbolForAST(nameAST, context);
            var foundCached = nameSymbol != null;

            if (!foundCached || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.typeCheckNameExpression(nameAST, enclosingDecl, context);
                }
                nameSymbol = this.computeNameExpression(nameAST, enclosingDecl, context);
            }

            this.resolveDeclaredSymbol(nameSymbol, context);

            if (nameSymbol && (nameSymbol.type != this.semanticInfoChain.anyTypeSymbol || nameSymbol.hasFlag(16777216 /* IsAnnotatedWithAny */ | 1 /* Exported */))) {
                this.setSymbolForAST(nameAST, nameSymbol, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.computeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var id = nameAST.text();

            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var aliasSymbol = null;
            var nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);

            if (!nameSymbol && id === "arguments" && enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol;

                this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), context);
            }

            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, 256 /* TypeAlias */);

                if (nameSymbol && !nameSymbol.isAlias()) {
                    nameSymbol = null;
                }
            }

            if (!nameSymbol) {
                if (context.resolvingTypeNameAsNameExpression) {
                    return null;
                } else {
                    context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.actualText]);
                    return this.getNewErrorTypeSymbol(id);
                }
            }

            var nameParentDecl = nameSymbol.getDeclarations()[0].getParentDecl();
            if (nameParentDecl && (nameParentDecl.kind & TypeScript.PullElementKind.SomeFunction) && (nameParentDecl.flags & 33554432 /* HasDefaultArgs */)) {
                var enclosingFunctionAST = this.semanticInfoChain.getASTForDecl(nameParentDecl);
                var currentParameterIndex = context.getCurrentParameterIndexForFunction(enclosingFunctionAST);

                if (currentParameterIndex >= 0) {
                    var foundMatchingParameter = false;
                    if (enclosingFunctionAST.parameters) {
                        for (var i = 0; i <= currentParameterIndex; i++) {
                            var candidateParameter = enclosingFunctionAST.parameters.members[i];
                            if (candidateParameter && candidateParameter.id.text() === id) {
                                foundMatchingParameter = true;
                            }
                        }
                    }
                    if (!foundMatchingParameter) {
                        context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, [enclosingFunctionAST.parameters.members[currentParameterIndex].id.actualText, nameAST.actualText]);
                        return this.getNewErrorTypeSymbol(id);
                    }
                }
            }

            if (nameSymbol.isType() && nameSymbol.isAlias()) {
                aliasSymbol = nameSymbol;
                if (!context.resolvingTypeQueryExpression) {
                    aliasSymbol.isUsedAsValue = true;
                }

                this.resolveDeclaredSymbol(nameSymbol, context);

                this.resolveDeclaredSymbol(aliasSymbol.assignedValue, context);
                this.resolveDeclaredSymbol(aliasSymbol.assignedContainer, context);

                var exportAssignmentSymbol = nameSymbol.getExportAssignedValueSymbol();

                if (exportAssignmentSymbol) {
                    nameSymbol = exportAssignmentSymbol;
                } else {
                    aliasSymbol = null;
                }
            }

            if (aliasSymbol) {
                this.currentUnit.setAliasSymbolForAST(nameAST, aliasSymbol);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(dottedNameAST, context);
            var foundCached = symbol != null;

            if (!foundCached || this.canTypeCheckAST(dottedNameAST, context)) {
                var canTypeCheckDottedNameAST = this.canTypeCheckAST(dottedNameAST, context);
                if (canTypeCheckDottedNameAST) {
                    this.setTypeChecked(dottedNameAST, context);
                }
                symbol = this.computeDottedNameExpressionSymbol(dottedNameAST, enclosingDecl, context, canTypeCheckDottedNameAST);
            }

            this.resolveDeclaredSymbol(symbol, context);

            if (symbol && (symbol.type != this.semanticInfoChain.anyTypeSymbol || symbol.hasFlag(16777216 /* IsAnnotatedWithAny */ | 1 /* Exported */))) {
                this.setSymbolForAST(dottedNameAST, symbol, context);
                this.setSymbolForAST(dottedNameAST.operand2, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.isPrototypeMember = function (dottedNameAST, enclosingDecl, context) {
            var rhsName = dottedNameAST.operand2.text();
            if (rhsName === "prototype") {
                var prevCanUseTypeSymbol = context.canUseTypeSymbol;
                context.canUseTypeSymbol = true;
                var lhsType = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context).type;
                context.canUseTypeSymbol = prevCanUseTypeSymbol;

                if (lhsType) {
                    if (lhsType.isClass() || lhsType.isConstructor()) {
                        return true;
                    } else {
                        var classInstanceType = lhsType.getAssociatedContainerType();

                        if (classInstanceType && classInstanceType.isClass()) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.computeDottedNameExpressionSymbol = function (dottedNameAST, enclosingDecl, context, checkSuperPrivateAndStaticAccess) {
            if (dottedNameAST.operand2.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var rhsName = dottedNameAST.operand2.text();
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            context.canUseTypeSymbol = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context);
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            var lhsType = lhs.type;

            if (lhs.isAlias()) {
                if (!context.resolvingTypeQueryExpression) {
                    lhs.isUsedAsValue = true;
                }
                lhsType = lhs.getExportAssignedTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            if (lhsType.isAlias()) {
                lhsType = lhsType.getExportAssignedTypeSymbol();
            }

            if (!lhsType) {
                context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [dottedNameAST.operand2.actualText]);
                return this.getNewErrorTypeSymbol();
            }

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, context);

                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (lhsType.isContainer() && !lhsType.isAlias() && !lhsType.isEnum()) {
                var instanceSymbol = lhsType.getInstanceSymbol();

                if (instanceSymbol) {
                    lhsType = instanceSymbol.type;
                }
            }

            if (this.isPrototypeMember(dottedNameAST, enclosingDecl, context)) {
                if (lhsType.isClass()) {
                    this.checkForStaticMemberAccess(dottedNameAST, lhsType, lhsType, enclosingDecl, context);

                    if (lhsType.isGeneric()) {
                        return this.specializeTypeToAny(lhsType, enclosingDecl, context);
                    }

                    return lhsType;
                } else {
                    var instanceType = lhsType.getAssociatedContainerType();

                    if (instanceType) {
                        if (instanceType.isGeneric()) {
                            instanceType = this.specializeTypeToAny(instanceType, enclosingDecl, context);
                        }
                    } else {
                        instanceType = lhsType;
                    }

                    if (instanceType && instanceType.isClass()) {
                        this.checkForStaticMemberAccess(dottedNameAST, lhsType, instanceType, enclosingDecl, context);

                        return instanceType;
                    }
                }
            }

            if (lhsType.isTypeParameter()) {
                lhsType = this.substituteUpperBoundForType(lhsType);
            }

            if ((lhsType === this.semanticInfoChain.numberTypeSymbol || lhsType.isEnum()) && this.cachedNumberInterfaceType()) {
                lhsType = this.cachedNumberInterfaceType();
            } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                lhsType = this.cachedStringInterfaceType();
            } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                lhsType = this.cachedBooleanInterfaceType();
            }

            var nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
            nameSymbol = this.resolveNameSymbol(nameSymbol, context);

            if (!nameSymbol) {
                if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                } else if (lhsType.kind === 32 /* DynamicModule */) {
                    var container = lhsType;
                    var associatedInstance = container.getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;

                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, instanceType);
                    }
                } else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, associatedType);
                    }
                }

                nameSymbol = this.resolveNameSymbol(nameSymbol, context);

                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                }

                if (!nameSymbol) {
                    context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [dottedNameAST.operand2.actualText, lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]);
                    return this.getNewErrorTypeSymbol(rhsName);
                }
            }

            if (checkSuperPrivateAndStaticAccess) {
                this.checkForSuperMemberAccess(dottedNameAST, nameSymbol, enclosingDecl, context) || this.checkForPrivateMemberAccess(dottedNameAST, lhsType, nameSymbol, enclosingDecl, context) || this.checkForStaticMemberAccess(dottedNameAST, lhsType, nameSymbol, enclosingDecl, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, enclosingDecl, context) {
            var typeNameSymbol = this.getSymbolForAST(nameAST, context);

            if (!typeNameSymbol || !typeNameSymbol.isType() || this.canTypeCheckAST(nameAST, context)) {
                if (this.canTypeCheckAST(nameAST, context)) {
                    this.setTypeChecked(nameAST, context);
                }
                typeNameSymbol = this.computeTypeNameExpression(nameAST, enclosingDecl, context);
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }

            this.resolveDeclaredSymbol(typeNameSymbol, context);

            if (typeNameSymbol && !(typeNameSymbol.isTypeParameter() && typeNameSymbol.isFunctionTypeParameter() && context.isSpecializingSignatureTypeParameters && !context.isSpecializingConstructorMethod)) {
                var substitution = context.findSpecializationForType(typeNameSymbol);

                if (typeNameSymbol.isTypeParameter() && (substitution != typeNameSymbol)) {
                    if (TypeScript.shouldSpecializeTypeParameterForTypeParameter(substitution, typeNameSymbol)) {
                        typeNameSymbol = substitution;
                    }
                }
            }

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.computeTypeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var id = nameAST.text();

            if (id === "any") {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (id === "string") {
                return this.semanticInfoChain.stringTypeSymbol;
            } else if (id === "number") {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if (id === "boolean") {
                return this.semanticInfoChain.booleanTypeSymbol;
            } else if (id === "void") {
                return this.semanticInfoChain.voidTypeSymbol;
            } else {
                var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

                if (enclosingDecl && !declPath.length) {
                    declPath = [enclosingDecl];
                }

                var kindToCheckFirst = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
                var kindToCheckSecond = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeContainer;

                var typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);

                if (!typeNameSymbol) {
                    typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
                }

                if (!typeNameSymbol) {
                    context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.actualText]);
                    return this.getNewErrorTypeSymbol(id);
                }

                var typeNameSymbolAlias = null;
                if (typeNameSymbol.isAlias()) {
                    typeNameSymbolAlias = typeNameSymbol;
                    this.resolveDeclaredSymbol(typeNameSymbol, context);

                    var aliasedType = typeNameSymbolAlias.getExportAssignedTypeSymbol();

                    this.resolveDeclaredSymbol(aliasedType, context);
                }

                if (typeNameSymbol.isTypeParameter()) {
                    if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) && (enclosingDecl.flags & 16 /* Static */)) {
                        var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();

                        if (parentDecl.kind == 8 /* Class */) {
                            context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Static_methods_cannot_reference_class_type_parameters, null);
                            return this.getNewErrorTypeSymbol();
                        }
                    }
                }
            }

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, enclosingDecl, context) {
            var savedResolvingTypeReference = context.resolvingTypeReference;
            var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.resolvingNamespaceMemberAccess = false;
            context.resolvingTypeReference = true;
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, enclosingDecl, context).type;
            context.resolvingTypeReference = savedResolvingTypeReference;
            context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;

            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }

            if (!genericTypeSymbol.inResolution && !genericTypeSymbol.isResolved) {
                this.resolveDeclaredSymbol(genericTypeSymbol, context);
            }

            if (genericTypeSymbol.isAlias()) {
                genericTypeSymbol = genericTypeSymbol.getExportAssignedTypeSymbol();
            }

            var typeArgs = [];

            if (!context.isResolvingTypeArguments(genericTypeAST)) {
                context.startResolvingTypeArguments(genericTypeAST);
                var savedIsResolvingClassExtendedType = context.isResolvingClassExtendedType;
                context.isResolvingClassExtendedType = false;

                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for (var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(genericTypeAST.typeArguments.members[i], enclosingDecl, context);

                        if (!(typeArg.isTypeParameter() && typeArg.isFunctionTypeParameter() && context.isSpecializingSignatureTypeParameters && !context.isSpecializingConstructorMethod)) {
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        } else {
                            typeArgs[i] = typeArg;
                        }

                        if (typeArgs[i].isError()) {
                            typeArgs[i] = this.semanticInfoChain.anyTypeSymbol;
                        }
                    }
                }
                context.isResolvingClassExtendedType = savedIsResolvingClassExtendedType;
                context.doneResolvingTypeArguments();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();

            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), TypeScript.DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length]);
                return this.getNewErrorTypeSymbol();
            }

            if (!genericTypeSymbol.isResolved) {
                var typeDecls = genericTypeSymbol.getDeclarations();
                var childDecls = null;

                for (var i = 0; i < typeDecls.length; i++) {
                    childDecls = typeDecls[i].getChildDecls();

                    for (var j = 0; j < childDecls.length; j++) {
                        childDecls[j].ensureSymbolIsBound();
                    }
                }
            }

            var specializedSymbol = TypeScript.specializeType(genericTypeSymbol, typeArgs, this, context);

            var typeConstraint = null;
            var upperBound = null;

            typeParameters = specializedSymbol.getTypeParameters();

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeArg = typeArgs[iArg];
                typeConstraint = typeParameters[iArg].getConstraint();

                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] == typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    }

                    if (typeArg.isTypeParameter()) {
                        upperBound = typeArg.getConstraint();

                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }

                    if (typeArg.inResolution) {
                        return specializedSymbol;
                    }
                    if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, context)) {
                        context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [typeArg.toString(null, true), typeConstraint.toString(null, true), typeParameters[iArg].toString(null, true)]);
                    }
                }
            }

            return specializedSymbol;
        };

        PullTypeResolver.prototype.resolveDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(dottedNameAST, context);
            if (!symbol || this.canTypeCheckAST(dottedNameAST, context)) {
                if (this.canTypeCheckAST(dottedNameAST, context)) {
                    this.setTypeChecked(dottedNameAST, context);
                }
                symbol = this.computeDottedTypeNameExpression(dottedNameAST, enclosingDecl, context);
                this.setSymbolForAST(dottedNameAST, symbol, context);
            }

            this.resolveDeclaredSymbol(symbol, context);

            return symbol;
        };

        PullTypeResolver.prototype.computeDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            if (dottedNameAST.operand2.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var rhsName = dottedNameAST.operand2.text();

            var savedResolvingTypeReference = context.resolvingTypeReference;
            var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.resolvingNamespaceMemberAccess = true;
            context.resolvingTypeReference = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context);
            context.resolvingTypeReference = savedResolvingTypeReference;
            context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;

            var lhsType = lhs.isAlias() ? lhs.getExportAssignedContainerSymbol() : lhs.type;

            if (context.isResolvingClassExtendedType) {
                if (lhs.isAlias()) {
                    lhs.isUsedAsValue = true;
                }
            }

            if (!lhsType) {
                return this.getNewErrorTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            var memberKind = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
            var childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);

            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = lhsType.getExportAssignedContainerSymbol();

                if (exportedContainer) {
                    childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, exportedContainer);
                }
            }

            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;

                while (parentDecl) {
                    if (parentDecl.kind & TypeScript.PullElementKind.SomeContainer) {
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol().type;

                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);
                    }
                }
            }

            if (!childTypeSymbol) {
                context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [dottedNameAST.operand2.actualText, lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]);
                return this.getNewErrorTypeSymbol(rhsName);
            }

            return childTypeSymbol;
        };

        PullTypeResolver.prototype.shouldContextuallyTypeAnyFunctionExpression = function (functionExpressionAST, typeParameters, parameters, returnTypeAnnotation, context) {
            if (typeParameters && typeParameters.members.length > 0) {
                return false;
            }

            if (returnTypeAnnotation) {
                return false;
            }

            if (parameters) {
                for (var i = 0; i < parameters.members.length; i++) {
                    var parameter = parameters.members[i];
                    if (parameter.typeExpr) {
                        return false;
                    }
                }
            }

            var contextualFunctionTypeSymbol = context.getContextualType();

            if (contextualFunctionTypeSymbol) {
                this.resolveDeclaredSymbol(contextualFunctionTypeSymbol, context);
                var callSignatures = contextualFunctionTypeSymbol.getCallSignatures();
                var exactlyOneCallSignature = callSignatures && callSignatures.length == 1;
                if (!exactlyOneCallSignature) {
                    return false;
                }

                var callSignatureIsGeneric = callSignatures[0].typeParameters && callSignatures[0].typeParameters.length > 0;
                return !callSignatureIsGeneric;
            }

            return false;
        };

        PullTypeResolver.prototype.resolveAnyFunctionExpression = function (funcDeclAST, typeParameters, parameters, returnTypeAnnotation, block, inContextuallyTypedAssignment, enclosingDecl, context) {
            var funcDeclSymbol = null;
            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (functionDecl && functionDecl.hasSymbol()) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved || funcDeclSymbol.inResolution) {
                    return funcDeclSymbol;
                }
            }

            if (!functionDecl) {
                var declCollectionContext = new TypeScript.DeclCollectionContext(this.currentUnit, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);
                this.currentUnit.addSynthesizedDecl(functionDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);
            }

            funcDeclSymbol = functionDecl.getSymbol();
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            funcDeclSymbol.startResolving();

            if (typeParameters) {
                for (var i = 0; i < typeParameters.members.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.members[i], context);
                }
            }

            var assigningFunctionSignature = null;
            if (inContextuallyTypedAssignment && this.shouldContextuallyTypeAnyFunctionExpression(funcDeclAST, typeParameters, parameters, returnTypeAnnotation, context)) {
                assigningFunctionSignature = context.getContextualType().getCallSignatures()[0];
            }

            if (parameters) {
                var contextParams = [];

                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.parameters;
                }

                var hasDefaultArgs = (functionDecl.flags & 33554432 /* HasDefaultArgs */) !== 0;
                if (hasDefaultArgs) {
                    context.pushParameterIndexContext(funcDeclAST);
                }

                var contextualParametersCount = contextParams.length;
                for (var i = 0, n = parameters.members.length; i < n; i++) {
                    var actualParameter = parameters.members[i];

                    var actualParameterIsVarArgParameter = actualParameter.isRest;
                    var correspondingContextualParameter = null;
                    var contextualParameterType = null;

                    if (i < contextualParametersCount) {
                        correspondingContextualParameter = contextParams[i];
                    } else if (contextualParametersCount && contextParams[contextualParametersCount - 1].isVarArg) {
                        correspondingContextualParameter = contextParams[contextualParametersCount - 1];
                    }

                    if (correspondingContextualParameter) {
                        if (correspondingContextualParameter.isVarArg === actualParameterIsVarArgParameter) {
                            contextualParameterType = correspondingContextualParameter.type;
                        } else if (correspondingContextualParameter.isVarArg) {
                            contextualParameterType = correspondingContextualParameter.type.getElementType();
                        }
                    }

                    this.resolveFunctionExpressionParameter(actualParameter, contextualParameterType, functionDecl, context);
                    if (hasDefaultArgs) {
                        context.incrementParameterIndex();
                    }
                }

                if (hasDefaultArgs) {
                    context.popParameterIndexContext();
                }
            }

            if (returnTypeAnnotation) {
                signature.returnType = this.resolveTypeReference(returnTypeAnnotation, functionDecl, context);
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.returnType;

                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);

                        this.resolveFunctionBodyReturnTypes(funcDeclAST, block, signature, true, functionDecl, context);
                        context.popContextualType();
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny) {
                            var functionExpressionName = functionDecl.getFunctionExpressionName();

                            if (functionExpressionName != "") {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionExpressionName]);
                            } else {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, null);
                            }
                        }
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, block, signature, false, functionDecl, context);
                }
            }

            context.setTypeInContext(funcDeclSymbol, funcDeclType);
            funcDeclSymbol.setResolved();

            if (this.canTypeCheckAST(funcDeclAST, context)) {
                this.typeCheckAnyFunctionExpression(funcDeclAST, typeParameters, returnTypeAnnotation, block, context);
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.typeCheckArrowFunctionExpression = function (arrowFunction, context) {
            return this.typeCheckAnyFunctionExpression(arrowFunction, arrowFunction.typeParameters, arrowFunction.returnTypeAnnotation, arrowFunction.block, context);
        };

        PullTypeResolver.prototype.typeCheckAnyFunctionExpression = function (funcDeclAST, typeParameters, returnTypeAnnotation, block, context) {
            var _this = this;
            this.setTypeChecked(funcDeclAST, context);

            var functionDecl = this.getDeclForAST(funcDeclAST);

            var funcDeclSymbol = functionDecl.getSymbol();
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            var returnTypeSymbol = signature.returnType;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.members.length; i++) {
                    this.resolveTypeParameterDeclaration(typeParameters.members[i], context);
                }
            }

            var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
            this.seenSuperConstructorCall = false;

            context.pushContextualType(null, context.inProvisionalResolution(), null);
            this.resolveAST(block, false, functionDecl, context);
            context.popContextualType();
            this.seenSuperConstructorCall = prevSeenSuperConstructorCall;

            var hasReturn = (functionDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

            if (block && returnTypeAnnotation != null && !hasReturn) {
                var isVoidOrAny = this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol;

                if (!isVoidOrAny && !(block.statements.members.length > 0 && block.statements.members[0].nodeType() === 98 /* ThrowStatement */)) {
                    var funcName = functionDecl.getDisplayName();
                    funcName = funcName ? "'" + funcName + "'" : "expression";

                    context.postError(this.unitPath, returnTypeAnnotation.minChar, returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName]);
                }
            }

            this.validateVariableDeclarationGroups(functionDecl, context);

            PullTypeResolver.typeCheckCallBacks.push(function (context) {
                var currentUnitPath = _this.unitPath;
                _this.setUnitPath(functionDecl.getScriptName());
                _this.typeCheckFunctionOverloads(funcDeclAST, context);
                _this.setUnitPath(currentUnitPath);
            });
        };

        PullTypeResolver.prototype.resolveThisExpression = function (thisExpression, enclosingDecl, context) {
            var thisTypeSymbol = this.computeThisTypeSymbol(enclosingDecl, context);
            if (this.canTypeCheckAST(thisExpression, context)) {
                this.typeCheckThisExpression(thisExpression, enclosingDecl, context);
            }

            return thisTypeSymbol;
        };

        PullTypeResolver.prototype.computeThisTypeSymbol = function (enclosingDecl, context) {
            return this.getContextualClassSymbolForEnclosingDecl(enclosingDecl, context) || this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckThisExpression = function (thisExpression, enclosingDecl, context) {
            var enclosingNonLambdaDecl = this.getEnclosingNonLambdaDecl(enclosingDecl);

            var thisTypeSymbol = this.computeThisTypeSymbol(enclosingDecl, context);
            var decls = thisTypeSymbol.getDeclarations();
            var classDecl = decls && decls[0] ? decls[0] : null;

            if (context.isResolvingSuperConstructorCallArgument && this.superCallMustBeFirstStatementInConstructor(enclosingDecl, classDecl)) {
                context.postError(this.unitPath, thisExpression.minChar, thisExpression.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_current_location, null);
            } else if (enclosingNonLambdaDecl) {
                if (enclosingNonLambdaDecl.kind === 8 /* Class */ && context.isInStaticInitializer) {
                    context.postError(this.unitPath, thisExpression.minChar, thisExpression.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_static_initializers_in_a_class_body, null);
                } else if (enclosingNonLambdaDecl.kind === 4 /* Container */ || enclosingNonLambdaDecl.kind === 32 /* DynamicModule */) {
                    context.postError(this.unitPath, thisExpression.minChar, thisExpression.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_within_module_bodies, null);
                } else if (context.inConstructorArguments) {
                    context.postError(this.unitPath, thisExpression.minChar, thisExpression.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_constructor_arguments, null);
                }
            }

            this.checkForThisCaptureInArrowFunction(thisExpression, enclosingDecl);
        };

        PullTypeResolver.prototype.getContextualClassSymbolForEnclosingDecl = function (enclosingDecl, context) {
            var declPath = TypeScript.getPathToDecl(enclosingDecl);

            if (declPath.length) {
                var isStaticContext = false;

                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declFlags & 16 /* Static */) {
                        isStaticContext = true;
                    } else if (declKind === 131072 /* FunctionExpression */ && !TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                        return null;
                    } else if (declKind === 16384 /* Function */) {
                        return null;
                    } else if (declKind === 8 /* Class */) {
                        if (context.isInStaticInitializer) {
                            return this.getNewErrorTypeSymbol();
                        } else {
                            var classSymbol = decl.getSymbol();
                            if (isStaticContext) {
                                var constructorSymbol = classSymbol.getConstructorMethod();
                                return constructorSymbol.type;
                            } else {
                                return classSymbol;
                            }
                        }
                    }
                }
            }

            return null;
        };

        PullTypeResolver.prototype.getEnclosingNonLambdaDecl = function (enclosingDecl) {
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    if (!(decl.kind === 131072 /* FunctionExpression */ && (decl.flags & 8192 /* FatArrow */))) {
                        return decl;
                    }
                }
            }

            return null;
        };

        PullTypeResolver.prototype.resolveSuperExpression = function (ast, enclosingDecl, context) {
            var superType = this.semanticInfoChain.anyTypeSymbol;
            if (enclosingDecl) {
                var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];
                var superType = this.semanticInfoChain.anyTypeSymbol;

                var classSymbol = this.getContextualClassSymbolForEnclosingDecl(enclosingDecl, context);

                if (classSymbol) {
                    this.resolveDeclaredSymbol(classSymbol, context);

                    var parents = classSymbol.getExtendedTypes();

                    if (parents.length) {
                        superType = parents[0];
                    }
                }
            }
            this.setSymbolForAST(ast, superType, context);

            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckSuperExpression(ast, enclosingDecl, context);
            }

            return superType;
        };

        PullTypeResolver.prototype.typeCheckSuperExpression = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.checkForThisCaptureInArrowFunction(ast, enclosingDecl);

            if (!enclosingDecl) {
                return;
            }

            var nonLambdaEnclosingDecl = this.getEnclosingNonLambdaDecl(enclosingDecl);

            if (nonLambdaEnclosingDecl) {
                var nonLambdaEnclosingDeclKind = nonLambdaEnclosingDecl.kind;
                var inSuperConstructorTarget = context.isResolvingSuperConstructorCallArgument;

                if (inSuperConstructorTarget && enclosingDecl.kind !== 32768 /* ConstructorMethod */) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors, null);
                } else if ((nonLambdaEnclosingDeclKind !== 8 /* Class */ && nonLambdaEnclosingDeclKind !== 65536 /* Method */ && nonLambdaEnclosingDeclKind !== 262144 /* GetAccessor */ && nonLambdaEnclosingDeclKind !== 524288 /* SetAccessor */ && nonLambdaEnclosingDeclKind !== 32768 /* ConstructorMethod */) || context.isInStaticInitializer) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class, null);
                } else if (!this.enclosingClassIsDerived(enclosingDecl)) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes, null);
                } else if (context.inConstructorArguments) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.super_cannot_be_referenced_in_constructor_arguments, null);
                }
            }
        };

        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(expressionAST, context);

            if (!symbol || additionalResults || this.canTypeCheckAST(expressionAST, context)) {
                if (this.canTypeCheckAST(expressionAST, context)) {
                    this.setTypeChecked(expressionAST, context);
                }
                symbol = this.computeObjectLiteralExpression(expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
                this.setSymbolForAST(expressionAST, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var objectLitAST = expressionAST;
            var span = TypeScript.TextSpan.fromBounds(objectLitAST.minChar, objectLitAST.limChar);

            var objectLitDecl = this.getDeclForAST(expressionAST);
            var typeSymbol = this.getSymbolForAST(objectLitAST, context);
            var isUsingExistingDecl = !!objectLitDecl;
            var isUsingExistingSymbol = !!typeSymbol;

            if (!objectLitDecl) {
                objectLitDecl = new TypeScript.PullDecl("", "", 512 /* ObjectLiteral */, 0 /* None */, span, this.unitPath);
                this.currentUnit.addSynthesizedDecl(objectLitDecl);

                if (enclosingDecl) {
                    objectLitDecl.setParentDecl(enclosingDecl);
                }

                this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
                this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);
            }

            if (!typeSymbol) {
                typeSymbol = new TypeScript.PullTypeSymbol("", 16 /* Interface */);
                typeSymbol.addDeclaration(objectLitDecl);
                this.setSymbolForAST(objectLitAST, typeSymbol, context);
                objectLitDecl.setSymbol(typeSymbol);
            }

            var memberDecls = objectLitAST.operand;

            var contextualType = null;

            if (inContextuallyTypedAssignment) {
                contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);
            }

            if (contextualType) {
                var indexSignatures = this.getBothKindsOfIndexSignatures(contextualType, context);
                var stringSignature = indexSignatures.stringSignature;
                var numberSignature = indexSignatures.numericSignature;

                var allMemberTypes = null;
                var allNumericMemberTypes = null;
                if (stringSignature) {
                    allMemberTypes = [stringSignature.returnType];
                }
                if (numberSignature) {
                    allNumericMemberTypes = [numberSignature.returnType];
                }
            }

            if (memberDecls) {
                var binex;
                var memberSymbol;
                var assigningSymbol = null;
                var acceptedContextualType = false;

                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }

                for (var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = memberDecls.members[i];

                    var id = binex.operand1;
                    var text;
                    var actualText;

                    if (id.nodeType() === 22 /* Name */) {
                        actualText = id.actualText;
                        text = id.text();
                    } else if (id.nodeType() === 5 /* StringLiteral */) {
                        actualText = id.actualText;
                        text = id.text();
                    } else if (id.nodeType() === 7 /* NumericLiteral */) {
                        actualText = text = id.text();
                    } else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    span = TypeScript.TextSpan.fromBounds(binex.minChar, binex.limChar);

                    var isAccessor = binex.operand2.nodeType() === 13 /* FunctionDeclaration */ && binex.operand2.isAccessor();

                    var decl = this.getDeclForAST(binex);
                    if (!isAccessor) {
                        if (!isUsingExistingDecl) {
                            decl = new TypeScript.PullDecl(text, actualText, 4096 /* Property */, 4 /* Public */, span, this.unitPath);
                            this.currentUnit.addSynthesizedDecl(decl);

                            objectLitDecl.addChildDecl(decl);
                            decl.setParentDecl(objectLitDecl);

                            this.currentUnit.setDeclForAST(binex, decl);
                            this.currentUnit.setASTForDecl(decl, binex);
                        }

                        if (!isUsingExistingSymbol) {
                            memberSymbol = new TypeScript.PullSymbol(text, 4096 /* Property */);
                            memberSymbol.addDeclaration(decl);
                            decl.setSymbol(memberSymbol);
                        } else {
                            memberSymbol = decl.getSymbol();
                        }
                    }

                    if (contextualType) {
                        assigningSymbol = this.getMemberSymbol(text, TypeScript.PullElementKind.SomeValue, contextualType);

                        if (!assigningSymbol) {
                            if (numberSignature && TypeScript.PullHelpers.isNameNumeric(text)) {
                                assigningSymbol = numberSignature;
                            } else if (stringSignature) {
                                assigningSymbol = stringSignature;
                            }
                        }

                        if (assigningSymbol) {
                            this.resolveDeclaredSymbol(assigningSymbol, context);

                            var contextualMemberType = assigningSymbol.kind === 4194304 /* IndexSignature */ ? assigningSymbol.returnType : assigningSymbol.type;
                            context.pushContextualType(contextualMemberType, context.inProvisionalResolution(), null);

                            acceptedContextualType = true;

                            if (additionalResults) {
                                additionalResults.membersContextTypeSymbols[i] = contextualMemberType;
                            }
                        }
                    }

                    if (isAccessor) {
                        var funcDeclAST = binex.operand2;
                        if (!isUsingExistingDecl) {
                            var declCollectionContext = new TypeScript.DeclCollectionContext(this.currentUnit, this.unitPath);

                            declCollectionContext.pushParent(objectLitDecl);

                            TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                            var functionDecl = this.getDeclForAST(funcDeclAST);
                            this.currentUnit.addSynthesizedDecl(functionDecl);
                        }

                        if (!isUsingExistingSymbol) {
                            var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                            binder.setUnit(this.unitPath);

                            if (funcDeclAST.isGetAccessor()) {
                                binder.bindGetAccessorDeclarationToPullSymbol(functionDecl);
                            } else {
                                binder.bindSetAccessorDeclarationToPullSymbol(functionDecl);
                            }
                        }
                    }

                    var memberExpr = this.widenType(binex.operand2, this.resolveAST(binex.operand2, contextualMemberType != null, enclosingDecl, context).type, enclosingDecl, context);

                    if (memberExpr.type) {
                        if (memberExpr.type.isGeneric()) {
                            typeSymbol.setHasGenericMember();
                        }

                        if (stringSignature) {
                            allMemberTypes.push(memberExpr.type);
                        }
                        if (numberSignature && TypeScript.PullHelpers.isNameNumeric(memberSymbol.name)) {
                            allNumericMemberTypes.push(memberExpr.type);
                        }
                    }

                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }

                    if (!isUsingExistingSymbol) {
                        if (isAccessor) {
                            this.setSymbolForAST(binex.operand1, memberExpr, context);
                        } else {
                            if (typeSymbol.findMember(memberSymbol.name)) {
                                context.postError(this.getUnitPath(), binex.minChar, binex.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [actualText]);
                            }

                            context.setTypeInContext(memberSymbol, memberExpr.type);
                            memberSymbol.setResolved();

                            this.setSymbolForAST(binex.operand1, memberSymbol, context);
                            typeSymbol.addMember(memberSymbol);
                        }
                    }
                }

                if (!isUsingExistingSymbol) {
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allMemberTypes, stringSignature, context);
                    this.stampObjectLiteralWithIndexSignature(typeSymbol, allNumericMemberTypes, numberSignature, context);
                }
            }

            if (!this.getSymbolForAST(objectLitAST, context)) {
                objectLitDecl.setSymbol(null);
            }
            typeSymbol.setResolved();
            return typeSymbol;
        };

        PullTypeResolver.prototype.stampObjectLiteralWithIndexSignature = function (objectLiteralSymbol, indexerTypeCandidates, contextualIndexSignature, context) {
            if (contextualIndexSignature) {
                var typeCollection = {
                    getLength: function () {
                        return indexerTypeCandidates.length;
                    },
                    getTypeAtIndex: function (index) {
                        return indexerTypeCandidates[index];
                    }
                };
                var decl = objectLiteralSymbol.getDeclarations()[0];
                var indexerReturnType = this.widenType(null, this.findBestCommonType(indexerTypeCandidates[0], typeCollection, context), decl, context);
                if (indexerReturnType == contextualIndexSignature.returnType) {
                    objectLiteralSymbol.addIndexSignature(contextualIndexSignature);
                } else {
                    this.currentUnit.addSyntheticIndexSignature(decl, objectLiteralSymbol, this.getASTForDecl(decl), contextualIndexSignature.parameters[0].name, contextualIndexSignature.parameters[0].type, indexerReturnType);
                }
            }
        };

        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(arrayLit, context);
            if (!symbol || this.canTypeCheckAST(arrayLit, context)) {
                if (this.canTypeCheckAST(arrayLit, context)) {
                    this.setTypeChecked(arrayLit, context);
                }
                symbol = this.computeArrayLiteralExpressionSymbol(arrayLit, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolForAST(arrayLit, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeArrayLiteralExpressionSymbol = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var elements = arrayLit.operand;
            var elementType = null;
            var elementTypes = [];
            var comparisonInfo = new TypeComparisonInfo();
            var contextualElementType = null;
            comparisonInfo.onlyCaptureFirstError = true;

            if (inContextuallyTypedAssignment) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);

                if (contextualType) {
                    if (contextualType.isArray()) {
                        contextualElementType = contextualType.getElementType();
                    } else {
                        var indexSignatures = this.getBothKindsOfIndexSignatures(contextualType, context);
                        if (indexSignatures.numericSignature) {
                            contextualElementType = indexSignatures.numericSignature.returnType;
                        }
                    }
                }
            }

            if (elements) {
                if (inContextuallyTypedAssignment) {
                    context.pushContextualType(contextualElementType, context.inProvisionalResolution(), null);
                }

                for (var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveAST(elements.members[i], inContextuallyTypedAssignment, enclosingDecl, context).type;
                }

                if (inContextuallyTypedAssignment) {
                    context.popContextualType();
                }
            }

            if (elementTypes.length) {
                elementType = elementTypes[0];
            }
            var collection;
            if (contextualElementType) {
                if (!elementType) {
                    elementType = contextualElementType;
                }

                collection = {
                    getLength: function () {
                        return elements.members.length + 1;
                    },
                    getTypeAtIndex: function (index) {
                        return index === elementTypes.length ? contextualElementType : elementTypes[index];
                    }
                };
            } else {
                collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    getTypeAtIndex: function (index) {
                        return elementTypes[index];
                    }
                };
            }

            elementType = elementType ? this.findBestCommonType(elementType, collection, context, comparisonInfo) : elementType;

            if (!elementType) {
                elementType = this.semanticInfoChain.undefinedTypeSymbol;
            }

            var arraySymbol = elementType.getArrayType();

            if (!arraySymbol) {
                this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), context);

                arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [elementType], this, context);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return arraySymbol;
        };

        PullTypeResolver.prototype.resolveIndexExpression = function (callEx, enclosingDecl, context) {
            var symbolAndDiagnostic = this.computeIndexExpressionSymbolAndDiagnostic(callEx, enclosingDecl, context);

            if (this.canTypeCheckAST(callEx, context)) {
                this.typeCheckIndexExpression(callEx, enclosingDecl, context, symbolAndDiagnostic);
            }

            return symbolAndDiagnostic.symbol;
        };

        PullTypeResolver.prototype.typeCheckIndexExpression = function (callEx, enclosingDecl, context, symbolAndDiagnostic) {
            if (typeof symbolAndDiagnostic === "undefined") { symbolAndDiagnostic = null; }
            this.setTypeChecked(callEx, context);
            var symbolAndDiagnostic = symbolAndDiagnostic || this.computeIndexExpressionSymbolAndDiagnostic(callEx, enclosingDecl, context);

            context.postDiagnostic(symbolAndDiagnostic.diagnostic);
        };

        PullTypeResolver.prototype.computeIndexExpressionSymbolAndDiagnostic = function (callEx, enclosingDecl, context) {
            var targetSymbol = this.resolveAST(callEx.operand1, false, enclosingDecl, context);
            var indexType = this.resolveAST(callEx.operand2, false, enclosingDecl, context).type;

            var targetTypeSymbol = targetSymbol.type;

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return { symbol: targetTypeSymbol };
            }

            var elementType = targetTypeSymbol.getElementType();

            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(indexType);

            if (elementType && isNumberIndex) {
                return { symbol: elementType };
            }

            if (callEx.operand2.nodeType() === 5 /* StringLiteral */ || callEx.operand2.nodeType() === 7 /* NumericLiteral */) {
                var memberName = callEx.operand2.nodeType() === 5 /* StringLiteral */ ? TypeScript.stripStartAndEndQuotes(callEx.operand2.actualText) : callEx.operand2.value.toString();

                var member = this.getMemberSymbol(memberName, TypeScript.PullElementKind.SomeValue, targetTypeSymbol);

                if (member) {
                    this.resolveDeclaredSymbol(member, context);

                    return { symbol: member.type };
                }
            }

            if (targetTypeSymbol == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                targetTypeSymbol = this.cachedStringInterfaceType();
            }

            var signatures = this.getBothKindsOfIndexSignatures(targetTypeSymbol, context);

            var stringSignature = signatures.stringSignature;
            var numberSignature = signatures.numericSignature;

            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                return { symbol: numberSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            } else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                return { symbol: stringSignature.returnType || this.semanticInfoChain.anyTypeSymbol };
            } else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                return { symbol: this.semanticInfoChain.anyTypeSymbol };
            } else {
                return {
                    symbol: this.getNewErrorTypeSymbol(),
                    diagnostic: new TypeScript.Diagnostic(this.getUnitPath(), callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Value_of_type_0_is_not_indexable_by_type_1, [targetTypeSymbol.toString(), indexType.toString()])
                };
            }
        };

        PullTypeResolver.prototype.getBothKindsOfIndexSignatures = function (enclosingType, context) {
            var signatures = enclosingType.getIndexSignatures();

            var stringSignature = null;
            var numberSignature = null;
            var signature = null;
            var paramSymbols;
            var paramType;

            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }

                signature = signatures[i];
                if (!signature.isResolved) {
                    this.resolveDeclaredSymbol(signature, context);
                }

                paramSymbols = signature.parameters;

                if (paramSymbols.length) {
                    paramType = paramSymbols[0].type;

                    if (!stringSignature && paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signature;
                        continue;
                    } else if (!numberSignature && paramType === this.semanticInfoChain.numberTypeSymbol) {
                        numberSignature = signature;
                        continue;
                    }
                }
            }

            return {
                numericSignature: numberSignature,
                stringSignature: stringSignature
            };
        };

        PullTypeResolver.prototype.resolveBinaryAdditionOperation = function (binaryExpression, enclosingDecl, context) {
            var lhsType = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type;
            var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

            if (TypeScript.PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (rhsType != this.semanticInfoChain.nullTypeSymbol && rhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    lhsType = rhsType;
                } else {
                    lhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (TypeScript.PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (lhsType != this.semanticInfoChain.nullTypeSymbol && lhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    rhsType = lhsType;
                } else {
                    rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var exprType = null;

            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            } else if (this.isAnyOrEquivalent(lhsType) || this.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (exprType) {
                if (binaryExpression.nodeType() === 41 /* AddAssignmentExpression */) {
                    var lhsExpression = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);
                    if (!this.isReference(binaryExpression.operand1, lhsExpression)) {
                        context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null);
                    }

                    this.checkAssignability(binaryExpression.operand1, exprType, lhsType, enclosingDecl, context);
                }
            } else {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_expression_types_not_known_to_support_the_addition_operator, null);
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.setTypeChecked(binaryExpression, context);
            }

            return exprType;
        };

        PullTypeResolver.prototype.resolveLogicalOrExpression = function (binex, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, false, enclosingDecl, context).type;
            var rightType = this.resolveAST(binex.operand2, false, enclosingDecl, context).type;

            var bestCommonType = this.bestCommonTypeOfTwoTypes(leftType, rightType, context);

            if (this.canTypeCheckAST(binex, context)) {
                this.typeCheckLogicalOrExpression(binex, enclosingDecl, context);
            }

            return bestCommonType;
        };

        PullTypeResolver.prototype.bestCommonTypeOfTwoTypes = function (type1, type2, context) {
            var collection = { getLength: function () {
                    return 2;
                }, getTypeAtIndex: function (index) {
                    return type2;
                } };
            return this.findBestCommonType(type1, collection, context);
        };

        PullTypeResolver.prototype.typeCheckLogicalOrExpression = function (binex, enclosingDecl, context) {
            this.setTypeChecked(binex, context);

            this.resolveAST(binex.operand1, false, enclosingDecl, context);
            this.resolveAST(binex.operand2, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveLogicalAndExpression = function (binex, enclosingDecl, context) {
            var secondOperandType = this.resolveAST(binex.operand2, false, enclosingDecl, context).type;

            if (this.canTypeCheckAST(binex, context)) {
                this.typeCheckLogicalAndExpression(binex, enclosingDecl, context);
            }

            return secondOperandType;
        };

        PullTypeResolver.prototype.typeCheckLogicalAndExpression = function (binex, enclosingDecl, context) {
            this.setTypeChecked(binex, context);

            this.resolveAST(binex.operand1, false, enclosingDecl, context);
            this.resolveAST(binex.operand2, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, enclosingDecl, context) {
            if (this.canTypeCheckAST(trinex, context)) {
                this.typeCheckConditionalExpression(trinex, enclosingDecl, context);
            }

            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).type;
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).type;

            if (!this.sourceIsSubtypeOfTarget(leftType, rightType, context) && !this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return this.getNewErrorTypeSymbol();
            }

            return this.bestCommonTypeOfTwoTypes(leftType, rightType, context);
        };

        PullTypeResolver.prototype.typeCheckConditionalExpression = function (trinex, enclosingDecl, context) {
            this.setTypeChecked(trinex, context);

            this.resolveAST(trinex.operand1, false, enclosingDecl, context);
            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).type;
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).type;

            if (!this.sourceIsSubtypeOfTarget(leftType, rightType, context) && !this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                context.postError(this.getUnitPath(), trinex.operand2.minChar, trinex.operand2.getLength(), TypeScript.DiagnosticCode.Type_of_conditional_expression_cannot_be_determined_0_is_not_identical_to_a_supertype_of_or_a_subtype_of_1, [leftType.toString(), rightType.toString()]);
            }
        };

        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, enclosingDecl, context) {
            return this.resolveAST(ast.expression, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, enclosingDecl, context) {
            if (this.canTypeCheckAST(ast, context)) {
                this.typeCheckExpressionStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.typeCheckExpressionStatement = function (ast, enclosingDecl, context) {
            this.setTypeChecked(ast, context);

            this.resolveAST(ast.expression, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveInvocationExpression = function (callEx, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeInvocationExpressionSymbol(callEx, enclosingDecl, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                if (symbol != this.semanticInfoChain.anyTypeSymbol) {
                    this.setSymbolForAST(callEx, symbol, context);
                }
                this.currentUnit.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckInvocationExpression(callEx, enclosingDecl, context);
                }

                var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                    additionalResults.targetTypeSymbol = callResolutionData.targetTypeSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.typeCheckInvocationExpression = function (callEx, enclosingDecl, context) {
            this.setTypeChecked(callEx, context);
            var targetSymbol = this.resolveAST(callEx.target, false, enclosingDecl, context);
            if (targetSymbol && callEx.target.nodeType() === 32 /* SuperExpression */) {
                var targetTypeSymbol = targetSymbol.type;
                if (targetTypeSymbol.isClass()) {
                    this.seenSuperConstructorCall = true;
                }
            }

            if (callEx.arguments) {
                var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);
                var isSuperCall = callEx.target.nodeType() === 32 /* SuperExpression */;

                var len = callEx.arguments.members.length;
                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols[i];
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }
                    var prevIsResolvingSuperConstructorCallArgument = context.isResolvingSuperConstructorCallArgument;

                    if (isSuperCall) {
                        context.isResolvingSuperConstructorCallArgument = true;
                    }

                    this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (isSuperCall) {
                        context.isResolvingSuperConstructorCallArgument = prevIsResolvingSuperConstructorCallArgument;
                    }

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
        };

        PullTypeResolver.prototype.computeInvocationExpressionSymbol = function (callEx, enclosingDecl, context, additionalResults) {
            var targetSymbol = this.resolveAST(callEx.target, false, enclosingDecl, context);
            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var targetTypeSymbol = targetSymbol.type;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.arguments, false, enclosingDecl, context);

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    if (targetTypeSymbol === this.semanticInfoChain.anyTypeSymbol) {
                        context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Untyped_function_calls_may_not_accept_type_arguments, null);
                        return this.getNewErrorTypeSymbol();
                    }
                }

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var isSuperCall = false;

            if (callEx.target.nodeType() === 32 /* SuperExpression */) {
                isSuperCall = true;

                if (targetTypeSymbol.isClass()) {
                    this.seenSuperConstructorCall = true;
                    targetSymbol = targetTypeSymbol.getConstructorMethod();
                    this.resolveDeclaredSymbol(targetSymbol, context);
                    targetTypeSymbol = targetSymbol.type;
                } else {
                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Calls_to_super_are_only_valid_inside_a_class, null);
                    this.resolveAST(callEx.arguments, false, enclosingDecl, context);

                    return this.getNewErrorTypeSymbol();
                }
            }

            var signatures = isSuperCall ? targetTypeSymbol.getConstructSignatures() : targetTypeSymbol.getCallSignatures();

            if (!signatures.length && (targetTypeSymbol.kind == 33554432 /* ConstructorType */)) {
                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, [targetTypeSymbol.toString()]);
            }

            var typeArgs = null;
            var typeReplacementMap = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var diagnostics = [];

            if (callEx.typeArguments) {
                typeArgs = [];

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            } else if (isSuperCall && targetTypeSymbol.isGeneric()) {
                typeArgs = targetTypeSymbol.getTypeArguments();
            }

            var triedToInferTypeArgs = false;

            if (targetTypeSymbol.isGeneric()) {
                var resolvedSignatures = [];
                var inferredTypeArgs;
                var specializedSignature;
                var typeParameters;
                var typeConstraint = null;
                var prevSpecializingToAny = context.specializingToAny;
                var prevSpecializing = context.isSpecializingSignatureTypeParameters;
                var beforeResolutionSignatures = signatures;

                for (var i = 0; i < signatures.length; i++) {
                    typeParameters = signatures[i].getTypeParameters();
                    couldNotAssignToConstraint = false;
                    triedToInferTypeArgs = false;

                    if (signatures[i].isGeneric() && typeParameters.length && (!signatures[i].isFixed() || typeArgs)) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        } else if (callEx.arguments) {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                            triedToInferTypeArgs = true;
                        } else {
                            inferredTypeArgs = [];
                        }

                        if (inferredTypeArgs) {
                            typeReplacementMap = {};

                            if (inferredTypeArgs.length) {
                                if (inferredTypeArgs.length != typeParameters.length) {
                                    continue;
                                }

                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeReplacementMap[typeParameters[j].pullSymbolIDString] = inferredTypeArgs[j];
                                }
                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeConstraint = typeParameters[j].getConstraint();

                                    if (typeConstraint) {
                                        if (typeConstraint.isTypeParameter()) {
                                            for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                if (typeParameters[k] == typeConstraint) {
                                                    typeConstraint = inferredTypeArgs[k];
                                                }
                                            }
                                        }
                                        if (typeConstraint.isTypeParameter()) {
                                            context.pushTypeSpecializationCache(typeReplacementMap);
                                            typeConstraint = TypeScript.specializeType(typeConstraint, null, this, context);
                                            context.popTypeSpecializationCache();
                                        }
                                        context.isComparingSpecializedSignatures = true;
                                        if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                            constraintDiagnostic = new TypeScript.Diagnostic(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(null, true), typeConstraint.toString(null, true), typeParameters[j].toString(null, true)]);
                                            couldNotAssignToConstraint = true;
                                        }
                                        context.isComparingSpecializedSignatures = false;

                                        if (couldNotAssignToConstraint) {
                                            break;
                                        }
                                    }
                                }
                            } else {
                                if (triedToInferTypeArgs) {
                                    if (signatures[i].isFixed()) {
                                        if (signatures[i].hasAGenericParameter) {
                                            context.specializingToAny = true;
                                        } else {
                                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                                        }
                                    } else {
                                        continue;
                                    }
                                }

                                context.specializingToAny = true;
                            }

                            if (couldNotAssignToConstraint) {
                                continue;
                            }

                            context.isSpecializingSignatureTypeParameters = true;
                            specializedSignature = TypeScript.specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                            context.isSpecializingSignatureTypeParameters = prevSpecializing;
                            context.specializingToAny = prevSpecializingToAny;

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    } else {
                        if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                        }
                    }
                }

                if (signatures.length && !resolvedSignatures.length) {
                    couldNotFindGenericOverload = true;
                }

                signatures = resolvedSignatures;
            }

            var errorCondition = null;

            if (!signatures.length) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;

                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                var prevIsResolvingSuperConstructorCallArgument = context.isResolvingSuperConstructorCallArgument;
                if (isSuperCall) {
                    context.isResolvingSuperConstructorCallArgument = true;
                }
                this.resolveAST(callEx.arguments, false, enclosingDecl, context);
                if (isSuperCall) {
                    context.isResolvingSuperConstructorCallArgument = prevIsResolvingSuperConstructorCallArgument;
                }

                if (!couldNotFindGenericOverload) {
                    if (this.cachedFunctionInterfaceType() && this.sourceIsSubtypeOfTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), context)) {
                        if (callEx.typeArguments) {
                            context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments, null);
                        }
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature, null);
                    errorCondition = this.getNewErrorTypeSymbol();
                } else {
                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression, null);
                    errorCondition = this.getNewErrorTypeSymbol();
                }

                if (constraintDiagnostic) {
                    context.postDiagnostic(constraintDiagnostic);
                }

                return errorCondition;
            }

            var prevIsResolvingSuperConstructorCallArgument = context.isResolvingSuperConstructorCallArgument;

            if (isSuperCall) {
                context.isResolvingSuperConstructorCallArgument = true;
            }

            var signature = this.resolveOverloads(callEx, signatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;

            if (isSuperCall) {
                context.isResolvingSuperConstructorCallArgument = prevIsResolvingSuperConstructorCallArgument;
            }

            if (!signature) {
                for (var i = 0; i < diagnostics.length; i++) {
                    context.postDiagnostic(diagnostics[i]);
                }

                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression, null);

                errorCondition = this.getNewErrorTypeSymbol();

                if (!signatures.length) {
                    return errorCondition;
                }

                signature = signatures[0];
            }

            if (!signature.isGeneric() && callEx.typeArguments) {
                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments, null);
            } else if (signature.isGeneric() && callEx.typeArguments && signature.getTypeParameters() && (callEx.typeArguments.members.length > signature.getTypeParameters().length)) {
                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [signature.getTypeParameters().length, callEx.typeArguments.members.length]);
            }

            var returnType = isSuperCall ? this.semanticInfoChain.voidTypeSymbol : signature.returnType;

            var actualParametersContextTypeSymbols = [];
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.parameters;
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];

                for (var i = 0; i < len; i++) {
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                            if (typeReplacementMap) {
                                context.pushTypeSpecializationCache(typeReplacementMap);
                            }
                            this.resolveDeclaredSymbol(params[i], context);
                            if (typeReplacementMap) {
                                context.popTypeSpecializationCache();
                            }
                            contextualType = params[i].type;
                        } else if (signature.hasVarArgs) {
                            contextualType = params[params.length - 1].type;
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }

                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }

                    var prevIsResolvingSuperConstructorCallArgument = context.isResolvingSuperConstructorCallArgument;

                    if (isSuperCall) {
                        context.isResolvingSuperConstructorCallArgument = true;
                    }

                    this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (isSuperCall) {
                        context.isResolvingSuperConstructorCallArgument = prevIsResolvingSuperConstructorCallArgument;
                    }

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }

            additionalResults.targetSymbol = targetSymbol;
            additionalResults.targetTypeSymbol = targetTypeSymbol;
            if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                additionalResults.resolvedSignatures = beforeResolutionSignatures;
                additionalResults.candidateSignature = beforeResolutionSignatures[0];
            } else {
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
            }
            additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

            if (errorCondition) {
                return errorCondition;
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveObjectCreationExpression = function (callEx, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx, context);

            if (!symbol || !symbol.isResolved) {
                if (!additionalResults) {
                    additionalResults = new PullAdditionalCallResolutionData();
                }
                symbol = this.computeObjectCreationExpressionSymbol(callEx, enclosingDecl, context, additionalResults);
                if (this.canTypeCheckAST(callEx, context)) {
                    this.setTypeChecked(callEx, context);
                }
                this.setSymbolForAST(callEx, symbol, context);
                this.currentUnit.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (this.canTypeCheckAST(callEx, context)) {
                    this.typeCheckObjectCreationExpression(callEx, enclosingDecl, context);
                }

                var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);
                if (additionalResults && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                    additionalResults.targetTypeSymbol = callResolutionData.targetTypeSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.typeCheckObjectCreationExpression = function (callEx, enclosingDecl, context) {
            this.setTypeChecked(callEx, context);
            this.resolveAST(callEx.target, false, enclosingDecl, context);
            var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);
            if (callEx.arguments) {
                var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);
                var len = callEx.arguments.members.length;

                for (var i = 0; i < len; i++) {
                    var contextualType = callResolutionData.actualParametersContextTypeSymbols[i];
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }

                    this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
        };

        PullTypeResolver.prototype.computeObjectCreationExpressionSymbol = function (callEx, enclosingDecl, context, additionalResults) {
            var returnType = null;

            var targetSymbol = this.resolveAST(callEx.target, false, enclosingDecl, context);
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.type;

            var targetAST = this.getCallTargetErrorSpanAST(callEx);

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var typeArgs = null;
            var typeReplacementMap = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var diagnostics = [];

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.arguments, false, enclosingDecl, context);
                return targetTypeSymbol;
            }

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;

                if (this.compilationSettings.noImplicitAny) {
                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type, null);
                }
            }

            if (constructSignatures.length) {
                if (callEx.typeArguments) {
                    typeArgs = [];

                    if (callEx.typeArguments && callEx.typeArguments.members.length) {
                        for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                            var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        }
                    }
                }

                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    var prevSpecializingToAny = context.specializingToAny;
                    var prevIsSpecializing = context.isSpecializingSignatureTypeParameters = true;
                    var triedToInferTypeArgs;

                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;

                        if (constructSignatures[i].isGeneric() && (!constructSignatures[i].isFixed() || typeArgs)) {
                            if (typeArgs) {
                                inferredTypeArgs = typeArgs;
                            } else if (callEx.arguments) {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                                triedToInferTypeArgs = true;
                            } else {
                                inferredTypeArgs = [];
                            }

                            if (inferredTypeArgs) {
                                typeParameters = constructSignatures[i].getTypeParameters();

                                typeReplacementMap = {};

                                if (inferredTypeArgs.length) {
                                    if (inferredTypeArgs.length < typeParameters.length) {
                                        continue;
                                    }

                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeReplacementMap[typeParameters[j].pullSymbolIDString] = inferredTypeArgs[j];
                                    }
                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeConstraint = typeParameters[j].getConstraint();

                                        if (typeConstraint) {
                                            if (typeConstraint.isTypeParameter()) {
                                                for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                    if (typeParameters[k] == typeConstraint) {
                                                        typeConstraint = inferredTypeArgs[k];
                                                    }
                                                }
                                            }
                                            if (typeConstraint.isTypeParameter()) {
                                                context.pushTypeSpecializationCache(typeReplacementMap);
                                                typeConstraint = TypeScript.specializeType(typeConstraint, null, this, context);
                                                context.popTypeSpecializationCache();
                                            }

                                            context.isComparingSpecializedSignatures = true;
                                            if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                                constraintDiagnostic = new TypeScript.Diagnostic(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(null, true), typeConstraint.toString(null, true), typeParameters[j].toString(null, true)]);
                                                couldNotAssignToConstraint = true;
                                            }
                                            context.isComparingSpecializedSignatures = false;

                                            if (couldNotAssignToConstraint) {
                                                break;
                                            }
                                        }
                                    }
                                } else {
                                    if (triedToInferTypeArgs) {
                                        if (constructSignatures[i].isFixed()) {
                                            if (!constructSignatures[i].hasAGenericParameter) {
                                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                                            }
                                        } else {
                                            continue;
                                        }
                                    } else {
                                        context.specializingToAny = true;
                                    }
                                }

                                if (couldNotAssignToConstraint) {
                                    continue;
                                }

                                context.isSpecializingSignatureTypeParameters = true;
                                specializedSignature = TypeScript.specializeSignature(constructSignatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                                context.specializingToAny = prevSpecializingToAny;
                                context.isSpecializingSignatureTypeParameters = prevIsSpecializing;

                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                }
                            }
                        } else {
                            if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                            }
                        }
                    }

                    constructSignatures = resolvedSignatures;
                }

                var signature = this.resolveOverloads(callEx, constructSignatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);

                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = [];

                if (!constructSignatures.length) {
                    if (constraintDiagnostic) {
                        context.postDiagnostic(constraintDiagnostic);
                    }

                    return this.getNewErrorTypeSymbol();
                }

                var errorCondition = null;

                if (!signature) {
                    for (var i = 0; i < diagnostics.length; i++) {
                        context.postDiagnostic(diagnostics[i]);
                    }

                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_new_expression, null);

                    errorCondition = this.getNewErrorTypeSymbol();

                    if (!constructSignatures.length) {
                        return errorCondition;
                    }

                    signature = constructSignatures[0];
                }

                if (signature.isGeneric() && callEx.typeArguments && signature.getTypeParameters() && (callEx.typeArguments.members.length > signature.getTypeParameters().length)) {
                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Signature_expected_0_type_arguments_got_1_instead, [signature.getTypeParameters().length, callEx.typeArguments.members.length]);
                }

                returnType = signature.returnType;

                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (typeArgs && typeArgs.length) {
                        returnType = TypeScript.specializeType(returnType, typeArgs, this, context);
                    } else {
                        returnType = this.specializeTypeToAny(returnType, enclosingDecl, context);
                    }
                }

                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Call_signatures_used_in_a_new_expression_must_have_a_void_return_type, null);

                        return this.getNewErrorTypeSymbol();
                    } else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (!returnType) {
                    returnType = signature.returnType;

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                var actualParametersContextTypeSymbols = [];
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.parameters;
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (var i = 0; i < len; i++) {
                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                                if (typeReplacementMap) {
                                    context.pushTypeSpecializationCache(typeReplacementMap);
                                }
                                this.resolveDeclaredSymbol(params[i], context);
                                if (typeReplacementMap) {
                                    context.popTypeSpecializationCache();
                                }
                                contextualType = params[i].type;
                            } else if (signature.hasVarArgs) {
                                contextualType = params[params.length - 1].type;
                                if (contextualType.isArray()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }

                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }

                        this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }

                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                additionalResults.resolvedSignatures = constructSignatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;

                if (errorCondition) {
                    return errorCondition;
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType;
            } else {
                this.resolveAST(callEx.arguments, false, enclosingDecl, context);
            }

            context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Invalid_new_expression, null);

            return this.getNewErrorTypeSymbol();
        };

        PullTypeResolver.prototype.resolveCastExpression = function (assertionExpression, enclosingDecl, context) {
            var typeAssertionType = this.resolveAST(assertionExpression.castType, false, enclosingDecl, context).type;

            if (this.canTypeCheckAST(assertionExpression, context)) {
                this.typeCheckCastExpression(assertionExpression, enclosingDecl, context);
            }

            return typeAssertionType;
        };

        PullTypeResolver.prototype.typeCheckCastExpression = function (assertionExpression, enclosingDecl, context) {
            this.setTypeChecked(assertionExpression, context);

            var typeAssertionType = this.resolveAST(assertionExpression.castType, false, enclosingDecl, context).type;
            var exprType = this.resolveAST(assertionExpression.operand, false, enclosingDecl, context).type;

            this.resolveDeclaredSymbol(typeAssertionType, context);
            this.resolveDeclaredSymbol(exprType, context);

            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(typeAssertionType, exprType, context, comparisonInfo) || this.sourceIsAssignableToTarget(exprType, typeAssertionType, context, comparisonInfo);

            if (!isAssignable) {
                if (comparisonInfo.message) {
                    context.postError(this.unitPath, assertionExpression.minChar, assertionExpression.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [exprType.toString(), typeAssertionType.toString(), comparisonInfo.message]);
                } else {
                    context.postError(this.unitPath, assertionExpression.minChar, assertionExpression.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [exprType.toString(), typeAssertionType.toString()]);
                }
            }
        };

        PullTypeResolver.prototype.resolveAssignmentExpression = function (binaryExpression, enclosingDecl, context) {
            var leftExpr = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);
            var leftType = leftExpr.type;

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            var rightType = this.resolveAST(binaryExpression.operand2, true, enclosingDecl, context).type;
            context.popContextualType();

            rightType = this.getInstanceTypeForAssignment(binaryExpression.operand1, rightType, enclosingDecl, context);

            if (this.canTypeCheckAST(binaryExpression, context)) {
                this.typeCheckAssignmentExpression(binaryExpression, enclosingDecl, context, leftExpr, rightType);
            }

            return rightType;
        };

        PullTypeResolver.prototype.typeCheckAssignmentExpression = function (binaryExpression, enclosingDecl, context, leftExpr, rightType) {
            this.setTypeChecked(binaryExpression, context);

            if (!this.isReference(binaryExpression.operand1, leftExpr)) {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null);
            } else {
                this.checkAssignability(binaryExpression.operand1, rightType, leftExpr.type, enclosingDecl, context);
            }
        };

        PullTypeResolver.prototype.computeAssignmentStatementSymbol = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).type;

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveAST(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();

            return leftType;
        };

        PullTypeResolver.prototype.getInstanceTypeForAssignment = function (lhs, type, enclosingDecl, context) {
            var typeToReturn = type;
            if (typeToReturn && typeToReturn.isAlias()) {
                typeToReturn = typeToReturn.getExportAssignedTypeSymbol();
            }

            if (typeToReturn && typeToReturn.isContainer() && !typeToReturn.isEnum()) {
                var instanceTypeSymbol = typeToReturn.getInstanceType();

                if (!instanceTypeSymbol) {
                    context.postError(this.unitPath, lhs.minChar, lhs.getLength(), TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [type.toString()]);
                    typeToReturn = null;
                } else {
                    typeToReturn = instanceTypeSymbol;
                }
            }

            return typeToReturn;
        };

        PullTypeResolver.prototype.mergeOrdered = function (a, b, context, comparisonInfo) {
            if (this.isAnyOrEquivalent(a) || this.isAnyOrEquivalent(b)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (a === b) {
                return a;
            } else if ((b === this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.voidTypeSymbol || b === this.semanticInfoChain.undefinedTypeSymbol || b === this.semanticInfoChain.nullTypeSymbol)) {
                return a;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.anyTypeSymbol)) {
                return b;
            } else if ((b === this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            } else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            } else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            } else if (a.isArray() && b.isArray()) {
                if (a.getElementType() === b.getElementType()) {
                    return a;
                } else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), context, comparisonInfo);
                    if (mergedET) {
                        var mergedArrayType = mergedET.getArrayType();

                        if (!mergedArrayType) {
                            mergedArrayType = TypeScript.specializeType(this.cachedArrayInterfaceType(), [mergedET], this, context);
                        }

                        return mergedArrayType;
                    }
                }
            } else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            } else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }

            return null;
        };

        PullTypeResolver.prototype.widenType = function (ast, type, enclosingDecl, context) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol || type === this.semanticInfoChain.nullTypeSymbol || type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (type.isArray()) {
                var elementType = this.widenType(null, type.getElementType(), enclosingDecl, context);

                if (this.compilationSettings.noImplicitAny && ast && ast.nodeType() === 23 /* ArrayLiteralExpression */) {
                    if (elementType === this.semanticInfoChain.anyTypeSymbol && type.getElementType() !== this.semanticInfoChain.anyTypeSymbol) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening, null);
                    }
                }

                var arraySymbol = elementType.getArrayType();

                if (!arraySymbol) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), context);

                    arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [elementType], this, context);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                return arraySymbol;
            }

            return type;
        };

        PullTypeResolver.prototype.isNullOrUndefinedType = function (type) {
            return type === this.semanticInfoChain.nullTypeSymbol || type === this.semanticInfoChain.undefinedTypeSymbol;
        };

        PullTypeResolver.prototype.canApplyContextualType = function (type) {
            if (!type) {
                return true;
            }

            var kind = type.kind;

            if ((kind & 8388608 /* ObjectType */) != 0) {
                return true;
            }
            if ((kind & 16 /* Interface */) != 0) {
                return true;
            } else if ((kind & TypeScript.PullElementKind.SomeFunction) != 0) {
                return this.canApplyContextualTypeToFunction(type, this.semanticInfoChain.getASTForDecl(type.getDeclarations[0]), true);
            } else if ((kind & 128 /* Array */) != 0) {
                return true;
            } else if (type == this.semanticInfoChain.anyTypeSymbol || kind != 2 /* Primitive */) {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.findBestCommonType = function (initialType, collection, context, comparisonInfo) {
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            var convergenceType = bestCommonType;

            while (nlastChecked < len) {
                for (var i = 0; i < len; i++) {
                    if (i === nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType === null || this.isAnyOrEquivalent(bestCommonType)) {
                        break;
                    }
                }

                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            if (!bestCommonType) {
                var emptyTypeDecl = new TypeScript.PullDecl("{}", "{}", 8388608 /* ObjectType */, 0 /* None */, new TypeScript.TextSpan(0, 0), this.currentUnit.getPath());
                var emptyType = new TypeScript.PullTypeSymbol("{}", 8388608 /* ObjectType */);

                emptyTypeDecl.setSymbol(emptyType);
                emptyType.addDeclaration(emptyTypeDecl);

                bestCommonType = emptyType;
            }

            return bestCommonType;
        };

        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, val) {
            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (val && t1.isPrimitive() && t1.isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripStartAndEndQuotes(val.actualText) === TypeScript.stripStartAndEndQuotes(t1.name));
            }

            if (val && t2.isPrimitive() && t2.isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripStartAndEndQuotes(val.actualText) === TypeScript.stripStartAndEndQuotes(t2.name));
            }

            if (t1.isPrimitive() && t1.isStringConstant() && t2.isPrimitive() && t2.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(t1.name) === TypeScript.stripStartAndEndQuotes(t2.name);
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isError() && t2.isError()) {
                return true;
            }

            if (t1.isTypeParameter()) {
                if (!t2.isTypeParameter()) {
                    return false;
                }

                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();

                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                } else {
                    return false;
                }
            }

            var comboId = t2.pullSymbolIDString + "#" + t1.pullSymbolIDString;

            if (this.identicalCache[comboId] != undefined) {
                return true;
            }

            if ((t1.kind & 64 /* Enum */) || (t2.kind & 64 /* Enum */)) {
                return t1.getAssociatedContainerType() === t2 || t2.getAssociatedContainerType() === t1;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.identicalCache[comboId] = true;
                } else {
                    this.identicalCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }

            this.identicalCache[comboId] = false;

            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();

                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol = null;
                var t2MemberSymbol = null;

                var t1MemberType = null;
                var t2MemberType = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getMemberSymbol(t1MemberSymbol.name, TypeScript.PullElementKind.SomeValue, t2);

                    if (!t2MemberSymbol || (t1MemberSymbol.isOptional != t2MemberSymbol.isOptional)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.type;
                    t2MemberType = t2MemberSymbol.type;

                    if (t1MemberType && t2MemberType && (this.identicalCache[t2MemberType.pullSymbolIDString + "#" + t1MemberType.pullSymbolIDString] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 === sg2) {
                return true;
            }

            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length != sg2.length) {
                return false;
            }

            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;

            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2, includingReturnType) {
            if (typeof includingReturnType === "undefined") { includingReturnType = true; }
            if (s1.hasVarArgs != s2.hasVarArgs) {
                return false;
            }

            if (s1.nonOptionalParamCount != s2.nonOptionalParamCount) {
                return false;
            }

            if (!!(s1.typeParameters && s1.typeParameters.length) != !!(s2.typeParameters && s2.typeParameters.length)) {
                return false;
            }

            if (s1.typeParameters && s2.typeParameters && (s1.typeParameters.length != s2.typeParameters.length)) {
                return false;
            }

            var s1Params = s1.parameters;
            var s2Params = s2.parameters;

            if (s1Params.length != s2Params.length) {
                return false;
            }

            if (includingReturnType && !this.typesAreIdentical(s1.returnType, s2.returnType)) {
                return false;
            }

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].type, s2Params[iParam].type)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.substituteUpperBoundForType = function (type) {
            if (!type || !type.isTypeParameter()) {
                return type;
            }

            var constraint = type.getConstraint();

            if (constraint) {
                return this.substituteUpperBoundForType(constraint);
            }

            return type;
        };

        PullTypeResolver.prototype.symbolsShareDeclaration = function (symbol1, symbol2) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();

            if (decls1.length && decls2.length) {
                return decls1[0].isEqual(decls2[0]);
            }

            return false;
        };

        PullTypeResolver.prototype.sourceExtendsTarget = function (source, target, context) {
            if (source.isGeneric() != target.isGeneric()) {
                return false;
            }

            if (source.kind & 33554432 /* ConstructorType */ && target.kind & 33554432 /* ConstructorType */) {
                return false;
            }

            if (source.hasBase(target)) {
                return true;
            }

            if (context.isInBaseTypeResolution() && (source.kind & (16 /* Interface */ | 8 /* Class */)) && (target.kind & (16 /* Interface */ | 8 /* Class */))) {
                var sourceDecls = source.getDeclarations();
                var sourceAST = null;
                var extendsSymbol = null;
                var extendsList = null;

                for (var i = 0; i < sourceDecls.length; i++) {
                    sourceAST = this.semanticInfoChain.getASTForDecl(sourceDecls[i]);
                    extendsList = sourceAST.extendsList;

                    if (extendsList && extendsList.members && extendsList.members.length) {
                        for (var j = 0; j < extendsList.members.length; j++) {
                            extendsSymbol = this.semanticInfoChain.getSymbolForAST(extendsList.members[j], sourceDecls[i].getScriptName());

                            if (extendsSymbol && (extendsSymbol == target || this.sourceExtendsTarget(extendsSymbol, target, context))) {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceMembersAreSubtypeOfTargetMembers = function (source, target, context, comparisonInfo) {
            return this.sourceMembersAreRelatableToTargetMembers(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourcePropertyIsSubtypeOfTargetProperty = function (source, target, sourceProp, targetProp, context, comparisonInfo) {
            return this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreSubtypeOfTargetCallSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.typeIsSubtypeOfFunction = function (source, context) {
            if (source.getCallSignatures().length || source.getConstructSignatures().length) {
                return true;
            }

            return this.cachedFunctionInterfaceType() && this.sourceIsSubtypeOfTarget(source, this.cachedFunctionInterfaceType(), context);
        };

        PullTypeResolver.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, context, comparisonInfo, isInProvisionalResolution) {
            if (typeof isInProvisionalResolution === "undefined") { isInProvisionalResolution = false; }
            var cache = isInProvisionalResolution ? {} : this.assignableCache;
            return this.sourceIsRelatableToTarget(source, target, true, cache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            if (source === target) {
                return true;
            }

            if (!(source && target)) {
                return true;
            }

            if (context.specializingToAny && (target.isTypeParameter() || source.isTypeParameter())) {
                return true;
            }

            var sourceSubstitution = source;

            if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedStringInterfaceType(), context);
                sourceSubstitution = this.cachedStringInterfaceType();
            } else if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedNumberInterfaceType(), context);
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType(), context);
                sourceSubstitution = this.cachedBooleanInterfaceType();
            } else if (TypeScript.PullHelpers.symbolIsEnum(source) && this.cachedNumberInterfaceType()) {
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source.isTypeParameter()) {
                sourceSubstitution = this.substituteUpperBoundForType(source);
            }

            var comboId = source.pullSymbolIDString + "#" + target.pullSymbolIDString;

            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && target.isStringConstant()) {
                    return comparisonInfo && comparisonInfo.stringConstantVal && (comparisonInfo.stringConstantVal.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripStartAndEndQuotes(comparisonInfo.stringConstantVal.actualText) === TypeScript.stripStartAndEndQuotes(target.name));
                }
            } else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && source.isStringConstant()) {
                    return true;
                }
            }

            if (source.isPrimitive() && source.isStringConstant() && target.isPrimitive() && target.isStringConstant()) {
                return TypeScript.stripStartAndEndQuotes(source.name) === TypeScript.stripStartAndEndQuotes(target.name);
            }

            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            if (target == this.semanticInfoChain.voidTypeSymbol) {
                if (source == this.semanticInfoChain.anyTypeSymbol || source == this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }

                return false;
            } else if (source == this.semanticInfoChain.voidTypeSymbol) {
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }

                return false;
            }

            if (target === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return true;
            }

            if (source === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(target)) {
                return true;
            }

            if (TypeScript.PullHelpers.symbolIsEnum(target) && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }

            if ((source.kind & 64 /* Enum */) || (target.kind & 64 /* Enum */)) {
                return false;
            }

            if (source.isArray() && target.isArray()) {
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            } else if (source.isArray() && target == this.cachedArrayInterfaceType()) {
                return true;
            } else if (target.isArray() && source == this.cachedArrayInterfaceType()) {
                return true;
            }

            if (source.isPrimitive() && target.isPrimitive()) {
                return false;
            } else if (source.isPrimitive() != target.isPrimitive()) {
                if (target.isPrimitive()) {
                    return false;
                }
            }

            if (target.isTypeParameter()) {
                if (source.isTypeParameter() && (source == sourceSubstitution)) {
                    var targetParentDeclaration = target.getDeclarations()[0].getParentDecl();
                    var sourceParentDeclaration = source.getDeclarations()[0].getParentDecl();

                    if (targetParentDeclaration !== sourceParentDeclaration) {
                        return this.symbolsShareDeclaration(target, source);
                    } else {
                        return this.typesAreIdentical(target, sourceSubstitution);
                    }
                } else {
                    if (context.isComparingSpecializedSignatures) {
                        target = this.substituteUpperBoundForType(target);
                    } else {
                        return this.typesAreIdentical(target, sourceSubstitution);
                    }
                }
            }

            comparisonCache[comboId] = false;

            if (this.sourceExtendsTarget(source, target, context)) {
                return true;
            }

            if (this.cachedObjectInterfaceType() && target === this.cachedObjectInterfaceType()) {
                return true;
            }

            if (this.cachedFunctionInterfaceType() && (sourceSubstitution.getCallSignatures().length || sourceSubstitution.getConstructSignatures().length) && target === this.cachedFunctionInterfaceType()) {
                return true;
            }

            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            comparisonCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetProps = target.getAllMembers(TypeScript.PullElementKind.SomeValue, 0 /* all */);

            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];
                var sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, source);

                this.resolveDeclaredSymbol(targetProp, context);

                var targetPropType = targetProp.type;

                if (sourceProp && sourceProp.hasFlag(16 /* Static */) && source.isClass()) {
                    sourceProp = null;
                }

                if (!sourceProp) {
                    if (this.cachedObjectInterfaceType()) {
                        sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                    }

                    if (!sourceProp) {
                        if (this.cachedFunctionInterfaceType() && (targetPropType.getCallSignatures().length || targetPropType.getConstructSignatures().length)) {
                            sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                        }

                        if (!sourceProp) {
                            if (!(targetProp.isOptional)) {
                                if (comparisonInfo) {
                                    comparisonInfo.flags |= 2 /* RequiredPropertyIsMissing */;
                                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_is_missing_property_1_from_type_2, [source.toString(), targetProp.getScopedNameEx().toString(), target.toString()]));
                                }
                                return false;
                            }
                            continue;
                        }
                    }
                }

                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetPropIsPrivate = targetProp.hasFlag(2 /* Private */);
            var sourcePropIsPrivate = sourceProp.hasFlag(2 /* Private */);

            if (targetPropIsPrivate != sourcePropIsPrivate) {
                if (comparisonInfo) {
                    if (targetPropIsPrivate) {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    } else {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    }
                    comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                }
                return false;
            } else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];

                if (!targetDecl.isEqual(sourceDecl)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_define_property_2_as_private, [sourceProp.getContainer().toString(), targetProp.getContainer().toString(), targetProp.getScopedNameEx().toString()]));
                    }

                    return false;
                }
            }

            this.resolveDeclaredSymbol(sourceProp, context);

            var sourcePropType = sourceProp.type;
            var targetPropType = targetProp.type;

            if (targetPropType && sourcePropType && (comparisonCache[sourcePropType.pullSymbolIDString + "#" + targetPropType.pullSymbolIDString] != undefined)) {
                return true;
            }

            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeComparisonInfo(comparisonInfo);
            }
            if (!this.sourceIsRelatableToTarget(sourcePropType, targetPropType, assignableTo, comparisonCache, context, comparisonInfoPropertyTypeCheck)) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 32 /* IncompatiblePropertyTypes */;
                    var message;
                    if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString(), comparisonInfoPropertyTypeCheck.message]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString()]);
                    }
                    comparisonInfo.addMessage(message);
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetCallSigs = target.getCallSignatures();

            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetCallSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetCallSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_call_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetConstructSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetConstructSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_construct_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetIndexSigs = this.getBothKindsOfIndexSignatures(target, context);
            var targetStringSig = targetIndexSigs.stringSignature;
            var targetNumberSig = targetIndexSigs.numericSignature;

            if (targetStringSig || targetNumberSig) {
                var sourceIndexSigs = this.getBothKindsOfIndexSignatures(source, context);
                var sourceStringSig = sourceIndexSigs.stringSignature;
                var sourceNumberSig = sourceIndexSigs.numericSignature;

                var comparable = true;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                if (targetStringSig) {
                    if (sourceStringSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceStringSig, targetStringSig, context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (comparable && targetNumberSig) {
                    if (sourceNumberSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceNumberSig, targetNumberSig, context, comparisonInfoSignatuesTypeCheck);
                    } else if (sourceStringSig) {
                        comparable = this.sourceIsAssignableToTarget(sourceStringSig.returnType, targetNumberSig.returnType, context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (!comparable) {
                    if (comparisonInfo) {
                        var message;
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var mSig = null;
            var nSig = null;
            var foundMatch = false;

            var targetExcludeDefinition = targetSG.length > 1;
            var sourceExcludeDefinition = sourceSG.length > 1;
            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];

                if (mSig.isStringConstantOverloadSignature() || (targetExcludeDefinition && mSig.isDefinition())) {
                    continue;
                }

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];

                    if (nSig.isStringConstantOverloadSignature() || (sourceExcludeDefinition && nSig.isDefinition())) {
                        continue;
                    }

                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo) {
            sourceSig = this.specializeSignatureToObject(sourceSig, sourceSig.getDeclarations()[0].getParentDecl(), context);
            targetSig = this.specializeSignatureToObject(targetSig, targetSig.getDeclarations()[0].getParentDecl(), context);

            var sourceParameters = sourceSig.parameters;
            var targetParameters = targetSig.parameters;

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetVarArgCount = targetSig.nonOptionalParamCount;
            var sourceVarArgCount = sourceSig.nonOptionalParamCount;

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVarArgs) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 3 /* SourceSignatureHasTooManyParameters */;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signature_expects_0_or_fewer_parameters, [targetVarArgCount]));
                }
                return false;
            }

            var sourceReturnType = sourceSig.returnType;
            var targetReturnType = targetSig.returnType;

            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 16 /* IncompatibleReturnTypes */;
                    }

                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && (sourceSig.hasVarArgs || (sourceParameters.length > sourceVarArgCount))) ? targetVarArgCount : sourceVarArgCount;

            if (!len) {
                len = (sourceParameters.length < targetParameters.length) ? sourceParameters.length : targetParameters.length;
            }

            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (iSource < sourceParameters.length && (!sourceSig.hasVarArgs || iSource < sourceVarArgCount)) {
                    sourceParamType = sourceParameters[iSource].type;
                    sourceParamName = sourceParameters[iSource].name;
                } else if (iSource === sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].type;
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].name;
                }

                if (iTarget < targetParameters.length && !targetSig.hasVarArgs && (!targetVarArgCount || (iTarget < targetVarArgCount))) {
                    targetParamType = targetParameters[iTarget].type;
                    targetParamName = targetParameters[iTarget].name;
                } else if (targetSig.hasVarArgs && iTarget === targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].type;

                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].name;
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 64 /* IncompatibleParameterTypes */;
                    }

                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.resolveOverloads = function (application, group, enclosingDecl, haveTypeArgumentsAtCallSite, context, diagnostics) {
            var finalDecision = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args = application.arguments;

            var signature;
            var returnType;
            var initialCandidates = TypeScript.ArrayUtilities.where(group, function (signature) {
                return !(hasOverloads && signature.isDefinition() || (haveTypeArgumentsAtCallSite && !signature.isGeneric()));
            });

            var applicableCandidates = this.getApplicableSignatures(initialCandidates, args, comparisonInfo, enclosingDecl, context);
            if (applicableCandidates.length > 0) {
                finalDecision = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);
            } else {
                var target = this.getCallTargetErrorSpanAST(application);
                if (comparisonInfo.message) {
                    diagnostics.push(new TypeScript.Diagnostic(this.unitPath, target.minChar, target.getLength(), TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0, [comparisonInfo.message]));
                } else {
                    diagnostics.push(new TypeScript.Diagnostic(this.unitPath, target.minChar, target.getLength(), TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null));
                }
            }

            return finalDecision;
        };

        PullTypeResolver.prototype.getCallTargetErrorSpanAST = function (callEx) {
            return (callEx.target.nodeType() === 34 /* MemberAccessExpression */) ? callEx.target.operand2 : callEx.target;
        };

        PullTypeResolver.prototype.overloadHasCorrectArity = function (signature, args) {
            if (args == null) {
                return signature.nonOptionalParamCount === 0;
            }

            var numberOfArgs = (args.members.length && args.members.length === args.separatorCount) ? args.separatorCount + 1 : args.members.length;
            if (numberOfArgs < signature.nonOptionalParamCount) {
                return false;
            }
            if (!signature.hasVarArgs && numberOfArgs > signature.parameters.length) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.overloadIsApplicable = function (signature, args, enclosingDecl, context, comparisonInfo) {
            if (args == null) {
                if (signature.nonOptionalParamCount > 0) {
                    return 0 /* NotApplicable */;
                } else {
                    return 2 /* ApplicableWithNoProvisionalErrors */;
                }
            } else {
                if (!this.overloadHasCorrectArity(signature, args)) {
                    return 0 /* NotApplicable */;
                }

                var isInVarArg = false;
                var hasProvisionalErrors = false;
                var parameters = signature.parameters;
                var hasProvisionalErrors = false;
                var paramType = null;

                for (var i = 0; i < args.members.length; i++) {
                    if (!isInVarArg) {
                        this.resolveDeclaredSymbol(parameters[i], context);

                        if (parameters[i].isVarArg) {
                            paramType = parameters[i].type.getElementType() || this.semanticInfoChain.anyTypeSymbol;
                            isInVarArg = true;
                        } else {
                            paramType = parameters[i].type;
                        }
                    }

                    var applicability = this.overloadIsApplicableForArgument(paramType, args.members[i], i, enclosingDecl, context, comparisonInfo);
                    if (applicability === 0 /* NotApplicable */) {
                        return applicability;
                    } else {
                        hasProvisionalErrors = hasProvisionalErrors || (applicability === 1 /* ApplicableButWithProvisionalErrors */);
                    }
                }

                return hasProvisionalErrors ? 1 /* ApplicableButWithProvisionalErrors */ : 2 /* ApplicableWithNoProvisionalErrors */;
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForArgument = function (paramType, arg, argIndex, enclosingDecl, context, comparisonInfo) {
            if (this.isAnyOrEquivalent(paramType)) {
                return 2 /* ApplicableWithNoProvisionalErrors */;
            } else if (arg.nodeType() === 82 /* ArrowFunctionExpression */) {
                var arrowFunction = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, arrowFunction.typeParameters, arrowFunction.parameters, arrowFunction.returnTypeAnnotation, arrowFunction.block, argIndex, enclosingDecl, context, comparisonInfo);
            } else if (arg.nodeType() === 13 /* FunctionDeclaration */) {
                var funcDecl = arg;
                return this.overloadIsApplicableForAnyFunctionExpressionArgument(paramType, arg, funcDecl.typeParameters, funcDecl.parameters, funcDecl.returnTypeAnnotation, funcDecl.block, argIndex, enclosingDecl, context, comparisonInfo);
            } else if (arg.nodeType() === 24 /* ObjectLiteralExpression */) {
                return this.overloadIsApplicableForObjectLiteralArgument(paramType, arg, argIndex, enclosingDecl, context, comparisonInfo);
            } else if (arg.nodeType() === 23 /* ArrayLiteralExpression */) {
                return this.overloadIsApplicableForArrayLiteralArgument(paramType, arg, argIndex, enclosingDecl, context, comparisonInfo);
            } else {
                return this.overloadIsApplicableForOtherArgument(paramType, arg, argIndex, enclosingDecl, context, comparisonInfo);
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForAnyFunctionExpressionArgument = function (paramType, arg, typeParameters, parameters, returnTypeAnnotation, block, argIndex, enclosingDecl, context, comparisonInfo) {
            if (this.cachedFunctionInterfaceType() && paramType === this.cachedFunctionInterfaceType()) {
                return 2 /* ApplicableWithNoProvisionalErrors */;
            }

            context.pushContextualType(paramType, true, null);

            var argSym = this.resolveAnyFunctionExpression(arg, typeParameters, parameters, returnTypeAnnotation, block, true, enclosingDecl, context);

            var applicable = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, context);
            var cxt = context.popContextualType();

            if (applicable) {
                return cxt.hasProvisionalErrors ? 1 /* ApplicableButWithProvisionalErrors */ : 2 /* ApplicableWithNoProvisionalErrors */;
            } else {
                return 0 /* NotApplicable */;
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForObjectLiteralArgument = function (paramType, arg, argIndex, enclosingDecl, context, comparisonInfo) {
            if (this.cachedObjectInterfaceType() && paramType === this.cachedObjectInterfaceType()) {
                return 2 /* ApplicableWithNoProvisionalErrors */;
            }

            context.pushContextualType(paramType, true, null);
            var argSym = this.resolveObjectLiteralExpression(arg, true, enclosingDecl, context);

            var applicable = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, context);

            var cxt = context.popContextualType();
            if (applicable) {
                return cxt.hasProvisionalErrors ? 1 /* ApplicableButWithProvisionalErrors */ : 2 /* ApplicableWithNoProvisionalErrors */;
            } else {
                return 0 /* NotApplicable */;
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForArrayLiteralArgument = function (paramType, arg, argIndex, enclosingDecl, context, comparisonInfo) {
            if (paramType === this.cachedArrayInterfaceType()) {
                return 2 /* ApplicableWithNoProvisionalErrors */;
            }

            context.pushContextualType(paramType, true, null);
            var argSym = this.resolveArrayLiteralExpression(arg, true, enclosingDecl, context);

            var applicable = this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, context);

            var cxt = context.popContextualType();

            if (applicable) {
                return cxt.hasProvisionalErrors ? 1 /* ApplicableButWithProvisionalErrors */ : 2 /* ApplicableWithNoProvisionalErrors */;
            } else {
                return 0 /* NotApplicable */;
            }
        };

        PullTypeResolver.prototype.overloadIsApplicableForOtherArgument = function (paramType, arg, argIndex, enclosingDecl, context, comparisonInfo) {
            var argSym = this.resolveAST(arg, false, enclosingDecl, context);

            if (argSym.type.isAlias()) {
                var aliasSym = argSym.type;
                argSym = aliasSym.getExportAssignedTypeSymbol();
            }

            comparisonInfo.stringConstantVal = arg;
            return this.overloadIsApplicableForArgumentHelper(paramType, argSym.type, argIndex, comparisonInfo, context) ? 2 /* ApplicableWithNoProvisionalErrors */ : 0 /* NotApplicable */;
        };

        PullTypeResolver.prototype.overloadIsApplicableForArgumentHelper = function (paramType, argSym, argumentIndex, comparisonInfo, context) {
            if (this.sourceIsAssignableToTarget(argSym.type, paramType, context, comparisonInfo, true)) {
                return true;
            }

            if (comparisonInfo && !comparisonInfo.message) {
                comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [paramType.toString(), (argumentIndex + 1), argSym.getTypeName()]));
            }

            return false;
        };

        PullTypeResolver.prototype.getApplicableSignatures = function (candidateSignatures, args, comparisonInfo, enclosingDecl, context) {
            var applicableSigs = [];

            for (var i = 0; i < candidateSignatures.length; i++) {
                var applicability = this.overloadIsApplicable(candidateSignatures[i], args, enclosingDecl, context, comparisonInfo);
                if (applicability !== 0 /* NotApplicable */) {
                    applicableSigs[applicableSigs.length] = { signature: candidateSignatures[i], hasProvisionalErrors: applicability === 1 /* ApplicableButWithProvisionalErrors */ };
                }
            }

            return applicableSigs;
        };

        PullTypeResolver.prototype.findMostApplicableSignature = function (signatures, args, enclosingDecl, context) {
            if (signatures.length === 1) {
                return signatures[0].signature;
            }

            var best = signatures[0];

            var PType = null;
            var QType = null;

            var ambiguous = false;

            var pParams;
            var qParams;

            for (var p = 0; p < best.signature.parameters.length; p++) {
                this.resolveDeclaredSymbol(best.signature.parameters[p], context);
            }

            if (args) {
                var ATypes = new Array(args.members.length);
                context.pushContextualType(this.semanticInfoChain.anyTypeSymbol, true, null);
                for (var i = 0; i < args.members.length; i++) {
                    ATypes[i] = this.resolveAST(args.members[i], true, enclosingDecl, context).type;
                }
                context.popContextualType();
            }

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                var P = best;
                var Q = signatures[qSig];

                for (var i = 0; args && i < args.members.length; i++) {
                    pParams = P.signature.parameters;
                    qParams = Q.signature.parameters;

                    PType = i < pParams.length ? pParams[i].type : pParams[pParams.length - 1].type.getElementType();
                    QType = i < qParams.length ? qParams[i].type : qParams[qParams.length - 1].type.getElementType();

                    if (this.typesAreIdentical(PType, QType) && !(QType.isPrimitive() && QType.isStringConstant())) {
                        continue;
                    } else if (PType.isPrimitive() && PType.isStringConstant() && args.members[i].nodeType() === 5 /* StringLiteral */ && TypeScript.stripStartAndEndQuotes(args.members[i].actualText) === TypeScript.stripStartAndEndQuotes(PType.name)) {
                        best = P;
                        break;
                    } else if (QType.isPrimitive() && QType.isStringConstant() && args.members[i].nodeType() === 5 /* StringLiteral */ && TypeScript.stripStartAndEndQuotes(args.members[i].actualText) === TypeScript.stripStartAndEndQuotes(QType.name)) {
                        best = Q;
                    } else if (this.typesAreIdentical(ATypes[i], PType)) {
                        best = P;
                        break;
                    } else if (this.typesAreIdentical(ATypes[i], QType)) {
                        best = Q;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        best = P;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                    } else if (Q.hasProvisionalErrors) {
                        best = P;
                        break;
                    } else if (P.hasProvisionalErrors) {
                        best = Q;
                    }
                }
            }

            return best.signature;
        };

        PullTypeResolver.prototype.canApplyContextualTypeToFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation) {
                return false;
            }

            beStringent = beStringent || (this.cachedFunctionInterfaceType() === candidateType);

            if (!beStringent) {
                return true;
            }
            var functionSymbol = this.getDeclForAST(funcDecl).getSymbol();
            var signature = functionSymbol.type.getCallSignatures()[0];
            var parameters = signature.parameters;
            var paramLen = parameters.length;

            for (var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = this.getASTForDecl(param.getDeclarations()[0]);

                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }

            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();

            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, args, comparisonInfo, enclosingDecl, context) {
            var cxt = null;

            var parameters = signature.parameters;
            var typeParameters = signature.getTypeParameters();
            var argContext = new TypeScript.ArgumentInferenceContext();

            var parameterType = null;

            for (var i = 0; i < typeParameters.length; i++) {
                argContext.addInferenceRoot(typeParameters[i]);
            }

            var substitutions;
            var inferenceCandidates;
            var inferenceCandidate;

            for (var i = 0; i < args.members.length; i++) {
                if (i >= parameters.length) {
                    break;
                }

                parameterType = parameters[i].type;

                if (signature.hasVarArgs && (i >= signature.nonOptionalParamCount - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }

                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};

                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {
                        argContext.resetRelationshipCache();

                        inferenceCandidate = inferenceCandidates[j];

                        substitutions = inferenceCandidates[j];

                        context.pushContextualType(parameterType, true, substitutions);

                        var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context);

                        this.relateTypeToTypeParameters(argSym.type, parameterType, false, argContext, enclosingDecl, context);

                        cxt = context.popContextualType();
                    }
                } else {
                    context.pushContextualType(parameterType, true, {});
                    var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context);

                    this.relateTypeToTypeParameters(argSym.type, parameterType, false, argContext, enclosingDecl, context);

                    cxt = context.popContextualType();
                }
            }

            var inferenceResults = argContext.inferArgumentTypes(this, enclosingDecl, context);

            if (inferenceResults.unfit) {
                return null;
            }

            var resultTypes = [];

            for (var i = 0; i < typeParameters.length; i++) {
                for (var j = 0; j < inferenceResults.results.length; j++) {
                    if (inferenceResults.results[j].param == typeParameters[i]) {
                        resultTypes[resultTypes.length] = inferenceResults.results[j].type;
                        break;
                    }
                }
            }

            if (!args.members.length && !resultTypes.length && typeParameters.length) {
                for (var i = 0; i < typeParameters.length; i++) {
                    resultTypes[resultTypes.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (resultTypes.length && resultTypes.length < typeParameters.length) {
                for (var i = resultTypes.length; i < typeParameters.length; i++) {
                    resultTypes[i] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return resultTypes;
        };

        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            if (!expressionType || !parameterType) {
                return;
            }

            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (parameterType === expressionType) {
                return;
            }

            if (parameterType.isTypeParameter()) {
                if (expressionType.isGeneric() && !expressionType.isFixed() && !expressionType.isTypeParameter()) {
                    expressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
                }
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var parameterDeclarations = parameterType.getDeclarations();
            var expressionDeclarations = expressionType.getDeclarations();
            if (!parameterType.isArray() && parameterDeclarations.length && expressionDeclarations.length && !(parameterType.isTypeParameter() || expressionType.isTypeParameter()) && (parameterDeclarations[0].isEqual(expressionDeclarations[0]) || (expressionType.isGeneric() && parameterType.isGeneric() && this.sourceIsSubtypeOfTarget(expressionType, parameterType, context, null))) && expressionType.isGeneric()) {
                var typeParameters = parameterType.getTypeArgumentsOrTypeParameters();
                var typeArguments = expressionType.getTypeArguments();

                if (!typeArguments) {
                    typeParameters = parameterType.getTypeArguments();
                    typeArguments = expressionType.getTypeArgumentsOrTypeParameters();
                }

                if (typeParameters && typeArguments && typeParameters.length === typeArguments.length) {
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (typeArguments[i] != typeParameters[i]) {
                            this.relateTypeToTypeParameters(typeArguments[i], typeParameters[i], true, argContext, enclosingDecl, context);
                        }
                    }
                }
            }

            var prevSpecializingToAny = context.specializingToAny;
            context.specializingToAny = true;

            if (!this.sourceIsAssignableToTarget(expressionType, parameterType, context)) {
                context.specializingToAny = prevSpecializingToAny;
                return;
            }
            context.specializingToAny = prevSpecializingToAny;

            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);

                return;
            }

            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, enclosingDecl, context) {
            var expressionParams = expressionSignature.parameters;
            var expressionReturnType = expressionSignature.returnType;

            var parameterParams = parameterSignature.parameters;
            var parameterReturnType = parameterSignature.returnType;

            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;

            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].type, parameterParams[i].type, true, argContext, enclosingDecl, context);
            }

            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, false, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var parameterSignature;

            var objectMember;
            var objectSignatures;

            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();

            if (objectTypeArguments && (objectTypeArguments.length === parameterTypeParameters.length)) {
                for (var i = 0; i < objectTypeArguments.length; i++) {
                    argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                }
            }

            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getMemberSymbol(parameterTypeMembers[i].name, TypeScript.PullElementKind.SomeValue, objectType);

                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.type, parameterTypeMembers[i].type, shouldFix, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        };

        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();

            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.specializeTypeToAny = function (typeToSpecialize, enclosingDecl, context) {
            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var rootType = TypeScript.getRootType(typeToSpecialize);

            var type = TypeScript.specializeType(rootType, [], this, context);

            context.specializingToAny = prevSpecialize;

            return type;
        };

        PullTypeResolver.prototype.specializeSignatureToAny = function (signatureToSpecialize, enclosingDecl, context) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap = {};
            var typeArguments = [];

            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].pullSymbolIDString] = typeArguments[i];
            }
            if (!typeArguments.length) {
                typeArguments[0] = this.semanticInfoChain.anyTypeSymbol;
            }

            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var sig = TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;

            return sig;
        };

        PullTypeResolver.prototype.specializeSignatureToObject = function (signatureToSpecialize, enclosingDecl, context) {
            if (!signatureToSpecialize.cachedObjectSpecialization) {
                var typeParameters = signatureToSpecialize.getTypeParameters();

                if (typeParameters.length) {
                    var typeReplacementMap = {};
                    var typeArguments = [];

                    for (var i = 0; i < typeParameters.length; i++) {
                        typeArguments[i] = this.cachedObjectInterfaceType();
                        typeReplacementMap[typeParameters[i].pullSymbolIDString] = typeArguments[i];
                    }

                    signatureToSpecialize.cachedObjectSpecialization = TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
                } else {
                    signatureToSpecialize.cachedObjectSpecialization = signatureToSpecialize;
                }
            }

            return signatureToSpecialize.cachedObjectSpecialization;
        };

        PullTypeResolver.typeCheck = function (compilationSettings, semanticInfoChain, scriptName, script) {
            var unit = semanticInfoChain.getUnit(scriptName);

            if (!unit.hasBeenTypeChecked) {
                unit.hasBeenTypeChecked = true;

                var scriptDecl = unit.getTopLevelDecl();

                var resolver = new PullTypeResolver(compilationSettings, semanticInfoChain, scriptName);
                var context = new TypeScript.PullTypeResolutionContext(resolver, true, scriptName);

                resolver.resolveAST(script, false, scriptDecl, context);
                resolver.validateVariableDeclarationGroups(scriptDecl, context);

                while (PullTypeResolver.typeCheckCallBacks.length) {
                    var callBack = PullTypeResolver.typeCheckCallBacks.pop();
                    callBack(context);
                }

                resolver.processPostTypeCheckWorkItems(context);

                PullTypeResolver.globalTypeCheckPhase++;
            }
        };

        PullTypeResolver.prototype.validateVariableDeclarationGroups = function (enclosingDecl, context) {
            var importDeclarationNames = null;
            if (enclosingDecl.kind & (4 /* Container */ | 32 /* DynamicModule */ | 1 /* Script */)) {
                var childDecls = enclosingDecl.getChildDecls();
                for (var i = 0, n = childDecls.length; i < n; i++) {
                    var childDecl = childDecls[i];
                    if (childDecl.kind === 256 /* TypeAlias */) {
                        importDeclarationNames = importDeclarationNames || new TypeScript.BlockIntrinsics();
                        importDeclarationNames[childDecl.name] = true;
                    }
                }
            }

            var declGroups = enclosingDecl.getVariableDeclGroups();

            for (var i = 0, i_max = declGroups.length; i < i_max; i++) {
                var firstSymbol = null;
                var firstSymbolType = null;

                if (enclosingDecl.kind === 1 /* Script */ && declGroups[i].length) {
                    var name = declGroups[i][0].name;
                    var candidateSymbol = this.semanticInfoChain.findTopLevelSymbol(name, 1024 /* Variable */, enclosingDecl.getScriptName());
                    if (candidateSymbol && candidateSymbol.isResolved) {
                        if (!candidateSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable)) {
                            firstSymbol = candidateSymbol;
                            firstSymbolType = candidateSymbol.type;
                        }
                    }

                    var importSymbol = this.semanticInfoChain.findTopLevelSymbol(name, 256 /* TypeAlias */, null);
                    if (importSymbol && importSymbol.isAlias()) {
                        importDeclarationNames = importDeclarationNames || new TypeScript.BlockIntrinsics();
                        importDeclarationNames[name] = true;
                    }
                }

                for (var j = 0, j_max = declGroups[i].length; j < j_max; j++) {
                    var decl = declGroups[i][j];
                    var boundDeclAST = this.semanticInfoChain.getASTForDecl(decl);

                    var name = decl.name;

                    if (importDeclarationNames && importDeclarationNames[name]) {
                        context.postError(this.currentUnit.getPath(), boundDeclAST.minChar, boundDeclAST.getLength(), TypeScript.DiagnosticCode.Variable_declaration_cannot_have_the_same_name_as_an_import_declaration, null);
                        continue;
                    }

                    var symbol = decl.getSymbol();
                    var symbolType = symbol.type;

                    if (j === 0 && !firstSymbol) {
                        firstSymbol = symbol;
                        firstSymbolType = symbolType;
                        continue;
                    }

                    if (symbolType && firstSymbolType && symbolType !== firstSymbolType && !this.typesAreIdentical(symbolType, firstSymbolType)) {
                        context.postError(this.currentUnit.getPath(), boundDeclAST.minChar, boundDeclAST.getLength(), TypeScript.DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, [symbol.getScopedName(), firstSymbolType.toString(), symbolType.toString()]);
                        continue;
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckFunctionOverloads = function (funcDecl, context, signature, allSignatures) {
            if (!signature) {
                var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.currentUnit);
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = this.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol();

            var definitionSignature = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }

            if (!signature.isDefinition()) {
                for (var i = 0; i < allSignatures.length; i++) {
                    if (allSignatures[i] === signature) {
                        break;
                    }

                    if (this.signaturesAreIdentical(allSignatures[i], signature, false)) {
                        if (!this.typesAreIdentical(allSignatures[i].returnType, signature.returnType)) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overloads_cannot_differ_only_by_return_type, null);
                        } else if (TypeScript.PullHelpers.isConstructor(funcDecl)) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_constructor_overload_signature, null);
                        } else if (TypeScript.PullHelpers.isConstructMember(funcDecl)) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_construct_signature, null);
                        } else if (TypeScript.PullHelpers.isCallMember(funcDecl)) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_call_signature, null);
                        } else {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_signature_for_0, [funcSymbol.getScopedNameEx().toString()]);
                        }

                        break;
                    }
                }
            }

            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_implementation_cannot_use_specialized_type, null);
                } else {
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }

                        if (!allSignatures[i].isResolved) {
                            this.resolveDeclaredSymbol(allSignatures[i], context);
                        }

                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }

                        if (this.signatureIsSubtypeOfTarget(signature, allSignatures[i], context)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }

                    if (!foundSubtypeSignature) {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature, null);
                    }
                }
            } else if (definitionSignature && definitionSignature != signature) {
                var comparisonInfo = new TypeComparisonInfo();

                if (!definitionSignature.isResolved) {
                    this.resolveDeclaredSymbol(definitionSignature, context);
                }

                if (!this.signatureIsAssignableToTarget(definitionSignature, signature, context, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition_NL_0, [comparisonInfo.message]);
                    } else {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition, null);
                    }
                }
            }

            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }

            if (!TypeScript.PullHelpers.isConstructor(funcDecl) && !TypeScript.PullHelpers.isConstructMember(funcDecl) && signatureForVisibilityCheck && signature != signatureForVisibilityCheck) {
                var errorCode;

                if (signatureForVisibilityCheck.hasFlag(2 /* Private */) != signature.hasFlag(2 /* Private */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                } else if (signatureForVisibilityCheck.hasFlag(1 /* Exported */) != signature.hasFlag(1 /* Exported */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_exported_or_not_exported;
                } else if (signatureForVisibilityCheck.hasFlag(8 /* Ambient */) != signature.hasFlag(8 /* Ambient */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                } else if (signatureForVisibilityCheck.hasFlag(128 /* Optional */) != signature.hasFlag(128 /* Optional */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }

                if (errorCode) {
                    context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), errorCode, null);
                }
            }
        };

        PullTypeResolver.prototype.checkSymbolPrivacy = function (declSymbol, symbol, privacyErrorReporter) {
            if (!symbol || symbol.kind === 2 /* Primitive */) {
                return;
            }

            if (symbol.isType()) {
                var typeSymbol = symbol;
                var isNamedType = typeSymbol.isNamedTypeSymbol();
                var isArrayType = typeSymbol.isArray();
                if (typeSymbol.inSymbolPrivacyCheck) {
                    if (!isArrayType && !isNamedType) {
                        var associatedContainerType = typeSymbol.getAssociatedContainerType();
                        if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                            this.checkSymbolPrivacy(declSymbol, associatedContainerType, privacyErrorReporter);
                        }
                    }

                    return;
                }

                typeSymbol.inSymbolPrivacyCheck = true;

                var typars = typeSymbol.getTypeArgumentsOrTypeParameters();
                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, typars[i], privacyErrorReporter);
                    }
                }

                if (!isNamedType) {
                    if (isArrayType) {
                        this.checkSymbolPrivacy(declSymbol, typeSymbol.getElementType(), privacyErrorReporter);
                    } else {
                        var members = typeSymbol.getMembers();
                        for (var i = 0; i < members.length; i++) {
                            this.checkSymbolPrivacy(declSymbol, members[i].type, privacyErrorReporter);
                        }

                        this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), privacyErrorReporter);
                        this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), privacyErrorReporter);
                        this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), privacyErrorReporter);
                    }
                } else if (typeSymbol.kind == 8192 /* TypeParameter */) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getConstraint(), privacyErrorReporter);
                }

                typeSymbol.inSymbolPrivacyCheck = false;

                if (!isNamedType) {
                    return;
                }
            }

            if (declSymbol.isExternallyVisible()) {
                var symbolIsVisible = symbol.isExternallyVisible();

                if (symbolIsVisible && symbol.kind != 8192 /* TypeParameter */) {
                    var symbolPath = symbol.pathToRoot();
                    var declSymbolPath = declSymbol.pathToRoot();

                    if (symbolPath[symbolPath.length - 1].kind === 32 /* DynamicModule */ && declSymbolPath[declSymbolPath.length - 1].kind == 32 /* DynamicModule */ && declSymbolPath[declSymbolPath.length - 1] != symbolPath[symbolPath.length - 1]) {
                        symbolIsVisible = false;
                        var declSymbolScope = declSymbolPath[declSymbolPath.length - 1];
                        for (var i = symbolPath.length - 1; i >= 0; i--) {
                            var aliasSymbol = symbolPath[i].getAliasedSymbol(declSymbolScope);
                            if (aliasSymbol) {
                                symbolIsVisible = true;
                                aliasSymbol.typeUsedExternally = true;
                                break;
                            }
                        }
                        symbol = symbolPath[symbolPath.length - 1];
                    }
                } else if (symbol.kind == 256 /* TypeAlias */) {
                    var aliasSymbol = symbol;
                    symbolIsVisible = true;
                    aliasSymbol.typeUsedExternally = true;
                }

                if (!symbolIsVisible) {
                    privacyErrorReporter(symbol);
                }
            }
        };

        PullTypeResolver.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, privacyErrorReporter) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length > 1 && signature.isDefinition()) {
                    continue;
                }

                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkSymbolPrivacy(declSymbol, typeParams[j], privacyErrorReporter);
                }

                var params = signature.parameters;
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].type;
                    this.checkSymbolPrivacy(declSymbol, paramType, privacyErrorReporter);
                }

                var returnType = signature.returnType;
                this.checkSymbolPrivacy(declSymbol, returnType, privacyErrorReporter);
            }
        };

        PullTypeResolver.prototype.typeParameterOfTypeDeclarationPrivacyErrorReporter = function (classOrInterface, indexOfTypeParameter, typeParameter, symbol, context) {
            var decl = this.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var messageCode;

            var typeParameters = classOrInterface.nodeType() === 14 /* ClassDeclaration */ ? classOrInterface.typeParameters : classOrInterface.typeParameters;

            var typeParameterAST = typeParameters.members[indexOfTypeParameter];

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.nodeType() === 14 /* ClassDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_is_using_inaccessible_module_1;
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1;
                }
            } else {
                if (classOrInterface.nodeType() === 14 /* ClassDeclaration */) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_class_has_or_is_using_private_type_1;
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [typeParameter.getScopedName(enclosingSymbol, true), typeSymbolName];
            context.postError(this.unitPath, typeParameterAST.minChar, typeParameterAST.getLength(), messageCode, messageArguments);
        };

        PullTypeResolver.prototype.baseListPrivacyErrorReporter = function (classOrInterface, declSymbol, baseAst, isExtendedType, symbol, context) {
            var decl = this.getDeclForAST(classOrInterface);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var messageCode;

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (classOrInterface.nodeType() === 14 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_class_from_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_interface_from_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_interface_from_inaccessible_module_1;
                }
            } else {
                if (classOrInterface.nodeType() === 14 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_private_class_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_private_interface_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_private_interface_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postError(this.unitPath, baseAst.minChar, baseAst.getLength(), messageCode, messageArguments);
        };

        PullTypeResolver.prototype.variablePrivacyErrorReporter = function (declSymbol, symbol, context) {
            var typeSymbol = symbol;
            var declAST = this.getASTForSymbol(declSymbol, context);
            var enclosingDecl = this.getEnclosingDecl(declSymbol.getDeclarations()[0]);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;

            var isProperty = declSymbol.kind === 4096 /* Property */;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.kind === 8 /* Class */ || declParent.kind === 32768 /* ConstructorMethod */)) {
                isPropertyOfClass = true;
            }

            var messageCode;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_is_using_inaccessible_module_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_is_using_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_is_using_inaccessible_module_1;
                }
            } else {
                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_has_or_is_using_private_type_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_has_or_is_using_private_type_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postError(this.unitPath, declAST.minChar, declAST.getLength(), messageCode, messageArguments);
        };

        PullTypeResolver.prototype.checkFunctionTypePrivacy = function (funcDeclAST, context) {
            var _this = this;
            if ((funcDeclAST.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDeclAST.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                return;
            }

            var functionDecl = this.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol();
            ;
            var functionSignature;

            var isGetter = funcDeclAST.isGetAccessor();
            var isSetter = funcDeclAST.isSetAccessor();
            var isIndexSignature = funcDeclAST.isIndexerMember();

            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).type.getCallSignatures()[0];
            } else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol();
                    if (functionSymbol && functionSymbol.isType() && !functionSymbol.isNamedTypeSymbol()) {
                        return;
                    }
                } else if (functionSymbol.kind == 65536 /* Method */ && !funcDeclAST.isStatic() && !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol();
            }

            if (funcDeclAST.typeParameters && !isGetter && !isSetter && !isIndexSignature && !funcDeclAST.isConstructor) {
                for (var i = 0; i < funcDeclAST.typeParameters.members.length; i++) {
                    var typeParameterAST = funcDeclAST.typeParameters.members[i];
                    var typeParameter = this.resolveTypeParameterDeclaration(typeParameterAST, context);
                    this.checkSymbolPrivacy(functionSymbol, typeParameter, function (symbol) {
                        return _this.functionTypeArgumentArgumentTypePrivacyErrorReporter(funcDeclAST, typeParameterAST, typeParameter, symbol, context);
                    });
                }
            }

            if (!isGetter && !isIndexSignature) {
                var funcParams = functionSignature.parameters;
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkSymbolPrivacy(functionSymbol, funcParams[i].type, function (symbol) {
                        return _this.functionArgumentTypePrivacyErrorReporter(funcDeclAST, i, funcParams[i], symbol, context);
                    });
                }
            }

            if (!isSetter) {
                this.checkSymbolPrivacy(functionSymbol, functionSignature.returnType, function (symbol) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDeclAST, functionSignature.returnType, symbol, context);
                });
            }
        };

        PullTypeResolver.prototype.functionTypeArgumentArgumentTypePrivacyErrorReporter = function (declAST, typeParameterAST, typeParameter, symbol, context) {
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;

            var isStatic = declAST.isStatic();
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var start = typeParameterAST.minChar;
            var length = typeParameterAST.getLength();

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            } else {
                if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.TypeParameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var messageArgs = [typeParameter.getScopedName(enclosingSymbol, true), typeSymbolName];
                context.postError(this.unitPath, start, length, messageCode, messageArgs);
            }
        };

        PullTypeResolver.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, argIndex, paramSymbol, symbol, context) {
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;

            var isGetter = declAST.isGetAccessor();
            var isSetter = declAST.isSetAccessor();
            var isStatic = declAST.isStatic();
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var start = declAST.parameters.members[argIndex].minChar;
            var length = declAST.parameters.members[argIndex].getLength();

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                } else if (!isGetter) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            } else {
                if (declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                } else if (!isGetter && !declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var messageArgs = [paramSymbol.getScopedName(enclosingSymbol), typeSymbolName];
                context.postError(this.unitPath, start, length, messageCode, messageArgs);
            }
        };

        PullTypeResolver.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, funcReturnType, symbol, context) {
            var _this = this;
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);

            var isGetter = declAST.isGetAccessor();
            var isSetter = declAST.isSetAccessor();
            var isStatic = declAST.isStatic();
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || isStatic)) {
                isMethodOfClass = true;
            }

            var messageCode = null;
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0;
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module_0;
                }
            } else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0;
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type_0;
                }
            }

            if (messageCode) {
                var messageArguments = [typeSymbolName];
                var reportOnFuncDecl = false;

                if (declAST.returnTypeAnnotation) {
                    var returnExpressionSymbol = this.resolveTypeReference(declAST.returnTypeAnnotation, decl, context);
                    if (returnExpressionSymbol === funcReturnType) {
                        context.postError(this.unitPath, declAST.returnTypeAnnotation.minChar, declAST.returnTypeAnnotation.getLength(), messageCode, messageArguments);
                    }
                }

                if (declAST.block) {
                    var reportErrorOnReturnExpressions = function (ast, walker) {
                        var go = true;
                        switch (ast.nodeType()) {
                            case 13 /* FunctionDeclaration */:
                            case 82 /* ArrowFunctionExpression */:
                                go = false;
                                break;

                            case 96 /* ReturnStatement */:
                                var returnStatement = ast;
                                var returnExpressionSymbol = _this.resolveAST(returnStatement.returnExpression, false, decl, context).type;

                                if (returnExpressionSymbol === funcReturnType) {
                                    context.postError(_this.unitPath, returnStatement.minChar, returnStatement.getLength(), messageCode, messageArguments);
                                } else {
                                    reportOnFuncDecl = true;
                                }
                                go = false;
                                break;

                            default:
                                break;
                        }

                        walker.options.goChildren = go;
                        return ast;
                    };

                    TypeScript.getAstWalkerFactory().walk(declAST.block, reportErrorOnReturnExpressions);
                }

                if (reportOnFuncDecl) {
                    context.postError(this.unitPath, declAST.minChar, declAST.getLength(), messageCode, messageArguments);
                }
            }
        };

        PullTypeResolver.prototype.enclosingClassIsDerived = function (decl) {
            if (decl) {
                var classSymbol = null;

                while (decl) {
                    if (decl.kind == 8 /* Class */) {
                        classSymbol = decl.getSymbol();
                        if (classSymbol.getExtendedTypes().length > 0) {
                            return true;
                        }

                        break;
                    }
                    decl = decl.getParentDecl();
                }
            }

            return false;
        };

        PullTypeResolver.prototype.isSuperCallNode = function (node) {
            if (node && node.nodeType() === 91 /* ExpressionStatement */) {
                var expressionStatement = node;
                if (expressionStatement.expression && expressionStatement.expression.nodeType() === 38 /* InvocationExpression */) {
                    var callExpression = expressionStatement.expression;
                    if (callExpression.target && callExpression.target.nodeType() === 32 /* SuperExpression */) {
                        return true;
                    }
                }
            }
            return false;
        };

        PullTypeResolver.prototype.getFirstStatementFromFunctionDeclAST = function (funcDeclAST) {
            if (funcDeclAST.block && funcDeclAST.block.statements && funcDeclAST.block.statements.members) {
                return funcDeclAST.block.statements.members[0];
            }

            return null;
        };

        PullTypeResolver.prototype.superCallMustBeFirstStatementInConstructor = function (enclosingConstructor, enclosingClass) {
            if (enclosingConstructor && enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }

                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];

                    if (member.kind === 4096 /* Property */) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.nodeType() === 21 /* Parameter */) {
                                return true;
                            }

                            if (ast.nodeType() === 19 /* VariableDeclarator */) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.init) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForThisCaptureInArrowFunction = function (expression, enclosingDecl) {
            var declPath = TypeScript.getPathToDecl(enclosingDecl);

            if (declPath.length) {
                var inFatArrow = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                        inFatArrow = true;
                        continue;
                    }

                    if (inFatArrow) {
                        if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                            decl.setFlags(decl.flags | 262144 /* MustCaptureThis */);

                            if (declKind === 8 /* Class */) {
                                var constructorSymbol = decl.getSymbol().getConstructorMethod();
                                var constructorDecls = constructorSymbol.getDeclarations();
                                for (var i = 0; i < constructorDecls.length; i++) {
                                    constructorDecls[i].flags = constructorDecls[i].flags | 262144 /* MustCaptureThis */;
                                }
                            }
                            break;
                        }
                    } else if (declKind === 16384 /* Function */ || declKind === 131072 /* FunctionExpression */) {
                        break;
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckMembersAgainstIndexer = function (containerType, containerTypeDecl, context) {
            var indexSignatures = this.getBothKindsOfIndexSignatures(containerType, context);
            var stringSignature = indexSignatures.stringSignature;
            var numberSignature = indexSignatures.numericSignature;

            if (stringSignature || numberSignature) {
                var members = containerTypeDecl.getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    var member = members[i];
                    if (member.name && member.kind !== 32768 /* ConstructorMethod */ && member.getSymbol().getContainer() === containerType) {
                        var isMemberNumeric = TypeScript.PullHelpers.isNameNumeric(member.name);
                        if (isMemberNumeric && numberSignature) {
                            this.checkThatMemberIsSubtypeOfIndexer(member.getSymbol(), numberSignature, this.semanticInfoChain.getASTForDecl(member), context, containerTypeDecl, true);
                        } else if (stringSignature) {
                            this.checkThatMemberIsSubtypeOfIndexer(member.getSymbol(), stringSignature, this.semanticInfoChain.getASTForDecl(member), context, containerTypeDecl, false);
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkThatMemberIsSubtypeOfIndexer = function (member, indexSignature, astForError, context, enclosingDecl, isNumeric) {
            var comparisonInfo = new TypeComparisonInfo();
            var resolutionContext = new TypeScript.PullTypeResolutionContext(this);

            if (!this.sourceIsSubtypeOfTarget(member.type, indexSignature.returnType, resolutionContext, comparisonInfo)) {
                if (isNumeric) {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1, [indexSignature.returnType.toString(), comparisonInfo.message]);
                    } else {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0, [indexSignature.returnType.toString()]);
                    }
                } else {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1, [indexSignature.returnType.toString(), comparisonInfo.message]);
                    } else {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0, [indexSignature.returnType.toString()]);
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, enclosingDecl, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }

            var typeMemberKind = typeMember.kind;
            var extendedMemberKind = extendedTypeMember.kind;

            if (typeMemberKind === extendedMemberKind) {
                return true;
            }

            var errorCode;
            if (typeMemberKind === 4096 /* Property */) {
                if (typeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
            } else if (typeMemberKind === 65536 /* Method */) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                }
            }

            var message = TypeScript.getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        };

        PullTypeResolver.prototype.typeCheckIfTypeExtendsType = function (classOrInterface, name, typeSymbol, extendedType, enclosingDecl, context) {
            var typeMembers = typeSymbol.getMembers();

            var resolutionContext = new TypeScript.PullTypeResolutionContext(this);
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = false;

            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].name;
                var extendedTypeProp = extendedType.findMember(propName);
                if (extendedTypeProp) {
                    this.resolveDeclaredSymbol(extendedTypeProp, context);
                    foundError = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, enclosingDecl, comparisonInfo);

                    if (!foundError) {
                        foundError = !this.sourcePropertyIsSubtypeOfTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, resolutionContext, comparisonInfo);
                    }

                    if (foundError) {
                        break;
                    }
                }
            }

            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = typeSymbol.getConstructorMethod().type;
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = extendedType.getConstructorMethod().type;
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);

                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].name;
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved) {
                                this.resolveDeclaredSymbol(extendedConstructorTypeProp, resolutionContext);
                            }

                            var typeConstructorTypePropType = typeConstructorTypeMembers[i].type;
                            var extendedConstructorTypePropType = extendedConstructorTypeProp.type;
                            if (!this.sourceIsSubtypeOfTarget(typeConstructorTypePropType, extendedConstructorTypePropType, resolutionContext, comparisonInfoForPropTypeCheck)) {
                                var propMessage;
                                if (comparisonInfoForPropTypeCheck.message) {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString(), comparisonInfoForPropTypeCheck.message]);
                                } else {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString()]);
                                }
                                comparisonInfo.addMessage(propMessage);
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_cannot_extend_class_1_NL_2;
                } else {
                    if (extendedType.isClass()) {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_class_1_NL_2;
                    } else {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_interface_1_NL_2;
                    }
                }

                context.postError(this.unitPath, name.minChar, name.getLength(), errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message]);
            }
        };

        PullTypeResolver.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, enclosingDecl, context) {
            var resolutionContext = new TypeScript.PullTypeResolutionContext(this);
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.sourceMembersAreSubtypeOfTargetMembers(classSymbol, implementedType, resolutionContext, comparisonInfo);
            if (!foundError) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                if (!foundError) {
                    foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    }
                }
            }

            if (foundError) {
                context.postError(this.unitPath, classDecl.name.minChar, classDecl.name.getLength(), TypeScript.DiagnosticCode.Class_0_declares_interface_1_but_does_not_implement_it_NL_2, [classSymbol.getScopedName(), implementedType.getScopedName(), comparisonInfo.message]);
            }
        };

        PullTypeResolver.prototype.hasClassTypeSymbolConflictAsValue = function (valueDeclAST, typeSymbol, enclosingDecl, context) {
            var typeSymbolAlias = this.currentUnit.getAliasSymbolForAST(valueDeclAST);
            var tempResolvingTypeNameAsNameExpression = context.resolvingTypeNameAsNameExpression;
            context.resolvingTypeNameAsNameExpression = true;
            var valueSymbol = this.computeNameExpression(valueDeclAST, enclosingDecl, context);
            context.resolvingTypeNameAsNameExpression = tempResolvingTypeNameAsNameExpression;
            var valueSymbolAlias = this.currentUnit.getAliasSymbolForAST(valueDeclAST);

            this.currentUnit.setAliasSymbolForAST(valueDeclAST, typeSymbolAlias);

            if (typeSymbolAlias && valueSymbolAlias) {
                return typeSymbolAlias != valueSymbolAlias;
            }

            if (!valueSymbol.hasFlag(16384 /* ClassConstructorVariable */)) {
                return true;
            }

            var associatedContainerType = valueSymbol.type ? valueSymbol.type.getAssociatedContainerType() : null;

            if (associatedContainerType) {
                return associatedContainerType != typeSymbol.getRootSymbol();
            }

            return true;
        };

        PullTypeResolver.prototype.typeCheckBase = function (classOrInterface, name, typeSymbol, baseDeclAST, isExtendedType, enclosingDecl, context) {
            var _this = this;
            var typeDecl = this.getDeclForAST(classOrInterface);

            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = true;
            var baseType = this.resolveTypeReference(baseDeclAST, typeDecl, context).type;
            context.resolvingTypeReference = savedResolvingTypeReference;

            if (!baseType) {
                return;
            }

            var typeDeclIsClass = typeSymbol.isClass();

            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (!baseType.isError()) {
                    if (isExtendedType) {
                        if (typeDeclIsClass) {
                            context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.A_class_may_only_extend_another_class, null);
                        } else {
                            context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.An_interface_may_only_extend_another_class_or_interface, null);
                        }
                    } else {
                        context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.A_class_may_only_implement_another_class_or_interface, null);
                    }
                }
                return;
            } else if (typeDeclIsClass && isExtendedType && baseDeclAST.term.nodeType() == 22 /* Name */) {
                if (this.hasClassTypeSymbolConflictAsValue(baseDeclAST.term, baseType, enclosingDecl, context)) {
                    context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.Type_reference_0_in_extends_clause_doesn_t_reference_constructor_function_for_1, [baseDeclAST.term.actualText, baseType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)]);
                }
            }

            if (baseType.hasBase(typeSymbol)) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();

                context.postError(this.unitPath, name.minChar, name.getLength(), typeDeclIsClass ? TypeScript.DiagnosticCode.Class_0_is_recursively_referenced_as_a_base_type_of_itself : TypeScript.DiagnosticCode.Interface_0_is_recursively_referenced_as_a_base_type_of_itself, [typeSymbol.getScopedName()]);
                return;
            }

            if (isExtendedType) {
                this.typeCheckIfTypeExtendsType(classOrInterface, name, typeSymbol, baseType, enclosingDecl, context);
            } else {
                TypeScript.Debug.assert(classOrInterface.nodeType() === 14 /* ClassDeclaration */);

                this.typeCheckIfClassImplementsType(classOrInterface, typeSymbol, baseType, enclosingDecl, context);
            }

            this.checkSymbolPrivacy(typeSymbol, baseType, function (errorSymbol) {
                return _this.baseListPrivacyErrorReporter(classOrInterface, typeSymbol, baseDeclAST, isExtendedType, errorSymbol, context);
            });
        };

        PullTypeResolver.prototype.typeCheckBases = function (classOrInterface, name, extendsList, implementsList, typeSymbol, enclosingDecl, context) {
            if (!extendsList && !implementsList) {
                return;
            }

            var typeDeclIsClass = classOrInterface.nodeType() === 14 /* ClassDeclaration */;

            if (extendsList) {
                for (var i = 0; i < extendsList.members.length; i++) {
                    this.typeCheckBase(classOrInterface, name, typeSymbol, extendsList.members[i], true, enclosingDecl, context);
                }
            }

            if (typeSymbol.isClass()) {
                if (implementsList) {
                    for (var i = 0; i < implementsList.members.length; i++) {
                        this.typeCheckBase(classOrInterface, name, typeSymbol, implementsList.members[i], false, enclosingDecl, context);
                    }
                }
            } else {
                if (implementsList) {
                    context.postError(this.unitPath, implementsList.minChar, implementsList.getLength(), TypeScript.DiagnosticCode.An_interface_cannot_implement_another_type, null);
                }
                if (extendsList && extendsList.members.length > 1 && !typeSymbol.hasBaseTypeConflict()) {
                    this.checkPropertyTypeIdentityBetweenBases(classOrInterface, name, typeSymbol, context);
                }
            }
        };

        PullTypeResolver.prototype.checkPropertyTypeIdentityBetweenBases = function (classOrInterface, name, typeSymbol, context) {
            var allMembers = typeSymbol.getAllMembers(4096 /* Property */ | 65536 /* Method */, 2 /* externallyVisible */);
            var membersBag = new TypeScript.BlockIntrinsics();
            for (var i = 0; i < allMembers.length; i++) {
                var member = allMembers[i];
                var memberName = member.name;

                if (membersBag[memberName]) {
                    var prevMember = membersBag[memberName];
                    if (!this.typesAreIdentical(member.type, prevMember.type)) {
                        var prevContainerName = prevMember.getContainer().getScopedName();
                        var curContainerName = member.getContainer().getScopedName();
                        context.postError(this.unitPath, name.minChar, name.getLength(), TypeScript.DiagnosticCode.Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_Types_of_property_3_of_types_1_and_2_are_not_identical, [typeSymbol.getDisplayName(), prevContainerName, curContainerName, memberName]);
                    }
                } else {
                    membersBag[memberName] = member;
                }
            }
        };

        PullTypeResolver.prototype.checkAssignability = function (ast, source, target, enclosingDecl, context) {
            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(source, target, context, comparisonInfo);

            if (!isAssignable) {
                if (comparisonInfo.message) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [source.toString(), target.toString(), comparisonInfo.message]);
                } else {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [source.toString(), target.toString()]);
                }
            }
        };

        PullTypeResolver.prototype.isReference = function (ast, astSymbol) {
            if (ast.nodeType() === 81 /* ParenthesizedExpression */) {
                return this.isReference(ast.expression, astSymbol);
            }

            if (ast.nodeType() !== 22 /* Name */ && ast.nodeType() !== 34 /* MemberAccessExpression */ && ast.nodeType() !== 37 /* ElementAccessExpression */) {
                return false;
            }

            if (ast.nodeType() === 22 /* Name */) {
                if (astSymbol.kind === 1024 /* Variable */ && astSymbol.hasFlag(4096 /* Enum */)) {
                    return false;
                }

                if (astSymbol.kind === 1024 /* Variable */ && astSymbol.hasFlag(TypeScript.PullElementFlags.SomeInitializedModule)) {
                    return false;
                }

                if (astSymbol.kind === 32768 /* ConstructorMethod */) {
                    return false;
                }
            }

            if (ast.nodeType() === 34 /* MemberAccessExpression */ && astSymbol.kind === 67108864 /* EnumMember */) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.checkForSuperMemberAccess = function (memberAccessExpression, resolvedName, enclosingDecl, context) {
            if (resolvedName) {
                if (memberAccessExpression.operand1.nodeType() === 32 /* SuperExpression */ && !resolvedName.isError() && resolvedName.kind !== 65536 /* Method */) {
                    context.postError(this.unitPath, memberAccessExpression.operand2.minChar, memberAccessExpression.operand2.getLength(), TypeScript.DiagnosticCode.Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword, null);
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForPrivateMemberAccess = function (memberAccessExpression, expressionType, resolvedName, enclosingDecl, context) {
            if (resolvedName) {
                if (resolvedName.hasFlag(2 /* Private */)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.kind === 33554432 /* ConstructorType */) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }

                    if (memberContainer && memberContainer.isClass()) {
                        var containingClass = enclosingDecl;

                        while (containingClass && containingClass.kind != 8 /* Class */) {
                            containingClass = containingClass.getParentDecl();
                        }

                        if (!containingClass || containingClass.getSymbol() !== memberContainer) {
                            var name = memberAccessExpression.operand2;
                            context.postError(this.unitPath, name.minChar, name.getLength(), TypeScript.DiagnosticCode._0_1_is_inaccessible, [memberContainer.toString(null, false), name.actualText]);
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForStaticMemberAccess = function (memberAccessExpression, expressionType, resolvedName, enclosingDecl, context) {
            if (expressionType && resolvedName && !resolvedName.isError()) {
                if (expressionType.isClass() || expressionType.kind === 33554432 /* ConstructorType */) {
                    var name = memberAccessExpression.operand2;

                    if (resolvedName.hasFlag(16 /* Static */) || this.isPrototypeMember(memberAccessExpression, enclosingDecl, context)) {
                        if (expressionType.kind !== 33554432 /* ConstructorType */) {
                            context.postError(this.unitPath, name.minChar, name.getLength(), TypeScript.DiagnosticCode.Static_member_cannot_be_accessed_off_an_instance_variable, null);
                            return true;
                        }
                    }
                }
            }

            return false;
        };
        PullTypeResolver.typeCheckCallBacks = [];
        PullTypeResolver.postTypeCheckWorkitems = [];

        PullTypeResolver.globalTypeCheckPhase = 0;
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;

    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo) {
            this.onlyCaptureFirstError = false;
            this.flags = 0 /* SuccessfulComparison */;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.flags = sourceComparisonInfo.flags;
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent + 1;
            }
        }
        TypeComparisonInfo.prototype.indentString = function () {
            var result = "";

            for (var i = 0; i < this.indent; i++) {
                result += "\t";
            }

            return result;
        };

        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = this.message + TypeScript.newLine() + this.indentString() + message;
            } else {
                this.message = this.indentString() + message;
            }
        };

        TypeComparisonInfo.prototype.setMessage = function (message) {
            this.message = this.indentString() + message;
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;

    var OverloadApplicabilityStatus;
    (function (OverloadApplicabilityStatus) {
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["NotApplicable"] = 0] = "NotApplicable";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["ApplicableButWithProvisionalErrors"] = 1] = "ApplicableButWithProvisionalErrors";
        OverloadApplicabilityStatus[OverloadApplicabilityStatus["ApplicableWithNoProvisionalErrors"] = 2] = "ApplicableWithNoProvisionalErrors";
    })(OverloadApplicabilityStatus || (OverloadApplicabilityStatus = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;

    var sentinalEmptyArray = [];

    var SemanticInfo = (function () {
        function SemanticInfo(compilationUnitPath) {
            this.topLevelDecl = null;
            this.topLevelSynthesizedDecls = [];
            this.declASTMap = new TypeScript.DataMap();
            this.astDeclMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
            this.astAliasSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.diagnostics = null;
            this.hasBeenTypeChecked = false;
            this.astCallResolutionDataMap = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, function (k) {
                return k;
            });
            this.importDeclarationNames = null;
            this.compilationUnitPath = compilationUnitPath;
        }
        SemanticInfo.prototype.invalidate = function () {
            this.astSymbolMap = new TypeScript.DataMap();
            this.astAliasSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.diagnostics = null;
            this.astCallResolutionDataMap = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, function (k) {
                return k;
            });
            this.importDeclarationNames = null;
            this.hasBeenTypeChecked = false;
        };

        SemanticInfo.prototype.addDiagnostic = function (diagnostic) {
            if (this.diagnostics === null) {
                this.diagnostics = [];
            }

            this.diagnostics.push(diagnostic);
        };

        SemanticInfo.prototype.addTopLevelDecl = function (decl) {
            this.topLevelDecl = decl;
        };

        SemanticInfo.prototype.getTopLevelDecl = function () {
            return this.topLevelDecl;
        };

        SemanticInfo.prototype.getPath = function () {
            return this.compilationUnitPath;
        };

        SemanticInfo.prototype.addSynthesizedDecl = function (decl) {
            this.topLevelSynthesizedDecls[this.topLevelSynthesizedDecls.length] = decl;
        };

        SemanticInfo.prototype.getSynthesizedDecls = function () {
            return this.topLevelSynthesizedDecls;
        };

        SemanticInfo.prototype.cleanSynthesizedDecls = function () {
            this.topLevelSynthesizedDecls = [];
        };

        SemanticInfo.prototype.getDeclForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.decl ? ast.decl : null;
            }

            return this.astDeclMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.setDeclForAST = function (ast, decl) {
            if (TypeScript.useDirectTypeStorage) {
                ast.decl = decl;
                return;
            }

            this.astDeclMap.link(ast.astIDString, decl);
        };

        SemanticInfo.prototype.getASTForDecl = function (decl) {
            if (TypeScript.useDirectTypeStorage) {
                return decl.ast;
            }

            return this.declASTMap.read(decl.declIDString);
        };

        SemanticInfo.prototype.setASTForDecl = function (decl, ast) {
            if (TypeScript.useDirectTypeStorage) {
                decl.ast = ast;
                return;
            }

            this.declASTMap.link(decl.declIDString, ast);
        };

        SemanticInfo.prototype.setSymbolForAST = function (ast, symbol) {
            if (TypeScript.useDirectTypeStorage) {
                ast.symbol = symbol;
                symbol.ast = ast;
                return;
            }

            this.astSymbolMap.link(ast.astIDString, symbol);
            this.symbolASTMap.link(symbol.pullSymbolIDString, ast);
        };

        SemanticInfo.prototype.getSymbolForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.symbol;
            }

            return this.astSymbolMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.getASTForSymbol = function (symbol) {
            if (TypeScript.useDirectTypeStorage) {
                return symbol.ast;
            }

            return this.symbolASTMap.read(symbol.pullSymbolIDString);
        };

        SemanticInfo.prototype.setAliasSymbolForAST = function (ast, symbol) {
            if (TypeScript.useDirectTypeStorage) {
                ast.aliasSymbol = symbol;
                return;
            }
            this.astAliasSymbolMap.link(ast.astIDString, symbol);
        };

        SemanticInfo.prototype.getAliasSymbolForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.aliasSymbol;
            }

            return this.astAliasSymbolMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.getCallResolutionDataForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.callResolutionData;
            }
            return this.astCallResolutionDataMap.get(ast.astID);
        };

        SemanticInfo.prototype.setCallResolutionDataForAST = function (ast, callResolutionData) {
            if (callResolutionData) {
                if (TypeScript.useDirectTypeStorage) {
                    ast.callResolutionData = callResolutionData;
                    return;
                }
                this.astCallResolutionDataMap.set(ast.astID, callResolutionData);
            }
        };

        SemanticInfo.prototype.getDiagnostics = function (semanticErrors) {
            if (this.diagnostics) {
                semanticErrors.push.apply(semanticErrors, this.diagnostics);
            }
        };

        SemanticInfo.prototype.getImportDeclarationNames = function () {
            if (this.importDeclarationNames === null) {
                this.importDeclarationNames = new TypeScript.BlockIntrinsics();
                this.populateImportDeclarationNames([this.topLevelDecl]);
            }

            return this.importDeclarationNames;
        };

        SemanticInfo.prototype.populateImportDeclarationNames = function (decls) {
            for (var i = 0, n = decls.length; i < n; i++) {
                var decl = decls[i];
                if (decl.kind === 256 /* TypeAlias */) {
                    this.importDeclarationNames[decl.name] = true;
                } else {
                    this.populateImportDeclarationNames(decl.getChildDecls());
                }
            }
        };

        SemanticInfo.prototype.isExternalModule = function () {
            var topLevelDecl = this.getTopLevelDecl();
            if (topLevelDecl.kind == 1 /* Script */) {
                var script = this.getASTForDecl(topLevelDecl);
                return script.isExternalModule;
            }

            return false;
        };

        SemanticInfo.prototype.addSyntheticIndexSignature = function (containingDecl, containingSymbol, ast, indexParamName, indexParamType, returnType) {
            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);
            var indexParameterSymbol = new TypeScript.PullSymbol(indexParamName, 2048 /* Parameter */);
            indexParameterSymbol.type = indexParamType;
            indexSignature.addParameter(indexParameterSymbol);
            indexSignature.returnType = returnType;
            indexSignature.setResolved();
            indexParameterSymbol.setResolved();

            containingSymbol.addIndexSignature(indexSignature);

            var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);
            var indexSigDecl = new TypeScript.PullDecl("", "", 4194304 /* IndexSignature */, 1024 /* Index */ | 2048 /* Signature */, span, this.getPath());
            var indexParamDecl = new TypeScript.PullDecl(indexParamName, indexParamName, 2048 /* Parameter */, 0 /* None */, span, this.getPath());
            indexSigDecl.addChildDecl(indexParamDecl);
            indexParamDecl.setParentDecl(indexSigDecl);
            containingDecl.addChildDecl(indexSigDecl);
            indexSigDecl.setParentDecl(containingDecl);
            this.addSynthesizedDecl(indexSigDecl);
            this.addSynthesizedDecl(indexParamDecl);
            indexSigDecl.setSignatureSymbol(indexSignature);
            indexParamDecl.setSymbol(indexParameterSymbol);
            indexSignature.addDeclaration(indexSigDecl);
            indexParameterSymbol.addDeclaration(indexParamDecl);
            this.setASTForDecl(indexSigDecl, ast);
            this.setASTForDecl(indexParamDecl, ast);
            indexSigDecl.setIsBound(true);
            indexParamDecl.setIsBound(true);
        };
        return SemanticInfo;
    })();
    TypeScript.SemanticInfo = SemanticInfo;

    var SemanticInfoChain = (function () {
        function SemanticInfoChain() {
            this.units = [new SemanticInfo("")];
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.unitCache = new TypeScript.BlockIntrinsics();
            this.topLevelDecls = [];
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.voidTypeSymbol = null;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this;
            }

            var globalDecl = this.getGlobalDecl();
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
        }
        SemanticInfoChain.prototype.addPrimitiveType = function (name, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 2 /* Primitive */, 0 /* None */, span, "");
            var symbol = new TypeScript.PullPrimitiveTypeSymbol(name);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);

            symbol.setResolved();

            if (globalDecl) {
                globalDecl.addChildDecl(decl);
            }

            return symbol;
        };

        SemanticInfoChain.prototype.addPrimitiveValue = function (name, type, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 1024 /* Variable */, 8 /* Ambient */, span, "");
            var symbol = new TypeScript.PullSymbol(name, 1024 /* Variable */);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);
            symbol.type = type;
            symbol.setResolved();

            globalDecl.addChildDecl(decl);
        };

        SemanticInfoChain.prototype.getGlobalDecl = function () {
            var span = new TypeScript.TextSpan(0, 0);
            var globalDecl = new TypeScript.PullDecl("", "", 0 /* Global */, 0 /* None */, span, "");

            this.anyTypeSymbol = this.addPrimitiveType("any", globalDecl);
            this.booleanTypeSymbol = this.addPrimitiveType("boolean", globalDecl);
            this.numberTypeSymbol = this.addPrimitiveType("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitiveType("string", globalDecl);
            this.voidTypeSymbol = this.addPrimitiveType("void", globalDecl);

            this.nullTypeSymbol = this.addPrimitiveType("null", null);
            this.undefinedTypeSymbol = this.addPrimitiveType("undefined", null);
            this.addPrimitiveValue("undefined", this.undefinedTypeSymbol, globalDecl);

            return globalDecl;
        };

        SemanticInfoChain.prototype.addUnit = function (unit) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        };

        SemanticInfoChain.prototype.getUnit = function (compilationUnitPath) {
            return this.unitCache[compilationUnitPath];
        };

        SemanticInfoChain.prototype.updateUnit = function (oldUnit, newUnit) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() === oldUnit.getPath()) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        };

        SemanticInfoChain.prototype.collectAllTopLevelDecls = function () {
            if (this.topLevelDecls.length) {
                return this.topLevelDecls;
            }

            for (var i = 0; i < this.units.length; i++) {
                this.topLevelDecls[this.topLevelDecls.length] = this.units[i].getTopLevelDecl();
            }

            return this.topLevelDecls;
        };

        SemanticInfoChain.prototype.collectAllSynthesizedDecls = function () {
            var decls = [];
            var synthDecls;

            for (var i = 0; i < this.units.length; i++) {
                synthDecls = this.units[i].getSynthesizedDecls();
                for (var j = 0; j < synthDecls.length; j++) {
                    decls[decls.length] = synthDecls[j];
                }
            }

            return decls;
        };

        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        };

        SemanticInfoChain.prototype.findTopLevelSymbol = function (name, kind, stopAtFile) {
            var cacheID = this.getDeclPathCacheID([name], kind);

            var symbol = this.symbolCache[cacheID];

            if (!symbol) {
                var topLevelDecls = this.collectAllTopLevelDecls();
                var foundDecls = null;

                for (var i = 0; i < topLevelDecls.length; i++) {
                    foundDecls = topLevelDecls[i].searchChildDecls(name, kind);

                    for (var j = 0; j < foundDecls.length; j++) {
                        if (foundDecls[j].hasSymbol()) {
                            symbol = foundDecls[j].getSymbol();
                            break;
                        }
                    }
                    if (symbol || topLevelDecls[i].name == stopAtFile) {
                        break;
                    }
                }

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.findExternalModule = function (id) {
            id = TypeScript.normalizePath(id);

            var dtsFile = id + ".d.ts";
            var dtsCacheID = this.getDeclPathCacheID([dtsFile], 32 /* DynamicModule */);
            var symbol = this.symbolCache[dtsCacheID];
            if (symbol) {
                return symbol;
            }

            var tsFile = id + ".ts";
            var tsCacheID = this.getDeclPathCacheID([tsFile], 32 /* DynamicModule */);
            symbol = this.symbolCache[tsCacheID];
            if (symbol != undefined) {
                return symbol;
            }

            symbol = null;
            for (var i = 0; i < this.units.length; i++) {
                var unit = this.units[i];
                if (unit.isExternalModule()) {
                    var unitPath = unit.getPath();
                    var isDtsFile = unitPath == dtsFile;
                    if (isDtsFile || unitPath == tsFile) {
                        var topLevelDecl = unit.getTopLevelDecl();
                        var dynamicModuleDecl = topLevelDecl.getChildDecls()[0];
                        symbol = dynamicModuleDecl.getSymbol();
                        this.symbolCache[dtsCacheID] = isDtsFile ? symbol : null;
                        this.symbolCache[tsCacheID] = !TypeScript.isDTSFile ? symbol : null;
                        return symbol;
                    }
                }
            }

            this.symbolCache[dtsCacheID] = null;
            this.symbolCache[tsCacheID] = null;

            return symbol;
        };

        SemanticInfoChain.prototype.findAmbientExternalModuleInGlobalContext = function (id) {
            var cacheID = this.getDeclPathCacheID([id], 32 /* DynamicModule */);

            var symbol = this.symbolCache[cacheID];
            if (symbol == undefined) {
                symbol = null;
                for (var i = 0; i < this.units.length; i++) {
                    var unit = this.units[i];
                    if (!unit.isExternalModule()) {
                        var topLevelDecl = unit.getTopLevelDecl();
                        var dynamicModules = topLevelDecl.searchChildDecls(id, 32 /* DynamicModule */);
                        if (dynamicModules.length) {
                            symbol = dynamicModules[0].getSymbol();
                            break;
                        }
                    }
                }

                this.symbolCache[cacheID] = symbol;
            }

            return symbol;
        };

        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }

            TypeScript.declCacheMiss++;

            var declsToSearch = this.collectAllTopLevelDecls();

            var decls = TypeScript.sentinelEmptyArray;
            var path;
            var foundDecls = TypeScript.sentinelEmptyArray;
            var keepSearching = (declKind & TypeScript.PullElementKind.SomeContainer) || (declKind & 16 /* Interface */);

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = TypeScript.sentinelEmptyArray;

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, declKind);

                    for (var k = 0; k < foundDecls.length; k++) {
                        if (decls == TypeScript.sentinelEmptyArray) {
                            decls = [];
                        }
                        decls[decls.length] = foundDecls[k];
                    }

                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        };

        SemanticInfoChain.prototype.findDeclsFromPath = function (declPath, declKind) {
            var declString = [];

            for (var i = 0, n = declPath.length; i < n; i++) {
                if (declPath[i].kind & 1 /* Script */) {
                    continue;
                }

                declString.push(declPath[i].name);
            }

            return this.findDecls(declString, declKind);
        };

        SemanticInfoChain.prototype.findMatchingValidDecl = function (invalidatedDecl) {
            var unitPath = invalidatedDecl.getScriptName();
            var unit = this.getUnit(unitPath);
            if (!unit) {
                return null;
            }

            var declsInPath = [];
            var current = invalidatedDecl;
            while (current) {
                if (current.kind !== 1 /* Script */) {
                    declsInPath.unshift(current);
                }

                current = current.getParentDecl();
            }

            var declsToSearch = [unit.getTopLevelDecl()];
            var foundDecls = [];
            var keepSearching = (invalidatedDecl.kind & 4 /* Container */) || (invalidatedDecl.kind & 16 /* Interface */) || (invalidatedDecl.kind & 8 /* Class */) || (invalidatedDecl.kind & 64 /* Enum */);

            for (var i = 0; i < declsInPath.length; i++) {
                var declInPath = declsInPath[i];
                var decls = [];

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(declInPath.name, declInPath.kind);

                    decls.push.apply(decls, foundDecls);

                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (declsToSearch.length == 0) {
                    break;
                }
            }

            return declsToSearch;
        };

        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            TypeScript.symbolCacheMiss++;

            var decls = this.findDecls(declPath, declType);
            var symbol = null;

            if (decls.length) {
                symbol = decls[0].getSymbol();

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.cacheGlobalSymbol = function (symbol, kind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.name], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.name], symbol.kind);

            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
            }

            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
            }
        };

        SemanticInfoChain.prototype.cleanDecl = function (decl) {
            decl.setSymbol(null);
            decl.setSignatureSymbol(null);
            decl.setSpecializingSignatureSymbol(null);
            decl.setIsBound(false);

            var children = decl.getChildDecls();

            for (var i = 0; i < children.length; i++) {
                this.cleanDecl(children[i]);
            }

            var typeParameters = decl.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                this.cleanDecl(typeParameters[i]);
            }

            var valueDecl = decl.getValueDecl();

            if (valueDecl) {
                this.cleanDecl(valueDecl);
            }
        };

        SemanticInfoChain.prototype.cleanAllDecls = function () {
            var topLevelDecls = this.collectAllTopLevelDecls();

            for (var i = 1; i < topLevelDecls.length; i++) {
                this.cleanDecl(topLevelDecls[i]);
            }

            var synthesizedDecls = this.collectAllSynthesizedDecls();

            for (var i = 0; i < synthesizedDecls.length; i++) {
                this.cleanDecl(synthesizedDecls[i]);
            }

            this.cleanAllSynthesizedDecls();
            this.topLevelDecls = [];
        };

        SemanticInfoChain.prototype.cleanAllSynthesizedDecls = function () {
            for (var i = 0; i < this.units.length; i++) {
                this.units[i].cleanSynthesizedDecls();
            }
        };

        SemanticInfoChain.prototype.update = function () {
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.units[0] = new SemanticInfo("");
            this.units[0].addTopLevelDecl(this.getGlobalDecl());
            this.cleanAllDecls();
            for (var unit in this.unitCache) {
                if (this.unitCache[unit]) {
                    this.unitCache[unit].invalidate();
                }
            }
        };

        SemanticInfoChain.prototype.invalidateUnit = function (compilationUnitPath) {
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.invalidate();
            }
        };

        SemanticInfoChain.prototype.getDeclForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getDeclForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var unit = this.unitCache[decl.getScriptName()];

            if (unit) {
                return unit.getASTForDecl(decl);
            }

            return null;
        };

        SemanticInfoChain.prototype.getSymbolForAST = function (ast, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.symbol;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getSymbolForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForSymbol = function (symbol, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return symbol.ast;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForSymbol(symbol);
            }

            return null;
        };

        SemanticInfoChain.prototype.setSymbolForAST = function (ast, symbol, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                ast.symbol = symbol;
                return;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                unit.setSymbolForAST(ast, symbol);
            }
        };

        SemanticInfoChain.prototype.getAliasSymbolForAST = function (ast, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.aliasSymbol;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getAliasSymbolForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.removeSymbolFromCache = function (symbol) {
            var path = [symbol.name];
            var kind = (symbol.kind & TypeScript.PullElementKind.SomeType) !== 0 ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeValue;

            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.kind);
        };

        SemanticInfoChain.prototype.postDiagnostics = function () {
            var errors = [];

            for (var i = 1; i < this.units.length; i++) {
                this.units[i].getDiagnostics(errors);
            }

            return errors;
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(semanticInfo, scriptName) {
            this.semanticInfo = semanticInfo;
            this.scriptName = scriptName;
            this.isDeclareFile = false;
            this.parentChain = new Array();
            this.containingModuleHasExportAssignmentArray = [false];
            this.isParsingAmbientModuleArray = [false];
            this.foundValueDecl = false;
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };

        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };

        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };

        DeclCollectionContext.prototype.containingModuleHasExportAssignment = function () {
            TypeScript.Debug.assert(this.containingModuleHasExportAssignmentArray.length > 0);
            return TypeScript.ArrayUtilities.last(this.containingModuleHasExportAssignmentArray);
        };

        DeclCollectionContext.prototype.isParsingAmbientModule = function () {
            TypeScript.Debug.assert(this.isParsingAmbientModuleArray.length > 0);
            return TypeScript.ArrayUtilities.last(this.isParsingAmbientModuleArray);
        };
        return DeclCollectionContext;
    })();
    TypeScript.DeclCollectionContext = DeclCollectionContext;

    function preCollectImportDecls(ast, context) {
        var importDecl = ast;
        var declFlags = 0 /* None */;
        var span = TypeScript.TextSpan.fromBounds(importDecl.minChar, importDecl.limChar);

        var parent = context.getParent();

        if (!context.containingModuleHasExportAssignment() && TypeScript.hasFlag(importDecl.getVarFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(importDecl.id.text(), importDecl.id.actualText, 256 /* TypeAlias */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        return false;
    }

    function preCollectScriptDecls(script, context) {
        var span = TypeScript.TextSpan.fromBounds(script.minChar, script.limChar);

        var decl = new TypeScript.PullDecl(context.scriptName, context.scriptName, 1 /* Script */, 0 /* None */, span, context.scriptName);
        context.semanticInfo.setDeclForAST(script, decl);
        context.semanticInfo.setASTForDecl(decl, script);

        context.pushParent(decl);
        context.isDeclareFile = script.isDeclareFile;
    }

    function preCollectModuleDecls(moduleDecl, context) {
        var declFlags = 0 /* None */;
        var modName = moduleDecl.name.text();
        var isDynamic = TypeScript.isQuoted(modName) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsExternalModule */);
        var kind = 4 /* Container */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 128 /* IsEnum */)) {
            declFlags |= (4096 /* Enum */ | 131072 /* InitializedEnum */);
            kind = 64 /* Enum */;
        } else {
            kind = isDynamic ? 32 /* DynamicModule */ : 4 /* Container */;
        }

        var span = TypeScript.TextSpan.fromBounds(moduleDecl.minChar, moduleDecl.limChar);

        var decl = new TypeScript.PullDecl(modName, moduleDecl.name.actualText, kind, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(moduleDecl, decl);
        context.semanticInfo.setASTForDecl(decl, moduleDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.pushParent(decl);

        context.containingModuleHasExportAssignmentArray.push(TypeScript.ArrayUtilities.any(moduleDecl.members.members, function (m) {
            return m.nodeType() === 90 /* ExportAssignment */;
        }));
        context.isParsingAmbientModuleArray.push(context.isDeclareFile || TypeScript.ArrayUtilities.last(context.isParsingAmbientModuleArray) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), 8 /* Ambient */));

        return true;
    }

    function preCollectClassDecls(classDecl, context) {
        var declFlags = 0 /* None */;
        var constructorDeclKind = 1024 /* Variable */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(classDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(classDecl.getVarFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var span = TypeScript.TextSpan.fromBounds(classDecl.minChar, classDecl.limChar);

        var decl = new TypeScript.PullDecl(classDecl.name.text(), classDecl.name.actualText, 8 /* Class */, declFlags, span, context.scriptName);

        var constructorDecl = new TypeScript.PullDecl(classDecl.name.text(), classDecl.name.actualText, constructorDeclKind, declFlags | 16384 /* ClassConstructorVariable */, span, context.scriptName);

        decl.setValueDecl(constructorDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        parent.addChildDecl(constructorDecl);
        decl.setParentDecl(parent);
        constructorDecl.setParentDecl(parent);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(classDecl, decl);
        context.semanticInfo.setASTForDecl(decl, classDecl);
        context.semanticInfo.setASTForDecl(constructorDecl, classDecl);

        return true;
    }

    function preCollectObjectTypeDecls(objectType, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(objectType.minChar, objectType.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", 8388608 /* ObjectType */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(objectType, decl);
        context.semanticInfo.setASTForDecl(decl, objectType);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectInterfaceDecls(interfaceDecl, context) {
        var declFlags = 0 /* None */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(interfaceDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new TypeScript.PullDecl(interfaceDecl.name.text(), interfaceDecl.name.actualText, 16 /* Interface */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectParameterDecl(argDecl, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(argDecl.getFlags(), 4 /* OptionalName */) || TypeScript.hasFlag(argDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var span = TypeScript.TextSpan.fromBounds(argDecl.minChar, argDecl.limChar);

        var decl = new TypeScript.PullDecl(argDecl.id.text(), argDecl.id.actualText, 2048 /* Parameter */, declFlags, span, context.scriptName);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (argDecl.init) {
            parent.flags |= 33554432 /* HasDefaultArgs */;
        }

        if (parent.kind == 32768 /* ConstructorMethod */) {
            decl.setFlag(67108864 /* ConstructorParameter */);
        }

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
            var propDecl = new TypeScript.PullDecl(argDecl.id.text(), argDecl.id.actualText, 4096 /* Property */, declFlags, span, context.scriptName);
            propDecl.setValueDecl(decl);
            decl.setFlag(8388608 /* PropertyParameter */);
            propDecl.setFlag(8388608 /* PropertyParameter */);

            if (parent.kind == 32768 /* ConstructorMethod */) {
                propDecl.setFlag(67108864 /* ConstructorParameter */);
            }

            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            propDecl.setParentDecl(context.parentChain[context.parentChain.length - 2]);
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setASTForDecl(propDecl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, propDecl);
        } else {
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, decl);
        }

        if (argDecl.typeExpr && (argDecl.typeExpr.term.nodeType() === 16 /* ObjectType */ || argDecl.typeExpr.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(argDecl.typeExpr.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function preCollectTypeParameterDecl(typeParameterDecl, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(typeParameterDecl.minChar, typeParameterDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(typeParameterDecl.name.text(), typeParameterDecl.name.actualText, 8192 /* TypeParameter */, declFlags, span, context.scriptName);
        context.semanticInfo.setASTForDecl(decl, typeParameterDecl);
        context.semanticInfo.setDeclForAST(typeParameterDecl, decl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (typeParameterDecl.constraint && (typeParameterDecl.constraint.term.nodeType() === 16 /* ObjectType */ || typeParameterDecl.constraint.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(typeParameterDecl.constraint.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createPropertySignature(propertyDecl, context) {
        var declFlags = 4 /* Public */;
        var parent = context.getParent();
        var declType = parent.kind === 64 /* Enum */ ? 67108864 /* EnumMember */ : 4096 /* Property */;

        if (TypeScript.hasFlag(propertyDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (propertyDecl.constantValue !== null) {
            declFlags |= 524288 /* Constant */;
        }

        var span = TypeScript.TextSpan.fromBounds(propertyDecl.minChar, propertyDecl.limChar);

        var decl = new TypeScript.PullDecl(propertyDecl.id.text(), propertyDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(propertyDecl, decl);
        context.semanticInfo.setASTForDecl(decl, propertyDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (propertyDecl.typeExpr && (propertyDecl.typeExpr.term.nodeType() === 16 /* ObjectType */ || propertyDecl.typeExpr.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(propertyDecl.typeExpr.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 4096 /* Property */;

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberDecl.minChar, memberDecl.limChar);

        var decl = new TypeScript.PullDecl(memberDecl.id.text(), memberDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberDecl, decl);
        context.semanticInfo.setASTForDecl(decl, memberDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (memberDecl.typeExpr && (memberDecl.typeExpr.term.nodeType() === 16 /* ObjectType */ || memberDecl.typeExpr.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(memberDecl.typeExpr.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function createVariableDeclaration(varDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(varDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var span = TypeScript.TextSpan.fromBounds(varDecl.minChar, varDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(varDecl.id.text(), varDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(varDecl, decl);
        context.semanticInfo.setASTForDecl(decl, varDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (varDecl.typeExpr && (varDecl.typeExpr.term.nodeType() === 16 /* ObjectType */ || varDecl.typeExpr.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(varDecl.typeExpr.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function preCollectVarDecls(ast, context) {
        var varDecl = ast;
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;
        var isProperty = false;
        var isStatic = false;

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 2048 /* ClassProperty */)) {
            return createMemberVariableDeclaration(varDecl, context);
        } else if (TypeScript.hasFlag(varDecl.getVarFlags(), 256 /* Property */)) {
            return createPropertySignature(varDecl, context);
        }

        return createVariableDeclaration(varDecl, context);
    }

    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 16777216 /* FunctionType */;

        var span = TypeScript.TextSpan.fromBounds(functionTypeDeclAST.minChar, functionTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (functionTypeDeclAST.returnTypeAnnotation && (functionTypeDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || functionTypeDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(functionTypeDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 33554432 /* ConstructorType */;

        var span = TypeScript.TextSpan.fromBounds(constructorTypeDeclAST.minChar, constructorTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorTypeDeclAST.returnTypeAnnotation && (constructorTypeDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || constructorTypeDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(constructorTypeDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 16384 /* Function */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        if (!funcDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(funcDeclAST.minChar, funcDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(funcDeclAST.name.text(), funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(funcDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, funcDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (funcDeclAST.returnTypeAnnotation && (funcDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || funcDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(funcDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createAnyFunctionExpressionDeclaration(functionExpressionDeclAST, id, returnTypeAnnotation, context) {
        var declFlags = 0 /* None */;

        if (functionExpressionDeclAST.nodeType() === 82 /* ArrowFunctionExpression */) {
            declFlags |= 8192 /* FatArrow */;
        }

        var span = TypeScript.TextSpan.fromBounds(functionExpressionDeclAST.minChar, functionExpressionDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var name = id ? id.actualText : "";
        var decl = new TypeScript.PullFunctionExpressionDecl(name, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (returnTypeAnnotation && (returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createMemberFunctionDeclaration(memberFunctionDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 65536 /* Method */;

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (!memberFunctionDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberFunctionDeclAST.minChar, memberFunctionDeclAST.limChar);

        var decl = new TypeScript.PullDecl(memberFunctionDeclAST.name.text(), memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (memberFunctionDeclAST.returnTypeAnnotation && (memberFunctionDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || memberFunctionDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(memberFunctionDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 1024 /* Index */;
        var declType = 4194304 /* IndexSignature */;

        var span = TypeScript.TextSpan.fromBounds(indexSignatureDeclAST.minChar, indexSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }
        if (indexSignatureDeclAST.getFunctionFlags() & 16 /* Static */) {
            declFlags |= 16 /* Static */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (indexSignatureDeclAST.returnTypeAnnotation && (indexSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || indexSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk(indexSignatureDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createCallSignatureDeclaration(callSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 1048576 /* CallSignature */;

        var span = TypeScript.TextSpan.fromBounds(callSignatureDeclAST.minChar, callSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (callSignatureDeclAST.returnTypeAnnotation && (callSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || callSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(callSignatureDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 2097152 /* ConstructSignature */;

        var span = TypeScript.TextSpan.fromBounds(constructSignatureDeclAST.minChar, constructSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructSignatureDeclAST.returnTypeAnnotation && (constructSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || constructSignatureDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(constructSignatureDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = 512 /* Constructor */;
        var declType = 32768 /* ConstructorMethod */;

        if (!constructorDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(constructorDeclAST.minChar, constructorDeclAST.limChar);

        var parent = context.getParent();

        if (parent) {
            var parentFlags = parent.flags;

            if (parentFlags & 1 /* Exported */) {
                declFlags |= 1 /* Exported */;
            }
        }

        var decl = new TypeScript.PullDecl(parent.name, parent.getDisplayName(), declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorDeclAST.returnTypeAnnotation && (constructorDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || constructorDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(constructorDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 262144 /* GetAccessor */;

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(getAccessorDeclAST.minChar, getAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(getAccessorDeclAST.name.text(), getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (getAccessorDeclAST.returnTypeAnnotation && (getAccessorDeclAST.returnTypeAnnotation.term.nodeType() === 16 /* ObjectType */ || getAccessorDeclAST.returnTypeAnnotation.term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk(getAccessorDeclAST.returnTypeAnnotation.term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 524288 /* SetAccessor */;

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(setAccessorDeclAST.minChar, setAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(setAccessorDeclAST.name.actualText, setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectCatchDecls(ast, context) {
        var declFlags = 0 /* None */;
        var declType = 1073741824 /* CatchBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectWithDecls(ast, context) {
        var declFlags = 0 /* None */;
        var declType = 536870912 /* WithBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectDecls(ast, walker) {
        var context = walker.state;
        var go = false;

        if (ast.nodeType() === 2 /* Script */) {
            preCollectScriptDecls(ast, context);
            go = true;
        } else if (ast.nodeType() === 1 /* List */) {
            go = true;
        } else if (ast.nodeType() === 84 /* Block */) {
            go = true;
        } else if (ast.nodeType() === 20 /* VariableDeclaration */) {
            go = true;
        } else if (ast.nodeType() === 100 /* VariableStatement */) {
            go = true;
        } else if (ast.nodeType() === 17 /* ModuleDeclaration */) {
            go = preCollectModuleDecls(ast, context);
        } else if (ast.nodeType() === 14 /* ClassDeclaration */) {
            go = preCollectClassDecls(ast, context);
        } else if (ast.nodeType() === 15 /* InterfaceDeclaration */) {
            go = preCollectInterfaceDecls(ast, context);
        } else if (ast.nodeType() === 16 /* ObjectType */) {
            go = preCollectObjectTypeDecls(ast, context);
        } else if (ast.nodeType() === 21 /* Parameter */) {
            go = preCollectParameterDecl(ast, context);
        } else if (ast.nodeType() === 19 /* VariableDeclarator */) {
            go = preCollectVarDecls(ast, context);
        } else if (ast.nodeType() === 13 /* FunctionDeclaration */) {
            var funcDecl = ast;

            if (funcDecl.isConstructor) {
                go = createClassConstructorDeclaration(funcDecl, context);
            } else if (funcDecl.isGetAccessor()) {
                go = createGetAccessorDeclaration(funcDecl, context);
            } else if (funcDecl.isSetAccessor()) {
                go = createSetAccessorDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 1024 /* ConstructMember */)) {
                go = TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */) ? createConstructorTypeDeclaration(funcDecl, context) : createConstructSignatureDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 512 /* CallMember */)) {
                go = createCallSignatureDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 4096 /* IndexerMember */)) {
                go = createIndexSignatureDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */)) {
                go = createFunctionTypeDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 256 /* Method */)) {
                go = createMemberFunctionDeclaration(funcDecl, context);
            } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), (8192 /* IsFunctionExpression */ | 16384 /* IsFunctionProperty */))) {
                go = createAnyFunctionExpressionDeclaration(funcDecl, funcDecl.name, funcDecl.returnTypeAnnotation, context);
            } else {
                go = createFunctionDeclaration(funcDecl, context);
            }
        } else if (ast.nodeType() === 82 /* ArrowFunctionExpression */) {
            var arrowFunction = ast;
            go = createAnyFunctionExpressionDeclaration(ast, null, arrowFunction.returnTypeAnnotation, context);
        } else if (ast.nodeType() === 18 /* ImportDeclaration */) {
            go = preCollectImportDecls(ast, context);
        } else if (ast.nodeType() === 9 /* TypeParameter */) {
            go = preCollectTypeParameterDecl(ast, context);
        } else if (ast.nodeType() === 94 /* IfStatement */) {
            go = true;
        } else if (ast.nodeType() === 93 /* ForStatement */) {
            go = true;
        } else if (ast.nodeType() === 92 /* ForInStatement */) {
            go = true;
        } else if (ast.nodeType() === 101 /* WhileStatement */) {
            go = true;
        } else if (ast.nodeType() === 88 /* DoStatement */) {
            go = true;
        } else if (ast.nodeType() === 27 /* CommaExpression */) {
            go = true;
        } else if (ast.nodeType() === 96 /* ReturnStatement */) {
            go = true;
        } else if (ast.nodeType() === 97 /* SwitchStatement */ || ast.nodeType() === 103 /* CaseClause */) {
            go = true;
        } else if (ast.nodeType() === 38 /* InvocationExpression */) {
            go = true;
        } else if (ast.nodeType() === 39 /* ObjectCreationExpression */) {
            go = true;
        } else if (ast.nodeType() === 99 /* TryStatement */) {
            go = true;
        } else if (ast.nodeType() === 95 /* LabeledStatement */) {
            go = true;
        } else if (ast.nodeType() === 104 /* CatchClause */) {
            go = preCollectCatchDecls(ast, context);
        } else if (ast.nodeType() === 102 /* WithStatement */) {
            go = preCollectWithDecls(ast, context);
        }

        walker.options.goChildren = go;
    }
    TypeScript.preCollectDecls = preCollectDecls;

    function isContainer(decl) {
        return decl.kind === 4 /* Container */ || decl.kind === 32 /* DynamicModule */ || decl.kind === 64 /* Enum */;
    }

    function getInitializationFlag(decl) {
        if (decl.kind & 4 /* Container */) {
            return 32768 /* InitializedModule */;
        } else if (decl.kind & 64 /* Enum */) {
            return 131072 /* InitializedEnum */;
        } else if (decl.kind & 32 /* DynamicModule */) {
            return 65536 /* InitializedDynamicModule */;
        }

        return 0 /* None */;
    }

    function hasInitializationFlag(decl) {
        var kind = decl.kind;

        if (kind & 4 /* Container */) {
            return (decl.flags & 32768 /* InitializedModule */) !== 0;
        } else if (kind & 64 /* Enum */) {
            return (decl.flags & 131072 /* InitializedEnum */) != 0;
        } else if (kind & 32 /* DynamicModule */) {
            return (decl.flags & 65536 /* InitializedDynamicModule */) !== 0;
        }

        return false;
    }

    function postCollectDecls(ast, walker) {
        var context = walker.state;
        var parentDecl;
        var initFlag = 0 /* None */;

        if (ast.nodeType() === 17 /* ModuleDeclaration */) {
            var thisModule = context.getParent();
            context.popParent();
            context.containingModuleHasExportAssignmentArray.pop();
            context.isParsingAmbientModuleArray.pop();

            parentDecl = context.getParent();

            if (hasInitializationFlag(thisModule)) {
                if (parentDecl && isContainer(parentDecl)) {
                    initFlag = getInitializationFlag(parentDecl);
                    parentDecl.setFlags(parentDecl.flags | initFlag);
                }

                var valueDecl = new TypeScript.PullDecl(thisModule.name, thisModule.getDisplayName(), 1024 /* Variable */, thisModule.flags, thisModule.getSpan(), context.scriptName);

                thisModule.setValueDecl(valueDecl);

                context.semanticInfo.setASTForDecl(valueDecl, ast);

                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                    valueDecl.setParentDecl(parentDecl);
                }
            }
        } else if (ast.nodeType() === 14 /* ClassDeclaration */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 15 /* InterfaceDeclaration */) {
            context.popParent();
        } else if (ast.nodeType() === 16 /* ObjectType */) {
            context.popParent();
        } else if (ast.nodeType() === 13 /* FunctionDeclaration */ || ast.nodeType() === 82 /* ArrowFunctionExpression */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 19 /* VariableDeclarator */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 104 /* CatchClause */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }

            context.popParent();
        } else if (ast.nodeType() === 102 /* WithStatement */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }

            context.popParent();
        }
    }
    TypeScript.postCollectDecls = postCollectDecls;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function getPathToDecl(decl) {
        if (!decl) {
            return [];
        }

        var decls = decl.getParentPath();

        if (decls) {
            return decls;
        } else {
            decls = [decl];
        }

        var parentDecl = decl.getParentDecl();

        while (parentDecl) {
            if (parentDecl && decls[decls.length - 1] != parentDecl && !(parentDecl.kind & 512 /* ObjectLiteral */)) {
                decls[decls.length] = parentDecl;
            }
            parentDecl = parentDecl.getParentDecl();
        }

        decls = decls.reverse();

        decl.setParentPath(decls);

        return decls;
    }
    TypeScript.getPathToDecl = getPathToDecl;

    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.semanticInfo = null;
        }
        PullSymbolBinder.prototype.findTypeParameterInCache = function (name) {
            return this.functionTypeParameterCache[name];
        };

        PullSymbolBinder.prototype.addTypeParameterToCache = function (typeParameter) {
            this.functionTypeParameterCache[typeParameter.getName()] = typeParameter;
        };

        PullSymbolBinder.prototype.resetTypeParameterCache = function () {
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
        };

        PullSymbolBinder.prototype.setUnit = function (fileName) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        };

        PullSymbolBinder.prototype.getParent = function (decl, returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parentDecl = decl.getParentDecl();

            if (parentDecl.kind == 1 /* Script */) {
                return null;
            }

            var parent = parentDecl.getSymbol();

            if (!parent && parentDecl && !parentDecl.isBound()) {
                this.bindDeclToPullSymbol(parentDecl);
            }

            parent = parentDecl.getSymbol();
            if (parent) {
                var parentDeclKind = parentDecl.kind;
                if (parentDeclKind == 262144 /* GetAccessor */) {
                    parent = parent.getGetter();
                } else if (parentDeclKind == 524288 /* SetAccessor */) {
                    parent = parent.getSetter();
                }
            }

            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = parent.getInstanceSymbol();

                    if (instanceSymbol) {
                        return instanceSymbol.type;
                    }
                }

                return parent.type;
            }

            return null;
        };

        PullSymbolBinder.prototype.findDeclsInContext = function (startingDecl, declKind, searchGlobally) {
            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.name, declKind);
            }

            var contextSymbolPath = getPathToDecl(startingDecl);

            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath = [];

                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].kind & 1 /* Script */) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].name;
                }

                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }

            return this.semanticInfoChain.findDecls([name], declKind);
        };

        PullSymbolBinder.prototype.getExistingSymbol = function (decl, searchKind, parent) {
            var lookingForValue = (searchKind & TypeScript.PullElementKind.SomeValue) !== 0;
            var lookingForType = (searchKind & TypeScript.PullElementKind.SomeType) !== 0;
            var lookingForContainer = (searchKind & TypeScript.PullElementKind.SomeContainer) !== 0;
            var name = decl.name;
            if (parent) {
                var isExported = (decl.flags & 1 /* Exported */) !== 0;

                var prevSymbol = null;
                if (lookingForValue) {
                    prevSymbol = parent.findContainedNonMember(name);
                } else if (lookingForType) {
                    prevSymbol = parent.findContainedNonMemberType(name, searchKind);
                } else if (lookingForContainer) {
                    prevSymbol = parent.findContainedNonMemberContainer(name, searchKind);
                }
                var prevIsExported = !prevSymbol;
                if (!prevSymbol) {
                    if (lookingForValue) {
                        prevSymbol = parent.findMember(name, false);
                    } else if (lookingForType) {
                        prevSymbol = parent.findNestedType(name, searchKind);
                    } else if (lookingForContainer) {
                        prevSymbol = parent.findNestedContainer(name, searchKind);
                    }
                }

                if (isExported && prevIsExported) {
                    return prevSymbol;
                }
                if (prevSymbol) {
                    var prevDecls = prevSymbol.getDeclarations();
                    var lastPrevDecl = prevDecls[prevDecls.length - 1];
                    var parentDecl = decl.getParentDecl();
                    var prevParentDecl = lastPrevDecl && lastPrevDecl.getParentDecl();
                    if (parentDecl !== prevParentDecl) {
                        return null;
                    }

                    return prevSymbol;
                }
            } else {
                var parentDecl = decl.getParentDecl();
                if (parentDecl && parentDecl.kind === 1 /* Script */) {
                    return this.semanticInfoChain.findTopLevelSymbol(name, searchKind, this.semanticInfo.getPath());
                } else {
                    var prevDecls = parentDecl && parentDecl.searchChildDecls(name, searchKind);
                    return prevDecls[0] && prevDecls[0].getSymbol();
                }
            }

            return null;
        };

        PullSymbolBinder.prototype.checkThatExportsMatch = function (decl, prevSymbol, reportError) {
            if (typeof reportError === "undefined") { reportError = true; }
            var isExported = (decl.flags & 1 /* Exported */) !== 0;
            var prevDecls = prevSymbol.getDeclarations();
            var prevIsExported = (prevDecls[prevDecls.length - 1].flags & 1 /* Exported */) !== 0;
            if ((isExported !== prevIsExported) && !prevSymbol.isSignature() && (decl.kind & TypeScript.PullElementKind.SomeSignature) == 0) {
                if (reportError) {
                    var ast = this.semanticInfo.getASTForDecl(decl);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported, [decl.getDisplayName()]));
                }
                return false;
            }

            return true;
        };

        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.name;

            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;

            var moduleInstanceDecl = moduleContainerDecl.getValueDecl();

            var moduleKind = moduleContainerDecl.kind;

            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleAST = this.semanticInfo.getASTForDecl(moduleContainerDecl);

            var isExported = moduleContainerDecl.flags & 1 /* Exported */;
            var isEnum = (moduleKind & 64 /* Enum */) != 0;
            var searchKind = isEnum ? 64 /* Enum */ : TypeScript.PullElementKind.SomeContainer;
            var isInitializedModule = (moduleContainerDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule) != 0;

            if (parent && moduleKind == 32 /* DynamicModule */) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), moduleAST.minChar, moduleAST.getLength(), TypeScript.DiagnosticCode.Ambient_external_module_declaration_must_be_defined_in_global_context, null));
            }

            var createdNewSymbol = false;

            moduleContainerTypeSymbol = this.getExistingSymbol(moduleContainerDecl, searchKind, parent);

            if (moduleContainerTypeSymbol) {
                if (moduleContainerTypeSymbol.kind !== moduleKind) {
                    if (isInitializedModule) {
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), moduleAST.minChar, moduleAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [moduleContainerDecl.getDisplayName()]));
                    }
                    moduleContainerTypeSymbol = null;
                } else if (moduleKind == 32 /* DynamicModule */) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), moduleAST.minChar, moduleAST.getLength(), TypeScript.DiagnosticCode.Ambient_external_module_declaration_cannot_be_reopened, null));
                } else if (!this.checkThatExportsMatch(moduleContainerDecl, moduleContainerTypeSymbol)) {
                    moduleContainerTypeSymbol = null;
                }
            }

            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            } else {
                moduleContainerTypeSymbol = new TypeScript.PullContainerSymbol(modName, moduleKind);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);

            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);

            if (!moduleInstanceSymbol && isInitializedModule) {
                var variableSymbol = null;
                if (parentInstanceSymbol) {
                    if (isExported) {
                        variableSymbol = parentInstanceSymbol.findMember(modName, false);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                        }
                    } else {
                        variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);

                        if (!variableSymbol) {
                            variableSymbol = parentInstanceSymbol.findMember(modName, false);
                        }
                    }

                    if (variableSymbol) {
                        var declarations = variableSymbol.getDeclarations();

                        if (declarations.length) {
                            var variableSymbolParentDecl = declarations[0].getParentDecl();

                            if (parentDecl !== variableSymbolParentDecl) {
                                variableSymbol = null;
                            }
                        }
                    }
                } else if (!(moduleContainerDecl.flags & 1 /* Exported */)) {
                    var siblingDecls = parentDecl.getChildDecls();
                    var augmentedDecl = null;

                    for (var i = 0; i < siblingDecls.length; i++) {
                        if (siblingDecls[i] == moduleContainerDecl) {
                            break;
                        }

                        if ((siblingDecls[i].name == modName) && (siblingDecls[i].kind & TypeScript.PullElementKind.SomeValue)) {
                            augmentedDecl = siblingDecls[i];
                            break;
                        }
                    }

                    if (augmentedDecl) {
                        variableSymbol = augmentedDecl.getSymbol();

                        if (variableSymbol) {
                            if (variableSymbol.isContainer()) {
                                variableSymbol = variableSymbol.getInstanceSymbol();
                            } else if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = variableSymbol.getConstructorMethod();
                            }
                        }
                    }
                }

                if (variableSymbol) {
                    moduleInstanceSymbol = variableSymbol;
                    moduleInstanceTypeSymbol = variableSymbol.type;
                } else {
                    moduleInstanceSymbol = new TypeScript.PullSymbol(modName, 1024 /* Variable */);
                }

                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);

                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */);
                    moduleInstanceSymbol.type = moduleInstanceTypeSymbol;
                }

                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);
                }
            }

            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();

            if (isEnum && moduleDeclarations.length > 1 && moduleAST.members.members.length > 0) {
                var multipleEnums = TypeScript.ArrayUtilities.where(moduleDeclarations, function (d) {
                    return d.kind === 64 /* Enum */;
                }).length > 1;
                if (multipleEnums) {
                    var firstVariable = moduleAST.members.members[0];
                    var firstVariableDeclarator = firstVariable.declaration.declarators.members[0];
                    if (!firstVariableDeclarator.init) {
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), firstVariableDeclarator.minChar, firstVariableDeclarator.getLength(), TypeScript.DiagnosticCode.Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element, null));
                    }
                }
            }

            if (createdNewSymbol) {
                if (parent) {
                    if (isEnum) {
                        if (moduleContainerDecl.flags & 1 /* Exported */) {
                            parent.addEnclosedMemberType(moduleContainerTypeSymbol);
                        } else {
                            parent.addEnclosedNonMemberType(moduleContainerTypeSymbol);
                        }
                    } else {
                        if (moduleContainerDecl.flags & 1 /* Exported */) {
                            parent.addEnclosedMemberContainer(moduleContainerTypeSymbol);
                        } else {
                            parent.addEnclosedNonMemberContainer(moduleContainerTypeSymbol);
                        }
                    }
                }
            }

            if (isEnum) {
                this.semanticInfo.addSyntheticIndexSignature(moduleContainerDecl, moduleContainerTypeSymbol.getInstanceSymbol().type, moduleAST.name, "x", this.semanticInfoChain.numberTypeSymbol, this.semanticInfoChain.stringTypeSymbol);
            }

            var valueDecl = moduleContainerDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }

            var otherDecls = this.findDeclsInContext(moduleContainerDecl, moduleContainerDecl.kind, true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.flags;
            var declKind = importDeclaration.kind;
            var importDeclAST = this.semanticInfo.getASTForDecl(importDeclaration);

            var isExported = false;
            var importSymbol = null;
            var declName = importDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);

            importSymbol = this.getExistingSymbol(importDeclaration, TypeScript.PullElementKind.SomeContainer, parent);

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), importDeclAST.minChar, importDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [importDeclaration.getDisplayName()]));
                importSymbol = null;
            }

            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, TypeScript.PullElementKind.SomeContainer);
                }
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);

            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addEnclosedMemberContainer(importSymbol);
                } else {
                    parent.addEnclosedNonMemberContainer(importSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.name;
            var classSymbol = null;

            var constructorSymbol = null;
            var constructorTypeSymbol = null;

            var classAST = this.semanticInfo.getASTForDecl(classDecl);

            var parent = this.getParent(classDecl);
            var parentDecl = classDecl.getParentDecl();
            var isExported = classDecl.flags & 1 /* Exported */;
            var isGeneric = false;

            classSymbol = this.getExistingSymbol(classDecl, TypeScript.PullElementKind.SomeType, parent);

            if (classSymbol && classSymbol.kind === 16 /* Interface */) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), classAST.minChar, classAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [classDecl.getDisplayName()]));
                classSymbol = null;
            }

            var decls;

            classSymbol = new TypeScript.PullTypeSymbol(className, 8 /* Class */);

            if (!parent) {
                this.semanticInfoChain.cacheGlobalSymbol(classSymbol, 8 /* Class */);
            }

            classSymbol.addDeclaration(classDecl);

            classDecl.setSymbol(classSymbol);

            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST, classSymbol);

            if (parent) {
                if (classDecl.flags & 1 /* Exported */) {
                    parent.addEnclosedMemberType(classSymbol);
                } else {
                    parent.addEnclosedNonMemberType(classSymbol);
                }
            }

            this.resetTypeParameterCache();

            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = constructorSymbol ? constructorSymbol.type : null;

            if (!constructorSymbol) {
                var siblingValueDecls = null;
                if (parentDecl) {
                    siblingValueDecls = parentDecl.searchChildDecls(className, TypeScript.PullElementKind.SomeValue);

                    if (siblingValueDecls && siblingValueDecls[0] && siblingValueDecls[0].hasSymbol()) {
                        constructorSymbol = siblingValueDecls[0].getSymbol();
                    }
                }

                constructorSymbol = constructorSymbol || new TypeScript.PullSymbol(className, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = constructorSymbol.type || new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);

                constructorSymbol.setIsSynthesized();

                constructorSymbol.type = constructorTypeSymbol;
                classSymbol.setConstructorMethod(constructorSymbol);

                classSymbol.setHasDefaultConstructor();
            }

            if (constructorSymbol.getIsSynthesized()) {
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                constructorTypeSymbol.addDeclaration(classDecl);
            } else {
                classSymbol.setHasDefaultConstructor(false);
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    classSymbol.addTypeParameter(typeParameter);
                    constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                    typeParameter.addDeclaration(typeParameters[i]);
                    typeParameters[i].setSymbol(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }
            }

            var valueDecl = classDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }
        };

        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.name;
            var interfaceSymbol = null;

            var interfaceAST = this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);

            var acceptableSharedKind = 16 /* Interface */;

            interfaceSymbol = this.getExistingSymbol(interfaceDecl, TypeScript.PullElementKind.SomeType, parent);

            if (interfaceSymbol) {
                if (!(interfaceSymbol.kind & acceptableSharedKind)) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), interfaceAST.minChar, interfaceAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [interfaceDecl.getDisplayName()]));
                    interfaceSymbol = null;
                } else if (!this.checkThatExportsMatch(interfaceDecl, interfaceSymbol)) {
                    interfaceSymbol = null;
                }
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, 16 /* Interface */);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);

            if (createdNewSymbol) {
                if (parent) {
                    if (interfaceDecl.flags & 1 /* Exported */) {
                        parent.addEnclosedMemberType(interfaceSymbol);
                    } else {
                        parent.addEnclosedNonMemberType(interfaceSymbol);
                    }
                }
            }

            this.resetTypeParameterCache();

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    interfaceSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();

                        if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                            this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));

                            break;
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            var otherDecls = this.findDeclsInContext(interfaceDecl, interfaceDecl.kind, true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfo.getASTForDecl(objectDecl);

            var objectSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);

            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    objectSymbol.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.kind;
            var declFlags = constructorTypeDeclaration.flags;
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);

            var constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);

            var signature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);

            if (TypeScript.lastParameterIsRest(constructorTypeAST.parameters)) {
                signature.hasVarArgs = true;
            }

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructorTypeDeclaration), constructorTypeSymbol, signature);

            constructorTypeSymbol.addConstructSignature(signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var varDeclAST = this.semanticInfo.getASTForDecl(variableDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var variableSymbol = null;

            var declName = variableDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(variableDeclaration, true);

            var parentDecl = variableDeclaration.getParentDecl();

            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) !== 0;
            var isModuleValue = (declFlags & (32768 /* InitializedModule */)) != 0;
            var isEnumValue = (declFlags & 131072 /* InitializedEnum */) != 0;
            var isClassConstructorVariable = (declFlags & 16384 /* ClassConstructorVariable */) != 0;

            if (parentDecl && !isImplicit) {
                parentDecl.addVariableDeclToGroup(variableDeclaration);
            }

            variableSymbol = this.getExistingSymbol(variableDeclaration, TypeScript.PullElementKind.SomeValue, parent);

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var span;
            var decl;
            var decls;
            var ast;
            var members;

            if (variableSymbol) {
                var prevKind = variableSymbol.kind;
                var prevIsAmbient = variableSymbol.hasFlag(8 /* Ambient */);
                var prevIsEnum = variableSymbol.hasFlag(131072 /* InitializedEnum */);
                var prevIsClassConstructorVariable = variableSymbol.hasFlag(16384 /* ClassConstructorVariable */);
                var prevIsModuleValue = variableSymbol.hasFlag(32768 /* InitializedModule */);
                var prevIsImplicit = variableSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable);
                var prevIsFunction = prevKind == 16384 /* Function */;
                var isAmbient = (variableDeclaration.flags & 8 /* Ambient */) != 0;
                var prevDecl = variableSymbol.getDeclarations()[0];
                var prevParentDecl = prevDecl.getParentDecl();
                var bothAreGlobal = parentDecl && (parentDecl.kind == 1 /* Script */) && (prevParentDecl.kind == 1 /* Script */);
                var shareParent = bothAreGlobal || prevDecl.getParentDecl() == variableDeclaration.getParentDecl();
                var prevIsParam = shareParent && prevKind == 2048 /* Parameter */ && declKind == 1024 /* Variable */;

                var acceptableRedeclaration = prevIsParam || (isImplicit && ((!isEnumValue && !isClassConstructorVariable && prevIsFunction) || ((isModuleValue || isEnumValue) && (prevIsModuleValue || prevIsEnum)) || (isClassConstructorVariable && prevIsModuleValue && isAmbient) || (isModuleValue && prevIsClassConstructorVariable)));

                if (acceptableRedeclaration && (prevIsClassConstructorVariable || prevIsFunction) && !prevIsAmbient) {
                    if (prevDecl.getScriptName() != variableDeclaration.getScriptName()) {
                        span = variableDeclaration.getSpan();
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2, [declName, declName, prevDecl.getScriptName()]));
                        variableSymbol.type = new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, declName);
                    }
                }

                if (!acceptableRedeclaration || prevIsParam) {
                    if (!prevIsParam && (isImplicit || prevIsImplicit || (prevKind & TypeScript.PullElementKind.SomeFunction) !== 0) || !shareParent) {
                        span = variableDeclaration.getSpan();
                        var diagnostic = new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [variableDeclaration.getDisplayName()]);
                        this.semanticInfo.addDiagnostic(diagnostic);
                        variableSymbol.type = new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, declName);
                    } else {
                        this.checkThatExportsMatch(variableDeclaration, variableSymbol);
                        variableSymbol = null;
                        parentHadSymbol = false;
                    }
                }

                if (variableSymbol && !(variableSymbol.type && variableSymbol.type.isError()) && !this.checkThatExportsMatch(variableDeclaration, variableSymbol, !(isModuleValue && prevIsModuleValue))) {
                    variableSymbol.type = new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, declName);
                }
            }

            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                    if (!parent) {
                        this.semanticInfoChain.cacheGlobalSymbol(variableSymbol, declKind);
                    }
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);

                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
            } else if (!parentHadSymbol) {
                if (isClassConstructorVariable) {
                    var classTypeSymbol = variableSymbol;

                    if (parent) {
                        members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].kind === 8 /* Class */)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var childDecls = parentDecl.searchChildDecls(declName, TypeScript.PullElementKind.SomeType);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        classTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }

                        if (!classTypeSymbol) {
                            classTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeType, this.semanticInfo.getPath());
                        }
                    }

                    if (classTypeSymbol && (classTypeSymbol.kind !== 8 /* Class */)) {
                        classTypeSymbol = null;
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }
                } else if (declFlags & TypeScript.PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var searchKind = (declFlags & (32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */)) ? TypeScript.PullElementKind.SomeContainer : 64 /* Enum */;
                            var childDecls = parentDecl.searchChildDecls(declName, searchKind);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        moduleContainerTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeContainer, this.semanticInfo.getPath());

                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, 64 /* Enum */, this.semanticInfo.getPath());
                            }
                        }
                    }

                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = moduleContainerTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        TypeScript.Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            } else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addMember(variableSymbol);
                } else {
                    parent.addEnclosedNonMember(variableSymbol);
                }
            }

            var otherDecls = this.findDeclsInContext(variableDeclaration, variableDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var propDeclAST = this.semanticInfo.getASTForDecl(propertyDeclaration);

            var isStatic = false;
            var isOptional = false;

            var propertySymbol = null;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 128 /* Optional */)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            propertySymbol = parent.findMember(declName, false);

            if (propertySymbol) {
                var span = propertyDeclaration.getSpan();

                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [propertyDeclaration.getDisplayName()]));
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            var classTypeSymbol;

            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol);

            this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
            this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);

            if (isOptional) {
                propertySymbol.isOptional = true;
            }

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };

        PullSymbolBinder.prototype.bindParameterSymbols = function (functionDeclaration, funcType, signatureSymbol) {
            var parameters = [];
            var decl = null;
            var argDecl = null;
            var parameterSymbol = null;
            var isProperty = false;
            var params = new TypeScript.BlockIntrinsics();
            var funcDecl = this.semanticInfo.getDeclForAST(functionDeclaration);

            if (functionDeclaration.parameters) {
                for (var i = 0; i < functionDeclaration.parameters.members.length; i++) {
                    argDecl = functionDeclaration.parameters.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */);
                    parameterSymbol = new TypeScript.PullSymbol(argDecl.id.text(), 2048 /* Parameter */);

                    if (argDecl.isRest) {
                        parameterSymbol.isVarArg = true;
                    }

                    if (decl.flags & 128 /* Optional */) {
                        parameterSymbol.isOptional = true;
                    }

                    if (params[argDecl.id.text()]) {
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), argDecl.minChar, argDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [argDecl.id.actualText]));
                    } else {
                        params[argDecl.id.text()] = true;
                    }
                    if (decl) {
                        if (isProperty) {
                            decl.ensureSymbolIsBound();
                            var valDecl = decl.getValueDecl();

                            if (valDecl) {
                                valDecl.setSymbol(parameterSymbol);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        } else {
                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol);
                        }

                        if (funcDecl) {
                            funcDecl.addVariableDeclToGroup(decl);
                        }
                    }

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.isOptional);

                    if (signatureSymbol.isDefinition()) {
                        funcType.addEnclosedNonMember(parameterSymbol);
                    }
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.kind;
            var declFlags = functionDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = functionDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(functionDeclaration, true);
            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;

            var functionSymbol = null;
            var functionTypeSymbol = null;

            functionSymbol = this.getExistingSymbol(functionDeclaration, TypeScript.PullElementKind.SomeValue, parent);

            if (functionSymbol) {
                var isAmbient = functionDeclaration.flags & 8 /* Ambient */;
                var acceptableRedeclaration = functionSymbol.kind === 16384 /* Function */ && (isSignature || functionSymbol.allDeclsHaveFlag(2048 /* Signature */)) || functionSymbol.hasFlag(32768 /* InitializedModule */) && isAmbient;
                if (!acceptableRedeclaration) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [functionDeclaration.getDisplayName()]));
                    functionSymbol.type = new TypeScript.PullErrorTypeSymbol(this.semanticInfoChain.anyTypeSymbol, funcName);
                }
            }

            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.type;
                parentHadSymbol = true;
            }

            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
            }

            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                functionSymbol.type = functionTypeSymbol;
                functionTypeSymbol.setFunctionSymbol(functionSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);

            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol);
                } else {
                    parent.addEnclosedNonMember(functionSymbol);
                }
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);

            if (TypeScript.lastParameterIsRest(funcDeclAST.parameters)) {
                signature.hasVarArgs = true;
            }

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionDeclaration), functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            functionTypeSymbol.addCallSignature(signature);

            var otherDecls = this.findDeclsInContext(functionDeclaration, functionDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.kind;
            var declFlags = functionExpressionDeclaration.flags;
            var funcExpAST = this.semanticInfo.getASTForDecl(functionExpressionDeclaration);

            var functionName = declKind == 131072 /* FunctionExpression */ ? functionExpressionDeclaration.getFunctionExpressionName() : functionExpressionDeclaration.name;
            var functionSymbol = new TypeScript.PullSymbol(functionName, 16384 /* Function */);
            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
            functionTypeSymbol.setFunctionSymbol(functionSymbol);

            functionSymbol.type = functionTypeSymbol;

            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);

            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);

            var signature = new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (TypeScript.lastParameterIsRest(funcExpAST.parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionExpressionDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.kind;
            var declFlags = functionTypeDeclaration.flags;
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);

            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);

            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (TypeScript.lastParameterIsRest(funcTypeAST.parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionTypeDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.kind;
            var declFlags = methodDeclaration.flags;
            var methodAST = this.semanticInfo.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & 2 /* Private */) !== 0;
            var isStatic = (declFlags & 16 /* Static */) !== 0;
            var isOptional = (declFlags & 128 /* Optional */) !== 0;

            var methodName = methodDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;

            var methodSymbol = null;
            var methodTypeSymbol = null;

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            methodSymbol = parent.findMember(methodName, false);

            if (methodSymbol && (methodSymbol.kind !== 65536 /* Method */ || (!isSignature && !methodSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), methodAST.minChar, methodAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [methodDeclaration.getDisplayName()]));
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.type;
                parentHadSymbol = true;
            }

            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, 65536 /* Method */);
            }

            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                methodSymbol.type = methodTypeSymbol;
                methodTypeSymbol.setFunctionSymbol(methodSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);

            if (isOptional) {
                methodSymbol.isOptional = true;
            }

            if (!parentHadSymbol) {
                parent.addMember(methodSymbol);
            }

            var sigKind = 1048576 /* CallSignature */;

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);

            if (TypeScript.lastParameterIsRest(methodAST.parameters)) {
                signature.hasVarArgs = true;
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterName;
            var typeParameterAST;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].name;
                typeParameterAST = this.semanticInfo.getASTForDecl(typeParameters[i]);

                typeParameter = signature.findTypeParameter(typeParameterName);

                if (!typeParameter) {
                    if (!typeParameterAST.constraint) {
                        typeParameter = this.findTypeParameterInCache(typeParameterName);
                    }

                    if (!typeParameter) {
                        typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName, true);

                        if (!typeParameterAST.constraint) {
                            this.addTypeParameterToCache(typeParameter);
                        }
                    }

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(methodDeclaration), methodTypeSymbol, signature);

            methodTypeSymbol.addCallSignature(signature);

            var otherDecls = this.findDeclsInContext(methodDeclaration, methodDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.kind;
            var declFlags = constructorDeclaration.flags;
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(constructorDeclaration, true);

            var parentHadSymbol = false;

            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;

            if (constructorSymbol && (constructorSymbol.kind !== 32768 /* ConstructorMethod */ || (!isSignature && constructorSymbol.type && constructorSymbol.type.hasOwnConstructSignatures()))) {
                var hasDefinitionSignature = false;
                var constructorSigs = constructorSymbol.type.getConstructSignatures();

                for (var i = 0; i < constructorSigs.length; i++) {
                    if (!constructorSigs[i].hasFlag(2048 /* Signature */)) {
                        hasDefinitionSignature = true;
                        break;
                    }
                }

                if (hasDefinitionSignature) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), constructorAST.minChar, constructorAST.getLength(), TypeScript.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed, null));

                    constructorSymbol = null;
                }
            }

            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.type;
            } else {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);
            }

            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.type = constructorTypeSymbol;

            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            constructorSymbol.setIsSynthesized(false);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);

            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */);

            constructSignature.returnType = parent;

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(constructorAST, constructorTypeSymbol, constructSignature);

            var typeParameters = constructorTypeSymbol.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                constructSignature.addTypeParameter(typeParameters[i]);
            }

            if (TypeScript.lastParameterIsRest(constructorAST.parameters)) {
                constructSignature.hasVarArgs = true;
            }

            constructorTypeSymbol.addConstructSignature(constructSignature);

            var otherDecls = this.findDeclsInContext(constructorDeclaration, constructorDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = this.semanticInfo.getASTForDecl(constructSignatureDeclaration);

            var constructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);

            if (TypeScript.lastParameterIsRest(constructorAST.parameters)) {
                constructSignature.hasVarArgs = true;
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), null, constructSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);

            parent.addConstructSignature(constructSignature);
        };

        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = this.semanticInfo.getASTForDecl(callSignatureDeclaration);

            var callSignature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */);

            if (TypeScript.lastParameterIsRest(callSignatureAST.parameters)) {
                callSignature.hasVarArgs = true;
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    callSignature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(callSignatureDeclaration), null, callSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);

            parent.addCallSignature(callSignature);
        };

        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);

            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = indexSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    indexSignature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameter.getDeclarations()[0]);
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), null, indexSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);

            var parent = this.getParent(indexSignatureDeclaration);

            var isStatic = TypeScript.hasFlag(indexSignatureDeclaration.flags, 16 /* Static */);
            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            parent.addIndexSignature(indexSignature);
            indexSignature.setContainer(parent);
        };

        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.kind;
            var declFlags = getAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = getAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [getAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol) {
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Getter_0_already_declared, [getAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.type;
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                getterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                getterTypeSymbol.setFunctionSymbol(getterSymbol);

                getterSymbol.type = getterTypeSymbol;

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, getterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, getterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(getAccessorDeclaration), getterTypeSymbol, signature);

            var typeParameters = getAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Accessors_cannot_have_type_parameters, null));
            }

            getterTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.kind;
            var declFlags = setAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = setAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [setAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol) {
                        this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Setter_0_already_declared, [setAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;

                if (setterSymbol) {
                    setterTypeSymbol = setterSymbol.type;
                }
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                setterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                setterTypeSymbol.setFunctionSymbol(setterSymbol);

                setterSymbol.type = setterTypeSymbol;

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, setterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, setterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(setAccessorDeclaration), setterTypeSymbol, signature);

            var typeParameters = setAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                this.semanticInfo.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Accessors_cannot_have_type_parameters, null));
            }

            setterTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl) {
            if (decl.isBound()) {
                return;
            }

            decl.setIsBound(true);

            switch (decl.kind) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case 64 /* Enum */:
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case 16 /* Interface */:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case 8 /* Class */:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case 16384 /* Function */:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case 1024 /* Variable */:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case 67108864 /* EnumMember */:
                case 4096 /* Property */:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case 65536 /* Method */:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case 32768 /* ConstructorMethod */:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case 1048576 /* CallSignature */:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case 2097152 /* ConstructSignature */:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case 4194304 /* IndexSignature */:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case 262144 /* GetAccessor */:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 524288 /* SetAccessor */:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 8388608 /* ObjectType */:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case 16777216 /* FunctionType */:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case 33554432 /* ConstructorType */:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case 131072 /* FunctionExpression */:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case 256 /* TypeAlias */:
                    this.bindImportDeclaration(decl);
                    break;

                case 2048 /* Parameter */:
                case 8192 /* TypeParameter */:
                    decl.getParentDecl().getSymbol();
                    break;

                case 1073741824 /* CatchBlock */:
                case 536870912 /* WithBlock */:
                    break;

                default:
                    TypeScript.CompilerDiagnostics.assert(false, "Unrecognized type declaration");
            }
        };

        PullSymbolBinder.prototype.bindDeclsForUnit = function (filePath) {
            this.setUnit(filePath);

            var topLevelDecl = this.semanticInfo.getTopLevelDecl();
            this.bindDeclToPullSymbol(topLevelDecl);
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullHelpers) {
        function isConstructor(ast) {
            return ast.nodeType() === 13 /* FunctionDeclaration */ && ast.isConstructor;
        }
        PullHelpers.isConstructor = isConstructor;

        function isConstructMember(ast) {
            return ast.nodeType() === 13 /* FunctionDeclaration */ && ast.isConstructMember();
        }
        PullHelpers.isConstructMember = isConstructMember;

        function isIndexerMember(ast) {
            return ast.nodeType() === 13 /* FunctionDeclaration */ && ast.isIndexerMember();
        }
        PullHelpers.isIndexerMember = isIndexerMember;

        function isCallMember(ast) {
            return ast.nodeType() === 13 /* FunctionDeclaration */ && ast.isCallMember();
        }
        PullHelpers.isCallMember = isCallMember;

        function getSignatureForFuncDecl(funcDecl, semanticInfo) {
            var functionDecl = semanticInfo.getDeclForAST(funcDecl);
            var funcSymbol = functionDecl.getSymbol();

            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol();
            }

            var functionSignature = null;
            var typeSymbolWithAllSignatures = null;
            if (funcSymbol.isSignature()) {
                functionSignature = funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol().type;
            } else {
                functionSignature = functionDecl.getSignatureSymbol();
                typeSymbolWithAllSignatures = funcSymbol.type;
            }
            var signatures;

            if (isConstructor(funcDecl) || isConstructMember(funcDecl)) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            } else if (isIndexerMember(funcDecl)) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            } else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }

            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;

        function getAccessorSymbol(getterOrSetter, semanticInfoChain, unitPath) {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter, unitPath);
            var getterOrSetterSymbol = functionDecl.getSymbol();

            return getterOrSetterSymbol;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;

        function getGetterAndSetterFunction(funcDecl, semanticInfoChain, unitPath) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain, unitPath);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }

            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;

        function symbolIsEnum(source) {
            return source && (source.kind & (64 /* Enum */ | 67108864 /* EnumMember */)) !== 0;
        }
        PullHelpers.symbolIsEnum = symbolIsEnum;

        function symbolIsModule(symbol) {
            return symbol && (symbol.kind == 4 /* Container */ || isOneDeclarationOfKind(symbol, 4 /* Container */));
        }
        PullHelpers.symbolIsModule = symbolIsModule;

        function isOneDeclarationOfKind(symbol, kind) {
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (decls[i].kind === kind) {
                    return true;
                }
            }

            return false;
        }

        function isNameNumeric(name) {
            return isFinite(+name);
        }
        PullHelpers.isNameNumeric = isNameNumeric;
    })(TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
    var PullHelpers = TypeScript.PullHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(fileName, lineMap, compilationSettings) {
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.compilationSettings = compilationSettings;
            this.position = 0;
            this.previousTokenTrailingComments = null;
        }
        SyntaxTreeToAstVisitor.visit = function (syntaxTree, fileName, compilationSettings, incrementalAST) {
            var visitor = incrementalAST ? new SyntaxTreeToIncrementalAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings) : new SyntaxTreeToAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        };

        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.position += element.fullWidth();
            }
        };

        SyntaxTreeToAstVisitor.prototype.moveTo = function (element1, element2) {
            if (element2 !== null) {
                this.position += TypeScript.Syntax.childOffset(element1, element2);
            }
        };

        SyntaxTreeToAstVisitor.prototype.setCommentsAndSpan = function (ast, fullStart, node) {
            var firstToken = node.firstToken();
            var lastToken = node.lastToken();

            this.setSpan2(ast, fullStart, node, firstToken, lastToken);
            ast.setPreComments(this.convertTokenLeadingComments(firstToken, fullStart));
            ast.setPostComments(this.convertNodeTrailingComments(node, lastToken, fullStart));
        };

        SyntaxTreeToAstVisitor.prototype.copySpan = function (from, to) {
            to.minChar = from.minChar;
            to.limChar = from.limChar;
            to.trailingTriviaWidth = from.trailingTriviaWidth;
        };

        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, fullStart, element) {
            this.setSpan2(span, fullStart, element, element.firstToken(), element.lastToken());
        };

        SyntaxTreeToAstVisitor.prototype.setSpan2 = function (span, fullStart, element, firstToken, lastToken) {
            var leadingTriviaWidth = firstToken ? firstToken.leadingTriviaWidth() : 0;
            var trailingTriviaWidth = lastToken ? lastToken.trailingTriviaWidth() : 0;

            var desiredMinChar = fullStart + leadingTriviaWidth;
            var desiredLimChar = fullStart + element.fullWidth() - trailingTriviaWidth;

            this.setSpanExplicit(span, desiredMinChar, desiredLimChar);

            span.trailingTriviaWidth = trailingTriviaWidth;
        };

        SyntaxTreeToAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            span.minChar = start;
            span.limChar = end;
        };

        SyntaxTreeToAstVisitor.prototype.identifierFromToken = function (token, isOptional, stringLiteralIsTextOfIdentifier) {
            var result = null;
            if (token.fullWidth() === 0) {
                result = new TypeScript.MissingIdentifier();
            } else if (token.tokenKind === 11 /* IdentifierName */) {
                var tokenText = token.text();
                var text = tokenText === SyntaxTreeToAstVisitor.protoString ? SyntaxTreeToAstVisitor.protoSubstitutionString : null;

                result = new TypeScript.Identifier(tokenText, text);
            } else {
                var tokenText = token.text();
                var text = token.tokenKind === 14 /* StringLiteral */ ? token.value() : null;
                if (stringLiteralIsTextOfIdentifier && text) {
                    text = TypeScript.quoteStr(text);
                }
                result = new TypeScript.Identifier(tokenText, text, token.tokenKind === 13 /* NumericLiteral */);
            }

            if (isOptional) {
                result.setFlags(result.getFlags() | 4 /* OptionalName */);
            }

            var start = this.position + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (node) {
            var start = this.position;
            var array = new Array(node.childCount());

            for (var i = 0, n = node.childCount(); i < n; i++) {
                array[i] = node.childAt(i).accept(this);
            }

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var start = this.position;
            var array = new Array(list.nonSeparatorCount());

            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    array[i / 2] = list.childAt(i).accept(this);
                    this.previousTokenTrailingComments = null;
                } else {
                    var separatorToken = list.childAt(i);
                    this.previousTokenTrailingComments = this.convertTokenTrailingComments(separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                    this.movePast(separatorToken);
                }
            }

            var result = new TypeScript.ASTList(array, list.separatorCount());
            this.setSpan(result, start, list);

            result.setPostComments(this.previousTokenTrailingComments);
            this.previousTokenTrailingComments = null;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.createRef = function (text, minChar) {
            var id = new TypeScript.Identifier(text, null);
            id.minChar = minChar;
            return id;
        };

        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia.fullText(), trivia.kind() === 6 /* MultiLineCommentTrivia */, hasTrailingNewLine);

            comment.minChar = commentStartPosition;
            comment.limChar = commentStartPosition + trivia.fullWidth();

            return comment;
        };

        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList, commentStartPosition) {
            var result = [];

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }

                commentStartPosition += trivia.fullWidth();
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.mergeComments = function (comments1, comments2) {
            if (comments1 === null) {
                return comments2;
            }

            if (comments2 === null) {
                return comments1;
            }

            return comments1.concat(comments2);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenLeadingComments = function (token, commentStartPosition) {
            if (token === null) {
                return null;
            }

            var preComments = token.hasLeadingComment() ? this.convertComments(token.leadingTrivia(), commentStartPosition) : null;

            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;

            return this.mergeComments(previousTokenTrailingComments, preComments);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenTrailingComments = function (token, commentStartPosition) {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        };

        SyntaxTreeToAstVisitor.prototype.convertNodeTrailingComments = function (node, lastToken, nodeStart) {
            if (lastToken === null || !lastToken.hasTrailingComment() || lastToken.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(lastToken.trailingTrivia(), nodeStart + node.fullWidth() - lastToken.trailingTriviaWidth());
        };

        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            var fullStart = this.position;

            var result;
            if (token.tokenKind === 35 /* ThisKeyword */) {
                result = new TypeScript.ThisExpression();
            } else if (token.tokenKind === 50 /* SuperKeyword */) {
                result = new TypeScript.SuperExpression();
            } else if (token.tokenKind === 37 /* TrueKeyword */) {
                result = new TypeScript.LiteralExpression(3 /* TrueLiteral */);
            } else if (token.tokenKind === 24 /* FalseKeyword */) {
                result = new TypeScript.LiteralExpression(4 /* FalseLiteral */);
            } else if (token.tokenKind === 32 /* NullKeyword */) {
                result = new TypeScript.LiteralExpression(8 /* NullLiteral */);
            } else if (token.tokenKind === 14 /* StringLiteral */) {
                result = new TypeScript.StringLiteral(token.text(), token.valueText());
            } else if (token.tokenKind === 12 /* RegularExpressionLiteral */) {
                result = new TypeScript.RegularExpressionLiteral(token.text());
            } else if (token.tokenKind === 13 /* NumericLiteral */) {
                var preComments = this.convertTokenLeadingComments(token, fullStart);

                var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                result = new TypeScript.NumericLiteral(value, token.text());

                result.setPreComments(preComments);
            } else {
                result = this.identifierFromToken(token, false);
            }

            this.movePast(token);

            var start = fullStart + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getLeadingComments = function (node) {
            var firstToken = node.firstToken();
            var result = [];

            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();

                for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);

                    if (trivia.isComment()) {
                        result.push(trivia);
                    }
                }
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.hasTopLevelImportOrExport = function (node) {
            var firstToken;

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);

                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.tokenKind === 47 /* ExportKeyword */) {
                    return true;
                }

                if (moduleElement.kind() === 133 /* ImportDeclaration */) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                        return true;
                    }
                }
            }

            var leadingComments = this.getLeadingComments(node);
            for (var i = 0, n = leadingComments.length; i < n; i++) {
                var trivia = leadingComments[i];

                if (TypeScript.getImplicitImport(trivia.fullText())) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };

        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            var start = this.position;

            var bod = this.visitSyntaxList(node.moduleElements);

            var isExternalModule = false;
            var amdDependencies = [];
            var moduleFlags = 0 /* None */;
            if (this.hasTopLevelImportOrExport(node)) {
                isExternalModule = true;

                var correctedFileName = TypeScript.switchToForwardSlashes(this.fileName);
                var id = new TypeScript.Identifier(correctedFileName, correctedFileName);
                var topLevelMod = new TypeScript.ModuleDeclaration(id, bod, null);
                this.setSpanExplicit(topLevelMod, start, this.position);

                moduleFlags = 256 /* IsExternalModule */ | 1 /* Exported */;
                if (TypeScript.isDTSFile(this.fileName)) {
                    moduleFlags |= 8 /* Ambient */;
                }

                topLevelMod.setModuleFlags(moduleFlags);

                var leadingComments = this.getLeadingComments(node);
                for (var i = 0, n = leadingComments.length; i < n; i++) {
                    var trivia = leadingComments[i];
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        amdDependencies.push(amdDependency);
                    }
                }

                bod = new TypeScript.ASTList([topLevelMod]);
                this.setSpanExplicit(bod, start, this.position);
            }

            var result = new TypeScript.Script(bod, isExternalModule, TypeScript.isDTSFile(this.fileName), amdDependencies);
            this.setSpanExplicit(result, start, start + node.fullWidth());

            result.setModuleFlags(moduleFlags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            this.moveTo(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return node.moduleName.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = null;
            var implementsList = null;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    extendsList = heritageClause.accept(this);
                } else {
                    implementsList = heritageClause.accept(this);
                }
            }

            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.ClassDeclaration(name, typeParameters, extendsList, implementsList, members, closeBraceSpan);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getVarFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                flags = flags | 8 /* Ambient */;
            }

            result.setVarFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);

            var extendsList = null;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                var heritageClause = node.heritageClauses.childAt(i);
                if (i === 0) {
                    extendsList = heritageClause.accept(this);
                } else {
                    this.movePast(heritageClause);
                }
            }

            this.movePast(node.body.openBraceToken);
            var members = this.visitSeparatedSyntaxList(node.body.typeMembers);

            this.movePast(node.body.closeBraceToken);

            var result = new TypeScript.InterfaceDeclaration(name, typeParameters, members, extendsList);
            this.setCommentsAndSpan(result, start, node);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 1 /* Exported */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitHeritageClause = function (node) {
            var start = this.position;
            var array = new Array(node.typeNames.nonSeparatorCount());

            this.movePast(node.extendsOrImplementsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeNames.childAt(i));
                } else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    array[i / 2] = type;
                }
            }

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNames = function (node) {
            var result = [];

            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, false, true));
                this.movePast(node.stringLiteral);
            } else {
                this.getModuleNamesHelper(node.moduleName, result);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNamesHelper = function (name, result) {
            if (name.kind() === 121 /* QualifiedName */) {
                var qualifiedName = name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, false));
                this.movePast(qualifiedName.right);
            } else {
                result.push(this.identifierFromToken(name, false));
                this.movePast(name);
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var start = this.position;

            var firstToken = node.firstToken();
            var preComments = this.convertTokenLeadingComments(firstToken, start);
            var postComments = this.convertNodeTrailingComments(node, node.closeBraceToken, start);

            this.moveTo(node, node.moduleKeyword);
            this.movePast(node.moduleKeyword);
            var names = this.getModuleNames(node);
            this.movePast(node.openBraceToken);

            var members = this.visitSyntaxList(node.moduleElements);

            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            for (var i = names.length - 1; i >= 0; i--) {
                var innerName = names[i];

                var result = new TypeScript.ModuleDeclaration(innerName, members, closeBraceSpan);
                this.setSpan(result, start, node);

                result.setPreComments(preComments);
                result.setPostComments(postComments);

                preComments = null;
                postComments = null;

                if (i || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                    result.setModuleFlags(result.getModuleFlags() | 1 /* Exported */);
                }

                members = new TypeScript.ASTList([result]);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                result.setModuleFlags(result.getModuleFlags() | 8 /* Ambient */);
            }

            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.hasDotDotDotParameter = function (parameters) {
            for (var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if (parameters.nonSeparatorAt(i).dotDotDotToken) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);

            this.movePast(node.identifier);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);

            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(name, false, typeParameters, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);

            if (node.semicolonToken) {
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            var flags = result.getFunctionFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                flags = flags | 8 /* Ambient */;
            }

            result.setFunctionFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);

            this.movePast(node.openBraceToken);
            var array = new Array(node.enumElements.nonSeparatorCount());

            var declarators = [];

            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.enumElements.childAt(i));
                } else {
                    var enumElement = node.enumElements.childAt(i);
                    var enumElementFullStart = this.position;
                    var memberStart = this.position + enumElement.leadingTriviaWidth();

                    var memberName = this.identifierFromToken(enumElement.propertyName, false);
                    this.movePast(enumElement.propertyName);

                    var init = enumElement.equalsValueClause !== null ? enumElement.equalsValueClause.accept(this) : null;

                    var typeReference = new TypeScript.TypeReference(this.createRef(name.actualText, -1), 0);
                    typeReference.minChar = name.minChar;
                    typeReference.limChar = name.limChar;

                    var declarator = new TypeScript.VariableDeclarator(memberName, typeReference, init);
                    declarator.constantValue = this.determineConstantValue(enumElement.equalsValueClause, declarators);

                    declarator.setVarFlags(declarator.getVarFlags() | 256 /* Property */);
                    this.setSpanExplicit(declarator, memberStart, this.position);
                    declarator.setPreComments(this.convertTokenLeadingComments(enumElement.firstToken(), enumElementFullStart));
                    declarator.setPostComments(this.convertNodeTrailingComments(enumElement, enumElement.lastToken(), enumElementFullStart));

                    declarators.push(declarator);

                    var declaration = new TypeScript.VariableDeclaration(new TypeScript.ASTList([declarator]));
                    this.setSpanExplicit(declaration, memberStart, this.position);

                    var statement = new TypeScript.VariableStatement(declaration);
                    statement.setFlags(16 /* EnumElement */);
                    this.setSpanExplicit(statement, memberStart, this.position);

                    array[i / 2] = statement;

                    declarator.setVarFlags(declarator.getVarFlags() | 1 /* Exported */);
                }
            }

            var members = new TypeScript.ASTList(array);

            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.ModuleDeclaration(name, members, closeBraceSpan);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getModuleFlags() | 128 /* IsEnum */;

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            result.setModuleFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.determineConstantValue = function (equalsValue, declarators) {
            var value = equalsValue === null ? null : equalsValue.value;
            if (value === null) {
                if (declarators.length === 0) {
                    return 0;
                } else {
                    var lastConstantValue = TypeScript.ArrayUtilities.last(declarators).constantValue;
                    return lastConstantValue !== null ? lastConstantValue + 1 : null;
                }
            } else {
                return this.computeConstantValue(value, declarators);
            }
        };

        SyntaxTreeToAstVisitor.prototype.computeConstantValue = function (expression, declarators) {
            if (TypeScript.Syntax.isIntegerLiteral(expression)) {
                var token;
                switch (expression.kind()) {
                    case 164 /* PlusExpression */:
                    case 165 /* NegateExpression */:
                        token = expression.operand;
                        break;
                    default:
                        token = expression;
                }

                var value = token.value();
                return value && expression.kind() === 165 /* NegateExpression */ ? -value : value;
            } else if (this.compilationSettings.propagateEnumConstants) {
                switch (expression.kind()) {
                    case 11 /* IdentifierName */:
                        var variableDeclarator = TypeScript.ArrayUtilities.firstOrDefault(declarators, function (d) {
                            return d.id.text() === expression.valueText();
                        });
                        return variableDeclarator ? variableDeclarator.constantValue : null;

                    case 202 /* LeftShiftExpression */:
                        var binaryExpression = expression;
                        return this.computeConstantValue(binaryExpression.left, declarators) << this.computeConstantValue(binaryExpression.right, declarators);
                }

                return null;
            } else {
                return null;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumElement = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ImportDeclaration(name, alias);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getVarFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }
            result.setVarFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExportAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ExportAssignment(name);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            var start = this.position;

            var preComments = null;
            if (node.modifiers.childCount() > 0) {
                preComments = this.convertTokenLeadingComments(node.modifiers.firstToken(), start);
            }

            this.moveTo(node, node.variableDeclaration);

            var declaration = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);

            for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                var varDecl = declaration.declarators.members[i];

                if (i === 0) {
                    varDecl.setPreComments(this.mergeComments(preComments, varDecl.preComments()));
                }

                var flags = varDecl.getVarFlags();
                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                    flags = flags | 1 /* Exported */;
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    flags = flags | 8 /* Ambient */;
                }

                varDecl.setVarFlags(flags);
            }

            var result = new TypeScript.VariableStatement(declaration);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            var start = this.position;

            var firstToken = node.firstToken();
            var preComments = this.convertTokenLeadingComments(firstToken, start);
            var postComments = this.convertNodeTrailingComments(node, node.lastToken(), start);

            this.moveTo(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);

            for (var i = 0; i < variableDecls.members.length; i++) {
                if (i === 0) {
                    variableDecls.members[i].setPreComments(preComments);
                    variableDecls.members[i].setPostComments(postComments);
                }
            }

            var result = new TypeScript.VariableDeclaration(variableDecls);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new TypeScript.VariableDeclarator(name, typeExpr, init);
            this.setSpan(result, start, node);

            if (init) {
                if (init.nodeType() === 13 /* FunctionDeclaration */) {
                    var funcDecl = init;
                    funcDecl.hint = name.actualText;
                } else if (init.nodeType() === 82 /* ArrowFunctionExpression */) {
                    var arrowFunction = init;
                    arrowFunction.hint = name.actualText;
                }
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            var afterEqualsComments = this.convertTokenTrailingComments(node.equalsToken, this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());

            this.movePast(node.equalsToken);
            var result = node.value.accept(this);
            result.setPreComments(this.mergeComments(afterEqualsComments, result.preComments()));

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getUnaryExpressionNodeType = function (kind) {
            switch (kind) {
                case 164 /* PlusExpression */:
                    return 28 /* PlusExpression */;
                case 165 /* NegateExpression */:
                    return 29 /* NegateExpression */;
                case 166 /* BitwiseNotExpression */:
                    return 74 /* BitwiseNotExpression */;
                case 167 /* LogicalNotExpression */:
                    return 75 /* LogicalNotExpression */;
                case 168 /* PreIncrementExpression */:
                    return 76 /* PreIncrementExpression */;
                case 169 /* PreDecrementExpression */:
                    return 77 /* PreDecrementExpression */;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var start = this.position;

            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);

            var result = new TypeScript.UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.isOnSingleLine = function (start, end) {
            return this.lineMap.getLineNumberFromPosition(start) === this.lineMap.getLineNumberFromPosition(end);
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var start = this.position;
            var openStart = this.position + node.openBracketToken.leadingTriviaWidth();
            this.movePast(node.openBracketToken);

            var expressions = this.visitSeparatedSyntaxList(node.expressions);

            var closeStart = this.position + node.closeBracketToken.leadingTriviaWidth();
            this.movePast(node.closeBracketToken);

            var result = new TypeScript.UnaryExpression(23 /* ArrayLiteralExpression */, expressions);
            this.setSpan(result, start, node);

            if (this.isOnSingleLine(openStart, closeStart)) {
                result.setFlags(result.getFlags() | 2 /* SingleLine */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            var start = this.position;

            var result = new TypeScript.OmittedExpression();
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var start = this.position;

            var openParenToken = node.openParenToken;
            var openParenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());

            this.movePast(openParenToken);

            var expr = node.expression.accept(this);
            this.movePast(node.closeParenToken);

            var result = new TypeScript.ParenthesizedExpression(expr);
            this.setSpan(result, start, node);

            result.openParenTrailingComments = openParenTrailingComments;
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getArrowFunctionStatements = function (body) {
            if (body.kind() === 146 /* Block */) {
                return body.accept(this);
            } else {
                var expression = body.accept(this);
                var returnStatement = new TypeScript.ReturnStatement(expression);

                var preComments = expression.preComments();
                if (preComments) {
                    body._ast = undefined;
                    returnStatement.setPreComments(preComments);
                    expression.setPreComments(null);
                }

                var statements = new TypeScript.ASTList([returnStatement]);

                var block = new TypeScript.Block(statements, new TypeScript.ASTSpan());
                return block;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsGreaterThanToken);

            var parameter = new TypeScript.Parameter(identifier, null, null, false, false);
            this.setSpanExplicit(parameter, identifier.minChar, identifier.limChar);

            var parameters = new TypeScript.ASTList([parameter]);

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new TypeScript.ArrowFunctionExpression(null, parameters, null, statements);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var start = this.position;

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.movePast(node.equalsGreaterThanToken);

            var block = this.getArrowFunctionStatements(node.body);

            var result = new TypeScript.ArrowFunctionExpression(typeParameters, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            var result;
            if (type.isToken()) {
                var start = this.position;
                result = new TypeScript.TypeReference(type.accept(this), 0);
                this.setSpan(result, start, type);
            } else {
                result = type.accept(this);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeQuery = function (node) {
            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var name = node.name.accept(this);

            var typeQuery = new TypeScript.TypeQuery(name);
            this.setSpan(typeQuery, start, node);

            var result = new TypeScript.TypeReference(typeQuery, 0);
            this.copySpan(typeQuery, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            var start = this.position;
            var left = this.visitType(node.left).term;
            this.movePast(node.dotToken);
            var right = this.identifierFromToken(node.right, false);
            this.movePast(node.right);

            var term = new TypeScript.BinaryExpression(34 /* MemberAccessExpression */, left, right);
            this.setSpan(term, start, node);

            var result = new TypeScript.TypeReference(term, 0);
            this.copySpan(term, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            var array = new Array(node.typeArguments.nonSeparatorCount());

            this.movePast(node.lessThanToken);

            var start = this.position;

            for (var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeArguments.childAt(i));
                } else {
                    array[i / 2] = this.visitType(node.typeArguments.childAt(i));
                }
            }
            this.movePast(node.greaterThanToken);

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node.typeArguments);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(null, false, typeParameters, parameters, returnType, null);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 128 /* Signature */ | 1024 /* ConstructMember */);

            funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);
            funcDecl.hint = "_construct";

            var result = new TypeScript.TypeReference(funcDecl, 0);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(null, false, typeParameters, parameters, returnType, null);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFlags(funcDecl.getFunctionFlags() | 128 /* Signature */);
            funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(funcDecl, 0);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            var start = this.position;

            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
            this.movePast(node.closeBraceToken);

            var objectType = new TypeScript.ObjectType(typeMembers);
            this.setSpan(objectType, start, node);

            objectType.setFlags(objectType.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(objectType, 0);
            this.copySpan(objectType, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            var start = this.position;

            var result;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);

            if (underlying.nodeType() === 11 /* TypeRef */) {
                result = underlying;
                result.arrayCount++;
            } else {
                result = new TypeScript.TypeReference(underlying, 1);
            }

            result.setFlags(result.getFlags() | 8 /* TypeReference */);

            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            var start = this.position;

            var underlying = this.visitType(node.name).term;
            var typeArguments = node.typeArgumentList.accept(this);

            var genericType = new TypeScript.GenericType(underlying, typeArguments);
            this.setSpan(genericType, start, node);

            genericType.setFlags(genericType.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(genericType, 0);
            this.copySpan(genericType, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            this.movePast(node.colonToken);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            var start = this.position;

            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            var closeBracePosition = this.position;

            var closeBraceLeadingComments = this.convertTokenLeadingComments(node.closeBraceToken, this.position);
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.Block(statements, closeBraceSpan);
            this.setSpan(result, start, node);

            result.closeBraceLeadingComments = closeBraceLeadingComments;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var identifier = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new TypeScript.Parameter(identifier, typeExpr, init, !!node.questionToken, node.dotDotDotToken !== null);
            this.setCommentsAndSpan(result, start, node);

            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.tokenKind === 57 /* PublicKeyword */) {
                    result.setVarFlags(result.getVarFlags() | 256 /* Property */ | 4 /* Public */);
                } else {
                    result.setVarFlags(result.getVarFlags() | 256 /* Property */ | 2 /* Private */);
                }
            }

            if (node.equalsValueClause || node.dotDotDotToken) {
                result.setFlags(result.getFlags() | 4 /* OptionalName */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.identifierFromToken(node.name, false);
            this.movePast(node.name);

            var result = new TypeScript.BinaryExpression(34 /* MemberAccessExpression */, expression, name);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var start = this.position;

            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);

            var result = new TypeScript.UnaryExpression(node.kind() === 210 /* PostIncrementExpression */ ? 78 /* PostIncrementExpression */ : 79 /* PostDecrementExpression */, operand);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);

            var result = new TypeScript.BinaryExpression(37 /* ElementAccessExpression */, expression, argumentExpression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.convertArgumentListArguments = function (node) {
            if (node === null) {
                return null;
            }

            var start = this.position;

            this.movePast(node.openParenToken);

            var result = this.visitSeparatedSyntaxList(node.arguments);

            if (node.arguments.fullWidth() === 0 && node.closeParenToken.fullWidth() === 0) {
                var openParenTokenEnd = start + node.openParenToken.leadingTriviaWidth() + node.openParenToken.width();
                this.setSpanExplicit(result, openParenTokenEnd, openParenTokenEnd + node.openParenToken.trailingTriviaWidth());
            }

            var closeParenPos = this.position;
            this.movePast(node.closeParenToken);
            var closeParenSpan = new TypeScript.ASTSpan();
            this.setSpan(closeParenSpan, closeParenPos, node.closeParenToken);

            return {
                argumentList: result,
                closeParenSpan: closeParenSpan
            };
        };

        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            var typeArguments = node.argumentList.typeArgumentList !== null ? node.argumentList.typeArgumentList.accept(this) : null;
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new TypeScript.InvocationExpression(expression, typeArguments, argumentList ? argumentList.argumentList : null, argumentList ? argumentList.closeParenSpan : null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.getBinaryExpressionNodeType = function (node) {
            switch (node.kind()) {
                case 173 /* CommaExpression */:
                    return 27 /* CommaExpression */;
                case 174 /* AssignmentExpression */:
                    return 40 /* AssignmentExpression */;
                case 175 /* AddAssignmentExpression */:
                    return 41 /* AddAssignmentExpression */;
                case 176 /* SubtractAssignmentExpression */:
                    return 42 /* SubtractAssignmentExpression */;
                case 177 /* MultiplyAssignmentExpression */:
                    return 44 /* MultiplyAssignmentExpression */;
                case 178 /* DivideAssignmentExpression */:
                    return 43 /* DivideAssignmentExpression */;
                case 179 /* ModuloAssignmentExpression */:
                    return 45 /* ModuloAssignmentExpression */;
                case 180 /* AndAssignmentExpression */:
                    return 46 /* AndAssignmentExpression */;
                case 181 /* ExclusiveOrAssignmentExpression */:
                    return 47 /* ExclusiveOrAssignmentExpression */;
                case 182 /* OrAssignmentExpression */:
                    return 48 /* OrAssignmentExpression */;
                case 183 /* LeftShiftAssignmentExpression */:
                    return 49 /* LeftShiftAssignmentExpression */;
                case 184 /* SignedRightShiftAssignmentExpression */:
                    return 50 /* SignedRightShiftAssignmentExpression */;
                case 185 /* UnsignedRightShiftAssignmentExpression */:
                    return 51 /* UnsignedRightShiftAssignmentExpression */;
                case 187 /* LogicalOrExpression */:
                    return 53 /* LogicalOrExpression */;
                case 188 /* LogicalAndExpression */:
                    return 54 /* LogicalAndExpression */;
                case 189 /* BitwiseOrExpression */:
                    return 55 /* BitwiseOrExpression */;
                case 190 /* BitwiseExclusiveOrExpression */:
                    return 56 /* BitwiseExclusiveOrExpression */;
                case 191 /* BitwiseAndExpression */:
                    return 57 /* BitwiseAndExpression */;
                case 192 /* EqualsWithTypeConversionExpression */:
                    return 58 /* EqualsWithTypeConversionExpression */;
                case 193 /* NotEqualsWithTypeConversionExpression */:
                    return 59 /* NotEqualsWithTypeConversionExpression */;
                case 194 /* EqualsExpression */:
                    return 60 /* EqualsExpression */;
                case 195 /* NotEqualsExpression */:
                    return 61 /* NotEqualsExpression */;
                case 196 /* LessThanExpression */:
                    return 62 /* LessThanExpression */;
                case 197 /* GreaterThanExpression */:
                    return 64 /* GreaterThanExpression */;
                case 198 /* LessThanOrEqualExpression */:
                    return 63 /* LessThanOrEqualExpression */;
                case 199 /* GreaterThanOrEqualExpression */:
                    return 65 /* GreaterThanOrEqualExpression */;
                case 200 /* InstanceOfExpression */:
                    return 35 /* InstanceOfExpression */;
                case 201 /* InExpression */:
                    return 33 /* InExpression */;
                case 202 /* LeftShiftExpression */:
                    return 71 /* LeftShiftExpression */;
                case 203 /* SignedRightShiftExpression */:
                    return 72 /* SignedRightShiftExpression */;
                case 204 /* UnsignedRightShiftExpression */:
                    return 73 /* UnsignedRightShiftExpression */;
                case 205 /* MultiplyExpression */:
                    return 68 /* MultiplyExpression */;
                case 206 /* DivideExpression */:
                    return 69 /* DivideExpression */;
                case 207 /* ModuloExpression */:
                    return 70 /* ModuloExpression */;
                case 208 /* AddExpression */:
                    return 66 /* AddExpression */;
                case 209 /* SubtractExpression */:
                    return 67 /* SubtractExpression */;
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            var start = this.position;

            var nodeType = this.getBinaryExpressionNodeType(node);
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);

            var result = new TypeScript.BinaryExpression(nodeType, left, right);
            this.setSpan(result, start, node);

            if (right.nodeType() === 13 /* FunctionDeclaration */ || right.nodeType() === 82 /* ArrowFunctionExpression */) {
                var id = left.nodeType() === 34 /* MemberAccessExpression */ ? left.operand2 : left;
                var idHint = id.nodeType() === 22 /* Name */ ? id.actualText : null;

                var funcDecl = right;
                funcDecl.hint = idHint;
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            var start = this.position;

            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this);

            var result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(null, false, typeParameters, parameters, returnType, null);
            this.setCommentsAndSpan(result, start, node);

            result.hint = "_construct";
            result.setFunctionFlags(result.getFunctionFlags() | 1024 /* ConstructMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMethodSignature = function (node) {
            var start = this.position;

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);

            var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(name, false, typeParameters, parameters, returnType, null);
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            var start = this.position;

            this.movePast(node.openBracketToken);

            var parameter = node.parameter.accept(this);

            this.movePast(node.closeBracketToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var name = new TypeScript.Identifier("__item", "__item");
            this.setSpanExplicit(name, start, start);

            var parameters = new TypeScript.ASTList([parameter]);

            var result = new TypeScript.FunctionDeclaration(name, false, null, parameters, returnType, null);
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 4096 /* IndexerMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            var start = this.position;

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new TypeScript.VariableDeclarator(name, typeExpr, null);
            this.setCommentsAndSpan(result, start, node);

            result.setVarFlags(result.getVarFlags() | 256 /* Property */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            var start = this.position;

            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            var start = this.position;

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(null, false, typeParameters, parameters, returnType, null);
            this.setCommentsAndSpan(result, start, node);

            result.hint = "_call";
            result.setFunctionFlags(result.getFunctionFlags() | 512 /* CallMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;

            var result = new TypeScript.TypeParameter(identifier, constraint);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;

            var result = new TypeScript.IfStatement(condition, thenBod, elseBod);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ExpressionStatement(expression);
            this.setCommentsAndSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.parameterList);
            var parameters = node.parameterList.accept(this);

            var block = node.block ? node.block.accept(this) : null;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(null, true, null, parameters, null, block);
            this.setCommentsAndSpan(result, start, node);

            if (node.semicolonToken) {
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitIndexMemberDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.indexSignature);
            var result = node.indexSignature.accept(this);
            this.setCommentsAndSpan(result, start, node);

            this.movePast(node.semicolonToken);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                result.setFunctionFlags(result.getFunctionFlags() | 16 /* Static */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);

            this.movePast(node.propertyName);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(name, false, typeParameters, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getFunctionFlags();
            if (node.semicolonToken) {
                flags = flags | 128 /* Signature */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                flags = flags | 2 /* Private */;
            } else {
                flags = flags | 4 /* Public */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                flags = flags | 16 /* Static */;
            }

            flags = flags | 256 /* Method */ | 32768 /* IsClassMethod */;
            result.setFunctionFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            var parameters = node.parameterList.accept(this);
            var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;
            var result = new TypeScript.FunctionDeclaration(name, false, null, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                result.setFunctionFlags(result.getFunctionFlags() | 2 /* Private */);
            } else {
                result.setFunctionFlags(result.getFunctionFlags() | 4 /* Public */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                result.setFunctionFlags(result.getFunctionFlags() | 16 /* Static */);
            }

            result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);

            result.setFunctionFlags(result.getFunctionFlags() | 32 /* GetAccessor */);
            result.hint = "get" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            var result = this.visitMemberAccessorDeclaration(node, null);

            result.setFunctionFlags(result.getFunctionFlags() | 64 /* SetAccessor */);
            result.hint = "set" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.variableDeclarator);
            this.moveTo(node.variableDeclarator, node.variableDeclarator.identifier);

            var name = this.identifierFromToken(node.variableDeclarator.identifier, false);
            this.movePast(node.variableDeclarator.identifier);
            var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
            var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.VariableDeclarator(name, typeExpr, init);
            this.setCommentsAndSpan(result, start, node);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 16 /* Static */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 2 /* Private */);
            } else {
                result.setVarFlags(result.getVarFlags() | 4 /* Public */);
            }

            result.setVarFlags(result.getVarFlags() | 2048 /* ClassProperty */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            var start = this.position;

            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ThrowStatement(expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            var start = this.position;

            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ReturnStatement(expression);
            this.setCommentsAndSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new TypeScript.ObjectCreationExpression(expression, typeArgumentList, argumentList ? argumentList.argumentList : null, argumentList ? argumentList.closeParenSpan : null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            var start = this.position;

            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var closeParenPosition = this.position;
            this.movePast(node.openBraceToken);

            var array = new Array(node.switchClauses.childCount());
            var defaultCase = null;

            for (var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                var switchClause = node.switchClauses.childAt(i);
                var translated = switchClause.accept(this);

                if (switchClause.kind() === 233 /* DefaultSwitchClause */) {
                    defaultCase = translated;
                }

                array[i] = translated;
            }

            var span = new TypeScript.ASTSpan();
            span.minChar = start;
            span.limChar = closeParenPosition;

            this.movePast(node.closeBraceToken);

            var result = new TypeScript.SwitchStatement(expression, new TypeScript.ASTList(array), defaultCase, span);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var start = this.position;

            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new TypeScript.CaseClause(expression, statements);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var start = this.position;

            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new TypeScript.CaseClause(null, statements);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            var start = this.position;

            this.movePast(node.breakKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);
            var identifier = node.identifier ? node.identifier.valueText() : null;

            var result = new TypeScript.Jump(85 /* BreakStatement */, identifier);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            var start = this.position;

            this.movePast(node.continueKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.Jump(86 /* ContinueStatement */, node.identifier ? node.identifier.valueText() : null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            var start = this.position;

            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.initializer ? node.initializer.accept(this) : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new TypeScript.ForStatement(init, cond, incr, body);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            var start = this.position;

            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
            if (node.variableDeclaration) {
                var variableDeclaration = init;
                for (var i = 0, n = variableDeclaration.declarators.members.length; i < n; i++) {
                    var boundDecl = variableDeclaration.declarators.members[i];
                    boundDecl.setVarFlags(boundDecl.getVarFlags() | 16384 /* ForInVariable */);
                }
            }

            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new TypeScript.ForInStatement(init, expression, body);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.WhileStatement(condition, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.WithStatement(condition, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            var start = this.position;

            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);

            var result = new TypeScript.CastExpression(castTerm, expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var start = this.position;

            var openStart = this.position + node.openBraceToken.leadingTriviaWidth();
            this.movePast(node.openBraceToken);

            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);

            var closeStart = this.position + node.closeBraceToken.leadingTriviaWidth();
            this.movePast(node.closeBraceToken);

            var result = new TypeScript.UnaryExpression(24 /* ObjectLiteralExpression */, propertyAssignments);
            this.setCommentsAndSpan(result, start, node);

            if (this.isOnSingleLine(openStart, closeStart)) {
                result.setFlags(result.getFlags() | 2 /* SingleLine */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var start = this.position;

            var left = node.propertyName.accept(this);

            var afterColonComments = this.convertTokenTrailingComments(node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());

            this.movePast(node.colonToken);
            var right = node.expression.accept(this);
            right.setPreComments(this.mergeComments(afterColonComments, right.preComments()));

            var result = new TypeScript.BinaryExpression(83 /* Member */, left, right);
            this.setCommentsAndSpan(result, start, node);

            if (right.nodeType() === 13 /* FunctionDeclaration */ || right.nodeType() === 82 /* ArrowFunctionExpression */) {
                var funcDecl = right;
                funcDecl.hint = left.text();
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var start = this.position;

            var left = node.propertyName.accept(this);
            var functionDeclaration = node.callSignature.accept(this);
            var block = node.block.accept(this);

            functionDeclaration.hint = left.text();
            functionDeclaration.block = block;
            functionDeclaration.setFunctionFlags(16384 /* IsFunctionProperty */);

            var result = new TypeScript.BinaryExpression(83 /* Member */, left, functionDeclaration);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            var functionName = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            this.movePast(node.closeParenToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(functionName, false, null, new TypeScript.ASTList([]), returnType, block);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 32 /* GetAccessor */ | 8192 /* IsFunctionExpression */);
            funcDecl.hint = "get" + node.propertyName.valueText();

            var result = new TypeScript.BinaryExpression(83 /* Member */, name, funcDecl);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            var functionName = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeParenToken);

            var parameters = new TypeScript.ASTList([parameter]);

            var block = node.block ? node.block.accept(this) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(functionName, false, null, parameters, null, block);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 64 /* SetAccessor */ | 8192 /* IsFunctionExpression */);
            funcDecl.hint = "set" + node.propertyName.valueText();

            var result = new TypeScript.BinaryExpression(83 /* Member */, name, funcDecl);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            var start = this.position;

            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(name, false, typeParameters, parameters, returnType, block);
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            var start = this.position;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.EmptyStatement();
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            var start = this.position;

            this.movePast(node.tryKeyword);
            var tryBody = node.block.accept(this);

            var catchClause = null;
            if (node.catchClause !== null) {
                catchClause = node.catchClause.accept(this);
            }

            var finallyBody = null;
            if (node.finallyClause !== null) {
                finallyBody = node.finallyClause.accept(this);
            }

            var result = new TypeScript.TryStatement(tryBody, catchClause, finallyBody);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            var start = this.position;

            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);

            var varDecl = new TypeScript.VariableDeclarator(identifier, typeExpr, null);
            this.setSpanExplicit(varDecl, identifier.minChar, identifier.limChar);

            var result = new TypeScript.CatchClause(varDecl, block);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            this.movePast(node.finallyKeyword);
            return node.block.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.LabeledStatement(identifier, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            var start = this.position;

            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileSpan = new TypeScript.ASTSpan();
            this.setSpan(whileSpan, this.position, node.whileKeyword);

            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.DoStatement(statement, condition, whileSpan);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var start = this.position;

            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(36 /* TypeOfExpression */, expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            var start = this.position;

            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(30 /* DeleteExpression */, expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            var start = this.position;

            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(26 /* VoidExpression */, expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var start = this.position;

            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.DebuggerStatement();
            this.setSpan(result, start, node);

            return result;
        };
        SyntaxTreeToAstVisitor.protoString = "__proto__";
        SyntaxTreeToAstVisitor.protoSubstitutionString = "#__proto__";
        return SyntaxTreeToAstVisitor;
    })();
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;

    function applyDelta(ast, delta) {
        if (ast) {
            if (ast.minChar !== -1) {
                ast.minChar += delta;
            }

            if (ast.limChar !== -1) {
                ast.limChar += delta;
            }
        }
    }

    function applyDeltaToComments(comments, delta) {
        if (comments && comments.length > 0) {
            for (var i = 0; i < comments.length; i++) {
                var comment = comments[i];
                applyDelta(comment, delta);
            }
        }
    }

    var SyntaxTreeToIncrementalAstVisitor = (function (_super) {
        __extends(SyntaxTreeToIncrementalAstVisitor, _super);
        function SyntaxTreeToIncrementalAstVisitor() {
            _super.apply(this, arguments);
        }
        SyntaxTreeToIncrementalAstVisitor.prototype.applyDelta = function (ast, delta) {
            if (delta === 0) {
                return;
            }

            var pre = function (cur, walker) {
                applyDelta(cur, delta);
                applyDeltaToComments(cur.preComments(), delta);
                applyDeltaToComments(cur.postComments(), delta);

                switch (cur.nodeType()) {
                    case 84 /* Block */:
                        applyDelta(cur.closeBraceSpan, delta);
                        break;

                    case 39 /* ObjectCreationExpression */:
                        applyDelta(cur.closeParenSpan, delta);
                        break;

                    case 38 /* InvocationExpression */:
                        applyDelta(cur.closeParenSpan, delta);
                        break;

                    case 17 /* ModuleDeclaration */:
                        applyDelta(cur.endingToken, delta);
                        break;

                    case 14 /* ClassDeclaration */:
                        applyDelta(cur.endingToken, delta);
                        break;

                    case 88 /* DoStatement */:
                        applyDelta(cur.whileSpan, delta);
                        break;

                    case 97 /* SwitchStatement */:
                        applyDelta(cur.statement, delta);
                        break;
                }
            };

            TypeScript.getAstWalkerFactory().walk(ast, pre);
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            if (span.minChar !== -1) {
                var delta = start - span.minChar;
                this.applyDelta(span, delta);

                span.limChar = end;
            } else {
                _super.prototype.setSpanExplicit.call(this, span, start, end);
            }
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.getAndMovePastAST = function (element) {
            if (this.previousTokenTrailingComments !== null) {
                return null;
            }

            var result = element._ast;
            if (!result) {
                return null;
            }

            var start = this.position;
            this.movePast(element);
            this.setSpan(result, start, element);
            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.setAST = function (element, ast) {
            element._ast = ast;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSyntaxList.call(this, list);

                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSeparatedSyntaxList.call(this, list);

                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitToken = function (token) {
            var result = this.getAndMovePastAST(token);

            if (!result) {
                result = _super.prototype.visitToken.call(this, token);
                this.setAST(token, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitClassDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitClassDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitInterfaceDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitHeritageClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitHeritageClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitModuleDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitImportDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitImportDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitExportAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExportAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPrefixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayLiteralExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitOmittedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitOmittedExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimpleArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitQualifiedName = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                var result = _super.prototype.visitQualifiedName.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectType = function (node) {
            var start = this.position;
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitGenericType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGenericType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBlock = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBlock.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParameter.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberAccessExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPostfixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitElementAccessExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitInvocationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitInvocationExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBinaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBinaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConditionalExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConditionalExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMethodSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMethodSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitIndexSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIndexSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPropertySignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPropertySignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCallSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCallSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeParameter.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitIfStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIfStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitExpressionStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExpressionStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberAccessorDeclaration.call(this, node, typeAnnotation);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberVariableDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitThrowStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitThrowStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitReturnStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitReturnStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectCreationExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSwitchStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSwitchStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCaseSwitchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDefaultSwitchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBreakStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBreakStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitContinueStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitContinueStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitForStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitForInStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForInStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitWhileStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWhileStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitWithStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWithStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCastExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCastExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectLiteralExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimplePropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGetAccessorPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSetAccessorPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitEmptyStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitEmptyStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTryStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTryStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCatchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCatchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitLabeledStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitLabeledStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDoStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDoStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeOfExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDeleteExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDeleteExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitVoidExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitVoidExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDebuggerStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };
        return SyntaxTreeToIncrementalAstVisitor;
    })(SyntaxTreeToAstVisitor);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.fileResolutionTime = 0;
    TypeScript.sourceCharactersCompiled = 0;
    TypeScript.syntaxTreeParseTime = 0;
    TypeScript.syntaxDiagnosticsTime = 0;
    TypeScript.astTranslationTime = 0;
    TypeScript.typeCheckTime = 0;

    TypeScript.emitTime = 0;
    TypeScript.emitWriteFileTime = 0;
    TypeScript.emitDirectoryExistsTime = 0;
    TypeScript.emitFileExistsTime = 0;
    TypeScript.emitResolvePathTime = 0;

    TypeScript.declarationEmitTime = 0;
    TypeScript.declarationEmitIsExternallyVisibleTime = 0;
    TypeScript.declarationEmitTypeSignatureTime = 0;
    TypeScript.declarationEmitGetBoundDeclTypeTime = 0;
    TypeScript.declarationEmitIsOverloadedCallSignatureTime = 0;
    TypeScript.declarationEmitFunctionDeclarationGetSymbolTime = 0;
    TypeScript.declarationEmitGetBaseTypeTime = 0;
    TypeScript.declarationEmitGetAccessorFunctionTime = 0;
    TypeScript.declarationEmitGetTypeParameterSymbolTime = 0;
    TypeScript.declarationEmitGetImportDeclarationSymbolTime = 0;

    TypeScript.ioHostResolvePathTime = 0;
    TypeScript.ioHostDirectoryNameTime = 0;
    TypeScript.ioHostCreateDirectoryStructureTime = 0;
    TypeScript.ioHostWriteFileTime = 0;

    var Document = (function () {
        function Document(fileName, referencedFiles, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree) {
            this.fileName = fileName;
            this.referencedFiles = referencedFiles;
            this.compilationSettings = compilationSettings;
            this.scriptSnapshot = scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
            this.version = version;
            this.isOpen = isOpen;
            this._diagnostics = null;
            this._syntaxTree = null;
            this._bloomFilter = null;
            if (isOpen) {
                this._syntaxTree = syntaxTree;
            } else {
                var start = new Date().getTime();
                this._diagnostics = syntaxTree.diagnostics();
                TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            }

            this.lineMap = syntaxTree.lineMap();

            var start = new Date().getTime();
            this.script = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, compilationSettings, isOpen);
            TypeScript.astTranslationTime += new Date().getTime() - start;
        }
        Document.prototype.diagnostics = function () {
            if (this._diagnostics === null) {
                this._diagnostics = this._syntaxTree.diagnostics();
            }

            return this._diagnostics;
        };

        Document.prototype.syntaxTree = function () {
            if (this._syntaxTree) {
                return this._syntaxTree;
            }

            return TypeScript.Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this.scriptSnapshot), TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this.compilationSettings));
        };

        Document.prototype.bloomFilter = function () {
            if (!this._bloomFilter) {
                var identifiers = new TypeScript.BlockIntrinsics();
                var pre = function (cur, walker) {
                    if (TypeScript.isValidAstNode(cur)) {
                        if (cur.nodeType() === 22 /* Name */) {
                            var nodeText = cur.text();

                            identifiers[nodeText] = true;
                        }
                    }
                };

                TypeScript.getAstWalkerFactory().walk(this.script, pre, null, null, identifiers);

                var identifierCount = 0;
                for (var name in identifiers) {
                    if (identifiers[name]) {
                        identifierCount++;
                    }
                }

                this._bloomFilter = new TypeScript.BloomFilter(identifierCount);
                this._bloomFilter.addKeys(identifiers);
            }
            return this._bloomFilter;
        };

        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange, settings) {
            var oldScript = this.script;
            var oldSyntaxTree = this._syntaxTree;

            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);

            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this.compilationSettings)) : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);

            return new Document(this.fileName, this.referencedFiles, this.compilationSettings, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree);
        };

        Document.create = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, compilationSettings) {
            var start = new Date().getTime();
            var syntaxTree = TypeScript.Parser.parse(fileName, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot), TypeScript.isDTSFile(fileName), TypeScript.getParseOptions(compilationSettings));
            TypeScript.syntaxTreeParseTime += new Date().getTime() - start;

            var document = new Document(fileName, referencedFiles, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree);

            return document;
        };
        return Document;
    })();
    TypeScript.Document = Document;

    TypeScript.globalSemanticInfoChain = null;
    TypeScript.globalBinder = null;
    TypeScript.globalLogger = null;

    TypeScript.useDirectTypeStorage = false;

    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, settings) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof settings === "undefined") { settings = new TypeScript.CompilationSettings(); }
            this.logger = logger;
            this.settings = settings;
            this.resolver = null;
            this.semanticInfoChain = null;
            this.fileNameToDocument = new TypeScript.StringHashTable();
            this.emitOptions = new TypeScript.EmitOptions(this.settings);
            TypeScript.globalLogger = logger;
        }
        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            return this.fileNameToDocument.lookup(TypeScript.switchToForwardSlashes(fileName));
        };

        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        };

        TypeScriptCompiler.prototype.addSourceUnit = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            fileName = TypeScript.switchToForwardSlashes(fileName);

            TypeScript.sourceCharactersCompiled += scriptSnapshot.getLength();

            var document = Document.create(fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, this.emitOptions.compilationSettings);
            this.fileNameToDocument.addOrUpdate(fileName, document);

            return document;
        };

        TypeScriptCompiler.prototype.updateSourceUnit = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            var _this = this;
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.timeFunction("pullUpdateUnit(" + fileName + ")", function () {
                var document = _this.getDocument(fileName);
                var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange, _this.settings);

                _this.fileNameToDocument.addOrUpdate(fileName, updatedDocument);

                _this.pullUpdateScript(document, updatedDocument);

                return updatedDocument;
            });
        };

        TypeScriptCompiler.prototype.isDynamicModuleCompilation = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                var script = document.script;
                if (!script.isDeclareFile && script.isExternalModule) {
                    return true;
                }
            }
            return false;
        };

        TypeScriptCompiler.prototype.updateCommonDirectoryPath = function () {
            var commonComponents = [];
            var commonComponentsLength = -1;

            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileNames[i]);
                var script = document.script;

                if (!script.isDeclareFile) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    if (this.emitOptions.compilationSettings.outDirOption || this.emitOptions.compilationSettings.sourceRoot) {
                                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Cannot_find_the_common_subdirectory_path_for_the_input_files, null);
                                    } else {
                                        this.emitOptions.commonDirectoryPath = "";
                                        return null;
                                    }
                                }

                                break;
                            }
                        }

                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this.emitOptions.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            return null;
        };

        TypeScriptCompiler.prototype.setEmitOptions = function (ioHost) {
            this.emitOptions.ioHost = ioHost;

            if (this.emitOptions.compilationSettings.moduleGenTarget === 0 /* Unspecified */ && this.isDynamicModuleCompilation()) {
                return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Cannot_compile_external_modules_unless_the_module_flag_is_provided, null);
            }

            if (!this.emitOptions.compilationSettings.mapSourceFiles) {
                if (this.emitOptions.compilationSettings.mapRoot) {
                    if (this.emitOptions.compilationSettings.sourceRoot) {
                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    } else {
                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    }
                } else if (this.emitOptions.compilationSettings.sourceRoot) {
                    return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                }
            }

            this.emitOptions.compilationSettings.mapRoot = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(this.emitOptions.compilationSettings.mapRoot));
            this.emitOptions.compilationSettings.sourceRoot = TypeScript.convertToDirectoryPath(TypeScript.switchToForwardSlashes(this.emitOptions.compilationSettings.sourceRoot));

            if (!this.emitOptions.compilationSettings.outFileOption && !this.emitOptions.compilationSettings.outDirOption && !this.emitOptions.compilationSettings.mapRoot && !this.emitOptions.compilationSettings.sourceRoot) {
                this.emitOptions.outputMany = true;
                this.emitOptions.commonDirectoryPath = "";
                return null;
            }

            if (this.emitOptions.compilationSettings.outFileOption) {
                this.emitOptions.compilationSettings.outFileOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outFileOption));
                this.emitOptions.outputMany = false;
            } else {
                this.emitOptions.outputMany = true;
            }

            if (this.emitOptions.compilationSettings.outDirOption) {
                this.emitOptions.compilationSettings.outDirOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outDirOption));
                this.emitOptions.compilationSettings.outDirOption = TypeScript.convertToDirectoryPath(this.emitOptions.compilationSettings.outDirOption);
            }

            if (this.emitOptions.compilationSettings.outDirOption || this.emitOptions.compilationSettings.mapRoot || this.emitOptions.compilationSettings.sourceRoot) {
                return this.updateCommonDirectoryPath();
            }

            return null;
        };

        TypeScriptCompiler.prototype.getScripts = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document.script);
            }

            return result;
        };

        TypeScriptCompiler.prototype.getDocuments = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document);
            }

            return result;
        };

        TypeScriptCompiler.prototype.writeByteOrderMarkForDocument = function (document) {
            if (this.emitOptions.outputMany || document.script.isExternalModule) {
                return document.byteOrderMark !== 0 /* None */;
            } else {
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    if (document.script.isExternalModule) {
                        continue;
                    }
                    var document = this.getDocument(fileNames[i]);
                    if (document.byteOrderMark !== 0 /* None */) {
                        return true;
                    }
                }

                return false;
            }
        };

        TypeScriptCompiler.mapToDTSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };

        TypeScriptCompiler.prototype.shouldEmitDeclarations = function (script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }

            if (!!script && (script.isDeclareFile || script.moduleElements === null)) {
                return false;
            }

            return true;
        };

        TypeScriptCompiler.prototype.emitDeclarations = function (document, declarationEmitter) {
            var script = document.script;
            if (this.shouldEmitDeclarations(script)) {
                if (declarationEmitter) {
                    declarationEmitter.document = document;
                } else {
                    var declareFileName = this.emitOptions.mapOutputFileName(document, TypeScriptCompiler.mapToDTSFileName);
                    declarationEmitter = new TypeScript.DeclarationEmitter(declareFileName, document, this);
                }

                declarationEmitter.emitDeclarations(script);
            }

            return declarationEmitter;
        };

        TypeScriptCompiler.prototype.emitAllDeclarations = function () {
            var start = new Date().getTime();

            if (this.shouldEmitDeclarations()) {
                var sharedEmitter = null;
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];

                    try  {
                        var document = this.getDocument(fileNames[i]);

                        if (this.emitOptions.outputMany || document.script.isExternalModule) {
                            var singleEmitter = this.emitDeclarations(document);
                            if (singleEmitter) {
                                singleEmitter.close();
                            }
                        } else {
                            sharedEmitter = this.emitDeclarations(document, sharedEmitter);
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                }

                if (sharedEmitter) {
                    try  {
                        sharedEmitter.close();
                    } catch (ex2) {
                        return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                    }
                }
            }

            TypeScript.declarationEmitTime += new Date().getTime() - start;

            return [];
        };

        TypeScriptCompiler.prototype.emitUnitDeclarations = function (fileName) {
            var document = this.getDocument(fileName);

            if (this.shouldEmitDeclarations(document.script)) {
                if (this.emitOptions.outputMany || document.script.isExternalModule) {
                    try  {
                        var emitter = this.emitDeclarations(document);
                        if (emitter) {
                            emitter.close();
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                } else {
                    return this.emitAllDeclarations();
                }
            }

            return [];
        };

        TypeScriptCompiler.mapToFileNameExtension = function (extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };

        TypeScriptCompiler.mapToJSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };

        TypeScriptCompiler.prototype.emit = function (document, inputOutputMapper, emitter) {
            var script = document.script;
            if (!script.isDeclareFile) {
                var typeScriptFileName = document.fileName;
                if (!emitter) {
                    var javaScriptFileName = this.emitOptions.mapOutputFileName(document, TypeScriptCompiler.mapToJSFileName);
                    var outFile = this.createFile(javaScriptFileName, this.writeByteOrderMarkForDocument(document));

                    emitter = new TypeScript.Emitter(javaScriptFileName, outFile, this.emitOptions, this.semanticInfoChain);

                    if (this.settings.mapSourceFiles) {
                        var sourceMapFile = this.createFile(javaScriptFileName + TypeScript.SourceMapper.MapFileExtension, false);
                        emitter.createSourceMapper(document, javaScriptFileName, outFile, sourceMapFile);
                    }

                    if (inputOutputMapper) {
                        inputOutputMapper(typeScriptFileName, javaScriptFileName);
                    }
                } else if (this.settings.mapSourceFiles) {
                    emitter.setSourceMapperNewSourceFile(document);
                }

                emitter.setDocument(document);
                emitter.emitJavascript(script, false);
            }

            return emitter;
        };

        TypeScriptCompiler.prototype.emitAll = function (ioHost, inputOutputMapper) {
            var start = new Date().getTime();

            var optionsDiagnostic = this.setEmitOptions(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var fileNames = this.fileNameToDocument.getAllKeys();
            var sharedEmitter = null;

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileName);

                try  {
                    if (this.emitOptions.outputMany || document.script.isExternalModule) {
                        var singleEmitter = this.emit(document, inputOutputMapper);

                        if (singleEmitter) {
                            singleEmitter.emitSourceMapsAndClose();
                        }
                    } else {
                        sharedEmitter = this.emit(document, inputOutputMapper, sharedEmitter);
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }
            }

            if (sharedEmitter) {
                try  {
                    sharedEmitter.emitSourceMapsAndClose();
                } catch (ex2) {
                    return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                }
            }

            TypeScript.emitTime += new Date().getTime() - start;
            return [];
        };

        TypeScriptCompiler.prototype.emitUnit = function (fileName, ioHost, inputOutputMapper) {
            var optionsDiagnostic = this.setEmitOptions(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var document = this.getDocument(fileName);

            if (this.emitOptions.outputMany || document.script.isExternalModule) {
                try  {
                    var emitter = this.emit(document, inputOutputMapper);

                    if (emitter) {
                        emitter.emitSourceMapsAndClose();
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }

                return [];
            } else {
                return this.emitAll(ioHost, inputOutputMapper);
            }
        };

        TypeScriptCompiler.prototype.createFile = function (fileName, writeByteOrderMark) {
            return new TypeScript.TextWriter(this.emitOptions.ioHost, fileName, writeByteOrderMark);
        };

        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            return this.getDocument(fileName).diagnostics();
        };

        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };
        TypeScriptCompiler.prototype.getScript = function (fileName) {
            return this.getDocument(fileName).script;
        };

        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            var errors = [];
            var unit = this.semanticInfoChain.getUnit(fileName);

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (unit) {
                var document = this.getDocument(fileName);
                var script = document.script;

                if (script) {
                    var startTime = (new Date()).getTime();
                    TypeScript.PullTypeResolver.typeCheck(this.settings, this.semanticInfoChain, fileName, script);
                    var endTime = (new Date()).getTime();

                    TypeScript.typeCheckTime += endTime - startTime;

                    unit.getDiagnostics(errors);
                }
            }

            errors = TypeScript.ArrayUtilities.distinct(errors, TypeScript.Diagnostic.equals);
            errors.sort(function (d1, d2) {
                if (d1.fileName() < d2.fileName()) {
                    return -1;
                } else if (d1.fileName() > d2.fileName()) {
                    return 1;
                }

                if (d1.start() < d2.start()) {
                    return -1;
                } else if (d1.start() > d2.start()) {
                    return 1;
                }

                var code1 = TypeScript.diagnosticInformationMap[d1.diagnosticKey()].code;
                var code2 = TypeScript.diagnosticInformationMap[d2.diagnosticKey()].code;
                if (code1 < code2) {
                    return -1;
                } else if (code1 > code2) {
                    return 1;
                }

                return 0;
            });

            return errors;
        };

        TypeScriptCompiler.prototype.resolveAllFiles = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                this.getSemanticDiagnostics(fileNames[i]);
            }
        };

        TypeScriptCompiler.prototype.setUnit = function (unitPath) {
            if (!this.resolver) {
                this.resolver = new TypeScript.PullTypeResolver(this.settings, this.semanticInfoChain, unitPath);
            }

            this.resolver.setUnitPath(unitPath);
        };

        TypeScriptCompiler.prototype.pullTypeCheck = function () {
            var start = new Date().getTime();

            this.semanticInfoChain = new TypeScript.SemanticInfoChain();
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;

            if (this.resolver) {
                this.resolver.semanticInfoChain = this.semanticInfoChain;
            }

            var declCollectionContext = null;
            var i, n;

            var createDeclsStartTime = new Date().getTime();

            var fileNames = this.fileNameToDocument.getAllKeys();
            var n = fileNames.length;
            for (var i = 0; i < n; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileName);
                var semanticInfo = new TypeScript.SemanticInfo(fileName);

                declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, fileName);

                TypeScript.getAstWalkerFactory().walk(document.script, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                semanticInfo.addTopLevelDecl(declCollectionContext.getParent());

                this.semanticInfoChain.addUnit(semanticInfo);
            }

            var createDeclsEndTime = new Date().getTime();

            var bindStartTime = new Date().getTime();

            var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
            TypeScript.globalBinder = binder;

            for (var i = 1; i < this.semanticInfoChain.units.length; i++) {
                binder.bindDeclsForUnit(this.semanticInfoChain.units[i].getPath());
            }

            var bindEndTime = new Date().getTime();

            this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
            this.logger.log("Binding: " + (bindEndTime - bindStartTime));
            this.logger.log("    Time in findSymbol: " + TypeScript.time_in_findSymbol);
            this.logger.log("Number of symbols created: " + TypeScript.pullSymbolID);
            this.logger.log("Number of specialized types created: " + TypeScript.nSpecializationsCreated);
            this.logger.log("Number of specialized signatures created: " + TypeScript.nSpecializedSignaturesCreated);
        };

        TypeScriptCompiler.prototype.pullUpdateScript = function (oldDocument, newDocument) {
            var _this = this;
            this.timeFunction("pullUpdateScript: ", function () {
                var oldScript = oldDocument.script;
                var newScript = newDocument.script;

                var newScriptSemanticInfo = new TypeScript.SemanticInfo(oldDocument.fileName);
                var oldScriptSemanticInfo = _this.semanticInfoChain.getUnit(oldDocument.fileName);

                TypeScript.lastBoundPullDeclId = TypeScript.pullDeclID;

                var declCollectionContext = new TypeScript.DeclCollectionContext(newScriptSemanticInfo, oldDocument.fileName);

                TypeScript.getAstWalkerFactory().walk(newScript, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecl();
                var newTopLevelDecl = declCollectionContext.getParent();

                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);

                if (_this.resolver) {
                    _this.resolver.cleanCachedGlobals();
                }

                _this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);

                _this.logger.log("Cleaning symbols...");
                var cleanStart = new Date().getTime();
                _this.semanticInfoChain.update();
                var cleanEnd = new Date().getTime();
                _this.logger.log("   time to clean: " + (cleanEnd - cleanStart));

                if (_this.resolver) {
                    _this.resolver.setUnitPath(oldDocument.fileName);
                }
            });
        };

        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }

            var ast = this.resolver.getASTForDecl(decl);
            if (!ast) {
                return null;
            }

            var enlosingDecl = this.resolver.getEnclosingDecl(decl);
            if (ast.nodeType() === 83 /* Member */) {
                return this.getSymbolOfDeclaration(enlosingDecl);
            }

            return this.resolver.resolveAST(ast, false, enlosingDecl, new TypeScript.PullTypeResolutionContext(this.resolver));
        };

        TypeScriptCompiler.prototype.resolvePosition = function (pos, document) {
            var declStack = [];
            var resultASTs = [];
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST = null;
            var foundAST = null;
            var symbol = null;
            var candidateSignature = null;
            var callSignatures = null;

            var lambdaAST = null;
            var declarationInitASTs = [];
            var objectLitAST = null;
            var asgAST = null;
            var typeAssertionASTs = [];
            var resolutionContext = new TypeScript.PullTypeResolutionContext(this.resolver);
            var inTypeReference = false;
            var enclosingDecl = null;
            var isConstructorCall = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var pre = function (cur) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        var previous = resultASTs[resultASTs.length - 1];

                        if (previous === undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                            var decl = semanticInfo.getDeclForAST(cur);

                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }

                            if (cur.nodeType() === 13 /* FunctionDeclaration */ && TypeScript.hasFlag(cur.getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                                lambdaAST = cur;
                            } else if (cur.nodeType() === 82 /* ArrowFunctionExpression */) {
                                lambdaAST = cur;
                            } else if (cur.nodeType() === 19 /* VariableDeclarator */) {
                                declarationInitASTs[declarationInitASTs.length] = cur;
                            } else if (cur.nodeType() === 24 /* ObjectLiteralExpression */) {
                                objectLitAST = cur;
                            } else if (cur.nodeType() === 80 /* CastExpression */) {
                                typeAssertionASTs[typeAssertionASTs.length] = cur;
                            } else if (cur.nodeType() === 40 /* AssignmentExpression */) {
                                asgAST = cur;
                            } else if (cur.nodeType() === 11 /* TypeRef */) {
                                inTypeReference = true;
                            }

                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
            };

            TypeScript.getAstWalkerFactory().walk(script, pre);

            if (resultASTs.length) {
                this.setUnit(scriptName);

                foundAST = resultASTs[resultASTs.length - 1];

                if (foundAST.nodeType() === 22 /* Name */ && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch (previousAST.nodeType()) {
                        case 15 /* InterfaceDeclaration */:
                            if (foundAST === previousAST.name) {
                                foundAST = previousAST;
                            }
                            break;
                        case 14 /* ClassDeclaration */:
                            if (foundAST === previousAST.name) {
                                foundAST = previousAST;
                            }
                            break;
                        case 17 /* ModuleDeclaration */:
                            if (foundAST === previousAST.name) {
                                foundAST = previousAST;
                            }
                            break;

                        case 19 /* VariableDeclarator */:
                            if (foundAST === previousAST.id) {
                                foundAST = previousAST;
                            }
                            break;

                        case 13 /* FunctionDeclaration */:
                            if (foundAST === previousAST.name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }

                var funcDecl = null;
                if (lastDeclAST === foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.resolver.resolveDeclaredSymbol(symbol, resolutionContext);
                    symbol.setUnresolved();
                    enclosingDecl = declStack[declStack.length - 1].getParentDecl();
                    if (foundAST.nodeType() === 13 /* FunctionDeclaration */ || foundAST.nodeType() === 82 /* ArrowFunctionExpression */) {
                        funcDecl = foundAST;
                    }
                } else {
                    for (var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].kind & (1024 /* Variable */ | 2048 /* Parameter */))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }

                    var callExpression = null;
                    if ((foundAST.nodeType() === 32 /* SuperExpression */ || foundAST.nodeType() === 31 /* ThisExpression */ || foundAST.nodeType() === 22 /* Name */) && resultASTs.length > 1) {
                        for (var i = resultASTs.length - 2; i >= 0; i--) {
                            if (resultASTs[i].nodeType() === 34 /* MemberAccessExpression */ && resultASTs[i].operand2 === resultASTs[i + 1]) {
                                foundAST = resultASTs[i];
                            } else if ((resultASTs[i].nodeType() === 38 /* InvocationExpression */ || resultASTs[i].nodeType() === 39 /* ObjectCreationExpression */) && resultASTs[i].target === resultASTs[i + 1]) {
                                callExpression = resultASTs[i];
                                break;
                            } else if (resultASTs[i].nodeType() === 13 /* FunctionDeclaration */ && resultASTs[i].name === resultASTs[i + 1]) {
                                funcDecl = resultASTs[i];
                                break;
                            } else {
                                break;
                            }
                        }
                    }

                    if (foundAST.nodeType() === 1 /* List */) {
                        for (var i = 0; i < foundAST.members.length; i++) {
                            if (foundAST.members[i].minChar > pos) {
                                foundAST = foundAST.members[i];
                                break;
                            }
                        }
                    }

                    resolutionContext.resolvingTypeReference = inTypeReference;

                    var inContextuallyTypedAssignment = false;

                    if (declarationInitASTs.length) {
                        var assigningAST;

                        for (var i = 0; i < declarationInitASTs.length; i++) {
                            assigningAST = declarationInitASTs[i];
                            inContextuallyTypedAssignment = (assigningAST !== null) && (assigningAST.typeExpr !== null);

                            this.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                            var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                            if (varSymbol && inContextuallyTypedAssignment) {
                                var contextualType = varSymbol.type;
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }

                            if (assigningAST.init) {
                                this.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }

                    if (typeAssertionASTs.length) {
                        for (var i = 0; i < typeAssertionASTs.length; i++) {
                            this.resolver.resolveAST(typeAssertionASTs[i], inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }

                    if (asgAST) {
                        this.resolver.resolveAST(asgAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (objectLitAST) {
                        this.resolver.resolveAST(objectLitAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (lambdaAST) {
                        this.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }

                    symbol = this.resolver.resolveAST(foundAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    if (callExpression) {
                        var isPropertyOrVar = symbol.kind === 4096 /* Property */ || symbol.kind === 1024 /* Variable */;
                        var typeSymbol = symbol.type;
                        if (isPropertyOrVar) {
                            isPropertyOrVar = (typeSymbol.kind !== 16 /* Interface */ && typeSymbol.kind !== 8388608 /* ObjectType */) || typeSymbol.name === "";
                        }

                        if (!isPropertyOrVar) {
                            isConstructorCall = foundAST.nodeType() === 32 /* SuperExpression */ || callExpression.nodeType() === 39 /* ObjectCreationExpression */;

                            if (foundAST.nodeType() === 32 /* SuperExpression */) {
                                if (symbol.kind === 8 /* Class */) {
                                    callSignatures = symbol.getConstructorMethod().type.getConstructSignatures();
                                }
                            } else {
                                callSignatures = callExpression.nodeType() === 38 /* InvocationExpression */ ? typeSymbol.getCallSignatures() : typeSymbol.getConstructSignatures();
                            }

                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (callExpression.nodeType() === 38 /* InvocationExpression */) {
                                this.resolver.resolveInvocationExpression(callExpression, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.resolver.resolveObjectCreationExpression(callExpression, enclosingDecl, resolutionContext, callResolutionResults);
                            }

                            if (callResolutionResults.candidateSignature) {
                                candidateSignature = callResolutionResults.candidateSignature;
                            }
                            if (callResolutionResults.targetSymbol && callResolutionResults.targetSymbol.name !== "") {
                                symbol = callResolutionResults.targetSymbol;
                            }
                            foundAST = callExpression;
                        }
                    }
                }

                if (funcDecl) {
                    if (symbol && symbol.kind !== 4096 /* Property */) {
                        var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain.getUnit(scriptName));
                        candidateSignature = signatureInfo.signature;
                        callSignatures = signatureInfo.allSignatures;
                    }
                } else if (!callSignatures && symbol && (symbol.kind === 65536 /* Method */ || symbol.kind === 16384 /* Function */)) {
                    var typeSym = symbol.type;
                    if (typeSym) {
                        callSignatures = typeSym.getCallSignatures();
                    }
                }
            }

            var enclosingScopeSymbol = this.getSymbolOfDeclaration(enclosingDecl);

            return {
                symbol: symbol,
                ast: foundAST,
                enclosingScopeSymbol: enclosingScopeSymbol,
                candidateSignature: candidateSignature,
                callSignatures: callSignatures,
                isConstructorCall: isConstructorCall
            };
        };

        TypeScriptCompiler.prototype.extractResolutionContextFromPath = function (path, document, propagateContextualTypes) {
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl = null;
            var enclosingDeclAST = null;
            var inContextuallyTypedAssignment = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var resolutionContext = new TypeScript.PullTypeResolutionContext(this.resolver);
            resolutionContext.resolveAggressively = true;

            if (path.count() === 0) {
                return null;
            }

            this.setUnit(semanticInfo.getPath());

            for (var i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];

                switch (current.nodeType()) {
                    case 13 /* FunctionDeclaration */:
                        if (TypeScript.hasFlag(current.getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                            this.resolver.resolveAST(current, true, enclosingDecl, resolutionContext);
                        }

                        break;

                    case 82 /* ArrowFunctionExpression */:
                        this.resolver.resolveAST(current, true, enclosingDecl, resolutionContext);
                        break;

                    case 19 /* VariableDeclarator */:
                        var assigningAST = current;
                        inContextuallyTypedAssignment = (assigningAST.typeExpr !== null);

                        if (inContextuallyTypedAssignment) {
                            if (propagateContextualTypes) {
                                this.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                                var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                                var contextualType = null;
                                if (varSymbol && inContextuallyTypedAssignment) {
                                    contextualType = varSymbol.type;
                                }

                                resolutionContext.pushContextualType(contextualType, false, null);

                                if (assigningAST.init) {
                                    this.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                                }
                            }
                        }

                        break;

                    case 38 /* InvocationExpression */:
                    case 39 /* ObjectCreationExpression */:
                        if (propagateContextualTypes) {
                            var isNew = current.nodeType() === 39 /* ObjectCreationExpression */;
                            var callExpression = current;
                            var contextualType = null;

                            if ((i + 1 < n) && callExpression.arguments === path.asts[i + 1]) {
                                var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                                if (isNew) {
                                    this.resolver.resolveObjectCreationExpression(callExpression, enclosingDecl, resolutionContext, callResolutionResults);
                                } else {
                                    this.resolver.resolveInvocationExpression(callExpression, enclosingDecl, resolutionContext, callResolutionResults);
                                }

                                if (callResolutionResults.actualParametersContextTypeSymbols) {
                                    var argExpression = (path.asts[i + 1] && path.asts[i + 1].nodeType() === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                                    if (argExpression) {
                                        for (var j = 0, m = callExpression.arguments.members.length; j < m; j++) {
                                            if (callExpression.arguments.members[j] === argExpression) {
                                                var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                                if (callContextualType) {
                                                    contextualType = callContextualType;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (isNew) {
                                    this.resolver.resolveObjectCreationExpression(callExpression, enclosingDecl, resolutionContext);
                                } else {
                                    this.resolver.resolveInvocationExpression(callExpression, enclosingDecl, resolutionContext);
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 23 /* ArrayLiteralExpression */:
                        if (propagateContextualTypes) {
                            var contextualType = null;
                            var currentContextualType = resolutionContext.getContextualType();
                            if (currentContextualType && currentContextualType.isArray()) {
                                contextualType = currentContextualType.getElementType();
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 24 /* ObjectLiteralExpression */:
                        if (propagateContextualTypes) {
                            var objectLiteralExpression = current;
                            var objectLiteralResolutionContext = new TypeScript.PullAdditionalObjectLiteralResolutionData();
                            this.resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, objectLiteralResolutionContext);

                            var memeberAST = (path.asts[i + 1] && path.asts[i + 1].nodeType() === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                            if (memeberAST) {
                                var contextualType = null;
                                var memberDecls = objectLiteralExpression.operand;
                                if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                    for (var j = 0, m = memberDecls.members.length; j < m; j++) {
                                        if (memberDecls.members[j] === memeberAST) {
                                            var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                            if (memberContextualType) {
                                                contextualType = memberContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }

                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                        }

                        break;

                    case 40 /* AssignmentExpression */:
                        if (propagateContextualTypes) {
                            var assignmentExpression = current;
                            var contextualType = null;

                            if (path.asts[i + 1] && path.asts[i + 1] === assignmentExpression.operand2) {
                                var leftType = this.resolver.resolveAST(assignmentExpression.operand1, inContextuallyTypedAssignment, enclosingDecl, resolutionContext).type;
                                if (leftType) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = leftType;
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 96 /* ReturnStatement */:
                        if (propagateContextualTypes) {
                            var returnStatement = current;
                            var contextualType = null;

                            if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction)) {
                                var functionDeclaration = enclosingDeclAST;
                                if (functionDeclaration.returnTypeAnnotation) {
                                    var currentResolvingTypeReference = resolutionContext.resolvingTypeReference;
                                    resolutionContext.resolvingTypeReference = true;
                                    var returnTypeSymbol = this.resolver.resolveTypeReference(functionDeclaration.returnTypeAnnotation, enclosingDecl, resolutionContext);
                                    resolutionContext.resolvingTypeReference = currentResolvingTypeReference;
                                    if (returnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = returnTypeSymbol;
                                    }
                                } else {
                                    var currentContextualType = resolutionContext.getContextualType();
                                    if (currentContextualType && currentContextualType.isFunction()) {
                                        var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                                        if (currentContextualTypeReturnTypeSymbol) {
                                            inContextuallyTypedAssignment = true;
                                            contextualType = currentContextualTypeReturnTypeSymbol;
                                        }
                                    }
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 12 /* TypeQuery */:
                        resolutionContext.resolvingTypeReference = false;
                        resolutionContext.resolvingTypeQueryExpression = true;
                        break;

                    case 11 /* TypeRef */:
                    case 9 /* TypeParameter */:
                        var typeExpressionNode = path.asts[i + 1];
                        if (!typeExpressionNode || typeExpressionNode.nodeType() == 22 /* Name */ || typeExpressionNode.nodeType() == 34 /* MemberAccessExpression */) {
                            resolutionContext.resolvingTypeReference = true;
                        }

                        break;

                    case 14 /* ClassDeclaration */:
                        var classDeclaration = current;
                        if (path.asts[i + 1]) {
                            if (path.asts[i + 1] === classDeclaration.extendsList || path.asts[i + 1] === classDeclaration.implementsList) {
                                resolutionContext.resolvingTypeReference = true;
                            }
                        }

                        break;

                    case 15 /* InterfaceDeclaration */:
                        var interfaceDeclaration = current;
                        if (path.asts[i + 1]) {
                            if (path.asts[i + 1] === interfaceDeclaration.extendsList || path.asts[i + 1] === interfaceDeclaration.name) {
                                resolutionContext.resolvingTypeReference = true;
                            }
                        }

                        break;
                }

                var decl = semanticInfo.getDeclForAST(current);
                if (decl && !(decl.kind & (1024 /* Variable */ | 2048 /* Parameter */ | 8192 /* TypeParameter */))) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }

            if (path.ast().nodeType() === 22 /* Name */ && path.count() > 1) {
                for (var i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType() === 34 /* MemberAccessExpression */ && path.asts[path.top - 1].operand2 === path.asts[path.top]) {
                        path.pop();
                    } else {
                        break;
                    }
                }
            }

            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment
            };
        };

        TypeScriptCompiler.prototype.pullGetSymbolInformationFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var ast = path.ast();
            var symbol = this.resolver.resolveAST(ast, context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext);
            var aliasSymbol = this.semanticInfoChain.getUnit(document.fileName).getAliasSymbolForAST(ast);

            return {
                symbol: symbol,
                aliasSymbol: aliasSymbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclarationSymbolInformation = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;

            var ast = path.ast();

            if (ast.nodeType() !== 14 /* ClassDeclaration */ && ast.nodeType() !== 15 /* InterfaceDeclaration */ && ast.nodeType() !== 17 /* ModuleDeclaration */ && ast.nodeType() !== 13 /* FunctionDeclaration */ && ast.nodeType() !== 82 /* ArrowFunctionExpression */ && ast.nodeType() !== 19 /* VariableDeclarator */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var decl = semanticInfo.getDeclForAST(ast);
            var symbol = (decl.kind & TypeScript.PullElementKind.SomeSignature) ? decl.getSignatureSymbol() : decl.getSymbol();
            this.resolver.resolveDeclaredSymbol(symbol, context.resolutionContext);

            symbol.setUnresolved();

            return {
                symbol: symbol,
                aliasSymbol: null,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetCallInformationFromPath = function (path, document) {
            if (path.ast().nodeType() !== 38 /* InvocationExpression */ && path.ast().nodeType() !== 39 /* ObjectCreationExpression */) {
                return null;
            }

            var isNew = (path.ast().nodeType() === 39 /* ObjectCreationExpression */);

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();

            if (isNew) {
                this.resolver.resolveObjectCreationExpression(path.ast(), context.enclosingDecl, context.resolutionContext, callResolutionResults);
            } else {
                this.resolver.resolveInvocationExpression(path.ast(), context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }

            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            var symbols = this.resolver.getVisibleMembersFromExpression(path.ast(), context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleDeclsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document, false);
            if (!context) {
                return null;
            }

            return this.resolver.getVisibleDecls(context.enclosingDecl, context.resolutionContext);
        };

        TypeScriptCompiler.prototype.pullGetContextualMembersFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (path.ast().nodeType() !== 24 /* ObjectLiteralExpression */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            var members = this.resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);

            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclInformation = function (decl, path, document) {
            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var symbol = decl.getSymbol();
            this.resolver.resolveDeclaredSymbol(symbol, context.resolutionContext);
            symbol.setUnresolved();

            return {
                symbol: symbol,
                aliasSymbol: null,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetTypeInfoAtPosition = function (pos, document) {
            var _this = this;
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", function () {
                return _this.resolvePosition(pos, document);
            });
        };

        TypeScriptCompiler.prototype.getTopLevelDeclaration = function (scriptName) {
            var unit = this.semanticInfoChain.getUnit(scriptName);

            if (!unit) {
                return null;
            }

            return unit.getTopLevelDecl();
        };

        TypeScriptCompiler.prototype.reportDiagnostics = function (errors, errorReporter) {
            for (var i = 0; i < errors.length; i++) {
                errorReporter.addDiagnostic(errors[i]);
            }
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ASTSpan = (function () {
        function ASTSpan() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
        }
        return ASTSpan;
    })();
    TypeScript.ASTSpan = ASTSpan;

    var astID = 0;

    function structuralEqualsNotIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, false);
    }
    TypeScript.structuralEqualsNotIncludingPosition = structuralEqualsNotIncludingPosition;

    function structuralEqualsIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, true);
    }
    TypeScript.structuralEqualsIncludingPosition = structuralEqualsIncludingPosition;

    function structuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }

        return ast1 !== null && ast2 !== null && ast1.nodeType() === ast2.nodeType() && ast1.structuralEquals(ast2, includingPosition);
    }

    function astArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? structuralEqualsIncludingPosition : structuralEqualsNotIncludingPosition);
    }

    var AST = (function () {
        function AST() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
            this._flags = 0 /* None */;
            this.typeCheckPhase = -1;
            this.astIDString = astID.toString();
            this.astID = astID++;
            this.symbol = null;
            this.aliasSymbol = null;
            this.decl = null;
            this._preComments = null;
            this._postComments = null;
            this._docComments = null;
        }
        AST.prototype.nodeType = function () {
            throw TypeScript.Errors.abstract();
        };

        AST.prototype.isStatement = function () {
            return false;
        };

        AST.prototype.preComments = function () {
            return this._preComments;
        };

        AST.prototype.postComments = function () {
            return this._postComments;
        };

        AST.prototype.setPreComments = function (comments) {
            if (comments && comments.length) {
                this._preComments = comments;
            } else if (this._preComments) {
                this._preComments = null;
            }
        };

        AST.prototype.setPostComments = function (comments) {
            if (comments && comments.length) {
                this._postComments = comments;
            } else if (this._postComments) {
                this._postComments = null;
            }
        };

        AST.prototype.shouldEmit = function (emitter) {
            return true;
        };

        AST.prototype.getFlags = function () {
            return this._flags;
        };

        AST.prototype.setFlags = function (flags) {
            this._flags = flags;
        };

        AST.prototype.getLength = function () {
            return this.limChar - this.minChar;
        };

        AST.prototype.isDeclaration = function () {
            return false;
        };

        AST.prototype.emit = function (emitter) {
            emitter.emitComments(this, true);
            this.emitWorker(emitter);
            emitter.emitComments(this, false);
        };

        AST.prototype.emitWorker = function (emitter) {
            throw TypeScript.Errors.abstract();
        };

        AST.prototype.docComments = function () {
            if (!this.isDeclaration() || !this.preComments() || this.preComments().length === 0) {
                return [];
            }

            if (!this._docComments) {
                var preComments = this.preComments();
                var preCommentsLength = preComments.length;
                var docComments = new Array();
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (preComments[i].isDocComment()) {
                        docComments.push(preComments[i]);
                        continue;
                    }
                    break;
                }

                this._docComments = docComments.reverse();
            }

            return this._docComments;
        };

        AST.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.minChar !== ast.minChar || this.limChar !== ast.limChar) {
                    return false;
                }
            }

            return this._flags === ast._flags && astArrayStructuralEquals(this.preComments(), ast.preComments(), includingPosition) && astArrayStructuralEquals(this.postComments(), ast.postComments(), includingPosition);
        };
        return AST;
    })();
    TypeScript.AST = AST;

    var ASTList = (function (_super) {
        __extends(ASTList, _super);
        function ASTList(members, separatorCount) {
            _super.call(this);
            this.members = members;
            this.separatorCount = separatorCount;
        }
        ASTList.prototype.nodeType = function () {
            return 1 /* List */;
        };

        ASTList.prototype.emit = function (emitter) {
            emitter.emitList(this);
        };

        ASTList.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ASTList;
    })(AST);
    TypeScript.ASTList = ASTList;

    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(actualText, text, isNumber) {
            if (typeof isNumber === "undefined") { isNumber = false; }
            _super.call(this);
            this.actualText = actualText;
            this.isNumber = isNumber;
            this._text = text;
        }
        Identifier.prototype.text = function () {
            if (!this._text) {
                this._text = TypeScript.Syntax.massageEscapes(this.actualText);
            }

            return this._text;
        };

        Identifier.prototype.nodeType = function () {
            return 22 /* Name */;
        };

        Identifier.prototype.isMissing = function () {
            return false;
        };

        Identifier.prototype.emit = function (emitter) {
            emitter.emitName(this, true);
        };

        Identifier.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.actualText === ast.actualText && this.isMissing() === ast.isMissing();
        };
        return Identifier;
    })(AST);
    TypeScript.Identifier = Identifier;

    var MissingIdentifier = (function (_super) {
        __extends(MissingIdentifier, _super);
        function MissingIdentifier() {
            _super.call(this, "__missing", "__missing");
        }
        MissingIdentifier.prototype.isMissing = function () {
            return true;
        };

        MissingIdentifier.prototype.emit = function (emitter) {
        };
        return MissingIdentifier;
    })(Identifier);
    TypeScript.MissingIdentifier = MissingIdentifier;

    var LiteralExpression = (function (_super) {
        __extends(LiteralExpression, _super);
        function LiteralExpression(_nodeType) {
            _super.call(this);
            this._nodeType = _nodeType;
        }
        LiteralExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        LiteralExpression.prototype.emitWorker = function (emitter) {
            emitter.emitLiteralExpression(this);
        };

        LiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return LiteralExpression;
    })(AST);
    TypeScript.LiteralExpression = LiteralExpression;

    var ThisExpression = (function (_super) {
        __extends(ThisExpression, _super);
        function ThisExpression() {
            _super.apply(this, arguments);
        }
        ThisExpression.prototype.nodeType = function () {
            return 31 /* ThisExpression */;
        };

        ThisExpression.prototype.emitWorker = function (emitter) {
            emitter.emitThisExpression(this);
        };

        ThisExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ThisExpression;
    })(AST);
    TypeScript.ThisExpression = ThisExpression;

    var SuperExpression = (function (_super) {
        __extends(SuperExpression, _super);
        function SuperExpression() {
            _super.apply(this, arguments);
        }
        SuperExpression.prototype.nodeType = function () {
            return 32 /* SuperExpression */;
        };

        SuperExpression.prototype.emitWorker = function (emitter) {
            emitter.emitSuperExpression(this);
        };

        SuperExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return SuperExpression;
    })(AST);
    TypeScript.SuperExpression = SuperExpression;

    var ParenthesizedExpression = (function (_super) {
        __extends(ParenthesizedExpression, _super);
        function ParenthesizedExpression(expression) {
            _super.call(this);
            this.expression = expression;
            this.openParenTrailingComments = null;
        }
        ParenthesizedExpression.prototype.nodeType = function () {
            return 81 /* ParenthesizedExpression */;
        };

        ParenthesizedExpression.prototype.emitWorker = function (emitter) {
            emitter.emitParenthesizedExpression(this);
        };

        ParenthesizedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ParenthesizedExpression;
    })(AST);
    TypeScript.ParenthesizedExpression = ParenthesizedExpression;

    var CastExpression = (function (_super) {
        __extends(CastExpression, _super);
        function CastExpression(castType, operand) {
            _super.call(this);
            this.castType = castType;
            this.operand = operand;
        }
        CastExpression.prototype.nodeType = function () {
            return 80 /* CastExpression */;
        };

        CastExpression.prototype.emitWorker = function (emitter) {
            emitter.emitCastExpression(this);
        };

        CastExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.castType, ast.castType, includingPosition) && structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return CastExpression;
    })(AST);
    TypeScript.CastExpression = CastExpression;

    var UnaryExpression = (function (_super) {
        __extends(UnaryExpression, _super);
        function UnaryExpression(_nodeType, operand) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.operand = operand;
        }
        UnaryExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        UnaryExpression.prototype.emitWorker = function (emitter) {
            emitter.emitUnaryExpression(this);
        };

        UnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return UnaryExpression;
    })(AST);
    TypeScript.UnaryExpression = UnaryExpression;

    var ObjectCreationExpression = (function (_super) {
        __extends(ObjectCreationExpression, _super);
        function ObjectCreationExpression(target, typeArguments, arguments, closeParenSpan) {
            _super.call(this);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.closeParenSpan = closeParenSpan;
            this.callResolutionData = null;
        }
        ObjectCreationExpression.prototype.nodeType = function () {
            return 39 /* ObjectCreationExpression */;
        };

        ObjectCreationExpression.prototype.emitWorker = function (emitter) {
            emitter.emitObjectCreationExpression(this);
        };

        ObjectCreationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return ObjectCreationExpression;
    })(AST);
    TypeScript.ObjectCreationExpression = ObjectCreationExpression;

    var InvocationExpression = (function (_super) {
        __extends(InvocationExpression, _super);
        function InvocationExpression(target, typeArguments, arguments, closeParenSpan) {
            _super.call(this);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.closeParenSpan = closeParenSpan;
            this.callResolutionData = null;
        }
        InvocationExpression.prototype.nodeType = function () {
            return 38 /* InvocationExpression */;
        };

        InvocationExpression.prototype.emitWorker = function (emitter) {
            emitter.emitInvocationExpression(this);
        };

        InvocationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return InvocationExpression;
    })(AST);
    TypeScript.InvocationExpression = InvocationExpression;

    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(_nodeType, operand1, operand2) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.operand1 = operand1;
            this.operand2 = operand2;
        }
        BinaryExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        BinaryExpression.getTextForBinaryToken = function (nodeType) {
            switch (nodeType) {
                case 27 /* CommaExpression */:
                    return ",";
                case 40 /* AssignmentExpression */:
                    return "=";
                case 41 /* AddAssignmentExpression */:
                    return "+=";
                case 42 /* SubtractAssignmentExpression */:
                    return "-=";
                case 44 /* MultiplyAssignmentExpression */:
                    return "*=";
                case 43 /* DivideAssignmentExpression */:
                    return "/=";
                case 45 /* ModuloAssignmentExpression */:
                    return "%=";
                case 46 /* AndAssignmentExpression */:
                    return "&=";
                case 47 /* ExclusiveOrAssignmentExpression */:
                    return "^=";
                case 48 /* OrAssignmentExpression */:
                    return "|=";
                case 49 /* LeftShiftAssignmentExpression */:
                    return "<<=";
                case 50 /* SignedRightShiftAssignmentExpression */:
                    return ">>=";
                case 51 /* UnsignedRightShiftAssignmentExpression */:
                    return ">>>=";
                case 53 /* LogicalOrExpression */:
                    return "||";
                case 54 /* LogicalAndExpression */:
                    return "&&";
                case 55 /* BitwiseOrExpression */:
                    return "|";
                case 56 /* BitwiseExclusiveOrExpression */:
                    return "^";
                case 57 /* BitwiseAndExpression */:
                    return "&";
                case 58 /* EqualsWithTypeConversionExpression */:
                    return "==";
                case 59 /* NotEqualsWithTypeConversionExpression */:
                    return "!=";
                case 60 /* EqualsExpression */:
                    return "===";
                case 61 /* NotEqualsExpression */:
                    return "!==";
                case 62 /* LessThanExpression */:
                    return "<";
                case 64 /* GreaterThanExpression */:
                    return ">";
                case 63 /* LessThanOrEqualExpression */:
                    return "<=";
                case 65 /* GreaterThanOrEqualExpression */:
                    return ">=";
                case 35 /* InstanceOfExpression */:
                    return "instanceof";
                case 33 /* InExpression */:
                    return "in";
                case 71 /* LeftShiftExpression */:
                    return "<<";
                case 72 /* SignedRightShiftExpression */:
                    return ">>";
                case 73 /* UnsignedRightShiftExpression */:
                    return ">>>";
                case 68 /* MultiplyExpression */:
                    return "*";
                case 69 /* DivideExpression */:
                    return "/";
                case 70 /* ModuloExpression */:
                    return "%";
                case 66 /* AddExpression */:
                    return "+";
                case 67 /* SubtractExpression */:
                    return "-";
            }

            throw TypeScript.Errors.invalidOperation();
        };

        BinaryExpression.prototype.emitWorker = function (emitter) {
            emitter.emitBinaryExpression(this);
        };

        BinaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition);
        };
        return BinaryExpression;
    })(AST);
    TypeScript.BinaryExpression = BinaryExpression;

    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(operand1, operand2, operand3) {
            _super.call(this);
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
        }
        ConditionalExpression.prototype.nodeType = function () {
            return 52 /* ConditionalExpression */;
        };

        ConditionalExpression.prototype.emitWorker = function (emitter) {
            emitter.emitConditionalExpression(this);
        };

        ConditionalExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition) && structuralEquals(this.operand3, ast.operand3, includingPosition);
        };
        return ConditionalExpression;
    })(AST);
    TypeScript.ConditionalExpression = ConditionalExpression;

    var NumericLiteral = (function (_super) {
        __extends(NumericLiteral, _super);
        function NumericLiteral(value, text) {
            _super.call(this);
            this.value = value;
            this._text = text;
        }
        NumericLiteral.prototype.text = function () {
            return this._text;
        };

        NumericLiteral.prototype.nodeType = function () {
            return 7 /* NumericLiteral */;
        };

        NumericLiteral.prototype.emitWorker = function (emitter) {
            emitter.emitNumericLiteral(this);
        };

        NumericLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && (this.value === ast.value || (isNaN(this.value) && isNaN(ast.value))) && this._text === ast._text;
        };
        return NumericLiteral;
    })(AST);
    TypeScript.NumericLiteral = NumericLiteral;

    var RegularExpressionLiteral = (function (_super) {
        __extends(RegularExpressionLiteral, _super);
        function RegularExpressionLiteral(text) {
            _super.call(this);
            this.text = text;
        }
        RegularExpressionLiteral.prototype.nodeType = function () {
            return 6 /* RegularExpressionLiteral */;
        };

        RegularExpressionLiteral.prototype.emitWorker = function (emitter) {
            emitter.emitRegularExpressionLiteral(this);
        };

        RegularExpressionLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text;
        };
        return RegularExpressionLiteral;
    })(AST);
    TypeScript.RegularExpressionLiteral = RegularExpressionLiteral;

    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(actualText, text) {
            _super.call(this);
            this.actualText = actualText;
            this._text = text;
        }
        StringLiteral.prototype.text = function () {
            return this._text;
        };

        StringLiteral.prototype.nodeType = function () {
            return 5 /* StringLiteral */;
        };

        StringLiteral.prototype.emitWorker = function (emitter) {
            emitter.emitStringLiteral(this);
        };

        StringLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.actualText === ast.actualText;
        };
        return StringLiteral;
    })(AST);
    TypeScript.StringLiteral = StringLiteral;

    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(id, alias) {
            _super.call(this);
            this.id = id;
            this.alias = alias;
            this._varFlags = 0 /* None */;
        }
        ImportDeclaration.prototype.nodeType = function () {
            return 18 /* ImportDeclaration */;
        };

        ImportDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ImportDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        ImportDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        ImportDeclaration.prototype.isExternalImportDeclaration = function () {
            if (this.alias.nodeType() == 22 /* Name */) {
                var text = this.alias.actualText;
                return TypeScript.isQuoted(text);
            }

            return false;
        };

        ImportDeclaration.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitImportDeclaration(this);
        };

        ImportDeclaration.prototype.emit = function (emitter) {
            emitter.emitImportDeclaration(this);
        };

        ImportDeclaration.prototype.getAliasName = function (aliasAST) {
            if (typeof aliasAST === "undefined") { aliasAST = this.alias; }
            if (aliasAST.nodeType() == 11 /* TypeRef */) {
                aliasAST = aliasAST.term;
            }

            if (aliasAST.nodeType() === 22 /* Name */) {
                return aliasAST.actualText;
            } else {
                var dotExpr = aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        };

        ImportDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.id, ast.id, includingPosition) && structuralEquals(this.alias, ast.alias, includingPosition);
        };
        return ImportDeclaration;
    })(AST);
    TypeScript.ImportDeclaration = ImportDeclaration;

    var ExportAssignment = (function (_super) {
        __extends(ExportAssignment, _super);
        function ExportAssignment(id) {
            _super.call(this);
            this.id = id;
        }
        ExportAssignment.prototype.nodeType = function () {
            return 90 /* ExportAssignment */;
        };

        ExportAssignment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };

        ExportAssignment.prototype.emit = function (emitter) {
            emitter.setExportAssignmentIdentifier(this.id.actualText);
        };
        return ExportAssignment;
    })(AST);
    TypeScript.ExportAssignment = ExportAssignment;

    var VariableDeclarator = (function (_super) {
        __extends(VariableDeclarator, _super);
        function VariableDeclarator(id, typeExpr, init) {
            _super.call(this);
            this.id = id;
            this.typeExpr = typeExpr;
            this.init = init;
            this.constantValue = null;
            this._varFlags = 0 /* None */;
        }
        VariableDeclarator.prototype.nodeType = function () {
            return 19 /* VariableDeclarator */;
        };

        VariableDeclarator.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 16 /* Static */);
        };

        VariableDeclarator.prototype.emit = function (emitter) {
            emitter.emitVariableDeclarator(this);
        };

        VariableDeclarator.prototype.isDeclaration = function () {
            return true;
        };

        VariableDeclarator.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        VariableDeclarator.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        VariableDeclarator.prototype.isProperty = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 256 /* Property */);
        };

        VariableDeclarator.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.typeExpr, ast.typeExpr, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };
        return VariableDeclarator;
    })(AST);
    TypeScript.VariableDeclarator = VariableDeclarator;

    var Parameter = (function (_super) {
        __extends(Parameter, _super);
        function Parameter(id, typeExpr, init, isOptional, isRest) {
            _super.call(this);
            this.id = id;
            this.typeExpr = typeExpr;
            this.init = init;
            this.isOptional = isOptional;
            this.isRest = isRest;
            this._varFlags = 0 /* None */;
        }
        Parameter.prototype.isDeclaration = function () {
            return true;
        };

        Parameter.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        Parameter.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        Parameter.prototype.nodeType = function () {
            return 21 /* Parameter */;
        };

        Parameter.prototype.isOptionalArg = function () {
            return this.isOptional || this.init !== null;
        };

        Parameter.prototype.isParameterProperty = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 256 /* Property */);
        };

        Parameter.prototype.emitWorker = function (emitter) {
            emitter.emitParameter(this);
        };

        Parameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.isOptional === ast.isOptional && this.isRest === ast.isRest;
        };
        return Parameter;
    })(AST);
    TypeScript.Parameter = Parameter;

    var ArrowFunctionExpression = (function (_super) {
        __extends(ArrowFunctionExpression, _super);
        function ArrowFunctionExpression(typeParameters, parameters, returnTypeAnnotation, block) {
            _super.call(this);
            this.typeParameters = typeParameters;
            this.parameters = parameters;
            this.returnTypeAnnotation = returnTypeAnnotation;
            this.block = block;
            this.hint = null;
        }
        ArrowFunctionExpression.prototype.isDeclaration = function () {
            return true;
        };

        ArrowFunctionExpression.prototype.nodeType = function () {
            return 82 /* ArrowFunctionExpression */;
        };

        ArrowFunctionExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.hint === ast.hint && structuralEquals(this.block, ast.block, includingPosition) && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.parameters, ast.parameters, includingPosition);
        };

        ArrowFunctionExpression.prototype.emit = function (emitter) {
            emitter.emitArrowFunctionExpression(this);
        };

        ArrowFunctionExpression.prototype.getNameText = function () {
            return this.hint;
        };
        return ArrowFunctionExpression;
    })(AST);
    TypeScript.ArrowFunctionExpression = ArrowFunctionExpression;

    var FunctionDeclaration = (function (_super) {
        __extends(FunctionDeclaration, _super);
        function FunctionDeclaration(name, isConstructor, typeParameters, parameters, returnTypeAnnotation, block) {
            _super.call(this);
            this.name = name;
            this.isConstructor = isConstructor;
            this.typeParameters = typeParameters;
            this.parameters = parameters;
            this.returnTypeAnnotation = returnTypeAnnotation;
            this.block = block;
            this.hint = null;
            this._functionFlags = 0 /* None */;
        }
        FunctionDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        FunctionDeclaration.prototype.nodeType = function () {
            return 13 /* FunctionDeclaration */;
        };

        FunctionDeclaration.prototype.getFunctionFlags = function () {
            return this._functionFlags;
        };

        FunctionDeclaration.prototype.setFunctionFlags = function (flags) {
            this._functionFlags = flags;
        };

        FunctionDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._functionFlags === ast._functionFlags && this.hint === ast.hint && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.block, ast.block, includingPosition) && this.isConstructor === ast.isConstructor && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.parameters, ast.parameters, includingPosition);
        };

        FunctionDeclaration.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitFunctionDeclaration(this);
        };

        FunctionDeclaration.prototype.emit = function (emitter) {
            emitter.emitFunctionDeclaration(this);
        };

        FunctionDeclaration.prototype.getNameText = function () {
            if (this.name) {
                return this.name.actualText;
            } else {
                return this.hint;
            }
        };

        FunctionDeclaration.prototype.isMethod = function () {
            return (this.getFunctionFlags() & 256 /* Method */) !== 0 /* None */;
        };

        FunctionDeclaration.prototype.isCallMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 512 /* CallMember */);
        };
        FunctionDeclaration.prototype.isConstructMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 1024 /* ConstructMember */);
        };
        FunctionDeclaration.prototype.isIndexerMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 4096 /* IndexerMember */);
        };
        FunctionDeclaration.prototype.isSpecialFn = function () {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();
        };
        FunctionDeclaration.prototype.isAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */) || TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isGetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */);
        };
        FunctionDeclaration.prototype.isSetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 16 /* Static */);
        };

        FunctionDeclaration.prototype.isSignature = function () {
            return (this.getFunctionFlags() & 128 /* Signature */) !== 0 /* None */;
        };
        return FunctionDeclaration;
    })(AST);
    TypeScript.FunctionDeclaration = FunctionDeclaration;

    var Script = (function (_super) {
        __extends(Script, _super);
        function Script(moduleElements, isExternalModule, isDeclareFile, amdDependencies) {
            _super.call(this);
            this.moduleElements = moduleElements;
            this.isExternalModule = isExternalModule;
            this.isDeclareFile = isDeclareFile;
            this.amdDependencies = amdDependencies;
            this._moduleFlags = 0 /* None */;
        }
        Script.prototype.nodeType = function () {
            return 2 /* Script */;
        };

        Script.prototype.getModuleFlags = function () {
            return this._moduleFlags;
        };

        Script.prototype.setModuleFlags = function (flags) {
            this._moduleFlags = flags;
        };

        Script.prototype.emit = function (emitter) {
            emitter.emitScript(this);
        };

        Script.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.moduleElements, ast.moduleElements, includingPosition);
        };
        return Script;
    })(AST);
    TypeScript.Script = Script;

    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(name, members, endingToken) {
            _super.call(this);
            this.name = name;
            this.members = members;
            this.endingToken = endingToken;
            this._moduleFlags = 0 /* None */;
        }
        ModuleDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ModuleDeclaration.prototype.nodeType = function () {
            return 17 /* ModuleDeclaration */;
        };

        ModuleDeclaration.prototype.getModuleFlags = function () {
            return this._moduleFlags;
        };

        ModuleDeclaration.prototype.setModuleFlags = function (flags) {
            this._moduleFlags = flags;
        };

        ModuleDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._moduleFlags === ast._moduleFlags && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition);
        };

        ModuleDeclaration.prototype.isEnum = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), 128 /* IsEnum */);
        };

        ModuleDeclaration.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitModuleDeclaration(this);
        };

        ModuleDeclaration.prototype.emit = function (emitter) {
            return emitter.emitModuleDeclaration(this);
        };
        return ModuleDeclaration;
    })(AST);
    TypeScript.ModuleDeclaration = ModuleDeclaration;

    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(name, typeParameters, extendsList, implementsList, members, endingToken) {
            _super.call(this);
            this.name = name;
            this.typeParameters = typeParameters;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this.members = members;
            this.endingToken = endingToken;
            this._varFlags = 0 /* None */;
        }
        ClassDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ClassDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        ClassDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        ClassDeclaration.prototype.nodeType = function () {
            return 14 /* ClassDeclaration */;
        };

        ClassDeclaration.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitClassDeclaration(this);
        };

        ClassDeclaration.prototype.emit = function (emitter) {
            emitter.emitClassDeclaration(this);
        };

        ClassDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition) && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.extendsList, ast.extendsList, includingPosition) && structuralEquals(this.implementsList, ast.implementsList, includingPosition);
        };
        return ClassDeclaration;
    })(AST);
    TypeScript.ClassDeclaration = ClassDeclaration;

    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(name, typeParameters, members, extendsList) {
            _super.call(this);
            this.name = name;
            this.typeParameters = typeParameters;
            this.members = members;
            this.extendsList = extendsList;
            this._varFlags = 0 /* None */;
        }
        InterfaceDeclaration.prototype.nodeType = function () {
            return 15 /* InterfaceDeclaration */;
        };

        InterfaceDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        InterfaceDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        InterfaceDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        InterfaceDeclaration.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitInterfaceDeclaration(this);
        };

        InterfaceDeclaration.prototype.emit = function (emitter) {
            emitter.emitInterfaceDeclaration(this);
        };

        InterfaceDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition) && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.extendsList, ast.extendsList, includingPosition);
        };
        return InterfaceDeclaration;
    })(AST);
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;

    var ObjectType = (function (_super) {
        __extends(ObjectType, _super);
        function ObjectType(members) {
            _super.call(this);
            this.members = members;
        }
        ObjectType.prototype.nodeType = function () {
            return 16 /* ObjectType */;
        };

        ObjectType.prototype.isDeclaration = function () {
            return true;
        };

        ObjectType.prototype.shouldEmit = function (emitter) {
            return false;
        };

        ObjectType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.members, ast.members, includingPosition);
        };
        return ObjectType;
    })(AST);
    TypeScript.ObjectType = ObjectType;

    var ThrowStatement = (function (_super) {
        __extends(ThrowStatement, _super);
        function ThrowStatement(expression) {
            _super.call(this);
            this.expression = expression;
        }
        ThrowStatement.prototype.nodeType = function () {
            return 98 /* ThrowStatement */;
        };

        ThrowStatement.prototype.isStatement = function () {
            return true;
        };

        ThrowStatement.prototype.emitWorker = function (emitter) {
            emitter.emitThrowStatement(this);
        };

        ThrowStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ThrowStatement;
    })(AST);
    TypeScript.ThrowStatement = ThrowStatement;

    var ExpressionStatement = (function (_super) {
        __extends(ExpressionStatement, _super);
        function ExpressionStatement(expression) {
            _super.call(this);
            this.expression = expression;
        }
        ExpressionStatement.prototype.nodeType = function () {
            return 91 /* ExpressionStatement */;
        };

        ExpressionStatement.prototype.isStatement = function () {
            return true;
        };

        ExpressionStatement.prototype.emitWorker = function (emitter) {
            emitter.emitExpressionStatement(this);
        };

        ExpressionStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ExpressionStatement;
    })(AST);
    TypeScript.ExpressionStatement = ExpressionStatement;

    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(identifier, statement) {
            _super.call(this);
            this.identifier = identifier;
            this.statement = statement;
        }
        LabeledStatement.prototype.nodeType = function () {
            return 95 /* LabeledStatement */;
        };

        LabeledStatement.prototype.isStatement = function () {
            return true;
        };

        LabeledStatement.prototype.emitWorker = function (emitter) {
            emitter.emitLabeledStatement(this);
        };

        LabeledStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.identifier, ast.identifier, includingPosition) && structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return LabeledStatement;
    })(AST);
    TypeScript.LabeledStatement = LabeledStatement;

    var VariableDeclaration = (function (_super) {
        __extends(VariableDeclaration, _super);
        function VariableDeclaration(declarators) {
            _super.call(this);
            this.declarators = declarators;
        }
        VariableDeclaration.prototype.nodeType = function () {
            return 20 /* VariableDeclaration */;
        };

        VariableDeclaration.prototype.emit = function (emitter) {
            emitter.emitVariableDeclaration(this);
        };

        VariableDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declarators, ast.declarators, includingPosition);
        };
        return VariableDeclaration;
    })(AST);
    TypeScript.VariableDeclaration = VariableDeclaration;

    var VariableStatement = (function (_super) {
        __extends(VariableStatement, _super);
        function VariableStatement(declaration) {
            _super.call(this);
            this.declaration = declaration;
        }
        VariableStatement.prototype.nodeType = function () {
            return 100 /* VariableStatement */;
        };

        VariableStatement.prototype.isStatement = function () {
            return true;
        };

        VariableStatement.prototype.shouldEmit = function (emitter) {
            return emitter.shouldEmitVariableStatement(this);
        };

        VariableStatement.prototype.emitWorker = function (emitter) {
            return emitter.emitVariableStatement(this);
        };

        VariableStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declaration, ast.declaration, includingPosition);
        };
        return VariableStatement;
    })(AST);
    TypeScript.VariableStatement = VariableStatement;

    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements, closeBraceSpan) {
            _super.call(this);
            this.statements = statements;
            this.closeBraceSpan = closeBraceSpan;
            this.closeBraceLeadingComments = null;
        }
        Block.prototype.nodeType = function () {
            return 84 /* Block */;
        };

        Block.prototype.isStatement = function () {
            return true;
        };

        Block.prototype.emitWorker = function (emitter) {
            emitter.emitBlock(this);
        };

        Block.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return Block;
    })(AST);
    TypeScript.Block = Block;

    var Jump = (function (_super) {
        __extends(Jump, _super);
        function Jump(_nodeType, target) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.target = target;
        }
        Jump.prototype.nodeType = function () {
            return this._nodeType;
        };

        Jump.prototype.isStatement = function () {
            return true;
        };

        Jump.prototype.emitWorker = function (emitter) {
            emitter.emitJump(this);
        };

        Jump.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.target === ast.target;
        };
        return Jump;
    })(AST);
    TypeScript.Jump = Jump;

    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(cond, body) {
            _super.call(this);
            this.cond = cond;
            this.body = body;
        }
        WhileStatement.prototype.nodeType = function () {
            return 101 /* WhileStatement */;
        };

        WhileStatement.prototype.isStatement = function () {
            return true;
        };

        WhileStatement.prototype.emitWorker = function (emitter) {
            emitter.emitWhileStatement(this);
        };

        WhileStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WhileStatement;
    })(AST);
    TypeScript.WhileStatement = WhileStatement;

    var DoStatement = (function (_super) {
        __extends(DoStatement, _super);
        function DoStatement(body, cond, whileSpan) {
            _super.call(this);
            this.body = body;
            this.cond = cond;
            this.whileSpan = whileSpan;
        }
        DoStatement.prototype.nodeType = function () {
            return 88 /* DoStatement */;
        };

        DoStatement.prototype.isStatement = function () {
            return true;
        };

        DoStatement.prototype.emitWorker = function (emitter) {
            emitter.emitDoStatement(this);
        };

        DoStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.body, ast.body, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition);
        };
        return DoStatement;
    })(AST);
    TypeScript.DoStatement = DoStatement;

    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(cond, thenBod, elseBod) {
            _super.call(this);
            this.cond = cond;
            this.thenBod = thenBod;
            this.elseBod = elseBod;
        }
        IfStatement.prototype.nodeType = function () {
            return 94 /* IfStatement */;
        };

        IfStatement.prototype.isStatement = function () {
            return true;
        };

        IfStatement.prototype.emitWorker = function (emitter) {
            emitter.emitIfStatement(this);
        };

        IfStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.thenBod, ast.thenBod, includingPosition) && structuralEquals(this.elseBod, ast.elseBod, includingPosition);
        };
        return IfStatement;
    })(AST);
    TypeScript.IfStatement = IfStatement;

    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement(returnExpression) {
            _super.call(this);
            this.returnExpression = returnExpression;
        }
        ReturnStatement.prototype.nodeType = function () {
            return 96 /* ReturnStatement */;
        };

        ReturnStatement.prototype.isStatement = function () {
            return true;
        };

        ReturnStatement.prototype.emitWorker = function (emitter) {
            emitter.emitReturnStatement(this);
        };

        ReturnStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.returnExpression, ast.returnExpression, includingPosition);
        };
        return ReturnStatement;
    })(AST);
    TypeScript.ReturnStatement = ReturnStatement;

    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(lval, obj, body) {
            _super.call(this);
            this.lval = lval;
            this.obj = obj;
            this.body = body;
        }
        ForInStatement.prototype.nodeType = function () {
            return 92 /* ForInStatement */;
        };

        ForInStatement.prototype.isStatement = function () {
            return true;
        };

        ForInStatement.prototype.emitWorker = function (emitter) {
            emitter.emitForInStatement(this);
        };

        ForInStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.lval, ast.lval, includingPosition) && structuralEquals(this.obj, ast.obj, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForInStatement;
    })(AST);
    TypeScript.ForInStatement = ForInStatement;

    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(init, cond, incr, body) {
            _super.call(this);
            this.init = init;
            this.cond = cond;
            this.incr = incr;
            this.body = body;
        }
        ForStatement.prototype.nodeType = function () {
            return 93 /* ForStatement */;
        };

        ForStatement.prototype.isStatement = function () {
            return true;
        };

        ForStatement.prototype.emitWorker = function (emitter) {
            emitter.emitForStatement(this);
        };

        ForStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.incr, ast.incr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForStatement;
    })(AST);
    TypeScript.ForStatement = ForStatement;

    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(expr, body) {
            _super.call(this);
            this.expr = expr;
            this.body = body;
        }
        WithStatement.prototype.nodeType = function () {
            return 102 /* WithStatement */;
        };

        WithStatement.prototype.isStatement = function () {
            return true;
        };

        WithStatement.prototype.emitWorker = function (emitter) {
            emitter.emitWithStatement(this);
        };

        WithStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WithStatement;
    })(AST);
    TypeScript.WithStatement = WithStatement;

    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(val, caseList, defaultCase, statement) {
            _super.call(this);
            this.val = val;
            this.caseList = caseList;
            this.defaultCase = defaultCase;
            this.statement = statement;
        }
        SwitchStatement.prototype.nodeType = function () {
            return 97 /* SwitchStatement */;
        };

        SwitchStatement.prototype.isStatement = function () {
            return true;
        };

        SwitchStatement.prototype.emitWorker = function (emitter) {
            emitter.emitSwitchStatement(this);
        };

        SwitchStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.caseList, ast.caseList, includingPosition) && structuralEquals(this.val, ast.val, includingPosition);
        };
        return SwitchStatement;
    })(AST);
    TypeScript.SwitchStatement = SwitchStatement;

    var CaseClause = (function (_super) {
        __extends(CaseClause, _super);
        function CaseClause(expr, body) {
            _super.call(this);
            this.expr = expr;
            this.body = body;
        }
        CaseClause.prototype.nodeType = function () {
            return 103 /* CaseClause */;
        };

        CaseClause.prototype.emitWorker = function (emitter) {
            emitter.emitCaseClause(this);
        };

        CaseClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CaseClause;
    })(AST);
    TypeScript.CaseClause = CaseClause;

    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(name, constraint) {
            _super.call(this);
            this.name = name;
            this.constraint = constraint;
        }
        TypeParameter.prototype.nodeType = function () {
            return 9 /* TypeParameter */;
        };

        TypeParameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.constraint, ast.constraint, includingPosition);
        };
        return TypeParameter;
    })(AST);
    TypeScript.TypeParameter = TypeParameter;

    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArguments) {
            _super.call(this);
            this.name = name;
            this.typeArguments = typeArguments;
        }
        GenericType.prototype.nodeType = function () {
            return 10 /* GenericType */;
        };

        GenericType.prototype.emit = function (emitter) {
            emitter.emitGenericType(this);
        };

        GenericType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition);
        };
        return GenericType;
    })(AST);
    TypeScript.GenericType = GenericType;

    var TypeQuery = (function (_super) {
        __extends(TypeQuery, _super);
        function TypeQuery(name) {
            _super.call(this);
            this.name = name;
        }
        TypeQuery.prototype.nodeType = function () {
            return 12 /* TypeQuery */;
        };

        TypeQuery.prototype.emit = function (emitter) {
            TypeScript.Emitter.throwEmitterError(new Error(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Should_not_emit_a_type_query, null)));
        };

        TypeQuery.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition);
        };
        return TypeQuery;
    })(AST);
    TypeScript.TypeQuery = TypeQuery;

    var TypeReference = (function (_super) {
        __extends(TypeReference, _super);
        function TypeReference(term, arrayCount) {
            _super.call(this);
            this.term = term;
            this.arrayCount = arrayCount;
            TypeScript.Debug.assert(term !== null && term !== undefined);
            this.minChar = term.minChar;
            this.limChar = term.limChar;
        }
        TypeReference.prototype.nodeType = function () {
            return 11 /* TypeRef */;
        };

        TypeReference.prototype.emit = function (emitter) {
            TypeScript.Emitter.throwEmitterError(new Error(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Should_not_emit_a_type_reference, null)));
        };

        TypeReference.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.term, ast.term, includingPosition) && this.arrayCount === ast.arrayCount;
        };
        return TypeReference;
    })(AST);
    TypeScript.TypeReference = TypeReference;

    var TryStatement = (function (_super) {
        __extends(TryStatement, _super);
        function TryStatement(tryBody, catchClause, finallyBody) {
            _super.call(this);
            this.tryBody = tryBody;
            this.catchClause = catchClause;
            this.finallyBody = finallyBody;
        }
        TryStatement.prototype.nodeType = function () {
            return 99 /* TryStatement */;
        };

        TryStatement.prototype.isStatement = function () {
            return true;
        };

        TryStatement.prototype.emitWorker = function (emitter) {
            emitter.emitTryStatement(this);
        };

        TryStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.tryBody, ast.tryBody, includingPosition) && structuralEquals(this.catchClause, ast.catchClause, includingPosition) && structuralEquals(this.finallyBody, ast.finallyBody, includingPosition);
        };
        return TryStatement;
    })(AST);
    TypeScript.TryStatement = TryStatement;

    var CatchClause = (function (_super) {
        __extends(CatchClause, _super);
        function CatchClause(param, body) {
            _super.call(this);
            this.param = param;
            this.body = body;
        }
        CatchClause.prototype.nodeType = function () {
            return 104 /* CatchClause */;
        };

        CatchClause.prototype.emitWorker = function (emitter) {
            emitter.emitCatchClause(this);
        };

        CatchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.param, ast.param, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CatchClause;
    })(AST);
    TypeScript.CatchClause = CatchClause;

    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
            _super.apply(this, arguments);
        }
        DebuggerStatement.prototype.nodeType = function () {
            return 87 /* DebuggerStatement */;
        };

        DebuggerStatement.prototype.isStatement = function () {
            return true;
        };

        DebuggerStatement.prototype.emitWorker = function (emitter) {
            emitter.emitDebuggerStatement(this);
        };
        return DebuggerStatement;
    })(AST);
    TypeScript.DebuggerStatement = DebuggerStatement;

    var OmittedExpression = (function (_super) {
        __extends(OmittedExpression, _super);
        function OmittedExpression() {
            _super.apply(this, arguments);
        }
        OmittedExpression.prototype.nodeType = function () {
            return 25 /* OmittedExpression */;
        };

        OmittedExpression.prototype.emitWorker = function (emitter) {
        };

        OmittedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return OmittedExpression;
    })(AST);
    TypeScript.OmittedExpression = OmittedExpression;

    var EmptyStatement = (function (_super) {
        __extends(EmptyStatement, _super);
        function EmptyStatement() {
            _super.apply(this, arguments);
        }
        EmptyStatement.prototype.nodeType = function () {
            return 89 /* EmptyStatement */;
        };

        EmptyStatement.prototype.isStatement = function () {
            return true;
        };

        EmptyStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutputWithSourceMapRecord(";", this);
        };

        EmptyStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return EmptyStatement;
    })(AST);
    TypeScript.EmptyStatement = EmptyStatement;

    var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(content, isBlockComment, endsLine) {
            _super.call(this);
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            this.text = null;
            this.docCommentText = null;
        }
        Comment.prototype.nodeType = function () {
            return 105 /* Comment */;
        };

        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.content === ast.content && this.isBlockComment === ast.isBlockComment && this.endsLine === ast.endsLine;
        };

        Comment.prototype.isPinnedOrTripleSlash = function () {
            if (this.content.match(TypeScript.tripleSlashReferenceRegExp)) {
                return true;
            } else {
                return this.content.indexOf("/*!") === 0;
            }
        };

        Comment.prototype.getText = function () {
            if (this.text === null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for (var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                } else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
                }
            }

            return this.text;
        };

        Comment.prototype.isDocComment = function () {
            if (this.isBlockComment) {
                return this.content.charAt(2) === "*" && this.content.charAt(3) !== "/";
            }

            return false;
        };

        Comment.prototype.getDocCommentTextValue = function () {
            if (this.docCommentText === null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }

            return this.docCommentText;
        };

        Comment.consumeLeadingSpace = function (line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = TypeScript.min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== 32 /* space */ && charCode !== 9 /* tab */) {
                    return startIndex;
                }
            }

            if (endIndex !== line.length) {
                return endIndex;
            }

            return -1;
        };

        Comment.isSpaceChar = function (line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);

                return charCode === 32 /* space */ || charCode === 9 /* tab */;
            }

            return index === length;
        };

        Comment.cleanDocCommentLine = function (line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        };

        Comment.cleanJSDocComment = function (content, spacesToRemove) {
            var docCommentLines = new Array();
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;

                    if (line.indexOf("param", i + 1) === i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }

                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }

            return docCommentLines.join("\n");
        };

        Comment.getDocCommentText = function (comments) {
            var docCommentText = new Array();
            for (var c = 0; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentTextValue();
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };

        Comment.getParameterDocCommentText = function (param, fncDocComments) {
            if (fncDocComments.length === 0 || !fncDocComments[0].isBlockComment) {
                return "";
            }

            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }

                    if (commentContents.charCodeAt(j) === 123 /* openBrace */) {
                        j++;

                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);

                            if (charCode === 123 /* openBrace */) {
                                curlies++;
                                continue;
                            }

                            if (charCode === 125 /* closeBrace */) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }

                            if (charCode === 64 /* at */) {
                                break;
                            }
                        }

                        if (j === commentContents.length) {
                            break;
                        }

                        if (charCode === 64 /* at */) {
                            continue;
                        }

                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    if (param !== commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }

                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        };
        return Comment;
    })(AST);
    TypeScript.Comment = Comment;
})(TypeScript || (TypeScript = {}));


var IOUtils;
(function (IOUtils) {
    function createDirectoryStructure(ioHost, dirName) {
        if (ioHost.directoryExists(dirName)) {
            return;
        }

        var parentDirectory = ioHost.dirName(dirName);
        if (parentDirectory != "") {
            createDirectoryStructure(ioHost, parentDirectory);
        }
        ioHost.createDirectory(dirName);
    }

    function writeFileAndFolderStructure(ioHost, fileName, contents, writeByteOrderMark) {
        var start = new Date().getTime();
        var path = ioHost.resolvePath(fileName);
        TypeScript.ioHostResolvePathTime += new Date().getTime() - start;

        var start = new Date().getTime();
        var dirName = ioHost.dirName(path);
        TypeScript.ioHostDirectoryNameTime += new Date().getTime() - start;

        var start = new Date().getTime();
        createDirectoryStructure(ioHost, dirName);
        TypeScript.ioHostCreateDirectoryStructureTime += new Date().getTime() - start;

        var start = new Date().getTime();
        ioHost.writeFile(path, contents, writeByteOrderMark);
        TypeScript.ioHostWriteFileTime += new Date().getTime() - start;
    }
    IOUtils.writeFileAndFolderStructure = writeFileAndFolderStructure;

    function throwIOError(message, error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }
    IOUtils.throwIOError = throwIOError;

    function combine(prefix, suffix) {
        return prefix + "/" + suffix;
    }
    IOUtils.combine = combine;

    var BufferedTextWriter = (function () {
        function BufferedTextWriter(writer, capacity) {
            if (typeof capacity === "undefined") { capacity = 1024; }
            this.writer = writer;
            this.capacity = capacity;
            this.buffer = "";
        }
        BufferedTextWriter.prototype.Write = function (str) {
            this.buffer += str;
            if (this.buffer.length >= this.capacity) {
                this.writer.Write(this.buffer);
                this.buffer = "";
            }
        };
        BufferedTextWriter.prototype.WriteLine = function (str) {
            this.Write(str + '\r\n');
        };
        BufferedTextWriter.prototype.Close = function () {
            this.writer.Write(this.buffer);
            this.writer.Close();
            this.buffer = null;
        };
        return BufferedTextWriter;
    })();
    IOUtils.BufferedTextWriter = BufferedTextWriter;
})(IOUtils || (IOUtils = {}));



var IO = (function () {
    function getWindowsScriptHostIO() {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var streamObjectPool = [];

        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            readFile: function (path, codepage) {
                return Environment.readFile(path, codepage);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                Environment.writeFile(path, contents, writeByteOrderMark);
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            resolvePath: function (path) {
                return fso.GetAbsolutePathName(path);
            },
            dirName: function (path) {
                return fso.GetParentFolderName(path);
            },
            findFile: function (rootPath, partialFilePath) {
                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;

                while (true) {
                    if (fso.FileExists(path)) {
                        return { fileInformation: this.readFile(path), path: path };
                    } else {
                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));

                        if (rootPath == "") {
                            return null;
                        } else {
                            path = fso.BuildPath(rootPath, partialFilePath);
                        }
                    }
                }
            },
            deleteFile: function (path) {
                try  {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true);
                    }
                } catch (e) {
                    IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_delete_file_0, [path]), e);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        fso.CreateFolder(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                }
            },
            dir: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "/" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },
            print: function (str) {
                WScript.StdOut.Write(str);
            },
            printLine: function (str) {
                WScript.Echo(str);
            },
            arguments: args,
            stderr: WScript.StdErr,
            stdout: WScript.StdOut,
            watchFile: null,
            run: function (source, fileName) {
                try  {
                    eval(source);
                } catch (e) {
                    IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Error_while_executing_file_0, [fileName]), e);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            quit: function (exitCode) {
                if (typeof exitCode === "undefined") { exitCode = 0; }
                try  {
                    WScript.Quit(exitCode);
                } catch (e) {
                }
            }
        };
    }
    ;

    function getNodeIO() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');

        return {
            readFile: function (file, codepage) {
                return Environment.readFile(file, codepage);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                Environment.writeFile(path, contents, writeByteOrderMark);
            },
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                    IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_delete_file_0, [path]), e);
                }
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            dir: function dir(path, spec, options) {
                options = options || {};

                function filesInFolder(folder) {
                    var paths = [];

                    try  {
                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var stat = _fs.statSync(folder + "/" + files[i]);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                            } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(folder + "/" + files[i]);
                            }
                        }
                    } catch (err) {
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        _fs.mkdirSync(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_create_directory_0, [path]), e);
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            resolvePath: function (path) {
                return _path.resolve(path);
            },
            dirName: function (path) {
                var dirPath = _path.dirname(path);

                if (dirPath === path) {
                    dirPath = null;
                }

                return dirPath;
            },
            findFile: function (rootPath, partialFilePath) {
                var path = rootPath + "/" + partialFilePath;

                while (true) {
                    if (_fs.existsSync(path)) {
                        return { fileInformation: this.readFile(path), path: path };
                    } else {
                        var parentPath = _path.resolve(rootPath, "..");

                        if (rootPath === parentPath) {
                            return null;
                        } else {
                            rootPath = parentPath;
                            path = _path.resolve(rootPath, partialFilePath);
                        }
                    }
                }
            },
            print: function (str) {
                process.stdout.write(str);
            },
            printLine: function (str) {
                process.stdout.write(str + '\n');
            },
            arguments: process.argv.slice(2),
            stderr: {
                Write: function (str) {
                    process.stderr.write(str);
                },
                WriteLine: function (str) {
                    process.stderr.write(str + '\n');
                },
                Close: function () {
                }
            },
            stdout: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            },
            watchFile: function (fileName, callback) {
                var firstRun = true;
                var processingChange = false;

                var fileChanged = function (curr, prev) {
                    if (!firstRun) {
                        if (curr.mtime < prev.mtime) {
                            return;
                        }

                        _fs.unwatchFile(fileName, fileChanged);
                        if (!processingChange) {
                            processingChange = true;
                            callback(fileName);
                            setTimeout(function () {
                                processingChange = false;
                            }, 100);
                        }
                    }
                    firstRun = false;
                    _fs.watchFile(fileName, { persistent: true, interval: 500 }, fileChanged);
                };

                fileChanged();
                return {
                    fileName: fileName,
                    close: function () {
                        _fs.unwatchFile(fileName, fileChanged);
                    }
                };
            },
            run: function (source, fileName) {
                require.main.fileName = fileName;
                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(fileName)));
                require.main._compile(source, fileName);
            },
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            quit: function (code) {
                var stderrFlushed = process.stderr.write('');
                var stdoutFlushed = process.stdout.write('');
                process.stderr.on('drain', function () {
                    stderrFlushed = true;
                    if (stdoutFlushed) {
                        process.exit(code);
                    }
                });
                process.stdout.on('drain', function () {
                    stdoutFlushed = true;
                    if (stderrFlushed) {
                        process.exit(code);
                    }
                });
                setTimeout(function () {
                    process.exit(code);
                }, 5);
            }
        };
    }
    ;

    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function")
        return getWindowsScriptHostIO();
    else if (typeof module !== 'undefined' && module.exports)
        return getNodeIO();
    else
        return null;
})();
var TypeScript;
(function (TypeScript) {
    var OptionsParser = (function () {
        function OptionsParser(host, version) {
            this.host = host;
            this.version = version;
            this.DEFAULT_SHORT_FLAG = "-";
            this.DEFAULT_LONG_FLAG = "--";
            this.printedVersion = false;
            this.unnamed = [];
            this.options = [];
        }
        OptionsParser.prototype.findOption = function (arg) {
            var upperCaseArg = arg && arg.toUpperCase();

            for (var i = 0; i < this.options.length; i++) {
                var current = this.options[i];

                if (upperCaseArg === (current.short && current.short.toUpperCase()) || upperCaseArg === (current.name && current.name.toUpperCase())) {
                    return current;
                }
            }

            return null;
        };

        OptionsParser.prototype.printUsage = function () {
            this.printVersion();

            var optionsWord = TypeScript.getLocalizedText(TypeScript.DiagnosticCode.options, null);
            var fileWord = TypeScript.getLocalizedText(TypeScript.DiagnosticCode.file1, null);
            var tscSyntax = "tsc [" + optionsWord + "] [" + fileWord + " ..]";
            var syntaxHelp = TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Syntax_0, [tscSyntax]);
            this.host.printLine(syntaxHelp);
            this.host.printLine("");
            this.host.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Examples, null) + " tsc hello.ts");
            this.host.printLine("          tsc --out foo.js foo.ts");
            this.host.printLine("          tsc @args.txt");
            this.host.printLine("");
            this.host.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Options, null));

            var output = [];
            var maxLength = 0;
            var i = 0;

            this.options = this.options.sort(function (a, b) {
                var aName = a.name.toLowerCase();
                var bName = b.name.toLowerCase();

                if (aName > bName) {
                    return 1;
                } else if (aName < bName) {
                    return -1;
                } else {
                    return 0;
                }
            });

            for (i = 0; i < this.options.length; i++) {
                var option = this.options[i];

                if (option.experimental) {
                    continue;
                }

                if (!option.usage) {
                    break;
                }

                var usageString = "  ";
                var type = option.type ? (" " + TypeScript.getLocalizedText(option.type, null)) : "";

                if (option.short) {
                    usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
                }

                usageString += this.DEFAULT_LONG_FLAG + option.name + type;

                output.push([usageString, TypeScript.getLocalizedText(option.usage.locCode, option.usage.args)]);

                if (usageString.length > maxLength) {
                    maxLength = usageString.length;
                }
            }

            var fileDescription = TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Insert_command_line_options_and_files_from_a_file, null);
            output.push(["  @<" + fileWord + ">", fileDescription]);

            for (i = 0; i < output.length; i++) {
                this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
            }
        };

        OptionsParser.prototype.printVersion = function () {
            if (!this.printedVersion) {
                this.host.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Version_0, [this.version]));
                this.printedVersion = true;
            }
        };

        OptionsParser.prototype.option = function (name, config, short) {
            if (!config) {
                config = short;
                short = null;
            }

            config.name = name;
            config.short = short;
            config.flag = false;

            this.options.push(config);
        };

        OptionsParser.prototype.flag = function (name, config, short) {
            if (!config) {
                config = short;
                short = null;
            }

            config.name = name;
            config.short = short;
            config.flag = true;

            this.options.push(config);
        };

        OptionsParser.prototype.parseString = function (argString) {
            var position = 0;
            var tokens = argString.match(/\s+|"|[^\s"]+/g);

            function peek() {
                return tokens[position];
            }

            function consume() {
                return tokens[position++];
            }

            function consumeQuotedString() {
                var value = '';
                consume();

                var token = peek();

                while (token && token !== '"') {
                    consume();

                    value += token;

                    token = peek();
                }

                consume();

                return value;
            }

            var args = [];
            var currentArg = '';

            while (position < tokens.length) {
                var token = peek();

                if (token === '"') {
                    currentArg += consumeQuotedString();
                } else if (token.match(/\s/)) {
                    if (currentArg.length > 0) {
                        args.push(currentArg);
                        currentArg = '';
                    }

                    consume();
                } else {
                    consume();
                    currentArg += token;
                }
            }

            if (currentArg.length > 0) {
                args.push(currentArg);
            }

            this.parse(args);
        };

        OptionsParser.prototype.parse = function (args) {
            var position = 0;

            function consume() {
                return args[position++];
            }

            while (position < args.length) {
                var current = consume();
                var match = current.match(/^(--?|@)(.*)/);
                var value = null;

                if (match) {
                    if (match[1] === '@') {
                        this.parseString(this.host.readFile(match[2], null).contents);
                    } else {
                        var arg = match[2];
                        var option = this.findOption(arg);

                        if (option === null) {
                            this.host.printLine(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unknown_option_0, [arg]));
                            this.host.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Use_the_0_flag_to_see_options, ["--help"]));
                        } else {
                            if (!option.flag) {
                                value = consume();
                                if (value === undefined) {
                                    this.host.printLine(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Option_0_specified_without_1, [arg, TypeScript.getLocalizedText(option.type, null)]));
                                    this.host.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Use_the_0_flag_to_see_options, ["--help"]));
                                    continue;
                                }
                            }

                            option.set(value);
                        }
                    }
                } else {
                    this.unnamed.push(current);
                }
            }
        };
        return OptionsParser;
    })();
    TypeScript.OptionsParser = OptionsParser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceFile = (function () {
        function SourceFile(scriptSnapshot, byteOrderMark) {
            this.scriptSnapshot = scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
        }
        return SourceFile;
    })();

    var DiagnosticsLogger = (function () {
        function DiagnosticsLogger(ioHost) {
            this.ioHost = ioHost;
        }
        DiagnosticsLogger.prototype.information = function () {
            return false;
        };
        DiagnosticsLogger.prototype.debug = function () {
            return false;
        };
        DiagnosticsLogger.prototype.warning = function () {
            return false;
        };
        DiagnosticsLogger.prototype.error = function () {
            return false;
        };
        DiagnosticsLogger.prototype.fatal = function () {
            return false;
        };
        DiagnosticsLogger.prototype.log = function (s) {
            this.ioHost.stdout.WriteLine(s);
        };
        return DiagnosticsLogger;
    })();

    TypeScript.useDirectTypeStorage = true;

    var BatchCompiler = (function () {
        function BatchCompiler(ioHost) {
            this.ioHost = ioHost;
            this.compilerVersion = "0.9.1.1";
            this.inputFiles = [];
            this.resolvedFiles = [];
            this.inputFileNameToOutputFileName = new TypeScript.StringHashTable();
            this.fileNameToSourceFile = new TypeScript.StringHashTable();
            this.hasErrors = false;
            this.logger = null;
            this.tcOnly = false;
            this.compilationSettings = new TypeScript.CompilationSettings();
        }
        BatchCompiler.prototype.batchCompile = function () {
            var _this = this;
            var start = new Date().getTime();

            TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: function (s) {
                    _this.ioHost.printLine(s);
                } };

            if (this.parseOptions()) {
                this.logger = this.compilationSettings.gatherDiagnostics ? new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();

                if (this.compilationSettings.watch) {
                    this.watchFiles();
                    return;
                }

                this.resolve();

                if (!this.compilationSettings.updateTC) {
                    this.compile();

                    if (this.compilationSettings.gatherDiagnostics) {
                        this.logger.log("");
                        this.logger.log("File resolution time:                     " + TypeScript.fileResolutionTime);
                        this.logger.log("SyntaxTree parse time:                    " + TypeScript.syntaxTreeParseTime);
                        this.logger.log("Syntax Diagnostics time:                  " + TypeScript.syntaxDiagnosticsTime);
                        this.logger.log("AST translation time:                     " + TypeScript.astTranslationTime);
                        this.logger.log("");
                        this.logger.log("Type check time:                          " + TypeScript.typeCheckTime);
                        this.logger.log("");
                        this.logger.log("Emit time:                                " + TypeScript.emitTime);
                        this.logger.log("Declaration emit time:                    " + TypeScript.declarationEmitTime);

                        this.logger.log("  IsExternallyVisibleTime:                " + TypeScript.declarationEmitIsExternallyVisibleTime);
                        this.logger.log("  TypeSignatureTime:                      " + TypeScript.declarationEmitTypeSignatureTime);
                        this.logger.log("  GetBoundDeclTypeTime:                   " + TypeScript.declarationEmitGetBoundDeclTypeTime);
                        this.logger.log("  IsOverloadedCallSignatureTime:          " + TypeScript.declarationEmitIsOverloadedCallSignatureTime);
                        this.logger.log("  FunctionDeclarationGetSymbolTime:       " + TypeScript.declarationEmitFunctionDeclarationGetSymbolTime);
                        this.logger.log("  GetBaseTypeTime:                        " + TypeScript.declarationEmitGetBaseTypeTime);
                        this.logger.log("  GetAccessorFunctionTime:                " + TypeScript.declarationEmitGetAccessorFunctionTime);
                        this.logger.log("  GetTypeParameterSymbolTime:             " + TypeScript.declarationEmitGetTypeParameterSymbolTime);
                        this.logger.log("  GetImportDeclarationSymbolTime:         " + TypeScript.declarationEmitGetImportDeclarationSymbolTime);

                        this.logger.log("Emit write file time:                     " + TypeScript.emitWriteFileTime);
                        this.logger.log("Emit directory exists time:               " + TypeScript.emitDirectoryExistsTime);
                        this.logger.log("Emit file exists time:                    " + TypeScript.emitFileExistsTime);
                        this.logger.log("Emit resolve path time:                   " + TypeScript.emitResolvePathTime);

                        this.logger.log("IO host resolve path time:                " + TypeScript.ioHostResolvePathTime);
                        this.logger.log("IO host directory name time:              " + TypeScript.ioHostDirectoryNameTime);
                        this.logger.log("IO host create directory structure time:  " + TypeScript.ioHostCreateDirectoryStructureTime);
                        this.logger.log("IO host write file time:                  " + TypeScript.ioHostWriteFileTime);

                        this.logger.log("Node make directory time:                 " + TypeScript.nodeMakeDirectoryTime);
                        this.logger.log("Node writeFileSync time:                  " + TypeScript.nodeWriteFileSyncTime);
                        this.logger.log("Node createBuffer time:                   " + TypeScript.nodeCreateBufferTime);
                    }
                } else {
                    this.updateCompile();
                }
            }

            this.ioHost.quit(this.hasErrors ? 1 : 0);
        };

        BatchCompiler.prototype.resolve = function () {
            var includeDefaultLibrary = !this.compilationSettings.noLib;
            var resolvedFiles = [];

            var start = new Date().getTime();

            if (!this.compilationSettings.noResolve) {
                var resolutionResults = TypeScript.ReferenceResolver.resolve(this.inputFiles, this, this.compilationSettings);
                resolvedFiles = resolutionResults.resolvedFiles;

                includeDefaultLibrary = !this.compilationSettings.noLib && !resolutionResults.seenNoDefaultLibTag;

                for (var i = 0, n = resolutionResults.diagnostics.length; i < n; i++) {
                    this.addDiagnostic(resolutionResults.diagnostics[i]);
                }
            } else {
                for (var i = 0, n = this.inputFiles.length; i < n; i++) {
                    var inputFile = this.inputFiles[i];
                    var referencedFiles = [];
                    var importedFiles = [];

                    if (this.compilationSettings.generateDeclarationFiles) {
                        var references = TypeScript.getReferencedFiles(inputFile, this.getScriptSnapshot(inputFile));
                        for (var j = 0; j < references.length; j++) {
                            referencedFiles.push(references[j].path);
                        }

                        inputFile = this.ioHost.resolvePath(inputFile);
                    }

                    resolvedFiles.push({
                        path: inputFile,
                        referencedFiles: referencedFiles,
                        importedFiles: importedFiles
                    });
                }
            }

            if (includeDefaultLibrary) {
                var libraryResolvedFile = {
                    path: this.getDefaultLibraryFilePath(),
                    referencedFiles: [],
                    importedFiles: []
                };

                resolvedFiles = [libraryResolvedFile].concat(resolvedFiles);
            }

            this.resolvedFiles = resolvedFiles;

            TypeScript.fileResolutionTime = new Date().getTime() - start;
        };

        BatchCompiler.prototype.compile = function () {
            var _this = this;
            var compiler = new TypeScript.TypeScriptCompiler(this.logger, this.compilationSettings);

            var anySyntacticErrors = false;
            var anySemanticErrors = false;

            for (var i = 0, n = this.resolvedFiles.length; i < n; i++) {
                var resolvedFile = this.resolvedFiles[i];
                var sourceFile = this.getSourceFile(resolvedFile.path);
                compiler.addSourceUnit(resolvedFile.path, sourceFile.scriptSnapshot, sourceFile.byteOrderMark, 0, false, resolvedFile.referencedFiles);

                var syntacticDiagnostics = compiler.getSyntacticDiagnostics(resolvedFile.path);
                compiler.reportDiagnostics(syntacticDiagnostics, this);

                if (syntacticDiagnostics.length > 0) {
                    anySyntacticErrors = true;
                }
            }

            if (anySyntacticErrors) {
                return true;
            }

            compiler.pullTypeCheck();
            var fileNames = compiler.fileNameToDocument.getAllKeys();
            var n = fileNames.length;
            for (var i = 0; i < n; i++) {
                var fileName = fileNames[i];
                var semanticDiagnostics = compiler.getSemanticDiagnostics(fileName);
                if (semanticDiagnostics.length > 0) {
                    anySemanticErrors = true;
                    compiler.reportDiagnostics(semanticDiagnostics, this);
                }
            }

            if (!this.tcOnly) {
                var mapInputToOutput = function (inputFile, outputFile) {
                    _this.inputFileNameToOutputFileName.addOrUpdate(inputFile, outputFile);
                };

                var emitDiagnostics = compiler.emitAll(this, mapInputToOutput);
                compiler.reportDiagnostics(emitDiagnostics, this);
                if (emitDiagnostics.length > 0) {
                    return true;
                }

                if (anySemanticErrors) {
                    return true;
                }

                var emitDeclarationsDiagnostics = compiler.emitAllDeclarations();
                compiler.reportDiagnostics(emitDeclarationsDiagnostics, this);
                if (emitDeclarationsDiagnostics.length > 0) {
                    return true;
                }
            }

            return false;
        };

        BatchCompiler.prototype.updateCompile = function () {
            var compiler = new TypeScript.TypeScriptCompiler(this.logger, this.compilationSettings);

            var anySyntacticErrors = false;
            var foundLib = false;

            for (var iCode = 0, n = this.resolvedFiles.length; iCode < n; iCode++) {
                var resolvedFile = this.resolvedFiles[iCode];

                if (resolvedFile.path.indexOf("lib.d.ts") != -1) {
                    foundLib = true;
                } else if ((foundLib && iCode > 1) || (!foundLib && iCode > 0)) {
                    break;
                }

                this.ioHost.stdout.WriteLine("Consuming " + resolvedFile.path + "...");

                var sourceFile = this.getSourceFile(resolvedFile.path);
                compiler.addSourceUnit(resolvedFile.path, sourceFile.scriptSnapshot, sourceFile.byteOrderMark, 0, true, resolvedFile.referencedFiles);

                var syntacticDiagnostics = compiler.getSyntacticDiagnostics(resolvedFile.path);
                compiler.reportDiagnostics(syntacticDiagnostics, this);

                if (syntacticDiagnostics.length > 0) {
                    anySyntacticErrors = true;
                }
            }

            this.ioHost.stdout.WriteLine("**** Initial type check errors:");
            compiler.pullTypeCheck();

            var semanticDiagnostics;

            for (var i = 0; i < iCode; i++) {
                semanticDiagnostics = compiler.getSemanticDiagnostics(this.resolvedFiles[i].path);
                compiler.reportDiagnostics(semanticDiagnostics, this);
            }

            if (iCode && iCode <= this.resolvedFiles.length - 1) {
                var lastTypecheckedFileName = this.resolvedFiles[iCode - 1].path;
                var snapshot;

                for (; iCode < this.resolvedFiles.length; iCode++) {
                    var resolvedFile = this.resolvedFiles[iCode];
                    var sourceFile = this.getSourceFile(resolvedFile.path);
                    this.ioHost.stdout.WriteLine("**** Update type check and errors for " + resolvedFile.path + ":");

                    compiler.updateSourceUnit(lastTypecheckedFileName, sourceFile.scriptSnapshot, 0, true, null);

                    semanticDiagnostics = compiler.getSemanticDiagnostics(lastTypecheckedFileName);
                    compiler.reportDiagnostics(semanticDiagnostics, this);
                }
            }

            return false;
        };

        BatchCompiler.prototype.parseOptions = function () {
            var _this = this;
            var opts = new TypeScript.OptionsParser(this.ioHost, this.compilerVersion);

            opts.option('out', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Concatenate_and_emit_output_to_single_file,
                    args: null
                },
                type: TypeScript.DiagnosticCode.file2,
                set: function (str) {
                    _this.compilationSettings.outFileOption = str;
                }
            });

            opts.option('outDir', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Redirect_output_structure_to_the_directory,
                    args: null
                },
                type: TypeScript.DiagnosticCode.DIRECTORY,
                set: function (str) {
                    _this.compilationSettings.outDirOption = str;
                }
            });

            opts.flag('sourcemap', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Generates_corresponding_0_file,
                    args: ['.map']
                },
                set: function () {
                    _this.compilationSettings.mapSourceFiles = true;
                }
            });

            opts.option('mapRoot', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,
                    args: null
                },
                type: TypeScript.DiagnosticCode.LOCATION,
                set: function (str) {
                    _this.compilationSettings.mapRoot = str;
                }
            });

            opts.option('sourceRoot', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,
                    args: null
                },
                type: TypeScript.DiagnosticCode.LOCATION,
                set: function (str) {
                    _this.compilationSettings.sourceRoot = str;
                }
            });

            opts.flag('declaration', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Generates_corresponding_0_file,
                    args: ['.d.ts']
                },
                set: function () {
                    _this.compilationSettings.generateDeclarationFiles = true;
                }
            }, 'd');

            if (this.ioHost.watchFile) {
                opts.flag('watch', {
                    usage: {
                        locCode: TypeScript.DiagnosticCode.Watch_input_files,
                        args: null
                    },
                    set: function () {
                        _this.compilationSettings.watch = true;
                    }
                }, 'w');
            }

            opts.flag('propagateEnumConstants', {
                experimental: true,
                set: function () {
                    _this.compilationSettings.propagateEnumConstants = true;
                }
            });

            opts.flag('removeComments', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Do_not_emit_comments_to_output,
                    args: null
                },
                set: function () {
                    _this.compilationSettings.removeComments = true;
                }
            });

            opts.flag('noResolve', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Skip_resolution_and_preprocessing,
                    args: null
                },
                set: function () {
                    _this.compilationSettings.noResolve = true;
                }
            });

            opts.flag('noLib', {
                experimental: true,
                set: function () {
                    _this.compilationSettings.noLib = true;
                }
            });

            opts.flag('diagnostics', {
                experimental: true,
                set: function () {
                    _this.compilationSettings.gatherDiagnostics = true;
                }
            });

            opts.flag('update', {
                experimental: true,
                set: function () {
                    _this.compilationSettings.updateTC = true;
                }
            });

            opts.option('target', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Specify_ECMAScript_target_version_0_default_or_1,
                    args: ['ES3', 'ES5']
                },
                type: TypeScript.DiagnosticCode.VERSION,
                set: function (type) {
                    type = type.toLowerCase();

                    if (type === 'es3') {
                        _this.compilationSettings.codeGenTarget = 0 /* EcmaScript3 */;
                    } else if (type === 'es5') {
                        _this.compilationSettings.codeGenTarget = 1 /* EcmaScript5 */;
                    } else {
                        _this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2, [type, "ES3", "ES5"]));
                    }
                }
            }, 't');

            opts.option('module', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Specify_module_code_generation_0_or_1,
                    args: ['commonjs', 'amd']
                },
                type: TypeScript.DiagnosticCode.KIND,
                set: function (type) {
                    type = type.toLowerCase();

                    if (type === 'commonjs') {
                        _this.compilationSettings.moduleGenTarget = 1 /* Synchronous */;
                    } else if (type === 'amd') {
                        _this.compilationSettings.moduleGenTarget = 2 /* Asynchronous */;
                    } else {
                        _this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Module_code_generation_0_not_supported, [type]));
                    }
                }
            }, 'm');

            var needsHelp = false;
            opts.flag('help', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Print_this_message,
                    args: null
                },
                set: function () {
                    needsHelp = true;
                }
            }, 'h');

            opts.flag('useCaseSensitiveFileResolution', {
                experimental: true,
                set: function () {
                    _this.compilationSettings.useCaseSensitiveFileResolution = true;
                }
            });
            var shouldPrintVersionOnly = false;
            opts.flag('version', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Print_the_compiler_s_version_0,
                    args: [this.compilerVersion]
                },
                set: function () {
                    shouldPrintVersionOnly = true;
                }
            }, 'v');

            var locale = null;
            opts.option('locale', {
                experimental: true,
                usage: {
                    locCode: TypeScript.DiagnosticCode.Specify_locale_for_errors_and_messages_For_example_0_or_1,
                    args: ['en', 'ja-jp']
                },
                type: TypeScript.DiagnosticCode.STRING,
                set: function (value) {
                    locale = value;
                }
            });

            opts.flag('noImplicitAny', {
                usage: {
                    locCode: TypeScript.DiagnosticCode.Warn_on_expressions_and_declarations_with_an_implied_any_type,
                    args: null
                },
                set: function () {
                    _this.compilationSettings.noImplicitAny = true;
                }
            });

            if (Environment.supportsCodePage()) {
                opts.option('codepage', {
                    usage: {
                        locCode: TypeScript.DiagnosticCode.Specify_the_codepage_to_use_when_opening_source_files,
                        args: null
                    },
                    type: TypeScript.DiagnosticCode.NUMBER,
                    set: function (arg) {
                        _this.compilationSettings.codepage = parseInt(arg, 10);
                    }
                });
            }

            opts.parse(this.ioHost.arguments);

            if (locale) {
                if (!this.setLocale(locale)) {
                    return false;
                }
            }

            for (var i = 0, n = opts.unnamed.length; i < n; i++) {
                this.inputFiles.push(opts.unnamed[i]);
            }

            if (this.inputFiles.length === 0 || needsHelp) {
                opts.printUsage();
                return false;
            } else if (shouldPrintVersionOnly) {
                opts.printVersion();
            }

            return !this.hasErrors;
        };

        BatchCompiler.prototype.setLocale = function (locale) {
            var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(locale.toLowerCase());
            if (!matchResult) {
                this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, ['en', 'ja-jp']));
                return false;
            }

            var language = matchResult[1];
            var territory = matchResult[3];

            if (!this.setLanguageAndTerritory(language, territory) && !this.setLanguageAndTerritory(language, null)) {
                this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Unsupported_locale_0, [locale]));
                return false;
            }

            return true;
        };

        BatchCompiler.prototype.setLanguageAndTerritory = function (language, territory) {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var containingDirectoryPath = this.ioHost.dirName(compilerFilePath);

            var filePath = IOUtils.combine(containingDirectoryPath, language);
            if (territory) {
                filePath = filePath + "-" + territory;
            }

            filePath = this.ioHost.resolvePath(IOUtils.combine(filePath, "diagnosticMessages.generated.json"));

            if (!this.ioHost.fileExists(filePath)) {
                return false;
            }

            var fileContents = this.ioHost.readFile(filePath, this.compilationSettings.codepage);
            TypeScript.LocalizedDiagnosticMessages = JSON.parse(fileContents.contents);
            return true;
        };

        BatchCompiler.prototype.watchFiles = function () {
            var _this = this;
            if (!this.ioHost.watchFile) {
                this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Current_host_does_not_support_0_option, ['-w[atch]']));
                return;
            }

            var lastResolvedFileSet = [];
            var watchers = {};
            var firstTime = true;

            var addWatcher = function (fileName) {
                if (!watchers[fileName]) {
                    var watcher = _this.ioHost.watchFile(fileName, onWatchedFileChange);
                    watchers[fileName] = watcher;
                } else {
                    TypeScript.CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
                }
            };

            var removeWatcher = function (fileName) {
                if (watchers[fileName]) {
                    watchers[fileName].close();
                    delete watchers[fileName];
                } else {
                    TypeScript.CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
                }
            };

            var onWatchedFileChange = function () {
                _this.hasErrors = false;

                _this.fileNameToSourceFile = new TypeScript.StringHashTable();

                _this.resolve();

                var oldFiles = lastResolvedFileSet;
                var newFiles = _this.resolvedFiles.map(function (resolvedFile) {
                    return resolvedFile.path;
                }).sort();

                var i = 0, j = 0;
                while (i < oldFiles.length && j < newFiles.length) {
                    var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                    if (compareResult === 0) {
                        i++;
                        j++;
                    } else if (compareResult < 0) {
                        removeWatcher(oldFiles[i]);
                        i++;
                    } else {
                        addWatcher(newFiles[j]);
                        j++;
                    }
                }

                for (var k = i; k < oldFiles.length; k++) {
                    removeWatcher(oldFiles[k]);
                }

                for (k = j; k < newFiles.length; k++) {
                    addWatcher(newFiles[k]);
                }

                lastResolvedFileSet = newFiles;

                if (!firstTime) {
                    var fileNames = "";
                    for (var k = 0; k < lastResolvedFileSet.length; k++) {
                        fileNames += Environment.newLine + "    " + lastResolvedFileSet[k];
                    }
                    _this.ioHost.printLine(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.NL_Recompiling_0, [fileNames]));
                } else {
                    firstTime = false;
                }

                _this.compile();
            };

            this.ioHost.stderr = this.ioHost.stdout;

            onWatchedFileChange();
        };

        BatchCompiler.prototype.getSourceFile = function (fileName) {
            var sourceFile = this.fileNameToSourceFile.lookup(fileName);
            if (!sourceFile) {
                var fileInformation;

                try  {
                    fileInformation = this.ioHost.readFile(fileName, this.compilationSettings.codepage);
                } catch (e) {
                    this.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Cannot_read_file_0_1, [fileName, e.message]));
                    fileInformation = new FileInformation("", 0 /* None */);
                }

                var snapshot = TypeScript.ScriptSnapshot.fromString(fileInformation.contents);
                var sourceFile = new SourceFile(snapshot, fileInformation.byteOrderMark);
                this.fileNameToSourceFile.add(fileName, sourceFile);
            }

            return sourceFile;
        };

        BatchCompiler.prototype.getDefaultLibraryFilePath = function () {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var containingDirectoryPath = this.ioHost.dirName(compilerFilePath);
            var libraryFilePath = this.ioHost.resolvePath(IOUtils.combine(containingDirectoryPath, "lib.d.ts"));

            return libraryFilePath;
        };

        BatchCompiler.prototype.getScriptSnapshot = function (fileName) {
            return this.getSourceFile(fileName).scriptSnapshot;
        };

        BatchCompiler.prototype.resolveRelativePath = function (path, directory) {
            var unQuotedPath = TypeScript.stripStartAndEndQuotes(path);
            var normalizedPath;

            if (TypeScript.isRooted(unQuotedPath) || !directory) {
                normalizedPath = unQuotedPath;
            } else {
                normalizedPath = IOUtils.combine(directory, unQuotedPath);
            }

            normalizedPath = this.resolvePath(normalizedPath);

            normalizedPath = TypeScript.switchToForwardSlashes(normalizedPath);

            return normalizedPath;
        };

        BatchCompiler.prototype.fileExists = function (path) {
            var start = new Date().getTime();
            var result = this.ioHost.fileExists(path);
            TypeScript.emitFileExistsTime += new Date().getTime() - start;
            return result;
        };

        BatchCompiler.prototype.getParentDirectory = function (path) {
            return this.ioHost.dirName(path);
        };

        BatchCompiler.prototype.addDiagnostic = function (diagnostic) {
            var diagnosticInfo = TypeScript.getDiagnosticInfoFromKey(diagnostic.diagnosticKey());
            if (diagnosticInfo.category === 1 /* Error */) {
                this.hasErrors = true;
            }

            if (diagnostic.fileName()) {
                var scriptSnapshot = this.getScriptSnapshot(diagnostic.fileName());
                var lineMap = new TypeScript.LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
                var lineCol = { line: -1, character: -1 };
                lineMap.fillLineAndCharacterFromPosition(diagnostic.start(), lineCol);

                this.ioHost.stderr.Write(diagnostic.fileName() + "(" + (lineCol.line + 1) + "," + (lineCol.character + 1) + "): ");
            }

            this.ioHost.stderr.WriteLine(diagnostic.message());
        };

        BatchCompiler.prototype.writeFile = function (fileName, contents, writeByteOrderMark) {
            var start = new Date().getTime();
            IOUtils.writeFileAndFolderStructure(this.ioHost, fileName, contents, writeByteOrderMark);
            TypeScript.emitWriteFileTime += new Date().getTime() - start;
        };

        BatchCompiler.prototype.directoryExists = function (path) {
            var start = new Date().getTime();
            var result = this.ioHost.directoryExists(path);
            TypeScript.emitDirectoryExistsTime += new Date().getTime() - start;
            return result;
        };

        BatchCompiler.prototype.resolvePath = function (path) {
            var start = new Date().getTime();
            var result = this.ioHost.resolvePath(path);
            TypeScript.emitResolvePathTime += new Date().getTime() - start;
            return result;
        };
        return BatchCompiler;
    })();
    TypeScript.BatchCompiler = BatchCompiler;
})(TypeScript || (TypeScript = {}));

var batch = new TypeScript.BatchCompiler(IO);
batch.batchCompile();
